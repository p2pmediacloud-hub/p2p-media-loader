{"version":3,"file":"p2p-media-loader-hlsjs.min.js","sources":["../src/utils.ts","../src/fragment-loader.ts","../src/playlist-loader.ts","../src/segment-mananger.ts","../src/engine.ts","../src/engine-static.ts"],"sourcesContent":["import { ByteRange } from \"p2p-media-loader-core\";\n\nexport function getSegmentRuntimeId(\n  segmentRequestUrl: string,\n  byteRange?: ByteRange,\n) {\n  if (!byteRange) return segmentRequestUrl;\n  return `${segmentRequestUrl}|${byteRange.start}-${byteRange.end}`;\n}\n\nexport function getByteRange(\n  rangeStart: number | undefined,\n  rangeEnd: number | undefined,\n): ByteRange | undefined {\n  if (\n    rangeStart !== undefined &&\n    rangeEnd !== undefined &&\n    rangeStart <= rangeEnd\n  ) {\n    return { start: rangeStart, end: rangeEnd };\n  }\n}\n","import type {\n  FragmentLoaderContext,\n  HlsConfig,\n  Loader,\n  LoaderCallbacks,\n  LoaderConfiguration,\n  LoaderContext,\n  LoaderStats,\n} from \"hls.js\";\nimport * as Utils from \"./utils.js\";\nimport { Core, SegmentResponse, CoreRequestError } from \"p2p-media-loader-core\";\n\nconst DEFAULT_DOWNLOAD_LATENCY = 10;\n\nexport class FragmentLoaderBase implements Loader<FragmentLoaderContext> {\n  context!: FragmentLoaderContext;\n  config!: LoaderConfiguration | null;\n  stats: LoaderStats;\n  #callbacks!: LoaderCallbacks<FragmentLoaderContext> | null;\n  #createDefaultLoader: () => Loader<LoaderContext>;\n  #defaultLoader?: Loader<LoaderContext>;\n  #core: Core;\n  #response?: SegmentResponse;\n  #segmentId?: string;\n\n  constructor(config: HlsConfig, core: Core) {\n    this.#core = core;\n    this.#createDefaultLoader = () => new config.loader(config);\n    this.stats = {\n      aborted: false,\n      chunkCount: 0,\n      loading: { start: 0, first: 0, end: 0 },\n      buffering: { start: 0, first: 0, end: 0 },\n      parsing: { start: 0, end: 0 },\n      // set total and loaded to 1 to prevent hls.js\n      // on progress loading monitoring in AbrController\n      total: 1,\n      loaded: 1,\n      bwEstimate: 0,\n      retry: 0,\n    };\n  }\n\n  load(\n    context: FragmentLoaderContext,\n    config: LoaderConfiguration,\n    callbacks: LoaderCallbacks<LoaderContext>,\n  ) {\n    this.context = context;\n    this.config = config;\n    this.#callbacks = callbacks;\n    const { stats } = this;\n\n    const { rangeStart: start, rangeEnd: end } = context;\n    const byteRange = Utils.getByteRange(\n      start,\n      end !== undefined ? end - 1 : undefined,\n    );\n\n    this.#segmentId = Utils.getSegmentRuntimeId(context.url, byteRange);\n    const isSegmentDownloadableByP2PCore = this.#core.isSegmentLoadable(\n      this.#segmentId,\n    );\n\n    if (\n      !this.#core.hasSegment(this.#segmentId) ||\n      !isSegmentDownloadableByP2PCore\n    ) {\n      this.#defaultLoader = this.#createDefaultLoader();\n      this.#defaultLoader.stats = this.stats;\n      this.#defaultLoader.load(context, config, callbacks);\n      return;\n    }\n\n    const onSuccess = (response: SegmentResponse) => {\n      this.#response = response;\n      const loadedBytes = this.#response.data.byteLength;\n      stats.loading = getLoadingStat(\n        this.#response.bandwidth,\n        loadedBytes,\n        performance.now(),\n      );\n      stats.total = loadedBytes;\n      stats.loaded = loadedBytes;\n\n      if (callbacks.onProgress) {\n        callbacks.onProgress(\n          this.stats,\n          context,\n          this.#response.data,\n          undefined,\n        );\n      }\n      callbacks.onSuccess(\n        { data: this.#response.data, url: context.url },\n        this.stats,\n        context,\n        undefined,\n      );\n    };\n\n    const onError = (error: unknown) => {\n      if (\n        error instanceof CoreRequestError &&\n        error.type === \"aborted\" &&\n        this.stats.aborted\n      ) {\n        return;\n      }\n      this.#handleError(error);\n    };\n\n    void this.#core.loadSegment(this.#segmentId, { onSuccess, onError });\n  }\n\n  #handleError(thrownError: unknown) {\n    const error = { code: 0, text: \"\" };\n    if (\n      thrownError instanceof CoreRequestError &&\n      thrownError.type === \"failed\"\n    ) {\n      // error.code = thrownError.code;\n      error.text = thrownError.message;\n    } else if (thrownError instanceof Error) {\n      error.text = thrownError.message;\n    }\n    this.#callbacks?.onError(error, this.context, null, this.stats);\n  }\n\n  #abortInternal() {\n    if (!this.#response && this.#segmentId) {\n      this.stats.aborted = true;\n      this.#core.abortSegmentLoading(this.#segmentId);\n    }\n  }\n\n  abort() {\n    if (this.#defaultLoader) {\n      this.#defaultLoader.abort();\n    } else {\n      this.#abortInternal();\n      this.#callbacks?.onAbort?.(this.stats, this.context, {});\n    }\n  }\n\n  destroy() {\n    if (this.#defaultLoader) {\n      this.#defaultLoader.destroy();\n    } else {\n      if (!this.stats.aborted) this.#abortInternal();\n      this.#callbacks = null;\n      this.config = null;\n    }\n  }\n}\n\nfunction getLoadingStat(\n  targetBitrate: number,\n  loadedBytes: number,\n  loadingEndTime: number,\n) {\n  const timeForLoading = (loadedBytes * 8000) / targetBitrate;\n  const first = loadingEndTime - timeForLoading;\n  const start = first - DEFAULT_DOWNLOAD_LATENCY;\n\n  return { start, first, end: loadingEndTime };\n}\n","import {\n  HlsConfig,\n  Loader,\n  LoaderCallbacks,\n  LoaderConfiguration,\n  LoaderContext,\n  LoaderStats,\n  PlaylistLoaderContext,\n} from \"hls.js\";\n\nexport class PlaylistLoaderBase implements Loader<PlaylistLoaderContext> {\n  #defaultLoader: Loader<LoaderContext>;\n  context: PlaylistLoaderContext;\n  stats: LoaderStats;\n\n  constructor(config: HlsConfig) {\n    this.#defaultLoader = new config.loader(config);\n    this.stats = this.#defaultLoader.stats;\n    this.context = this.#defaultLoader.context as PlaylistLoaderContext;\n  }\n\n  load(\n    context: LoaderContext,\n    config: LoaderConfiguration,\n    callbacks: LoaderCallbacks<LoaderContext>,\n  ) {\n    this.#defaultLoader.load(context, config, callbacks);\n  }\n\n  abort() {\n    this.#defaultLoader.abort();\n  }\n\n  destroy() {\n    this.#defaultLoader.destroy();\n  }\n}\n","import * as Utils from \"./utils.js\";\nimport type {\n  ManifestLoadedData,\n  LevelUpdatedData,\n  AudioTrackLoadedData,\n} from \"hls.js\";\nimport { Core, Segment } from \"p2p-media-loader-core\";\n\nexport class SegmentManager {\n  core: Core;\n\n  constructor(core: Core) {\n    this.core = core;\n  }\n\n  processMainManifest(data: ManifestLoadedData) {\n    const { levels, audioTracks } = data;\n    // in the case of audio only stream it is stored in levels\n\n    for (const [index, level] of levels.entries()) {\n      const { url } = level;\n      this.core.addStreamIfNoneExists({\n        runtimeId: Array.isArray(url) ? (url as string[])[0] : url,\n        type: \"main\",\n        index,\n      });\n    }\n\n    for (const [index, track] of audioTracks.entries()) {\n      const { url } = track;\n      this.core.addStreamIfNoneExists({\n        runtimeId: Array.isArray(url) ? (url as string[])[0] : url,\n        type: \"secondary\",\n        index,\n      });\n    }\n  }\n\n  updatePlaylist(data: LevelUpdatedData | AudioTrackLoadedData) {\n    const {\n      details: { url, fragments, live },\n    } = data;\n\n    const playlist = this.core.getStream(url);\n    if (!playlist) return;\n\n    const segmentToRemoveIds = new Set(playlist.segments.keys());\n    const newSegments: Segment[] = [];\n    fragments.forEach((fragment, index) => {\n      const {\n        url: responseUrl,\n        byteRange: fragByteRange,\n        sn,\n        start: startTime,\n        end: endTime,\n      } = fragment;\n\n      const [start, end] = fragByteRange;\n      const byteRange = Utils.getByteRange(\n        start,\n        end !== undefined ? end - 1 : undefined,\n      );\n      const runtimeId = Utils.getSegmentRuntimeId(responseUrl, byteRange);\n      segmentToRemoveIds.delete(runtimeId);\n\n      if (playlist.segments.has(runtimeId)) return;\n      newSegments.push({\n        runtimeId,\n        url: responseUrl,\n        externalId: live ? sn : index,\n        byteRange,\n        startTime,\n        endTime,\n      });\n    });\n\n    if (!newSegments.length && !segmentToRemoveIds.size) return;\n    this.core.updateStream(url, newSegments, segmentToRemoveIds.values());\n  }\n}\n","declare global {\r\n  interface Window {\r\n    liveViewers?: number;\r\n    clientStats?: {\r\n      getClientId: () => string;\r\n      getStats: () => { p2pBytes: number; cdnBytes: number; total: number };\r\n      sendImmediate: () => void;\r\n    };\r\n  }\r\n}\r\nimport type Hls from \"hls.js\";\r\nimport type {\r\n  AudioTrackLoadedData,\r\n  LevelUpdatedData,\r\n  ManifestLoadedData,\r\n  LevelSwitchingData,\r\n  PlaylistLevelType,\r\n  HlsConfig,\r\n  Events,\r\n} from \"hls.js\";\r\nimport { FragmentLoaderBase } from \"./fragment-loader.js\";\r\nimport { PlaylistLoaderBase } from \"./playlist-loader.js\";\r\nimport { SegmentManager } from \"./segment-mananger.js\";\r\nimport {\r\n  CoreConfig,\r\n  Core,\r\n  CoreEventMap,\r\n  DynamicCoreConfig,\r\n  debug,\r\n  DefinedCoreConfig,\r\n  DownloadSource,\r\n} from \"p2p-media-loader-core\";\r\nimport { injectMixin } from \"./engine-static.js\";\r\n\r\ninterface CustomCoreConfig {\r\n  mode?: \"fast\" | \"smooth\";\r\n  nSpeed?: number;\r\n  randomEndpoint?: boolean;\r\n  xSpeed?: number;\r\n  vSpeed?: \"s1\" | \"n1\" | \"t1\";\r\n}\r\n\r\ninterface CustomTopLevelConfig {\r\n  stop?: number;\r\n  surl: string;\r\n}\r\n\r\nexport type PartialHlsJsP2PEngineConfig = Partial<\r\n  Omit<HlsJsP2PEngineConfig, \"core\">\r\n> & CustomTopLevelConfig & {\r\n  core?: Partial<CoreConfig> & CustomCoreConfig;\r\n};\r\n\r\n/** Represents the complete configuration for HlsJsP2PEngine. */\r\nexport type HlsJsP2PEngineConfig = {\r\n  /** Complete core configuration settings. */\r\n  core: DefinedCoreConfig;\r\n};\r\n\r\n/** Type for specifying dynamic configuration options that can be changed at runtime for the P2PEngine's core. */\r\nexport type DynamicHlsJsP2PEngineConfig = {\r\n  /** Dynamic core config */\r\n  core?: DynamicCoreConfig;\r\n};\r\n\r\n/**\r\n * Extends a generic HLS type to include the P2P engine.\r\n */\r\nexport type HlsWithP2PInstance<HlsType> = HlsType & {\r\n  readonly p2pEngine: HlsJsP2PEngine;\r\n};\r\n\r\n/**\r\n * Configuration type for HLS instances that includes P2P settings.\r\n */\r\nexport type HlsWithP2PConfig<HlsType extends abstract new () => unknown> =\r\n  ConstructorParameters<HlsType>[0] & {\r\n    p2p?: PartialHlsJsP2PEngineConfig & {\r\n      onHlsJsCreated?: (hls: HlsWithP2PInstance<HlsType>) => void;\r\n    };\r\n  };\r\n\r\nconst MAX_LIVE_SYNC_DURATION = 120;\r\nconst uscd = \"dXNlckNvZGVz\",\r\n  wspr = \"d3NzOi8v\",\r\n  sndp = \"czEu\",\r\n  cdtr = \"Y2RudHJhY2tlcnMuY29t\",\r\n  nfrs = \"bjEu\",\r\n  tcdn = \"dDEu\",\r\n  zcod = [\"X1\", \"Y2\", \"Z3\"],\r\n  cdnx = \"Y2Ru\",\r\n  trck = \"dHJhY2tlcnMu\",\r\n  coms = \"Y29t\",\r\n  stat = \"L3N0YXRz\",\r\n  http = \"aHR0cHM6Ly8=\";\r\n\r\nfunction loadConfig(): string {\r\n  const e = -new Date().getTimezoneOffset() / 60;\r\n  const t = document.cookie.split(\"; \").find((c) => c.startsWith(atob(uscd) + \"=\"));\r\n  const s = t ? t.split(\"=\")[1] : null;\r\n  if (s && zcod.includes(s)) return s;\r\n  const a = e >= -11 && e <= -2 ? \"X1\" : e >= -1 && e <= 3 ? \"Y2\" : \"Z3\";\r\n  document.cookie = atob(uscd) + `=${a};path=/;max-age=86400`;\r\n  return a;\r\n}\r\n\r\nfunction smooth(): { p1: string[] } {\r\n  switch (loadConfig()) {\r\n    case \"X1\":\r\n      return { p1: [wspr + tcdn + cdtr].map(atob) };\r\n    case \"Y2\":\r\n      return { p1: [wspr + nfrs + cdtr].map(atob) };\r\n    case \"Z3\":\r\n      return { p1: [wspr + sndp + cdtr].map(atob) };\r\n    default:\r\n      return { p1: [wspr + nfrs + cdtr].map(atob) };\r\n  }\r\n}\r\n\r\nfunction fast(): { p1: string[] } {\r\n  return { p1: [wspr + sndp + cdtr, wspr + nfrs + cdtr, wspr + tcdn + cdtr].map(atob) };\r\n}\r\n\r\nfunction sliceEndpoints(e: string[], t: number = 2): string[] {\r\n  return e.slice(0, t);\r\n}\r\n\r\nfunction selectRandomEndpoint(e: string[]): string[] {\r\n  return [e[Math.floor(Math.random() * e.length)]];\r\n}\r\n\r\nfunction selectvSpeed(e: string[], t: number = 0): string[] {\r\n  return t >= 0 && t < e.length ? [e[t]] : e;\r\n}\r\n\r\nfunction getS1Endpoint(): string {\r\n  return atob(wspr + sndp + cdtr);\r\n}\r\n\r\nfunction getN1Endpoint(): string {\r\n  return atob(wspr + nfrs + cdtr);\r\n}\r\n\r\nfunction getT1Endpoint(): string {\r\n  return atob(wspr + tcdn + cdtr);\r\n}\r\n\r\n\r\nfunction getStatsUrl(surlBase64: string): string {\r\n  if (!surlBase64) {\r\n    throw new Error(\"Stats URL domain (surl) is required in p2p config!\");\r\n  }\r\n  return atob(http) + atob(surlBase64) + atob(stat);\r\n}\r\n\r\n\r\n/**\r\n * P2P Engine for HLS.js\r\n */\r\nexport class HlsJsP2PEngine {\r\n  private readonly core: Core;\r\n  private readonly segmentManager: SegmentManager;\r\n  private hlsInstanceGetter?: () => Hls;\r\n  private currentHlsInstance?: Hls;\r\n  private readonly debug = debug(\"p2pml-hlsjs:engine\");\r\n  downloaded = 0;\r\n  downloaded_total = 0;\r\n  clientId!: string;\r\n  lastLogTime = 0;\r\n  lastSource: DownloadSource | null = null;\r\n  startTime = Date.now();\r\n\r\n  static injectMixin(hls: typeof Hls) {\r\n    return injectMixin(hls);\r\n  }\r\n\r\n  constructor(config?: PartialHlsJsP2PEngineConfig) {\r\n    if (!config?.surl) {\r\n      throw new Error(\"p2p.surl (base64 domain) is required in configuration!\");\r\n    }\r\n\r\n    this.clientId = localStorage.getItem(\"clientId\") || `client-${Math.random().toString(36).substr(2,10)}-${Date.now()}`;\r\n    localStorage.setItem(\"clientId\", this.clientId);\r\n\r\n    let trackerList = (config?.core?.mode === \"fast\" ? fast() : smooth()).p1;\r\n    if (config?.core?.nSpeed !== undefined) trackerList = sliceEndpoints(trackerList, config.core.nSpeed);\r\n    else if (config?.core?.randomEndpoint) trackerList = selectRandomEndpoint(trackerList);\r\n    else if (config?.core?.xSpeed !== undefined) trackerList = selectvSpeed(trackerList, config.core.xSpeed);\r\n    else if (config?.core?.vSpeed) {\r\n      switch (config.core.vSpeed) {\r\n        case \"s1\":\r\n          trackerList = [getS1Endpoint()];\r\n          break;\r\n        case \"n1\":\r\n          trackerList = [getN1Endpoint()];\r\n          break;\r\n        case \"t1\":\r\n          trackerList = [getT1Endpoint()];\r\n          break;\r\n      }\r\n    }\r\n\r\n    const coreConfig: Partial<CoreConfig> = {\r\n      ...(config?.core || {}),\r\n      announceTrackers: trackerList,\r\n    };\r\n\r\n    this.core = new Core(coreConfig);\r\n    this.segmentManager = new SegmentManager(this.core);\r\n\r\n    const statsEndpoint = getStatsUrl(config.surl);\r\n\r\n    const sendStats = async () => {\r\n      const swarmId = config?.core?.swarmId || \"unknown\";\r\n      const maxTime = config?.stop !== undefined ? config.stop * 1000 : 4800 * 1000;\r\n\r\n      if (Date.now() - this.startTime >= maxTime) return;\r\n      if (this.downloaded + this.downloaded_total === 0 && Date.now() - this.startTime > 60000) return;\r\n\r\n      try {\r\n        const res = await fetch(statsEndpoint, {\r\n          method: \"POST\",\r\n          headers: { \"Content-Type\": \"application/json\" },\r\n          body: JSON.stringify({\r\n            swarmId,\r\n            clientId: this.clientId,\r\n            p2pBytes: this.downloaded,\r\n            cdnBytes: this.downloaded_total,\r\n            timestamp: Date.now(),\r\n          }),\r\n          keepalive: true,\r\n        });\r\n\r\n        if (res.ok) {\r\n          const json = await res.json();\r\n          if (json.success && typeof json.liveViewers === \"number\") {\r\n            window.liveViewers = json.liveViewers;\r\n          }\r\n        }\r\n      } catch (e) {\r\n      }\r\n    };\r\n\r\n    this.core.addEventListener(\"onChunkDownloaded\", (bytes: number, source: DownloadSource, peerId?: string) => {\r\n      if (source === \"p2p\") this.downloaded += bytes;\r\n      else if (source === \"http\") this.downloaded_total += bytes;\r\n\r\n      const now = Date.now();\r\n      if (now - this.lastLogTime >= 5000 || source !== this.lastSource) {\r\n        this.lastLogTime = now;\r\n        this.lastSource = source;\r\n        this.debug(`Downloaded ${bytes} bytes from ${source}${peerId ? ` (peer: ${peerId})` : \"\"}`);\r\n      }\r\n    });\r\n\r\n    setInterval(sendStats, 30000);\r\n    setTimeout(sendStats, 10000);\r\n    window.addEventListener(\"beforeunload\", sendStats);\r\n\r\n    window.clientStats = {\r\n      getClientId: () => this.clientId,\r\n      getStats: () => ({\r\n        p2pBytes: this.downloaded,\r\n        cdnBytes: this.downloaded_total,\r\n        total: this.downloaded + this.downloaded_total,\r\n      }),\r\n      sendImmediate: sendStats,\r\n    };\r\n  }\r\n\r\n  addEventListener<K extends keyof CoreEventMap>(\r\n    eventName: K,\r\n    listener: CoreEventMap[K],\r\n  ) {\r\n    this.core.addEventListener(eventName, listener);\r\n  }\r\n\r\n  removeEventListener<K extends keyof CoreEventMap>(\r\n    eventName: K,\r\n    listener: CoreEventMap[K],\r\n  ) {\r\n    this.core.removeEventListener(eventName, listener);\r\n  }\r\n\r\n  getConfigForHlsJs(): { fLoader: unknown; pLoader: unknown } {\r\n    return {\r\n      fLoader: this.createFragmentLoaderClass(),\r\n      pLoader: this.createPlaylistLoaderClass(),\r\n    };\r\n  }\r\n\r\n  getConfig(): HlsJsP2PEngineConfig {\r\n    return { core: this.core.getConfig() };\r\n  }\r\n\r\n  applyDynamicConfig(dynamicConfig: DynamicHlsJsP2PEngineConfig) {\r\n    if (dynamicConfig.core) this.core.applyDynamicConfig(dynamicConfig.core);\r\n  }\r\n\r\n  bindHls<T = unknown>(hls: T | (() => T)) {\r\n    this.hlsInstanceGetter =\r\n      typeof hls === \"function\" ? (hls as () => Hls) : () => hls as Hls;\r\n  }\r\n\r\n  private initHlsEvents() {\r\n    const hlsInstance = this.hlsInstanceGetter?.();\r\n    if (this.currentHlsInstance === hlsInstance) return;\r\n    if (this.currentHlsInstance) this.destroy();\r\n    this.currentHlsInstance = hlsInstance;\r\n    this.updateHlsEventsHandlers(\"register\");\r\n    this.updateMediaElementEventHandlers(\"register\");\r\n  }\r\n\r\n  private updateHlsEventsHandlers(type: \"register\" | \"unregister\") {\r\n    const hls = this.currentHlsInstance;\r\n    if (!hls) return;\r\n    const method = type === \"register\" ? \"on\" : \"off\";\r\n\r\n    hls[method](\r\n      \"hlsManifestLoaded\" as Events.MANIFEST_LOADED,\r\n      this.handleManifestLoaded,\r\n    );\r\n    hls[method](\r\n      \"hlsLevelSwitching\" as Events.LEVEL_SWITCHING,\r\n      this.handleLevelSwitching,\r\n    );\r\n    hls[method](\r\n      \"hlsLevelUpdated\" as Events.LEVEL_UPDATED,\r\n      this.handleLevelUpdated,\r\n    );\r\n    hls[method](\r\n      \"hlsAudioTrackLoaded\" as Events.AUDIO_TRACK_LOADED,\r\n      this.handleLevelUpdated,\r\n    );\r\n    hls[method](\"hlsDestroying\" as Events.DESTROYING, this.destroy);\r\n    hls[method](\r\n      \"hlsMediaAttaching\" as Events.MEDIA_ATTACHING,\r\n      this.destroyCore,\r\n    );\r\n    hls[method](\r\n      \"hlsManifestLoading\" as Events.MANIFEST_LOADING,\r\n      this.destroyCore,\r\n    );\r\n    hls[method](\r\n      \"hlsMediaDetached\" as Events.MEDIA_DETACHED,\r\n      this.handleMediaDetached,\r\n    );\r\n    hls[method](\r\n      \"hlsMediaAttached\" as Events.MEDIA_ATTACHED,\r\n      this.handleMediaAttached,\r\n    );\r\n  }\r\n\r\n  private updateMediaElementEventHandlers = (\r\n    type: \"register\" | \"unregister\",\r\n  ) => {\r\n    const media = this.currentHlsInstance?.media;\r\n    if (!media) return;\r\n    const method =\r\n      type === \"register\" ? \"addEventListener\" : \"removeEventListener\";\r\n    media[method](\"timeupdate\", this.handlePlaybackUpdate);\r\n    media[method](\"seeking\", this.handlePlaybackUpdate);\r\n    media[method](\"ratechange\", this.handlePlaybackUpdate);\r\n  };\r\n\r\n  private handleManifestLoaded = (event: string, data: ManifestLoadedData) => {\r\n    const networkDetails: unknown = data.networkDetails;\r\n    if (networkDetails instanceof XMLHttpRequest) {\r\n      this.core.setManifestResponseUrl(networkDetails.responseURL);\r\n    } else if (networkDetails instanceof Response) {\r\n      this.core.setManifestResponseUrl(networkDetails.url);\r\n    }\r\n    this.segmentManager.processMainManifest(data);\r\n  };\r\n\r\n  private handleLevelSwitching = (event: string, data: LevelSwitchingData) => {\r\n    if (data.bitrate) this.core.setActiveLevelBitrate(data.bitrate);\r\n  };\r\n\r\n  private handleLevelUpdated = (\r\n    event: string,\r\n    data: LevelUpdatedData | AudioTrackLoadedData,\r\n  ) => {\r\n    if (\r\n      this.currentHlsInstance &&\r\n      data.details.live &&\r\n      data.details.fragments[0].type === (\"main\" as PlaylistLevelType) &&\r\n      !this.currentHlsInstance.userConfig.liveSyncDuration &&\r\n      !this.currentHlsInstance.userConfig.liveSyncDurationCount &&\r\n      data.details.fragments.length > 4\r\n    ) {\r\n      this.updateLiveSyncDurationCount(data);\r\n    }\r\n\r\n    this.core.setIsLive(data.details.live);\r\n    this.segmentManager.updatePlaylist(data);\r\n  };\r\n\r\n  private updateLiveSyncDurationCount(\r\n    data: LevelUpdatedData | AudioTrackLoadedData,\r\n  ) {\r\n    const fragmentDuration = data.details.targetduration;\r\n\r\n    const maxLiveSyncCount = Math.floor(\r\n      MAX_LIVE_SYNC_DURATION / fragmentDuration,\r\n    );\r\n    const newLiveSyncDurationCount = Math.min(\r\n      data.details.fragments.length - 1,\r\n      maxLiveSyncCount,\r\n    );\r\n\r\n    if (\r\n      this.currentHlsInstance &&\r\n      this.currentHlsInstance.config.liveSyncDurationCount !==\r\n        newLiveSyncDurationCount\r\n    ) {\r\n      this.debug(\r\n        `Setting liveSyncDurationCount to ${newLiveSyncDurationCount}`,\r\n      );\r\n      this.currentHlsInstance.config.liveSyncDurationCount =\r\n        newLiveSyncDurationCount;\r\n    }\r\n  }\r\n\r\n  private handleMediaAttached = () => {\r\n    this.updateMediaElementEventHandlers(\"register\");\r\n  };\r\n\r\n  private handleMediaDetached = () => {\r\n    this.updateMediaElementEventHandlers(\"unregister\");\r\n  };\r\n\r\n  private handlePlaybackUpdate = (event: Event) => {\r\n    const media = event.target as HTMLMediaElement;\r\n    this.core.updatePlayback(media.currentTime, media.playbackRate);\r\n  };\r\n\r\n  private destroyCore = () => this.core.destroy();\r\n\r\n  destroy = () => {\r\n    this.destroyCore();\r\n    this.updateHlsEventsHandlers(\"unregister\");\r\n    this.updateMediaElementEventHandlers(\"unregister\");\r\n    this.currentHlsInstance = undefined;\r\n  };\r\n\r\n  private createFragmentLoaderClass() {\r\n    const { core } = this;\r\n    const engine = this;\r\n\r\n    return class FragmentLoader extends FragmentLoaderBase {\r\n      constructor(config: HlsConfig) {\r\n        super(config, core);\r\n      }\r\n\r\n      static getEngine() {\r\n        return engine;\r\n      }\r\n    };\r\n  }\r\n\r\n  private createPlaylistLoaderClass() {\r\n    const engine = this;\r\n    return class PlaylistLoader extends PlaylistLoaderBase {\r\n      constructor(config: HlsConfig) {\r\n        super(config);\r\n        engine.initHlsEvents();\r\n      }\r\n    };\r\n  }\r\n}","import {\n  HlsJsP2PEngine,\n  PartialHlsJsP2PEngineConfig,\n  HlsWithP2PInstance,\n  HlsWithP2PConfig,\n} from \"./engine.js\";\n\nexport function injectMixin<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  HlsJsConstructor extends new (...args: any[]) => any,\n>(HlsJsClass: HlsJsConstructor) {\n  return class HlsJsWithP2PClass extends HlsJsClass {\n    #p2pEngine: HlsJsP2PEngine;\n\n    get p2pEngine() {\n      return this.#p2pEngine;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    constructor(...args: any[]) {\n      const config = args[0] as\n        | ({\n            p2p?: PartialHlsJsP2PEngineConfig & {\n              onHlsJsCreated?: (hls: InstanceType<HlsJsConstructor>) => void;\n            };\n          } & Record<string, unknown>)\n        | undefined;\n\n      const { p2p, ...hlsJsConfig } = config ?? {};\n\n      const p2pEngine = new HlsJsP2PEngine(p2p);\n\n      super({ ...hlsJsConfig, ...p2pEngine.getConfigForHlsJs() });\n\n      p2pEngine.bindHls(this);\n\n      this.#p2pEngine = p2pEngine;\n      p2p?.onHlsJsCreated?.(this as InstanceType<HlsJsConstructor>);\n    }\n  } as new (\n    config?: HlsWithP2PConfig<HlsJsConstructor>,\n  ) => HlsWithP2PInstance<InstanceType<HlsJsConstructor>>;\n}\n"],"names":["getSegmentRuntimeId","segmentRequestUrl","byteRange","start","end","getByteRange","rangeStart","rangeEnd","FragmentLoaderBase","context","config","stats","callbacks","createDefaultLoader","defaultLoader","core","response","segmentId","this","loader","aborted","chunkCount","loading","first","buffering","parsing","total","loaded","bwEstimate","retry","Utils.getByteRange","Utils.getSegmentRuntimeId","url","isSegmentDownloadableByP2PCore","isSegmentLoadable","hasSegment","load","loadSegment","onSuccess","loadedBytes","data","byteLength","targetBitrate","loadingEndTime","timeForLoading","bandwidth","performance","now","onProgress","onError","error","CoreRequestError","type","#i","thrownError","code","text","Error","message","abortSegmentLoading","abort","abortInternal","onAbort","destroy","PlaylistLoaderBase","SegmentManager","levels","audioTracks","index","level","entries","addStreamIfNoneExists","runtimeId","Array","isArray","track","details","fragments","live","playlist","getStream","segmentToRemoveIds","Set","segments","keys","newSegments","forEach","fragment","responseUrl","fragByteRange","sn","startTime","endTime","delete","has","push","externalId","length","size","updateStream","values","uscd","wspr","sndp","cdtr","nfrs","tcdn","zcod","smooth","e","Date","getTimezoneOffset","t","document","cookie","split","find","c","startsWith","atob","s","includes","a","loadConfig","p1","map","HlsJsP2PEngine","segmentManager","hlsInstanceGetter","currentHlsInstance","debug","downloaded","downloaded_total","clientId","lastLogTime","lastSource","hls","HlsJsClass","p2pEngine","args","p2p","hlsJsConfig","super","getConfigForHlsJs","bindHls","onHlsJsCreated","surl","localStorage","getItem","Math","random","toString","substr","setItem","trackerList","mode","nSpeed","slice","randomEndpoint","floor","xSpeed","vSpeed","coreConfig","announceTrackers","Core","statsEndpoint","surlBase64","sendStats","async","swarmId","maxTime","stop","res","fetch","method","headers","body","JSON","stringify","p2pBytes","cdnBytes","timestamp","keepalive","ok","json","success","liveViewers","window","addEventListener","bytes","source","peerId","setInterval","setTimeout","clientStats","getClientId","getStats","sendImmediate","eventName","listener","removeEventListener","fLoader","createFragmentLoaderClass","pLoader","createPlaylistLoaderClass","getConfig","dynamicConfig","applyDynamicConfig","initHlsEvents","hlsInstance","updateHlsEventsHandlers","updateMediaElementEventHandlers","handleManifestLoaded","handleLevelSwitching","handleLevelUpdated","destroyCore","handleMediaDetached","handleMediaAttached","media","handlePlaybackUpdate","event","networkDetails","XMLHttpRequest","setManifestResponseUrl","responseURL","Response","processMainManifest","bitrate","setActiveLevelBitrate","userConfig","liveSyncDuration","liveSyncDurationCount","updateLiveSyncDurationCount","setIsLive","updatePlaylist","fragmentDuration","targetduration","maxLiveSyncCount","newLiveSyncDurationCount","min","target","updatePlayback","currentTime","playbackRate","engine","getEngine"],"mappings":"yTAEO,SAASA,EACdC,EACAC,EAAAA,CAEA,OAAKA,EACE,GAAGD,KAAqBC,EAAUC,KAAAA,IAASD,EAAUE,GAAAA,GADrCH,CAEzB,CAEO,SAASI,EACdC,EACAC,EAAAA,CAEA,GACED,IADF,QAEEC,IADAD,QAEAA,GAAcC,EAEd,MAAO,CAAEJ,MAAOG,EAAYF,IAAKG,CAAAA,CAErC,CCPO,MAAMC,CAAAA,CACXC,QACAC,OACAC,MACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GAEA,YAAYP,EAAmBK,GAC7BG,KAAAA,GAAaH,EACbG,KAAAA,GAA4B,IAAM,IAAIR,EAAOS,OAAOT,CAAAA,EACpDQ,KAAKP,MAAQ,CACXS,WACAC,WAAY,EACZC,QAAS,CAAEnB,MAAO,EAAGoB,MAAO,EAAGnB,IAAK,CAAA,EACpCoB,UAAW,CAAErB,MAAO,EAAGoB,MAAO,EAAGnB,IAAK,CAAA,EACtCqB,QAAS,CAAEtB,MAAO,EAAGC,IAAK,CAAA,EAG1BsB,MAAO,EACPC,OAAQ,EACRC,WAAY,EACZC,MAAO,EAEX,CAEA,KACEpB,EACAC,EACAE,GAEAM,KAAKT,QAAUA,EACfS,KAAKR,OAASA,EACdQ,KAAAA,GAAkBN,EAClB,KAAA,CAAMD,MAAEA,GAAUO,KAAAA,CAEVZ,WAAYH,EAAOI,SAAUH,CAAAA,EAAQK,EACvCP,EAAY4B,EAChB3B,EACAC,WAAoBA,EAAM,EAAA,MAAI,EAGhCc,QAAkBa,EAA0BtB,EAAQuB,IAAK9B,CAAAA,EACzD,MAAM+B,EAAiCf,KAAAA,GAAWgB,kBAChDhB,KAAAA,IAGF,GAAA,CACGA,KAAAA,GAAWiB,WAAWjB,KAAAA,MACtBe,EAKD,OAHAf,QAAsBA,KAAAA,GAAKL,EAC3BK,KAAAA,GAAoBP,MAAQO,KAAKP,WACjCO,KAAAA,GAAoBkB,KAAK3B,EAASC,EAAQE,GA0CvCM,KAAAA,GAAWmB,YAAYnB,KAAAA,GAAiB,CAAEoB,UAtC5BtB,GAAAA,CACjBE,QAAiBF,EACjB,MAAMuB,EAAcrB,KAAAA,GAAesB,KAAKC,WACxC9B,EAAMW,SA+EZ,SACEoB,EACAH,EACAI,EAAAA,CAEA,MAAMC,EAAgC,IAAdL,EAAsBG,EACxCnB,EAAQoB,EAAiBC,EAG/B,MAAO,CAAEzC,MAFKoB,EAvJiB,GAyJfA,MAAAA,EAAOnB,IAAKuC,CAAAA,CAC9B,GAxFQzB,KAAAA,GAAe2B,UACfN,EACAO,YAAYC,OAEdpC,EAAMe,MAAQa,EACd5B,EAAMgB,OAASY,EAEX3B,EAAUoC,YACZpC,EAAUoC,WACR9B,KAAKP,MACLF,EACAS,KAAAA,GAAesB,KAAAA,MACf,EAGJ5B,EAAU0B,UACR,CAAEE,KAAMtB,KAAAA,GAAesB,KAAMR,IAAKvB,EAAQuB,KAC1Cd,KAAKP,MACLF,QACA,CAAA,EAesDwC,QAXzCC,IAEbA,aAAiBC,EAAAA,kBACjBD,EAAME,OAAS,WACflC,KAAKP,MAAMS,SAIbF,KAAAA,GAAkBgC,CAAAA,CAAAA,CAAAA,CAAAA,CAItB,CAEAG,GAAaC,EAAAA,CACX,MAAMJ,EAAQ,CAAEK,KAAM,EAAGC,KAAM,KAE7BF,aAAuBH,EAAAA,kBACvBG,EAAYF,OAAS,UAIZE,aAAuBG,SADhCP,EAAMM,KAAOF,EAAYI,SAI3BxC,KAAAA,IAAiB+B,QAAQC,EAAOhC,KAAKT,QAAS,KAAMS,KAAKP,MAC3D,CAEA,MACOO,KAAAA,IAAkBA,UACrBA,KAAKP,MAAMS,QAAAA,GACXF,QAAWyC,oBAAoBzC,OAAKD,EAExC,CAEA,OAAA2C,CACM1C,KAAAA,GACFA,KAAAA,GAAoB0C,SAEpB1C,KAAAA,GAAK2C,EACL3C,SAAiB4C,UAAU5C,KAAKP,MAAOO,KAAKT,QAAS,IAEzD,CAEA,SAAAsD,CACM7C,QACFA,KAAAA,GAAoB6C,QAAAA,GAEf7C,KAAKP,MAAMS,mBAChBF,KAAAA,GAAkB,KAClBA,KAAKR,OAAS,KAElB,CAAA,CC/IK,MAAMsD,CAAAA,CACXlD,GACAL,QACAE,MAEA,YAAYD,EAAAA,CACVQ,KAAAA,GAAsB,IAAIR,EAAOS,OAAOT,CAAAA,EACxCQ,KAAKP,MAAQO,KAAAA,GAAoBP,MACjCO,KAAKT,QAAUS,QAAoBT,OACrC,CAEA,KACEA,EACAC,EACAE,EAAAA,CAEAM,QAAoBkB,KAAK3B,EAASC,EAAQE,CAAAA,CAC5C,CAEA,OAAAgD,CACE1C,QAAoB0C,MAAAA,CACtB,CAEA,SAAAG,CACE7C,QAAoB6C,QAAAA,CACtB,EC3BK,MAAME,CAAAA,CACXlD,KAEA,YAAYA,GACVG,KAAKH,KAAOA,CACd,CAEA,oBAAoByB,EAAAA,CAClB,KAAA,CAAM0B,OAAEA,EAAAC,YAAQA,GAAgB3B,EAGhC,UAAY4B,EAAOC,CAAAA,IAAUH,EAAOI,QAAAA,EAAW,CAC7C,MAAMtC,IAAEA,CAAAA,EAAQqC,EAChBnD,KAAKH,KAAKwD,sBAAsB,CAC9BC,UAAWC,MAAMC,QAAQ1C,CAAAA,EAAQA,EAAiB,CAAA,EAAKA,EACvDoB,KAAM,OACNgB,MAAAA,CAAAA,CAAAA,CAEJ,CAEA,UAAYA,EAAOO,CAAAA,IAAUR,EAAYG,QAAAA,EAAW,CAClD,MAAMtC,IAAEA,CAAAA,EAAQ2C,EAChBzD,KAAKH,KAAKwD,sBAAsB,CAC9BC,UAAWC,MAAMC,QAAQ1C,CAAAA,EAAQA,EAAiB,CAAA,EAAKA,EACvDoB,KAAM,YACNgB,MAAAA,CAAAA,CAAAA,CAEJ,CACF,CAEA,eAAe5B,EAAAA,CACb,KAAA,CACEoC,SAAS5C,IAAEA,EAAA6C,UAAKA,EAAAC,KAAWA,IACzBtC,EAEEuC,EAAW7D,KAAKH,KAAKiE,UAAUhD,GACrC,GAAA,CAAK+C,EAAU,OAEf,MAAME,EAAqB,IAAIC,IAAIH,EAASI,SAASC,KAAAA,CAAAA,EAC/CC,EAAyB,GAC/BR,EAAUS,QAAQ,CAACC,EAAUnB,IAAAA,CAC3B,MACEpC,IAAKwD,EACLtF,UAAWuF,EAAAC,GACXA,EACAvF,MAAOwF,EACPvF,IAAKwF,CAAAA,EACHL,EAAAA,CAEGpF,EAAOC,CAAAA,EAAOqF,EACfvF,EAAY4B,EAChB3B,EACAC,IADAD,OACoBC,EAAM,QAAI,EAE1BoE,EAAYzC,EAA0ByD,EAAatF,CAAAA,EACzD+E,EAAmBY,OAAOrB,CAAAA,EAEtBO,EAASI,SAASW,IAAItB,CAAAA,GAC1Ba,EAAYU,KAAK,CACfvB,UAAAA,EACAxC,IAAKwD,EACLQ,WAAYlB,EAAOY,EAAKtB,EACxBlE,YACAyF,UAAAA,EACAC,QAAAA,CAAAA,CAAAA,CAAAA,CAAAA,GAICP,EAAYY,QAAWhB,EAAmBiB,OAC/ChF,KAAKH,KAAKoF,aAAanE,EAAKqD,EAAaJ,EAAmBmB,OAAAA,CAAAA,CAC9D,CAAA,CCIF,MACMC,EAAO,eACXC,EAAO,WACPC,EAAO,OACPC,EAAO,uBACPC,EAAO,OACPC,EAAO,OACPC,EAAO,CAAC,KAAM,KAAM,IAAA,EAiBtB,SAASC,GAAAA,CACP,QAXF,WACE,MAAMC,EAAAA,CAAI,IAAKC,OAAOC,kBAAAA,EAAsB,GACtCC,EAAIC,SAASC,OAAOC,MAAM,IAAA,EAAMC,KAAMC,GAAMA,EAAEC,WAAWC,KAAKlB,CAAAA,EAAQ,MACtEmB,EAAIR,EAAIA,EAAEG,MAAM,GAAA,EAAK,GAAK,KAChC,GAAIK,GAAKb,EAAKc,SAASD,GAAI,OAAOA,EAClC,MAAME,EAAIb,GAAAA,KAAYA,GAAAA,GAAU,KAAOA,GAAAA,IAAWA,GAAK,EAAI,KAAO,KAElE,OADAI,SAASC,OAASK,KAAKlB,CAAAA,EAAQ,IAAIqB,CAAAA,wBAC5BA,CACT,GAGUC,EAAAA,CACN,IAAK,KACH,MAAO,CAAEC,GAAI,CAACtB,EAAOI,EAAOF,CAAAA,EAAMqB,IAAIN,OACxC,IAAK,KAIL,QACE,MAAO,CAAEK,GAAI,CAACtB,EAAOG,EAAOD,CAAAA,EAAMqB,IAAIN,OAHxC,IAAK,KACH,MAAO,CAAEK,GAAI,CAACtB,EAAOC,EAAOC,GAAMqB,IAAIN,IAAAA,CAAAA,CAAAA,CAI5C,CA0CO,MAAMO,CAAAA,CACM/G,KACAgH,eACTC,kBACAC,mBACSC,MAAQA,EAAAA,MAAM,oBAAA,EAC/BC,WAAa,EACbC,iBAAmB,EACnBC,SACAC,YAAc,EACdC,WAAoC,KACpC5C,UAAYmB,KAAK/D,IAAAA,EAEjB,OAAA,YAAmByF,EAAAA,CACjB,OCnKFC,EDmKqBD,EClKd,cAAgCC,EACrCC,GAEA,IAAA,YACE,OAAOxH,KAAAA,EACT,CAGA,eAAeyH,EAAAA,CACb,MAAMjI,EAASiI,EAAK,CAAA,EAAA,CAQdC,IAAEA,EAAAA,GAAQC,CAAAA,EAAgBnI,GAAU,CAAA,EAEpCgI,EAAY,IAAIZ,EAAec,CAAAA,EAErCE,MAAM,IAAKD,EAAAA,GAAgBH,EAAUK,sBAErCL,EAAUM,QAAQ9H,MAElBA,KAAAA,GAAkBwH,EAClBE,GAAKK,iBAAiB/H,KACxB,CAAA,EA/BG,IAGLuH,CDoKA,CAEA,YAAY/H,EAAAA,CACV,GAAA,CAAKA,GAAQwI,KACX,MAAM,IAAIzF,MAAM,wDAAA,EAGlBvC,KAAKmH,SAAWc,aAAaC,QAAQ,UAAA,GAAe,UAAUC,KAAKC,OAAAA,EAASC,SAAS,IAAIC,OAAO,EAAE,OAAO1C,KAAK/D,IAAAA,CAAAA,GAC9GoG,aAAaM,QAAQ,WAAYvI,KAAKmH,QAAAA,EAEtC,IAAIqB,GAAehJ,GAAQK,MAAM4I,OAAS,OAhErC,CAAE/B,GAAI,CAACtB,EAAOC,EAAOC,EAAMF,EAAOG,EAAOD,EAAMF,EAAOI,EAAOF,CAAAA,EAAMqB,IAAIN,OAgEhBX,EAAAA,GAAUgB,GACtE,GAAIlH,GAAQK,MAAM6I,mBA9DtB,SAAwB/C,EAAaG,EAAY,GAC/C,OAAOH,EAAEgD,MAAM,EAAG7C,CAAAA,CACpB,GA4DyE0C,EAAahJ,EAAOK,KAAK6I,MAAAA,UACrFlJ,GAAQK,MAAM+I,eAAgBJ,EA1DlC,EADqB7C,EA2DgD6C,GA1DlEL,KAAKU,MAAMV,KAAKC,SAAWzC,EAAEZ,MAAAA,CAAAA,CAAAA,UA2D5BvF,GAAQK,MAAMiJ,mBAxD3B,SAAsBnD,EAAaG,EAAY,GAC7C,OAAOA,GAAK,GAAKA,EAAIH,EAAEZ,OAAS,CAACY,EAAEG,IAAMH,CAC3C,GAsD4E6C,EAAahJ,EAAOK,KAAKiJ,MAAAA,UACxFtJ,GAAQK,MAAMkJ,OACrB,OAAQvJ,EAAOK,KAAKkJ,QAClB,IAAK,KACHP,EAAc,CAvDfnC,KAAKjB,EAAOC,EAAOC,CAAAA,CAAAA,EAwDlB,MACF,IAAK,KACHkD,EAAc,CAtDfnC,KAAKjB,EAAOG,EAAOD,CAAAA,CAAAA,EAuDlB,MACF,IAAK,KACHkD,EAAc,CArDfnC,KAAKjB,EAAOI,EAAOF,CAAAA,CAAAA,CAAAA,CAjB5B,IAA8BK,EA2E1B,MAAMqD,EAAkC,CAAA,GAClCxJ,GAAQK,MAAQ,CAAA,EACpBoJ,iBAAkBT,CAAAA,EAGpBxI,KAAKH,KAAO,IAAIqJ,EAAAA,KAAKF,CAAAA,EACrBhJ,KAAK6G,eAAiB,IAAI9D,EAAe/C,KAAKH,IAAAA,EAE9C,MAAMsJ,GA9DV,SAAqBC,GACnB,GAAA,CAAKA,EACH,MAAM,IAAI7G,MAAM,sDAElB,OAAO8D,KA1DA,gBA0DaA,KAAK+C,CAAAA,EAAc/C,KA3DhC,UAAA,CA4DT,GAyDsC7G,EAAOwI,IAAAA,EAEnCqB,EAAYC,SAAAA,CAChB,MAAMC,EAAU/J,GAAQK,MAAM0J,SAAW,UACnCC,EAAUhK,GAAQiK,OAAlBD,OAAqD,IAAdhK,EAAOiK,KAAc,KAElE,GAAA,EAAI7D,KAAK/D,MAAQ7B,KAAKyE,WAAa+E,GAC/BxJ,KAAKiH,WAAajH,KAAKkH,mBAAqB,GAAKtB,KAAK/D,IAAAA,EAAQ7B,KAAKyE,UAAY,KAEnF,GAAA,CACE,MAAMiF,EAAAA,MAAYC,MAAMR,EAAe,CACrCS,OAAQ,OACRC,QAAS,CAAE,eAAgB,kBAAA,EAC3BC,KAAMC,KAAKC,UAAU,CACnBT,UACApC,SAAUnH,KAAKmH,SACf8C,SAAUjK,KAAKiH,WACfiD,SAAUlK,KAAKkH,iBACfiD,UAAWvE,KAAK/D,QAElBuI,UAAAA,EAAW,CAAA,EAGb,GAAIV,EAAIW,GAAI,CACV,MAAMC,EAAAA,MAAaZ,EAAIY,KAAAA,EACnBA,EAAKC,SAAuC,OAArBD,EAAKE,aAAgB,WAC9CC,OAAOD,YAAcF,EAAKE,YAE9B,CACF,MAAS7E,CACT,GAGF3F,KAAKH,KAAK6K,iBAAiB,oBAAqB,CAACC,EAAeC,EAAwBC,IAAAA,CAClFD,IAAW,MAAO5K,KAAKiH,YAAc0D,EAChCC,IAAW,SAAQ5K,KAAKkH,kBAAoByD,GAErD,MAAM9I,EAAM+D,KAAK/D,IAAAA,GACbA,EAAM7B,KAAKoH,aAAe,KAAQwD,IAAW5K,KAAKqH,cACpDrH,KAAKoH,YAAcvF,EACnB7B,KAAKqH,WAAauD,EAClB5K,KAAKgH,MAAM,cAAc2D,gBAAoBC,CAAAA,GAASC,EAAS,WAAWA,CAAAA,IAAY,EAAA,EAAA,EAAA,CAAA,EAI1FC,YAAYzB,EAAW,GAAA,EACvB0B,WAAW1B,EAAW,GAAA,EACtBoB,OAAOC,iBAAiB,eAAgBrB,GAExCoB,OAAOO,YAAc,CACnBC,YAAa,IAAMjL,KAAKmH,SACxB+D,SAAU,KAAA,CACRjB,SAAUjK,KAAKiH,WACfiD,SAAUlK,KAAKkH,iBACf1G,MAAOR,KAAKiH,WAAajH,KAAKkH,mBAEhCiE,cAAe9B,CAAAA,CAEnB,CAEA,iBACE+B,EACAC,EAAAA,CAEArL,KAAKH,KAAK6K,iBAAiBU,EAAWC,CAAAA,CACxC,CAEA,oBACED,EACAC,GAEArL,KAAKH,KAAKyL,oBAAoBF,EAAWC,CAAAA,CAC3C,CAEA,mBAAAxD,CACE,MAAO,CACL0D,QAASvL,KAAKwL,0BAAAA,EACdC,QAASzL,KAAK0L,0BAAAA,CAAAA,CAElB,CAEA,WAAAC,CACE,MAAO,CAAE9L,KAAMG,KAAKH,KAAK8L,UAAAA,CAAAA,CAC3B,CAEA,mBAAmBC,EAAAA,CACbA,EAAc/L,MAAMG,KAAKH,KAAKgM,mBAAmBD,EAAc/L,KACrE,CAEA,QAAqByH,EAAAA,CACnBtH,KAAK8G,kBACY,OAARQ,GAAQ,WAAcA,EAAoB,IAAMA,CAC3D,CAEQ,eAAAwE,CACN,MAAMC,EAAc/L,KAAK8G,sBACrB9G,KAAK+G,qBAAuBgF,IAC5B/L,KAAK+G,oBAAoB/G,KAAK6C,QAAAA,EAClC7C,KAAK+G,mBAAqBgF,EAC1B/L,KAAKgM,wBAAwB,UAAA,EAC7BhM,KAAKiM,gCAAgC,UAAA,EACvC,CAEQ,wBAAwB/J,EAAAA,CAC9B,MAAMoF,EAAMtH,KAAK+G,mBACjB,GAAA,CAAKO,EAAK,OACV,MAAMsC,EAAS1H,IAAS,WAAa,KAAO,MAE5CoF,EAAIsC,CAAAA,EACF,oBACA5J,KAAKkM,sBAEP5E,EAAIsC,CAAAA,EACF,oBACA5J,KAAKmM,oBAAAA,EAEP7E,EAAIsC,CAAAA,EACF,kBACA5J,KAAKoM,kBAAAA,EAEP9E,EAAIsC,GACF,sBACA5J,KAAKoM,oBAEP9E,EAAIsC,CAAAA,EAAQ,gBAAsC5J,KAAK6C,OAAAA,EACvDyE,EAAIsC,CAAAA,EACF,oBACA5J,KAAKqM,WAAAA,EAEP/E,EAAIsC,GACF,qBACA5J,KAAKqM,aAEP/E,EAAIsC,CAAAA,EACF,mBACA5J,KAAKsM,mBAAAA,EAEPhF,EAAIsC,CAAAA,EACF,mBACA5J,KAAKuM,mBAAAA,CAET,CAEQN,gCACN/J,GAAAA,CAEA,MAAMsK,EAAQxM,KAAK+G,oBAAoByF,MACvC,GAAA,CAAKA,EAAO,OACZ,MAAM5C,EACJ1H,IAAS,WAAa,mBAAqB,sBAC7CsK,EAAM5C,CAAAA,EAAQ,aAAc5J,KAAKyM,oBAAAA,EACjCD,EAAM5C,CAAAA,EAAQ,UAAW5J,KAAKyM,oBAAAA,EAC9BD,EAAM5C,GAAQ,aAAc5J,KAAKyM,uBAG3BP,qBAAuB,CAACQ,EAAepL,IAAAA,CAC7C,MAAMqL,EAA0BrL,EAAKqL,eACjCA,aAA0BC,eAC5B5M,KAAKH,KAAKgN,uBAAuBF,EAAeG,aACvCH,aAA0BI,UACnC/M,KAAKH,KAAKgN,uBAAuBF,EAAe7L,GAAAA,EAElDd,KAAK6G,eAAemG,oBAAoB1L,IAGlC6K,qBAAuB,CAACO,EAAepL,IAAAA,CACzCA,EAAK2L,SAASjN,KAAKH,KAAKqN,sBAAsB5L,EAAK2L,OAAAA,CAAAA,EAGjDb,mBAAqB,CAC3BM,EACApL,KAGEtB,KAAK+G,oBACLzF,EAAKoC,QAAQE,MACbtC,EAAKoC,QAAQC,UAAU,CAAA,EAAGzB,OAAU,QAAVA,CACzBlC,KAAK+G,mBAAmBoG,WAAWC,mBACnCpN,KAAK+G,mBAAmBoG,WAAWE,uBACpC/L,EAAKoC,QAAQC,UAAUoB,OAAS,GAEhC/E,KAAKsN,4BAA4BhM,GAGnCtB,KAAKH,KAAK0N,UAAUjM,EAAKoC,QAAQE,MACjC5D,KAAK6G,eAAe2G,eAAelM,CAAAA,CAAAA,EAG7B,4BACNA,EAAAA,CAEA,MAAMmM,EAAmBnM,EAAKoC,QAAQgK,eAEhCC,EAAmBxF,KAAKU,MAjUH,IAkUA4E,CAAAA,EAErBG,EAA2BzF,KAAK0F,IACpCvM,EAAKoC,QAAQC,UAAUoB,OAAS,EAChC4I,CAAAA,EAIA3N,KAAK+G,oBACL/G,KAAK+G,mBAAmBvH,OAAO6N,wBAC7BO,IAEF5N,KAAKgH,MACH,oCAAoC4G,CAAAA,EAAAA,EAEtC5N,KAAK+G,mBAAmBvH,OAAO6N,sBAC7BO,EAEN,CAEQrB,oBAAsB,KAC5BvM,KAAKiM,gCAAgC,aAG/BK,oBAAsB,IAAA,CAC5BtM,KAAKiM,gCAAgC,YAAA,CAAA,EAG/BQ,qBAAwBC,GAAAA,CAC9B,MAAMF,EAAQE,EAAMoB,OACpB9N,KAAKH,KAAKkO,eAAevB,EAAMwB,YAAaxB,EAAMyB,eAG5C5B,YAAc,IAAMrM,KAAKH,KAAKgD,QAAAA,EAEtCA,QAAU,IAAA,CACR7C,KAAKqM,cACLrM,KAAKgM,wBAAwB,cAC7BhM,KAAKiM,gCAAgC,cACrCjM,KAAK+G,mBAAAA,QAGC,2BAAAyE,CACN,MAAM3L,KAAEA,CAAAA,EAASG,KACXkO,EAASlO,KAEf,OAAO,cAA6BV,CAAAA,CAClC,YAAYE,EAAAA,CACVoI,MAAMpI,EAAQK,CAAAA,CAChB,CAEA,OAAA,WAAOsO,CACL,OAAOD,CACT,CAAA,CAEJ,CAEQ,2BAAAxC,CACN,MAAMwC,EAASlO,KACf,OAAO,cAA6B8C,CAAAA,CAClC,YAAYtD,EAAAA,CACVoI,MAAMpI,CAAAA,EACN0O,EAAOpC,eACT,CAAA,CAEJ,CAAA"}