{"version":3,"file":"p2p-media-loader-core.min.js","sources":["../src/types.ts","../src/http-loader.ts","../../../node_modules/.pnpm/vite-plugin-node-polyfills@0.24.0_rollup@4.53.2_vite@7.2.2_@types+node@24.10.1_terser@5.44.1_yaml@2.8.1_/node_modules/vite-plugin-node-polyfills/shims/process/dist/index.js","../../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js","../../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/browser.js","../../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/common.js","../../../node_modules/.pnpm/events@3.3.0/node_modules/events/events.js","../../../node_modules/.pnpm/once@1.4.0/node_modules/once/once.js","../../../node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js","../../../node_modules/.pnpm/queue-microtask@1.2.3/node_modules/queue-microtask/index.js","../../../node_modules/.pnpm/run-parallel@1.2.0/node_modules/run-parallel/index.js","../../../node_modules/.pnpm/webrtc-polyfill@1.1.10/node_modules/webrtc-polyfill/browser.js","../../../node_modules/.pnpm/fast-fifo@1.3.2/node_modules/fast-fifo/index.js","../../../node_modules/.pnpm/fast-fifo@1.3.2/node_modules/fast-fifo/fixed-size.js","../../../node_modules/.pnpm/text-decoder@1.2.3/node_modules/text-decoder/lib/browser-decoder.js","../../../node_modules/.pnpm/text-decoder@1.2.3/node_modules/text-decoder/index.js","../../../node_modules/.pnpm/streamx@2.23.0/node_modules/streamx/index.js","../../../node_modules/.pnpm/events-universal@1.0.1/node_modules/events-universal/default.js","../../../node_modules/.pnpm/err-code@3.0.1/node_modules/err-code/index.js","../../../node_modules/.pnpm/uint8-util@2.2.5/node_modules/uint8-util/util.js","../../../node_modules/.pnpm/base64-arraybuffer@1.0.2/node_modules/base64-arraybuffer/dist/base64-arraybuffer.es5.js","../../../node_modules/.pnpm/uint8-util@2.2.5/node_modules/uint8-util/browser.js","../../../node_modules/.pnpm/@thaunknown+simple-peer@10.0.12/node_modules/@thaunknown/simple-peer/lite.js","../__vite-browser-external","../../../node_modules/.pnpm/bittorrent-tracker@11.2.2/node_modules/bittorrent-tracker/lib/common.js","../../../node_modules/.pnpm/@thaunknown+simple-websocket@9.1.3_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@thaunknown/simple-websocket/index.js","../../../node_modules/.pnpm/bittorrent-tracker@11.2.2/node_modules/bittorrent-tracker/lib/client/tracker.js","../../../node_modules/.pnpm/bittorrent-tracker@11.2.2/node_modules/bittorrent-tracker/lib/client/websocket-tracker.js","../../../node_modules/.pnpm/bittorrent-tracker@11.2.2/node_modules/bittorrent-tracker/client.js","../../../node_modules/.pnpm/nano-md5@1.0.5/node_modules/nano-md5/md5.js","../src/utils/peer.ts","../src/utils/version.ts","../src/utils/logger.ts","../src/utils/utils.ts","../src/p2p/commands/types.ts","../src/p2p/commands/binary-serialization.ts","../src/p2p/commands/binary-command-creator.ts","../src/p2p/commands/commands.ts","../src/p2p/peer-protocol.ts","../src/p2p/peer.ts","../src/p2p/tracker-client.ts","../src/utils/stream.ts","../src/p2p/loader.ts","../src/p2p/loaders-container.ts","../src/requests/request.ts","../src/requests/request-container.ts","../src/requests/engine-request.ts","../src/utils/queue.ts","../src/hybrid-loader.ts","../src/bandwidth-calculator.ts","../src/segment-storage/utils.ts","../src/segment-storage/segment-memory-storage.ts","../src/utils/event-target.ts","../src/core.ts"],"sourcesContent":["import { SegmentStorage } from \"./segment-storage/index.js\";\n\n/** Represents the types of streams available, either primary (main) or secondary. */\nexport type StreamType = \"main\" | \"secondary\";\n\n/** Represents a range of bytes, used for specifying a segment of data to download. */\nexport type ByteRange = {\n  /** The starting byte index of the range. */\n  start: number;\n  /** The ending byte index of the range. */\n  end: number;\n};\n\n/** Describes a media segment with its unique identifiers, location, and timing information. */\nexport type Segment = {\n  /** A runtime identifier for the segment that includes URL and byte range from its manifest. */\n  readonly runtimeId: string;\n\n  /** An unique identifier of the segment in its stream used for P2P communications: sequence number for HLS or playtime for MPEG-DASH. */\n  readonly externalId: number;\n\n  /** The URL from which the segment can be downloaded. */\n  readonly url: string;\n\n  /** An optional property specifying the range of bytes that represent the segment. */\n  readonly byteRange?: ByteRange;\n\n  /** The start time of the segment in seconds, relative to the beginning of the stream. */\n  readonly startTime: number;\n\n  /** The end time of the segment in seconds, relative to the beginning of the stream. */\n  readonly endTime: number;\n};\n\n/** Extends a Segment with a reference to its associated stream. */\nexport type SegmentWithStream<TStream extends Stream = Stream> = Segment & {\n  readonly stream: StreamWithSegments<TStream>;\n};\n\n/**\n * Represents a stream that includes multiple segments, each associated with the stream.\n * @template TStream Type of the underlying stream data structure.\n */\nexport type StreamWithSegments<TStream extends Stream = Stream> = TStream & {\n  readonly segments: Map<string, SegmentWithStream<TStream>>;\n};\n\n/** Represents a media stream with various defining characteristics. */\nexport type Stream = {\n  /** Runtime identifier of the stream from an engine. */\n  readonly runtimeId: string;\n\n  /** Stream type. */\n  readonly type: StreamType;\n\n  /** Stream index in the manifest. */\n  readonly index: number;\n};\n\n/** Represents a defined Core configuration with specific settings for the main and secondary streams. */\nexport type DefinedCoreConfig = CommonCoreConfig & {\n  /** Configuration for the main stream. */\n  mainStream: StreamConfig;\n  /** Configuration for the secondary stream. */\n  secondaryStream: StreamConfig;\n};\n\n/** Represents a set of properties that can be dynamically modified at runtime. */\nexport type DynamicStreamProperties =\n  | \"highDemandTimeWindow\"\n  | \"httpDownloadTimeWindow\"\n  | \"p2pDownloadTimeWindow\"\n  | \"simultaneousHttpDownloads\"\n  | \"simultaneousP2PDownloads\"\n  | \"webRtcMaxMessageSize\"\n  | \"p2pNotReceivingBytesTimeoutMs\"\n  | \"p2pInactiveLoaderDestroyTimeoutMs\"\n  | \"httpNotReceivingBytesTimeoutMs\"\n  | \"httpErrorRetries\"\n  | \"p2pErrorRetries\"\n  | \"validateP2PSegment\"\n  | \"httpRequestSetup\"\n  | \"isP2PDisabled\"\n  | \"isP2PUploadDisabled\";\n\n/**\n * Represents a dynamically modifiable configuration, allowing updates to selected CoreConfig properties at runtime.\n *\n * @example\n * ```typescript\n * const dynamicConfig: DynamicCoreConfig = {\n *   core: {\n *     cachedSegmentsCount: 200,\n *   },\n *   mainStream: {\n *     swarmId: \"custom swarm ID for video stream\",\n *     p2pDownloadTimeWindow: 6000,\n *   },\n *   secondaryStream: {\n *     swarmId: \"custom swarm ID for audio stream\",\n *     p2pDownloadTimeWindow: 3000,\n *   }\n * };\n * ```\n */\nexport type DynamicCoreConfig = Partial<\n  Pick<CoreConfig, DynamicStreamProperties>\n> &\n  Partial<CommonCoreConfig> & {\n    /** Optional dynamic configuration for the main stream. */\n    mainStream?: DynamicStreamConfig;\n    /** Optional dynamic configuration for the secondary stream. */\n    secondaryStream?: DynamicStreamConfig;\n  };\n\n/** Represents a partial configuration for a stream with dynamic properties. */\nexport type DynamicStreamConfig = Partial<\n  Pick<StreamConfig, DynamicStreamProperties>\n>;\n\n/** Represents the configuration for the Core functionality that is common to all streams. */\nexport type CommonCoreConfig = {\n  /**\n   * Defines the memory storage limit for media segments, in MiB.\n   *\n   * @default\n   * ```typescript\n   * segmentMemoryStorageLimit: undefined\n   * ```\n   *\n   * - When `undefined`, the default limit is determined based on the device type and browser:\n   *    - Desktop: 4096 MiB\n   *    - Android: 2048 MiB\n   *    - iOS: 1024 MiB\n   *    - Android WebView: 1024 MiB\n   *    - iOS WebView: 1024 MiB\n   *\n   */\n  segmentMemoryStorageLimit: number | undefined;\n\n  /**\n   * Optional custom storage factory for the segments storage.\n   *\n   * @default\n   * ```typescript\n   * customSegmentStorageFactory: undefined\n   * ```\n   */\n  customSegmentStorageFactory?: (isLive: boolean) => SegmentStorage;\n};\n\n/**\n * Represents a set of configuration parameters that can be used to override or extend the\n * default configuration settings for a specific stream (main or secondary).\n *\n * @example Configuration for basic video stream\n *\n * ```typescript\n * const config: CoreConfig = {\n *  highDemandTimeWindow: 15,\n *  httpDownloadTimeWindow: 3000,\n *  p2pDownloadTimeWindow: 6000,\n *  swarmId: \"custom swarm ID for video stream\",\n * }\n * ```\n *\n * @example Configuration for advanced video stream\n *\n * ```typescript\n * const config: CoreConfig = {\n *  // Configuration for both streams\n *  highDemandTimeWindow: 20,\n *  httpDownloadTimeWindow: 3000,\n *  p2pDownloadTimeWindow: 6000,\n *  mainStream: {\n *   // Optional configuration for the main stream\n *   swarmId: \"custom swarm ID for video stream\",\n *  },\n *  secondaryStream: {\n *   // Optional configuration for the secondary stream\n *   swarmId: \"custom swarm ID for audio stream\",\n *  },\n *  ```\n */\nexport type CoreConfig = Partial<StreamConfig> &\n  Partial<CommonCoreConfig> & {\n    /** Optional configuration for the main stream. */\n    mainStream?: Partial<StreamConfig>;\n    /** Optional configuration for the secondary stream. */\n    secondaryStream?: Partial<StreamConfig>;\n  };\n\n/** Configuration options for the Core functionality, including network and processing parameters. */\nexport type StreamConfig = {\n  /**\n   * Controls if peer-to-peer upload is disabled for the stream.\n   * If `true`, the stream only downloads segments without uploading to peers.\n   *\n   * @default\n   * ```typescript\n   * isP2PUploadDisabled: false\n   * ```\n   */\n  isP2PUploadDisabled: boolean;\n  /**\n   * Controls whether peer-to-peer functionality is disabled for the stream.\n   *\n   * @default\n   * ```typescript\n   * isP2PDisabled: false\n   * ```\n   */\n  isP2PDisabled: boolean;\n  /**\n   * Defines the duration of the time window, in seconds, during which segments are pre-loaded to ensure smooth playback.\n   * This window helps prioritize the fetching of media segments that are imminent to playback.\n   *\n   * @default\n   * ```typescript\n   * highDemandTimeWindow: 15\n   * ```\n   */\n  highDemandTimeWindow: number;\n\n  /**\n   * Defines the time window, in seconds, for HTTP segment downloads. This property specifies the duration\n   * over which media segments are pre-fetched using HTTP requests.\n   *\n   * For a better P2P ratio, it is recommended to set this `httpDownloadTimeWindow` to be lower than `p2pDownloadTimeWindow`.\n   *\n   * NOTE: This setting only takes effect if there is at least one peer connection and the connected peer\n   * does not have the requested segments available to share via P2P.\n   *\n   * @default\n   * ```typescript\n   * httpDownloadTimeWindow: 3000\n   * ```\n   */\n  httpDownloadTimeWindow: number;\n\n  /**\n   * Defines the time window, in seconds, dedicated to pre-fetching media segments via Peer-to-Peer (P2P) downloads.\n   * This duration determines how much content is downloaded in advance using P2P connections to ensure smooth playback and reduce reliance on HTTP downloads.\n   *\n   * For a better P2P ratio, it is recommended to set this time window to be greater than `httpDownloadTimeWindow` to maximize P2P usage.\n   *\n   * @default\n   * ```typescript\n   * p2pDownloadTimeWindow: 6000\n   * ```\n   */\n  p2pDownloadTimeWindow: number;\n\n  /**\n   * Maximum number of simultaneous HTTP downloads allowed.\n   *\n   * @default\n   * ```typescript\n   * simultaneousHttpDownloads: 2\n   * ```\n   */\n  simultaneousHttpDownloads: number;\n\n  /**\n   * Maximum number of simultaneous P2P downloads allowed.\n   *\n   * @default\n   * ```typescript\n   * simultaneousP2PDownloads: 3\n   * ```\n   */\n  simultaneousP2PDownloads: number;\n\n  /**\n   * Maximum message size for WebRTC communications, in bytes.\n   *\n   * @default\n   * ```typescript\n   * webRtcMaxMessageSize: 64 * 1024 - 1\n   * ```\n   */\n  webRtcMaxMessageSize: number;\n\n  /**\n   * Timeout for not receiving bytes from P2P, in milliseconds.\n   *\n   * @default\n   * ```typescript\n   * p2pNotReceivingBytesTimeoutMs: 2000\n   * ```\n   */\n  p2pNotReceivingBytesTimeoutMs: number;\n\n  /**\n   * Timeout for destroying the P2P loader if inactive, in milliseconds.\n   *\n   * @default\n   * ```typescript\n   * p2pInactiveLoaderDestroyTimeoutMs: 30 * 1000\n   * ```\n   */\n  p2pInactiveLoaderDestroyTimeoutMs: number;\n\n  /**\n   * Timeout for not receiving bytes from HTTP downloads, in milliseconds.\n   *\n   * @default\n   * ```typescript\n   * httpNotReceivingBytesTimeoutMs: 3000\n   * ```\n   */\n  httpNotReceivingBytesTimeoutMs: number;\n\n  /**\n   * Number of retries allowed after an HTTP error.\n   *\n   * @default\n   * ```typescript\n   * httpErrorRetries: 3\n   * ```\n   */\n  httpErrorRetries: number;\n\n  /**\n   * Number of retries allowed after a P2P error.\n   *\n   * @default\n   * ```typescript\n   * p2pErrorRetries: 3\n   * ```\n   */\n  p2pErrorRetries: number;\n\n  /**\n   * List of URLs to the WebTorrent trackers used for announcing and discovering peers (i.e. WebRTC signaling).\n   *\n   * WARNING: In the Safari browser, only the first tracker will be used. Safari has issues with multiple trackers,\n   * leading to problems with sending SDP messages for WebRTC signaling.\n   *\n   * @default\n   * The default trackers used are:\n   * ```typescript\n   * [\n   *   \"wss://tracker.novage.com.ua\",\n   *   \"wss://tracker.webtorrent.dev\",\n   *   \"wss://tracker.openwebtorrent.com\",\n   * ]\n   * ```\n   */\n  announceTrackers: string[];\n\n  /**\n   * Configuration for the RTC layer, used in WebRTC communication.\n   * This configuration specifies the STUN/TURN servers used by WebRTC to establish connections through NATs and firewalls.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/RTCConfiguration\n   *\n   * @default\n   * ```json\n   * {\n   *   \"rtcConfig\": {\n   *     \"iceServers\": [\n   *       { \"urls\": \"stun:stun.l.google.com:19302\" },\n   *       { \"urls\": \"stun:global.stun.twilio.com:3478\" }\n   *     ]\n   *   }\n   * }\n   * ```\n   */\n  rtcConfig: RTCConfiguration;\n\n  /**\n   * Prefix to use for the WebTorrent client version in tracker communications.\n   * If undefined, the default version prefix is used, which is calculated based on the package version.\n   *\n   * @default\n   * ```typescript\n   * trackerClientVersionPrefix: undefined\n   * ```\n   */\n  trackerClientVersionPrefix: string;\n\n  /**\n   * Optional unique identifier for the swarm, used to isolate peer pools by media stream.\n   * If undefined, the URL of the manifest is used as the swarm ID.\n   * @default\n   * ```typescript\n   * swarmId: undefined\n   * ```\n   */\n  swarmId?: string;\n\n  /**\n   * Optional function to validate a P2P segment before fully integrating it into the playback buffer.\n   * @param url URL of the segment to validate.\n   * @param byteRange Optional byte range of the segment.\n   * @param data Downloaded segment data.\n   * @returns A promise that resolves with a boolean indicating if the segment is valid.\n   *\n   * @default\n   * ```typescript\n   * validateP2PSegment: undefined\n   * ```\n   */\n  validateP2PSegment?: (\n    url: string,\n    byteRange: ByteRange | undefined,\n    data: ArrayBuffer,\n  ) => Promise<boolean>;\n\n  /**\n   * Optional function to validate a HTTP segment before fully integrating it into the playback buffer.\n   * @param url URL of the segment to validate.\n   * @param byteRange Optional byte range of the segment.\n   * @param data Downloaded segment data.\n   * @returns A promise that resolves with a boolean indicating if the segment is valid.\n   *\n   * @default\n   * ```typescript\n   * validateHTTPSegment: undefined\n   * ```\n   */\n  validateHTTPSegment?: (\n    url: string,\n    byteRange: ByteRange | undefined,\n    data: ArrayBuffer,\n  ) => Promise<boolean>;\n\n  /**\n   * Optional function to customize the setup of HTTP requests for segment downloads.\n   * @param segmentUrl URL of the segment.\n   * @param segmentByteRange The range of bytes requested for the segment.\n   * @param requestAbortSignal An abort signal to cancel the request if needed.\n   * @param requestByteRange Additional byte range for partial requests, if required.\n   * @returns A promise that resolves with the configured request, or undefined if no customization should be made.\n   *\n   * @default\n   * ```typescript\n   * httpRequestSetup: undefined\n   * ```\n   */\n  httpRequestSetup?: (\n    segmentUrl: string,\n    segmentByteRange: ByteRange | undefined,\n    requestAbortSignal: AbortSignal,\n    requestByteRange: { start: number; end?: number } | undefined,\n  ) => Promise<Request | undefined | null>;\n};\n\n/**\n * Specifies the source of a download within a media streaming context.\n *\n * \"http\" - Indicates that the segment was downloaded using the HTTP protocol.\n *\n * \"p2p\"- Indicates that the segment was downloaded through a peer-to-peer network.\n */\nexport type DownloadSource = \"http\" | \"p2p\";\n\n/** Represents details about a segment event. */\nexport type SegmentStartDetails = {\n  /** The segment that the event is about. */\n  segment: Segment;\n\n  /** The origin of the segment download. */\n  downloadSource: DownloadSource;\n\n  /** The peer ID, if the segment is downloaded from a peer. */\n  peerId: string | undefined;\n};\n\n/** Represents details about a segment error event. */\nexport type SegmentErrorDetails = {\n  /** The error that occurred during the segment download. */\n  error: RequestError;\n\n  /** The segment that the event is about. */\n  segment: Segment;\n\n  /** The source of the download. */\n  downloadSource: DownloadSource;\n\n  /** The peer ID, if the segment was downloaded from a peer. */\n  peerId: string | undefined;\n\n  /** The type of stream that the segment is associated with. */\n  streamType: StreamType;\n};\n\n/** Represents details about a segment abort event. */\nexport type SegmentAbortDetails = {\n  /** The segment that the event is about. */\n  segment: Segment;\n\n  /** The source of the download. */\n  downloadSource: DownloadSource | undefined;\n\n  /** The peer ID, if the segment was downloaded from a peer. */\n  peerId: string | undefined;\n\n  /** The type of stream that the segment is associated with. */\n  streamType: StreamType;\n};\n\n/** Represents the details about a loaded segment. */\nexport type SegmentLoadDetails = {\n  /** The URL of the loaded segment */\n  segmentUrl: string;\n\n  /** The length of the segment in bytes. */\n  bytesLength: number;\n\n  /** The source of the download. */\n  downloadSource: DownloadSource;\n\n  /** The peer ID, if the segment was downloaded from a peer. */\n  peerId: string | undefined;\n\n  /** The segment that the event is about. */\n  streamType: StreamType;\n};\n\n/** Represents the details of a peer in a peer-to-peer network. */\nexport type PeerDetails = {\n  /** The unique identifier for a peer in the network. */\n  peerId: string;\n  /** The type of stream that the peer is connected to. */\n  streamType: StreamType;\n};\n\n/** Represents the details of a peer error event. */\nexport type PeerErrorDetails = {\n  /** The unique identifier for a peer in the network. */\n  peerId: string;\n  /** The type of stream that the peer is connected to. */\n  streamType: StreamType;\n  /** The error that occurred during the peer-to-peer connection. */\n  error: Error;\n};\n\n/** Represents the details of a tracker error event. */\nexport type TrackerErrorDetails = {\n  /** The type of stream that the tracker is for. */\n  streamType: StreamType;\n  /** The error that occurred during the tracker request. */\n  error: unknown;\n};\n\nexport type TrackerWarningDetails = {\n  /** The type of stream that the tracker is for. */\n  streamType: StreamType;\n  /** The warning that occurred during the tracker request. */\n  warning: unknown;\n};\n\n/**\n * The CoreEventMap defines a comprehensive suite of event handlers crucial for monitoring and controlling the lifecycle\n * of segment downloading and uploading processes.\n */\nexport type CoreEventMap = {\n  /**\n   * Invoked when a segment is fully downloaded and available for use.\n   *\n   * @param params - Contains information about the loaded segment.\n   */\n  onSegmentLoaded: (params: SegmentLoadDetails) => void;\n\n  /**\n   * Triggered when an error occurs during the download of a segment.\n   *\n   * @param params - Contains information about the errored segment.\n   */\n  onSegmentError: (params: SegmentErrorDetails) => void;\n\n  /**\n   * Called if the download of a segment is aborted before completion.\n   *\n   * @param params - Contains information about the aborted segment.\n   */\n  onSegmentAbort: (params: SegmentAbortDetails) => void;\n\n  /**\n   * Fired at the beginning of a segment download process.\n   *\n   * @param params - Provides details about the segment being downloaded.\n   */\n  onSegmentStart: (params: SegmentStartDetails) => void;\n\n  /**\n   * Occurs when a new peer-to-peer connection is established.\n   *\n   * @param params - Contains details about the peer that the event is about.\n   */\n  onPeerConnect: (params: PeerDetails) => void;\n\n  /**\n   * Triggered when an existing peer-to-peer connection is closed.\n   *\n   * @param params - Contains details about the peer that the event is about.\n   */\n  onPeerClose: (params: PeerDetails) => void;\n\n  /**\n   * Triggered when an error occurs during a peer-to-peer connection.\n   *\n   * @param params - Contains details about the error and the peer that the event is about.\n   */\n  onPeerError: (params: PeerErrorDetails) => void;\n\n  /**\n   * Invoked after a chunk of data from a segment has been successfully downloaded.\n   *\n   * @param bytesLength - The size of the downloaded chunk in bytes.\n   * @param downloadSource - The source of the download.\n   * @param peerId - The peer ID of the peer that the event is about, if applicable.\n   */\n  onChunkDownloaded: (\n    bytesLength: number,\n    downloadSource: DownloadSource,\n    peerId?: string,\n  ) => void;\n\n  /**\n   * Called when a chunk of data has been successfully uploaded to a peer.\n   *\n   * @param bytesLength - The length of the segment in bytes.\n   * @param peerId - The peer ID, if the segment was downloaded from a peer\n   */\n  onChunkUploaded: (bytesLength: number, peerId: string) => void;\n\n  /**\n   * Called when an error occurs during the tracker request process.\n   *\n   * @param params - Contains information about the tracker error.\n   */\n  onTrackerError: (params: TrackerErrorDetails) => void;\n\n  /**\n   * Called when a warning occurs during the tracker request process.\n   *\n   * @param params - Contains information about the tracker warning.\n   */\n  onTrackerWarning: (params: TrackerWarningDetails) => void;\n};\n\n/** Defines the types of errors that can occur during a request abortion process. */\nexport type RequestAbortErrorType = \"abort\" | \"bytes-receiving-timeout\";\n\n/** Defines the types of errors specific to HTTP requests. */\nexport type HttpRequestErrorType =\n  | \"http-error\"\n  | \"http-bytes-mismatch\"\n  | \"http-unexpected-status-code\"\n  | \"http-segment-validation-failed\";\n\n/** Defines the types of errors specific to peer-to-peer requests. */\nexport type PeerRequestErrorType =\n  | \"peer-response-bytes-length-mismatch\"\n  | \"peer-protocol-violation\"\n  | \"peer-segment-absent\"\n  | \"peer-closed\"\n  | \"p2p-segment-validation-failed\";\n\n/** Enumerates all possible request error types, including HTTP and peer-related errors. */\nexport type RequestErrorType =\n  | RequestAbortErrorType\n  | PeerRequestErrorType\n  | HttpRequestErrorType;\n\n/**\n * Represents an error that can occur during the request process, with a timestamp for when the error occurred.\n * @template T - The specific type of request error.\n */\nexport class RequestError<\n  T extends RequestErrorType = RequestErrorType,\n> extends Error {\n  /** Error timestamp. */\n  readonly timestamp: number;\n\n  /**\n   * Constructs a new RequestError.\n   * @param type - The specific error type.\n   * @param message - Optional message describing the error.\n   */\n  constructor(\n    readonly type: T,\n    message?: string,\n  ) {\n    super(message);\n    this.timestamp = performance.now();\n  }\n}\n\n/** Represents the response from a segment request, including the data and measured bandwidth. */\nexport type SegmentResponse = {\n  /** Segment data as an ArrayBuffer. */\n  data: ArrayBuffer;\n\n  /** Measured bandwidth for the segment download, in bytes per second. */\n  bandwidth: number;\n};\n\n/** Custom error class for errors that occur during core network requests. */\nexport class CoreRequestError extends Error {\n  /**\n   * Constructs a new CoreRequestError.\n   * @param type - The type of the error, either 'failed' or 'aborted'.\n   */\n  constructor(readonly type: \"failed\" | \"aborted\") {\n    super();\n  }\n}\n\n/** Callbacks for handling the success or failure of an engine operation. */\nexport type EngineCallbacks = {\n  /**\n   * Called when the operation is successful.\n   * @param response - The response from the successful operation.\n   */\n  onSuccess: (response: SegmentResponse) => void;\n\n  /**\n   * Called when the operation encounters an error.\n   * @param reason - The error encountered during the operation.\n   */\n  onError: (reason: CoreRequestError) => void;\n};\n","import {\n  CoreConfig,\n  CoreEventMap,\n  RequestError,\n  HttpRequestErrorType,\n} from \"./types.js\";\nimport {\n  Request as SegmentRequest,\n  RequestControls,\n} from \"./requests/request.js\";\nimport { EventTarget } from \"./utils/event-target.js\";\n\ntype HttpConfig = Pick<\n  CoreConfig,\n  \"httpNotReceivingBytesTimeoutMs\" | \"httpRequestSetup\" | \"validateHTTPSegment\"\n>;\n\nexport class HttpRequestExecutor {\n  private readonly requestControls: RequestControls;\n  private readonly abortController = new AbortController();\n  private readonly expectedBytesLength?: number;\n  private readonly requestByteRange?: { start: number; end?: number };\n  private readonly onChunkDownloaded: CoreEventMap[\"onChunkDownloaded\"];\n\n  constructor(\n    private readonly request: SegmentRequest,\n    private readonly httpConfig: HttpConfig,\n    eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    this.onChunkDownloaded =\n      eventTarget.getEventDispatcher(\"onChunkDownloaded\");\n\n    const { byteRange } = this.request.segment;\n    if (byteRange) this.requestByteRange = { ...byteRange };\n\n    if (request.loadedBytes !== 0) {\n      this.requestByteRange = this.requestByteRange ?? { start: 0 };\n      this.requestByteRange.start =\n        this.requestByteRange.start + request.loadedBytes;\n    }\n    if (this.request.totalBytes) {\n      this.expectedBytesLength =\n        this.request.totalBytes - this.request.loadedBytes;\n    }\n\n    this.requestControls = this.request.start(\n      { downloadSource: \"http\" },\n      {\n        abort: () => this.abortController.abort(\"abort\"),\n        notReceivingBytesTimeoutMs:\n          this.httpConfig.httpNotReceivingBytesTimeoutMs,\n      },\n    );\n    void this.fetch();\n  }\n\n  private async fetch() {\n    const { segment } = this.request;\n    try {\n      let request = await this.httpConfig.httpRequestSetup?.(\n        segment.url,\n        segment.byteRange,\n        this.abortController.signal,\n        this.requestByteRange,\n      );\n\n      if (!request) {\n        const headers = new Headers(\n          this.requestByteRange\n            ? {\n                Range: `bytes=${this.requestByteRange.start}-${\n                  this.requestByteRange.end ?? \"\"\n                }`,\n              }\n            : undefined,\n        );\n\n        request = new Request(segment.url, {\n          headers,\n          signal: this.abortController.signal,\n        });\n      }\n\n      if (this.abortController.signal.aborted) {\n        throw new DOMException(\n          \"Request aborted before request fetch\",\n          \"AbortError\",\n        );\n      }\n\n      const response = await window.fetch(request);\n\n      this.handleResponseHeaders(response);\n\n      if (!response.body) return;\n      const { requestControls } = this;\n      requestControls.firstBytesReceived();\n\n      const reader = response.body.getReader();\n      for await (const chunk of readStream(reader)) {\n        this.requestControls.addLoadedChunk(chunk);\n        this.onChunkDownloaded(chunk.byteLength, \"http\");\n      }\n\n      const isValid =\n        (await this.httpConfig.validateHTTPSegment?.(\n          segment.url,\n          segment.byteRange,\n          this.request.data,\n        )) ?? true;\n\n      if (!isValid) {\n        this.request.clearLoadedBytes();\n        throw new RequestError<\"http-segment-validation-failed\">(\n          \"http-segment-validation-failed\",\n        );\n      }\n\n      requestControls.completeOnSuccess();\n    } catch (error) {\n      this.handleError(error);\n    }\n  }\n\n  private handleResponseHeaders(response: Response) {\n    if (!response.ok) {\n      if (response.status === 406) {\n        this.request.clearLoadedBytes();\n        throw new RequestError<\"http-bytes-mismatch\">(\n          \"http-bytes-mismatch\",\n          response.statusText,\n        );\n      } else {\n        throw new RequestError<\"http-error\">(\"http-error\", response.statusText);\n      }\n    }\n\n    const { requestByteRange } = this;\n    if (requestByteRange) {\n      if (response.status === 200) {\n        if (this.request.segment.byteRange) {\n          throw new RequestError(\"http-unexpected-status-code\");\n        } else {\n          this.request.clearLoadedBytes();\n        }\n      } else {\n        if (response.status !== 206) {\n          throw new RequestError(\n            \"http-unexpected-status-code\",\n            response.statusText,\n          );\n        }\n        const contentLengthHeader = response.headers.get(\"Content-Length\");\n        if (\n          contentLengthHeader &&\n          this.expectedBytesLength !== undefined &&\n          this.expectedBytesLength !== +contentLengthHeader\n        ) {\n          this.request.clearLoadedBytes();\n          throw new RequestError(\"http-bytes-mismatch\", response.statusText);\n        }\n\n        const contentRangeHeader = response.headers.get(\"Content-Range\");\n        const contentRange = contentRangeHeader\n          ? parseContentRangeHeader(contentRangeHeader)\n          : undefined;\n        if (contentRange) {\n          const { from, to } = contentRange;\n          const responseExpectedBytesLength =\n            to !== undefined && from !== undefined ? to - from + 1 : undefined;\n\n          if (\n            (responseExpectedBytesLength !== undefined &&\n              this.expectedBytesLength !== responseExpectedBytesLength) ||\n            (from !== undefined && requestByteRange.start !== from) ||\n            (to !== undefined &&\n              requestByteRange.end !== undefined &&\n              requestByteRange.end !== to)\n          ) {\n            this.request.clearLoadedBytes();\n            throw new RequestError(\"http-bytes-mismatch\", response.statusText);\n          }\n        }\n      }\n    }\n\n    if (response.status === 200 && this.request.totalBytes === undefined) {\n      const contentLengthHeader = response.headers.get(\"Content-Length\");\n      if (contentLengthHeader) this.request.setTotalBytes(+contentLengthHeader);\n    }\n  }\n\n  private handleError(error: unknown) {\n    if (error instanceof Error) {\n      if (error.name !== \"abort\") return;\n\n      const httpLoaderError =\n        error instanceof RequestError\n          ? (error as RequestError<HttpRequestErrorType>)\n          : new RequestError(\"http-error\", error.message);\n\n      this.requestControls.abortOnError(httpLoaderError);\n    }\n  }\n}\n\nasync function* readStream(\n  reader: ReadableStreamDefaultReader<Uint8Array>,\n): AsyncGenerator<Uint8Array> {\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) break;\n    yield value;\n  }\n}\n\nconst rangeHeaderRegex = /^bytes (?:(?:(\\d+)|)-(?:(\\d+)|)|\\*)\\/(?:(\\d+)|\\*)$/;\n\nfunction parseContentRangeHeader(headerValue: string) {\n  const match = rangeHeaderRegex.exec(headerValue.trim());\n  if (!match) return;\n\n  const [, from, to, total] = match;\n  return {\n    from: from ? parseInt(from) : undefined,\n    to: to ? parseInt(to) : undefined,\n    total: total ? parseInt(total) : undefined,\n  };\n}\n","function getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar browser = {exports: {}};\n\n// shim for using process in browser\nvar process = browser.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ());\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] };\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\nvar browserExports = browser.exports;\nconst process$1 = /*@__PURE__*/getDefaultExportFromCjs(browserExports);\n\nexport { process$1 as default, process$1 as process };\n//# sourceMappingURL=index.js.map\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\tlet m;\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\t// eslint-disable-next-line no-return-assign\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug') || exports.storage.getItem('DEBUG') ;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '')\n\t\t\t.trim()\n\t\t\t.replace(/\\s+/g, ',')\n\t\t\t.split(',')\n\t\t\t.filter(Boolean);\n\n\t\tfor (const ns of split) {\n\t\t\tif (ns[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(ns.slice(1));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(ns);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the given string matches a namespace template, honoring\n\t * asterisks as wildcards.\n\t *\n\t * @param {String} search\n\t * @param {String} template\n\t * @return {Boolean}\n\t */\n\tfunction matchesTemplate(search, template) {\n\t\tlet searchIndex = 0;\n\t\tlet templateIndex = 0;\n\t\tlet starIndex = -1;\n\t\tlet matchIndex = 0;\n\n\t\twhile (searchIndex < search.length) {\n\t\t\tif (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {\n\t\t\t\t// Match character or proceed with wildcard\n\t\t\t\tif (template[templateIndex] === '*') {\n\t\t\t\t\tstarIndex = templateIndex;\n\t\t\t\t\tmatchIndex = searchIndex;\n\t\t\t\t\ttemplateIndex++; // Skip the '*'\n\t\t\t\t} else {\n\t\t\t\t\tsearchIndex++;\n\t\t\t\t\ttemplateIndex++;\n\t\t\t\t}\n\t\t\t} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition\n\t\t\t\t// Backtrack to the last '*' and try to match more characters\n\t\t\t\ttemplateIndex = starIndex + 1;\n\t\t\t\tmatchIndex++;\n\t\t\t\tsearchIndex = matchIndex;\n\t\t\t} else {\n\t\t\t\treturn false; // No match\n\t\t\t}\n\t\t}\n\n\t\t// Handle trailing '*' in template\n\t\twhile (templateIndex < template.length && template[templateIndex] === '*') {\n\t\t\ttemplateIndex++;\n\t\t}\n\n\t\treturn templateIndex === template.length;\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names,\n\t\t\t...createDebug.skips.map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tfor (const skip of createDebug.skips) {\n\t\t\tif (matchesTemplate(name, skip)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (const ns of createDebug.names) {\n\t\t\tif (matchesTemplate(name, ns)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","var wrappy = require('wrappy')\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n","// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n","/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nlet promise\n\nmodule.exports = typeof queueMicrotask === 'function'\n  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : global)\n  // reuse resolved promise, and allocate it lazily\n  : cb => (promise || (promise = Promise.resolve()))\n    .then(cb)\n    .catch(err => setTimeout(() => { throw err }, 0))\n","/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nmodule.exports = runParallel\n\nconst queueMicrotask = require('queue-microtask')\n\nfunction runParallel (tasks, cb) {\n  let results, pending, keys\n  let isSync = true\n\n  if (Array.isArray(tasks)) {\n    results = []\n    pending = tasks.length\n  } else {\n    keys = Object.keys(tasks)\n    results = {}\n    pending = keys.length\n  }\n\n  function done (err) {\n    function end () {\n      if (cb) cb(err, results)\n      cb = null\n    }\n    if (isSync) queueMicrotask(end)\n    else end()\n  }\n\n  function each (i, err, result) {\n    results[i] = result\n    if (--pending === 0 || err) {\n      done(err)\n    }\n  }\n\n  if (!pending) {\n    // empty\n    done(null)\n  } else if (keys) {\n    // object\n    keys.forEach(function (key) {\n      tasks[key](function (err, result) { each(key, err, result) })\n    })\n  } else {\n    // array\n    tasks.forEach(function (task, i) {\n      task(function (err, result) { each(i, err, result) })\n    })\n  }\n\n  isSync = false\n}\n","const scope = typeof window !== 'undefined' ? window : self\r\n\r\n// @ts-ignore\r\nexport const RTCPeerConnection = scope.RTCPeerConnection || scope.mozRTCPeerConnection || scope.webkitRTCPeerConnection\r\n// @ts-ignore\r\nexport const RTCSessionDescription = scope.RTCSessionDescription || scope.mozRTCSessionDescription || scope.webkitRTCSessionDescription\r\n// @ts-ignore\r\nexport const RTCIceCandidate = scope.RTCIceCandidate || scope.mozRTCIceCandidate || scope.webkitRTCIceCandidate\r\nexport const RTCIceTransport = scope.RTCIceTransport\r\nexport const RTCDataChannel = scope.RTCDataChannel\r\nexport const RTCSctpTransport = scope.RTCSctpTransport\r\nexport const RTCDtlsTransport = scope.RTCDtlsTransport\r\nexport const RTCCertificate = scope.RTCCertificate\r\nexport const MediaStream = scope.MediaStream\r\nexport const MediaStreamTrack = scope.MediaStreamTrack\r\nexport const MediaStreamTrackEvent = scope.MediaStreamTrackEvent\r\nexport const RTCPeerConnectionIceEvent = scope.RTCPeerConnectionIceEvent\r\nexport const RTCDataChannelEvent = scope.RTCDataChannelEvent\r\nexport const RTCTrackEvent = scope.RTCTrackEvent\r\nexport const RTCError = scope.RTCError\r\nexport const RTCErrorEvent = scope.RTCErrorEvent\r\nexport const RTCRtpTransceiver = scope.RTCRtpTransceiver\r\nexport const RTCRtpReceiver = scope.RTCRtpReceiver\r\nexport const RTCRtpSender = scope.RTCRtpSender\r\n\r\nexport * as default from './browser.js'\r\n","const FixedFIFO = require('./fixed-size')\n\nmodule.exports = class FastFIFO {\n  constructor (hwm) {\n    this.hwm = hwm || 16\n    this.head = new FixedFIFO(this.hwm)\n    this.tail = this.head\n    this.length = 0\n  }\n\n  clear () {\n    this.head = this.tail\n    this.head.clear()\n    this.length = 0\n  }\n\n  push (val) {\n    this.length++\n    if (!this.head.push(val)) {\n      const prev = this.head\n      this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length)\n      this.head.push(val)\n    }\n  }\n\n  shift () {\n    if (this.length !== 0) this.length--\n    const val = this.tail.shift()\n    if (val === undefined && this.tail.next) {\n      const next = this.tail.next\n      this.tail.next = null\n      this.tail = next\n      return this.tail.shift()\n    }\n\n    return val\n  }\n\n  peek () {\n    const val = this.tail.peek()\n    if (val === undefined && this.tail.next) return this.tail.next.peek()\n    return val\n  }\n\n  isEmpty () {\n    return this.length === 0\n  }\n}\n","module.exports = class FixedFIFO {\n  constructor (hwm) {\n    if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) throw new Error('Max size for a FixedFIFO should be a power of two')\n    this.buffer = new Array(hwm)\n    this.mask = hwm - 1\n    this.top = 0\n    this.btm = 0\n    this.next = null\n  }\n\n  clear () {\n    this.top = this.btm = 0\n    this.next = null\n    this.buffer.fill(undefined)\n  }\n\n  push (data) {\n    if (this.buffer[this.top] !== undefined) return false\n    this.buffer[this.top] = data\n    this.top = (this.top + 1) & this.mask\n    return true\n  }\n\n  shift () {\n    const last = this.buffer[this.btm]\n    if (last === undefined) return undefined\n    this.buffer[this.btm] = undefined\n    this.btm = (this.btm + 1) & this.mask\n    return last\n  }\n\n  peek () {\n    return this.buffer[this.btm]\n  }\n\n  isEmpty () {\n    return this.buffer[this.btm] === undefined\n  }\n}\n","module.exports = class BrowserDecoder {\n  constructor (encoding) {\n    this.decoder = new TextDecoder(encoding === 'utf16le' ? 'utf16-le' : encoding)\n  }\n\n  get remaining () {\n    return -1\n  }\n\n  decode (data) {\n    return this.decoder.decode(data, { stream: true })\n  }\n\n  flush () {\n    return this.decoder.decode(new Uint8Array(0))\n  }\n}\n","const PassThroughDecoder = require('./lib/pass-through-decoder')\nconst UTF8Decoder = require('./lib/utf8-decoder')\n\nmodule.exports = class TextDecoder {\n  constructor (encoding = 'utf8') {\n    this.encoding = normalizeEncoding(encoding)\n\n    switch (this.encoding) {\n      case 'utf8':\n        this.decoder = new UTF8Decoder()\n        break\n      case 'utf16le':\n      case 'base64':\n        throw new Error('Unsupported encoding: ' + this.encoding)\n      default:\n        this.decoder = new PassThroughDecoder(this.encoding)\n    }\n  }\n\n  get remaining () {\n    return this.decoder.remaining\n  }\n\n  push (data) {\n    if (typeof data === 'string') return data\n    return this.decoder.decode(data)\n  }\n\n  // For Node.js compatibility\n  write (data) {\n    return this.push(data)\n  }\n\n  end (data) {\n    let result = ''\n    if (data) result = this.push(data)\n    result += this.decoder.flush()\n    return result\n  }\n}\n\nfunction normalizeEncoding (encoding) {\n  encoding = encoding.toLowerCase()\n\n  switch (encoding) {\n    case 'utf8':\n    case 'utf-8':\n      return 'utf8'\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return 'utf16le'\n    case 'latin1':\n    case 'binary':\n      return 'latin1'\n    case 'base64':\n    case 'ascii':\n    case 'hex':\n      return encoding\n    default:\n      throw new Error('Unknown encoding: ' + encoding)\n  }\n};\n","const { EventEmitter } = require('events-universal')\nconst STREAM_DESTROYED = new Error('Stream was destroyed')\nconst PREMATURE_CLOSE = new Error('Premature close')\n\nconst FIFO = require('fast-fifo')\nconst TextDecoder = require('text-decoder')\n\n// if we do a future major, expect queue microtask to be there always, for now a bit defensive\nconst qmt = typeof queueMicrotask === 'undefined' ? fn => global.process.nextTick(fn) : queueMicrotask\n\n/* eslint-disable no-multi-spaces */\n\n// 29 bits used total (4 from shared, 14 from read, and 11 from write)\nconst MAX = ((1 << 29) - 1)\n\n// Shared state\nconst OPENING       = 0b0001\nconst PREDESTROYING = 0b0010\nconst DESTROYING    = 0b0100\nconst DESTROYED     = 0b1000\n\nconst NOT_OPENING = MAX ^ OPENING\nconst NOT_PREDESTROYING = MAX ^ PREDESTROYING\n\n// Read state (4 bit offset from shared state)\nconst READ_ACTIVE           = 0b00000000000001 << 4\nconst READ_UPDATING         = 0b00000000000010 << 4\nconst READ_PRIMARY          = 0b00000000000100 << 4\nconst READ_QUEUED           = 0b00000000001000 << 4\nconst READ_RESUMED          = 0b00000000010000 << 4\nconst READ_PIPE_DRAINED     = 0b00000000100000 << 4\nconst READ_ENDING           = 0b00000001000000 << 4\nconst READ_EMIT_DATA        = 0b00000010000000 << 4\nconst READ_EMIT_READABLE    = 0b00000100000000 << 4\nconst READ_EMITTED_READABLE = 0b00001000000000 << 4\nconst READ_DONE             = 0b00010000000000 << 4\nconst READ_NEXT_TICK        = 0b00100000000000 << 4\nconst READ_NEEDS_PUSH       = 0b01000000000000 << 4\nconst READ_READ_AHEAD       = 0b10000000000000 << 4\n\n// Combined read state\nconst READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED\nconst READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH\nconst READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE\nconst READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED\nconst READ_RESUMED_READ_AHEAD = READ_RESUMED | READ_READ_AHEAD\n\nconst READ_NOT_ACTIVE             = MAX ^ READ_ACTIVE\nconst READ_NON_PRIMARY            = MAX ^ READ_PRIMARY\nconst READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH)\nconst READ_PUSHED                 = MAX ^ READ_NEEDS_PUSH\nconst READ_PAUSED                 = MAX ^ READ_RESUMED\nconst READ_NOT_QUEUED             = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE)\nconst READ_NOT_ENDING             = MAX ^ READ_ENDING\nconst READ_PIPE_NOT_DRAINED       = MAX ^ READ_FLOWING\nconst READ_NOT_NEXT_TICK          = MAX ^ READ_NEXT_TICK\nconst READ_NOT_UPDATING           = MAX ^ READ_UPDATING\nconst READ_NO_READ_AHEAD          = MAX ^ READ_READ_AHEAD\nconst READ_PAUSED_NO_READ_AHEAD   = MAX ^ READ_RESUMED_READ_AHEAD\n\n// Write state (18 bit offset, 4 bit offset from shared state and 14 from read state)\nconst WRITE_ACTIVE     = 0b00000000001 << 18\nconst WRITE_UPDATING   = 0b00000000010 << 18\nconst WRITE_PRIMARY    = 0b00000000100 << 18\nconst WRITE_QUEUED     = 0b00000001000 << 18\nconst WRITE_UNDRAINED  = 0b00000010000 << 18\nconst WRITE_DONE       = 0b00000100000 << 18\nconst WRITE_EMIT_DRAIN = 0b00001000000 << 18\nconst WRITE_NEXT_TICK  = 0b00010000000 << 18\nconst WRITE_WRITING    = 0b00100000000 << 18\nconst WRITE_FINISHING  = 0b01000000000 << 18\nconst WRITE_CORKED     = 0b10000000000 << 18\n\nconst WRITE_NOT_ACTIVE    = MAX ^ (WRITE_ACTIVE | WRITE_WRITING)\nconst WRITE_NON_PRIMARY   = MAX ^ WRITE_PRIMARY\nconst WRITE_NOT_FINISHING = MAX ^ (WRITE_ACTIVE | WRITE_FINISHING)\nconst WRITE_DRAINED       = MAX ^ WRITE_UNDRAINED\nconst WRITE_NOT_QUEUED    = MAX ^ WRITE_QUEUED\nconst WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK\nconst WRITE_NOT_UPDATING  = MAX ^ WRITE_UPDATING\nconst WRITE_NOT_CORKED    = MAX ^ WRITE_CORKED\n\n// Combined shared state\nconst ACTIVE = READ_ACTIVE | WRITE_ACTIVE\nconst NOT_ACTIVE = MAX ^ ACTIVE\nconst DONE = READ_DONE | WRITE_DONE\nconst DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING\nconst OPEN_STATUS = DESTROY_STATUS | OPENING\nconst AUTO_DESTROY = DESTROY_STATUS | DONE\nconst NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY\nconst ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK\nconst TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE\nconst IS_OPENING = OPEN_STATUS | TICKING\n\n// Combined shared state and read state\nconst READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE\nconst READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED\nconst READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED\nconst READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE\nconst SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH | READ_READ_AHEAD\nconst READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE\nconst READ_UPDATE_SYNC_STATUS = READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY\nconst READ_NEXT_TICK_OR_OPENING = READ_NEXT_TICK | OPENING\n\n// Combined write state\nconst WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED\nconst WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE\nconst WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE\nconst WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED | WRITE_CORKED\nconst WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE\nconst WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING\nconst WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE\nconst WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_UPDATE_SYNC_STATUS = WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY\nconst WRITE_DROP_DATA = WRITE_FINISHING | WRITE_DONE | DESTROY_STATUS\n\nconst asyncIterator = Symbol.asyncIterator || Symbol('asyncIterator')\n\nclass WritableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapWritable, byteLength, byteLengthWritable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark\n    this.buffered = 0\n    this.error = null\n    this.pipeline = null\n    this.drains = null // if we add more seldomly used helpers we might them into a subobject so its a single ptr\n    this.byteLength = byteLengthWritable || byteLength || defaultByteLength\n    this.map = mapWritable || map\n    this.afterWrite = afterWrite.bind(this)\n    this.afterUpdateNextTick = updateWriteNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & WRITE_DONE) !== 0\n  }\n\n  push (data) {\n    if ((this.stream._duplexState & WRITE_DROP_DATA) !== 0) return false\n    if (this.map !== null) data = this.map(data)\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    if (this.buffered < this.highWaterMark) {\n      this.stream._duplexState |= WRITE_QUEUED\n      return true\n    }\n\n    this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED\n    return false\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= WRITE_NOT_QUEUED\n\n    return data\n  }\n\n  end (data) {\n    if (typeof data === 'function') this.stream.once('finish', data)\n    else if (data !== undefined && data !== null) this.push(data)\n    this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY\n  }\n\n  autoBatch (data, cb) {\n    const buffer = []\n    const stream = this.stream\n\n    buffer.push(data)\n    while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {\n      buffer.push(stream._writableState.shift())\n    }\n\n    if ((stream._duplexState & OPEN_STATUS) !== 0) return cb(null)\n    stream._writev(buffer, cb)\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= WRITE_UPDATING\n\n    do {\n      while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {\n        const data = this.shift()\n        stream._duplexState |= WRITE_ACTIVE_AND_WRITING\n        stream._write(data, this.afterWrite)\n      }\n\n      if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= WRITE_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {\n      stream._duplexState = stream._duplexState | WRITE_ACTIVE\n      stream._final(afterFinal.bind(this))\n      return\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= WRITE_NEXT_TICK\n    if ((this.stream._duplexState & WRITE_UPDATING) === 0) qmt(this.afterUpdateNextTick)\n  }\n}\n\nclass ReadableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapReadable, byteLength, byteLengthReadable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark\n    this.buffered = 0\n    this.readAhead = highWaterMark > 0\n    this.error = null\n    this.pipeline = null\n    this.byteLength = byteLengthReadable || byteLength || defaultByteLength\n    this.map = mapReadable || map\n    this.pipeTo = null\n    this.afterRead = afterRead.bind(this)\n    this.afterUpdateNextTick = updateReadNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & READ_DONE) !== 0\n  }\n\n  pipe (pipeTo, cb) {\n    if (this.pipeTo !== null) throw new Error('Can only pipe to one destination')\n    if (typeof cb !== 'function') cb = null\n\n    this.stream._duplexState |= READ_PIPE_DRAINED\n    this.pipeTo = pipeTo\n    this.pipeline = new Pipeline(this.stream, pipeTo, cb)\n\n    if (cb) this.stream.on('error', noop) // We already error handle this so supress crashes\n\n    if (isStreamx(pipeTo)) {\n      pipeTo._writableState.pipeline = this.pipeline\n      if (cb) pipeTo.on('error', noop) // We already error handle this so supress crashes\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline)) // TODO: just call finished from pipeTo itself\n    } else {\n      const onerror = this.pipeline.done.bind(this.pipeline, pipeTo)\n      const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null) // onclose has a weird bool arg\n      pipeTo.on('error', onerror)\n      pipeTo.on('close', onclose)\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline))\n    }\n\n    pipeTo.on('drain', afterDrain.bind(this))\n    this.stream.emit('piping', pipeTo)\n    pipeTo.emit('pipe', this.stream)\n  }\n\n  push (data) {\n    const stream = this.stream\n\n    if (data === null) {\n      this.highWaterMark = 0\n      stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED\n      return false\n    }\n\n    if (this.map !== null) {\n      data = this.map(data)\n      if (data === null) {\n        stream._duplexState &= READ_PUSHED\n        return this.buffered < this.highWaterMark\n      }\n    }\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED\n\n    return this.buffered < this.highWaterMark\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= READ_NOT_QUEUED\n    return data\n  }\n\n  unshift (data) {\n    const pending = [this.map !== null ? this.map(data) : data]\n    while (this.buffered > 0) pending.push(this.shift())\n\n    for (let i = 0; i < pending.length - 1; i++) {\n      const data = pending[i]\n      this.buffered += this.byteLength(data)\n      this.queue.push(data)\n    }\n\n    this.push(pending[pending.length - 1])\n  }\n\n  read () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n      return data\n    }\n\n    if (this.readAhead === false) {\n      stream._duplexState |= READ_READ_AHEAD\n      this.updateNextTick()\n    }\n\n    return null\n  }\n\n  drain () {\n    const stream = this.stream\n\n    while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n    }\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= READ_UPDATING\n\n    do {\n      this.drain()\n\n      while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === READ_READ_AHEAD) {\n        stream._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH\n        stream._read(this.afterRead)\n        this.drain()\n      }\n\n      if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {\n        stream._duplexState |= READ_EMITTED_READABLE\n        stream.emit('readable')\n      }\n\n      if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= READ_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {\n      stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING\n      stream.emit('end')\n      if ((stream._duplexState & AUTO_DESTROY) === DONE) stream._duplexState |= DESTROYING\n      if (this.pipeTo !== null) this.pipeTo.end()\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTickIfOpen () {\n    if ((this.stream._duplexState & READ_NEXT_TICK_OR_OPENING) !== 0) return\n    this.stream._duplexState |= READ_NEXT_TICK\n    if ((this.stream._duplexState & READ_UPDATING) === 0) qmt(this.afterUpdateNextTick)\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= READ_NEXT_TICK\n    if ((this.stream._duplexState & READ_UPDATING) === 0) qmt(this.afterUpdateNextTick)\n  }\n}\n\nclass TransformState {\n  constructor (stream) {\n    this.data = null\n    this.afterTransform = afterTransform.bind(stream)\n    this.afterFinal = null\n  }\n}\n\nclass Pipeline {\n  constructor (src, dst, cb) {\n    this.from = src\n    this.to = dst\n    this.afterPipe = cb\n    this.error = null\n    this.pipeToFinished = false\n  }\n\n  finished () {\n    this.pipeToFinished = true\n  }\n\n  done (stream, err) {\n    if (err) this.error = err\n\n    if (stream === this.to) {\n      this.to = null\n\n      if (this.from !== null) {\n        if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {\n          this.from.destroy(this.error || new Error('Writable stream closed prematurely'))\n        }\n        return\n      }\n    }\n\n    if (stream === this.from) {\n      this.from = null\n\n      if (this.to !== null) {\n        if ((stream._duplexState & READ_DONE) === 0) {\n          this.to.destroy(this.error || new Error('Readable stream closed before ending'))\n        }\n        return\n      }\n    }\n\n    if (this.afterPipe !== null) this.afterPipe(this.error)\n    this.to = this.from = this.afterPipe = null\n  }\n}\n\nfunction afterDrain () {\n  this.stream._duplexState |= READ_PIPE_DRAINED\n  this.updateCallback()\n}\n\nfunction afterFinal (err) {\n  const stream = this.stream\n  if (err) stream.destroy(err)\n  if ((stream._duplexState & DESTROY_STATUS) === 0) {\n    stream._duplexState |= WRITE_DONE\n    stream.emit('finish')\n  }\n  if ((stream._duplexState & AUTO_DESTROY) === DONE) {\n    stream._duplexState |= DESTROYING\n  }\n\n  stream._duplexState &= WRITE_NOT_FINISHING\n\n  // no need to wait the extra tick here, so we short circuit that\n  if ((stream._duplexState & WRITE_UPDATING) === 0) this.update()\n  else this.updateNextTick()\n}\n\nfunction afterDestroy (err) {\n  const stream = this.stream\n\n  if (!err && this.error !== STREAM_DESTROYED) err = this.error\n  if (err) stream.emit('error', err)\n  stream._duplexState |= DESTROYED\n  stream.emit('close')\n\n  const rs = stream._readableState\n  const ws = stream._writableState\n\n  if (rs !== null && rs.pipeline !== null) rs.pipeline.done(stream, err)\n\n  if (ws !== null) {\n    while (ws.drains !== null && ws.drains.length > 0) ws.drains.shift().resolve(false)\n    if (ws.pipeline !== null) ws.pipeline.done(stream, err)\n  }\n}\n\nfunction afterWrite (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n  stream._duplexState &= WRITE_NOT_ACTIVE\n\n  if (this.drains !== null) tickDrains(this.drains)\n\n  if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {\n    stream._duplexState &= WRITE_DRAINED\n    if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {\n      stream.emit('drain')\n    }\n  }\n\n  this.updateCallback()\n}\n\nfunction afterRead (err) {\n  if (err) this.stream.destroy(err)\n  this.stream._duplexState &= READ_NOT_ACTIVE\n  if (this.readAhead === false && (this.stream._duplexState & READ_RESUMED) === 0) this.stream._duplexState &= READ_NO_READ_AHEAD\n  this.updateCallback()\n}\n\nfunction updateReadNT () {\n  if ((this.stream._duplexState & READ_UPDATING) === 0) {\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction updateWriteNT () {\n  if ((this.stream._duplexState & WRITE_UPDATING) === 0) {\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction tickDrains (drains) {\n  for (let i = 0; i < drains.length; i++) {\n    // drains.writes are monotonic, so if one is 0 its always the first one\n    if (--drains[i].writes === 0) {\n      drains.shift().resolve(true)\n      i--\n    }\n  }\n}\n\nfunction afterOpen (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n\n  if ((stream._duplexState & DESTROYING) === 0) {\n    if ((stream._duplexState & READ_PRIMARY_STATUS) === 0) stream._duplexState |= READ_PRIMARY\n    if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0) stream._duplexState |= WRITE_PRIMARY\n    stream.emit('open')\n  }\n\n  stream._duplexState &= NOT_ACTIVE\n\n  if (stream._writableState !== null) {\n    stream._writableState.updateCallback()\n  }\n\n  if (stream._readableState !== null) {\n    stream._readableState.updateCallback()\n  }\n}\n\nfunction afterTransform (err, data) {\n  if (data !== undefined && data !== null) this.push(data)\n  this._writableState.afterWrite(err)\n}\n\nfunction newListener (name) {\n  if (this._readableState !== null) {\n    if (name === 'data') {\n      this._duplexState |= (READ_EMIT_DATA | READ_RESUMED_READ_AHEAD)\n      this._readableState.updateNextTick()\n    }\n    if (name === 'readable') {\n      this._duplexState |= READ_EMIT_READABLE\n      this._readableState.updateNextTick()\n    }\n  }\n\n  if (this._writableState !== null) {\n    if (name === 'drain') {\n      this._duplexState |= WRITE_EMIT_DRAIN\n      this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Stream extends EventEmitter {\n  constructor (opts) {\n    super()\n\n    this._duplexState = 0\n    this._readableState = null\n    this._writableState = null\n\n    if (opts) {\n      if (opts.open) this._open = opts.open\n      if (opts.destroy) this._destroy = opts.destroy\n      if (opts.predestroy) this._predestroy = opts.predestroy\n      if (opts.signal) {\n        opts.signal.addEventListener('abort', abort.bind(this))\n      }\n    }\n\n    this.on('newListener', newListener)\n  }\n\n  _open (cb) {\n    cb(null)\n  }\n\n  _destroy (cb) {\n    cb(null)\n  }\n\n  _predestroy () {\n    // does nothing\n  }\n\n  get readable () {\n    return this._readableState !== null ? true : undefined\n  }\n\n  get writable () {\n    return this._writableState !== null ? true : undefined\n  }\n\n  get destroyed () {\n    return (this._duplexState & DESTROYED) !== 0\n  }\n\n  get destroying () {\n    return (this._duplexState & DESTROY_STATUS) !== 0\n  }\n\n  destroy (err) {\n    if ((this._duplexState & DESTROY_STATUS) === 0) {\n      if (!err) err = STREAM_DESTROYED\n      this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY\n\n      if (this._readableState !== null) {\n        this._readableState.highWaterMark = 0\n        this._readableState.error = err\n      }\n      if (this._writableState !== null) {\n        this._writableState.highWaterMark = 0\n        this._writableState.error = err\n      }\n\n      this._duplexState |= PREDESTROYING\n      this._predestroy()\n      this._duplexState &= NOT_PREDESTROYING\n\n      if (this._readableState !== null) this._readableState.updateNextTick()\n      if (this._writableState !== null) this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Readable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | WRITE_DONE | READ_READ_AHEAD\n    this._readableState = new ReadableState(this, opts)\n\n    if (opts) {\n      if (this._readableState.readAhead === false) this._duplexState &= READ_NO_READ_AHEAD\n      if (opts.read) this._read = opts.read\n      if (opts.eagerOpen) this._readableState.updateNextTick()\n      if (opts.encoding) this.setEncoding(opts.encoding)\n    }\n  }\n\n  setEncoding (encoding) {\n    const dec = new TextDecoder(encoding)\n    const map = this._readableState.map || echo\n    this._readableState.map = mapOrSkip\n    return this\n\n    function mapOrSkip (data) {\n      const next = dec.push(data)\n      return next === '' && (data.byteLength !== 0 || dec.remaining > 0) ? null : map(next)\n    }\n  }\n\n  _read (cb) {\n    cb(null)\n  }\n\n  pipe (dest, cb) {\n    this._readableState.updateNextTick()\n    this._readableState.pipe(dest, cb)\n    return dest\n  }\n\n  read () {\n    this._readableState.updateNextTick()\n    return this._readableState.read()\n  }\n\n  push (data) {\n    this._readableState.updateNextTickIfOpen()\n    return this._readableState.push(data)\n  }\n\n  unshift (data) {\n    this._readableState.updateNextTickIfOpen()\n    return this._readableState.unshift(data)\n  }\n\n  resume () {\n    this._duplexState |= READ_RESUMED_READ_AHEAD\n    this._readableState.updateNextTick()\n    return this\n  }\n\n  pause () {\n    this._duplexState &= (this._readableState.readAhead === false ? READ_PAUSED_NO_READ_AHEAD : READ_PAUSED)\n    return this\n  }\n\n  static _fromAsyncIterator (ite, opts) {\n    let destroy\n\n    const rs = new Readable({\n      ...opts,\n      read (cb) {\n        ite.next().then(push).then(cb.bind(null, null)).catch(cb)\n      },\n      predestroy () {\n        destroy = ite.return()\n      },\n      destroy (cb) {\n        if (!destroy) return cb(null)\n        destroy.then(cb.bind(null, null)).catch(cb)\n      }\n    })\n\n    return rs\n\n    function push (data) {\n      if (data.done) rs.push(null)\n      else rs.push(data.value)\n    }\n  }\n\n  static from (data, opts) {\n    if (isReadStreamx(data)) return data\n    if (data[asyncIterator]) return this._fromAsyncIterator(data[asyncIterator](), opts)\n    if (!Array.isArray(data)) data = data === undefined ? [] : [data]\n\n    let i = 0\n    return new Readable({\n      ...opts,\n      read (cb) {\n        this.push(i === data.length ? null : data[i++])\n        cb(null)\n      }\n    })\n  }\n\n  static isBackpressured (rs) {\n    return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark\n  }\n\n  static isPaused (rs) {\n    return (rs._duplexState & READ_RESUMED) === 0\n  }\n\n  [asyncIterator] () {\n    const stream = this\n\n    let error = null\n    let promiseResolve = null\n    let promiseReject = null\n\n    this.on('error', (err) => { error = err })\n    this.on('readable', onreadable)\n    this.on('close', onclose)\n\n    return {\n      [asyncIterator] () {\n        return this\n      },\n      next () {\n        return new Promise(function (resolve, reject) {\n          promiseResolve = resolve\n          promiseReject = reject\n          const data = stream.read()\n          if (data !== null) ondata(data)\n          else if ((stream._duplexState & DESTROYED) !== 0) ondata(null)\n        })\n      },\n      return () {\n        return destroy(null)\n      },\n      throw (err) {\n        return destroy(err)\n      }\n    }\n\n    function onreadable () {\n      if (promiseResolve !== null) ondata(stream.read())\n    }\n\n    function onclose () {\n      if (promiseResolve !== null) ondata(null)\n    }\n\n    function ondata (data) {\n      if (promiseReject === null) return\n      if (error) promiseReject(error)\n      else if (data === null && (stream._duplexState & READ_DONE) === 0) promiseReject(STREAM_DESTROYED)\n      else promiseResolve({ value: data, done: data === null })\n      promiseReject = promiseResolve = null\n    }\n\n    function destroy (err) {\n      stream.destroy(err)\n      return new Promise((resolve, reject) => {\n        if (stream._duplexState & DESTROYED) return resolve({ value: undefined, done: true })\n        stream.once('close', function () {\n          if (err) reject(err)\n          else resolve({ value: undefined, done: true })\n        })\n      })\n    }\n  }\n}\n\nclass Writable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | READ_DONE\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n      if (opts.eagerOpen) this._writableState.updateNextTick()\n    }\n  }\n\n  cork () {\n    this._duplexState |= WRITE_CORKED\n  }\n\n  uncork () {\n    this._duplexState &= WRITE_NOT_CORKED\n    this._writableState.updateNextTick()\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  static isBackpressured (ws) {\n    return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0\n  }\n\n  static drained (ws) {\n    if (ws.destroyed) return Promise.resolve(false)\n    const state = ws._writableState\n    const pending = (isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length)\n    const writes = pending + ((ws._duplexState & WRITE_WRITING) ? 1 : 0)\n    if (writes === 0) return Promise.resolve(true)\n    if (state.drains === null) state.drains = []\n    return new Promise((resolve) => {\n      state.drains.push({ writes, resolve })\n    })\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Duplex extends Readable { // and Writable\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState = OPENING | (this._duplexState & READ_READ_AHEAD)\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n    }\n  }\n\n  cork () {\n    this._duplexState |= WRITE_CORKED\n  }\n\n  uncork () {\n    this._duplexState &= WRITE_NOT_CORKED\n    this._writableState.updateNextTick()\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Transform extends Duplex {\n  constructor (opts) {\n    super(opts)\n    this._transformState = new TransformState(this)\n\n    if (opts) {\n      if (opts.transform) this._transform = opts.transform\n      if (opts.flush) this._flush = opts.flush\n    }\n  }\n\n  _write (data, cb) {\n    if (this._readableState.buffered >= this._readableState.highWaterMark) {\n      this._transformState.data = data\n    } else {\n      this._transform(data, this._transformState.afterTransform)\n    }\n  }\n\n  _read (cb) {\n    if (this._transformState.data !== null) {\n      const data = this._transformState.data\n      this._transformState.data = null\n      cb(null)\n      this._transform(data, this._transformState.afterTransform)\n    } else {\n      cb(null)\n    }\n  }\n\n  destroy (err) {\n    super.destroy(err)\n    if (this._transformState.data !== null) {\n      this._transformState.data = null\n      this._transformState.afterTransform()\n    }\n  }\n\n  _transform (data, cb) {\n    cb(null, data)\n  }\n\n  _flush (cb) {\n    cb(null)\n  }\n\n  _final (cb) {\n    this._transformState.afterFinal = cb\n    this._flush(transformAfterFlush.bind(this))\n  }\n}\n\nclass PassThrough extends Transform {}\n\nfunction transformAfterFlush (err, data) {\n  const cb = this._transformState.afterFinal\n  if (err) return cb(err)\n  if (data !== null && data !== undefined) this.push(data)\n  this.push(null)\n  cb(null)\n}\n\nfunction pipelinePromise (...streams) {\n  return new Promise((resolve, reject) => {\n    return pipeline(...streams, (err) => {\n      if (err) return reject(err)\n      resolve()\n    })\n  })\n}\n\nfunction pipeline (stream, ...streams) {\n  const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams]\n  const done = (all.length && typeof all[all.length - 1] === 'function') ? all.pop() : null\n\n  if (all.length < 2) throw new Error('Pipeline requires at least 2 streams')\n\n  let src = all[0]\n  let dest = null\n  let error = null\n\n  for (let i = 1; i < all.length; i++) {\n    dest = all[i]\n\n    if (isStreamx(src)) {\n      src.pipe(dest, onerror)\n    } else {\n      errorHandle(src, true, i > 1, onerror)\n      src.pipe(dest)\n    }\n\n    src = dest\n  }\n\n  if (done) {\n    let fin = false\n\n    const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy)\n\n    dest.on('error', (err) => {\n      if (error === null) error = err\n    })\n\n    dest.on('finish', () => {\n      fin = true\n      if (!autoDestroy) done(error)\n    })\n\n    if (autoDestroy) {\n      dest.on('close', () => done(error || (fin ? null : PREMATURE_CLOSE)))\n    }\n  }\n\n  return dest\n\n  function errorHandle (s, rd, wr, onerror) {\n    s.on('error', onerror)\n    s.on('close', onclose)\n\n    function onclose () {\n      if (rd && s._readableState && !s._readableState.ended) return onerror(PREMATURE_CLOSE)\n      if (wr && s._writableState && !s._writableState.ended) return onerror(PREMATURE_CLOSE)\n    }\n  }\n\n  function onerror (err) {\n    if (!err || error) return\n    error = err\n\n    for (const s of all) {\n      s.destroy(err)\n    }\n  }\n}\n\nfunction echo (s) {\n  return s\n}\n\nfunction isStream (stream) {\n  return !!stream._readableState || !!stream._writableState\n}\n\nfunction isStreamx (stream) {\n  return typeof stream._duplexState === 'number' && isStream(stream)\n}\n\nfunction isEnded (stream) {\n  return !!stream._readableState && stream._readableState.ended\n}\n\nfunction isFinished (stream) {\n  return !!stream._writableState && stream._writableState.ended\n}\n\nfunction getStreamError (stream, opts = {}) {\n  const err = (stream._readableState && stream._readableState.error) || (stream._writableState && stream._writableState.error)\n\n  // avoid implicit errors by default\n  return (!opts.all && err === STREAM_DESTROYED) ? null : err\n}\n\nfunction isReadStreamx (stream) {\n  return isStreamx(stream) && stream.readable\n}\n\nfunction isDisturbed (stream) {\n  return (stream._duplexState & OPENING) !== OPENING || (stream._duplexState & ACTIVE_OR_TICKING) !== 0\n}\n\nfunction isTypedArray (data) {\n  return typeof data === 'object' && data !== null && typeof data.byteLength === 'number'\n}\n\nfunction defaultByteLength (data) {\n  return isTypedArray(data) ? data.byteLength : 1024\n}\n\nfunction noop () {}\n\nfunction abort () {\n  this.destroy(new Error('Stream aborted.'))\n}\n\nfunction isWritev (s) {\n  return s._writev !== Writable.prototype._writev && s._writev !== Duplex.prototype._writev\n}\n\nmodule.exports = {\n  pipeline,\n  pipelinePromise,\n  isStream,\n  isStreamx,\n  isEnded,\n  isFinished,\n  isDisturbed,\n  getStreamError,\n  Stream,\n  Writable,\n  Readable,\n  Duplex,\n  Transform,\n  // Export PassThrough for compatibility with Node.js core's stream module\n  PassThrough\n}\n","module.exports = require('events')\n","'use strict';\n\n/**\n * @typedef {{ [key: string]: any }} Extensions\n * @typedef {Error} Err\n * @property {string} message\n */\n\n/**\n *\n * @param {Error} obj\n * @param {Extensions} props\n * @returns {Error & Extensions}\n */\nfunction assign(obj, props) {\n    for (const key in props) {\n        Object.defineProperty(obj, key, {\n            value: props[key],\n            enumerable: true,\n            configurable: true,\n        });\n    }\n\n    return obj;\n}\n\n/**\n *\n * @param {any} err - An Error\n * @param {string|Extensions} code - A string code or props to set on the error\n * @param {Extensions} [props] - Props to set on the error\n * @returns {Error & Extensions}\n */\nfunction createError(err, code, props) {\n    if (!err || typeof err === 'string') {\n        throw new TypeError('Please pass an Error to err-code');\n    }\n\n    if (!props) {\n        props = {};\n    }\n\n    if (typeof code === 'object') {\n        props = code;\n        code = '';\n    }\n\n    if (code) {\n        props.code = code;\n    }\n\n    try {\n        return assign(err, props);\n    } catch (_) {\n        props.message = err.message;\n        props.stack = err.stack;\n\n        const ErrClass = function () {};\n\n        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));\n\n        // @ts-ignore\n        const output = assign(new ErrClass(), props);\n\n        return output;\n    }\n}\n\nmodule.exports = createError;\n","/* Common package for dealing with hex/string/uint8 conversions (and sha1 hashing)\r\n*\r\n* @author   Jimmy Wrting <jimmy@warting.se> (https://jimmy.warting.se/opensource)\r\n* @license  MIT\r\n*/\r\nexport const alphabet = '0123456789abcdef'\r\nconst encodeLookup = []\r\nconst decodeLookup = []\r\n\r\nfor (let i = 0; i < 256; i++) {\r\n  encodeLookup[i] = alphabet[i >> 4 & 0xf] + alphabet[i & 0xf]\r\n  if (i < 16) {\r\n    if (i < 10) {\r\n      decodeLookup[0x30 + i] = i\r\n    } else {\r\n      decodeLookup[0x61 - 10 + i] = i\r\n    }\r\n  }\r\n}\r\n\r\nexport const arr2hex = data => {\r\n  const length = data.length\r\n  let string = ''\r\n  let i = 0\r\n  while (i < length) {\r\n    string += encodeLookup[data[i++]]\r\n  }\r\n  return string\r\n}\r\n\r\nexport const hex2arr = str => {\r\n  const sizeof = str.length >> 1\r\n  const length = sizeof << 1\r\n  const array = new Uint8Array(sizeof)\r\n  let n = 0\r\n  let i = 0\r\n  while (i < length) {\r\n    array[n++] = decodeLookup[str.charCodeAt(i++)] << 4 | decodeLookup[str.charCodeAt(i++)]\r\n  }\r\n  return array\r\n}\r\n\r\nexport const concat = (chunks, size = 0) => {\r\n  const length = chunks.length || 0\r\n  if (!size) {\r\n    let i = length\r\n    while (i--) size += chunks[i].length\r\n  }\r\n  const b = new Uint8Array(size)\r\n  let offset = size\r\n  let i = length\r\n  while (i--) {\r\n    offset -= chunks[i].length\r\n    b.set(chunks[i], offset)\r\n  }\r\n\r\n  return b\r\n}\r\n\r\nexport const equal = (a, b) => {\r\n  if (a.length !== b.length) return false\r\n  for (let i = a.length; i > -1; i -= 1) {\r\n    if ((a[i] !== b[i])) return false\r\n  }\r\n  return true\r\n}\r\n","/*\n * base64-arraybuffer 1.0.2 <https://github.com/niklasvh/base64-arraybuffer>\n * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>\n * Released under MIT License\n */\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n// Use a lookup table to find the index.\nvar lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\nfor (var i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n}\nvar encode = function (arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';\n    for (i = 0; i < len; i += 3) {\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64 += chars[bytes[i + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + '=';\n    }\n    else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + '==';\n    }\n    return base64;\n};\nvar decode = function (base64) {\n    var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n    if (base64[base64.length - 1] === '=') {\n        bufferLength--;\n        if (base64[base64.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n    var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n    for (i = 0; i < len; i += 4) {\n        encoded1 = lookup[base64.charCodeAt(i)];\n        encoded2 = lookup[base64.charCodeAt(i + 1)];\n        encoded3 = lookup[base64.charCodeAt(i + 2)];\n        encoded4 = lookup[base64.charCodeAt(i + 3)];\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n    return arraybuffer;\n};\n\nexport { decode, encode };\n//# sourceMappingURL=base64-arraybuffer.es5.js.map\n","import { arr2hex, hex2arr, alphabet } from './util.js'\r\nimport { decode, encode } from 'base64-arraybuffer'\r\n\r\nconst decoder = new TextDecoder()\r\n// 50% slower at < 48 chars, but little impact at 4M OPS/s vs 8M OPS/s\r\nexport const arr2text = (data, enc) => {\r\n  if (!enc) return decoder.decode(data)\r\n  const dec = new TextDecoder(enc)\r\n  return dec.decode(data)\r\n}\r\n\r\n// sacrifice ~20% speed for bundle size\r\nconst encoder = new TextEncoder()\r\nexport const text2arr = str => encoder.encode(str)\r\n\r\nexport const arr2base = data => encode(data)\r\n\r\nexport const base2arr = str => new Uint8Array(decode(str))\r\n\r\nexport const bin2hex = str => {\r\n  let res = ''\r\n  let c\r\n  let i = 0\r\n  const len = str.length\r\n\r\n  while (i < len) {\r\n    c = str.charCodeAt(i++)\r\n    res += alphabet[c >> 4] + alphabet[c & 0xF]\r\n  }\r\n\r\n  return res\r\n}\r\n\r\nconst MAX_ARGUMENTS_LENGTH = 0x10000\r\nexport const hex2bin = hex => {\r\n  const points = hex2arr(hex)\r\n  if (points.length <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode(...points)\r\n\r\n  let res = ''\r\n  let i = 0\r\n  while (i < points.length) {\r\n    res += String.fromCharCode(...points.subarray(i, i += MAX_ARGUMENTS_LENGTH))\r\n  }\r\n  return res\r\n}\r\n\r\nconst scope = typeof window !== 'undefined' ? window : self\r\nconst crypto = scope.crypto || scope.msCrypto || {}\r\nconst subtle = crypto.subtle || crypto.webkitSubtle\r\n\r\nconst formatMap = {\r\n  hex: arr2hex,\r\n  base64: arr2base\r\n}\r\n\r\nexport const hash = async (data, format, algo = 'sha-1') => {\r\n  if (!subtle) throw new Error('no web crypto support')\r\n  if (typeof data === 'string') data = text2arr(data)\r\n  const out = new Uint8Array(await subtle.digest(algo, data))\r\n  return format ? formatMap[format](out) : out\r\n}\r\n\r\nexport const randomBytes = size => {\r\n  const view = new Uint8Array(size)\r\n  return crypto.getRandomValues(view)\r\n}\r\n\r\nexport * from './util.js'\r\n","/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\r\nimport debug from 'debug'\r\nimport { RTCPeerConnection, RTCSessionDescription, RTCIceCandidate } from 'webrtc-polyfill'\r\nimport { Duplex } from 'streamx'\r\nimport errCode from 'err-code'\r\nimport { randomBytes, arr2hex, text2arr } from 'uint8-util'\r\n\r\nconst Debug = debug('simple-peer')\r\n\r\nconst MAX_BUFFERED_AMOUNT = 64 * 1024\r\nconst ICECOMPLETE_TIMEOUT = 5 * 1000\r\nconst CHANNEL_CLOSING_TIMEOUT = 5 * 1000\r\n\r\n// HACK: Filter trickle lines when trickle is disabled #354\r\nfunction filterTrickle (sdp) {\r\n  return sdp.replace(/a=ice-options:trickle\\s\\n/g, '')\r\n}\r\n\r\nfunction warn (message) {\r\n  console.warn(message)\r\n}\r\n\r\n/**\r\n * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.\r\n * Duplex stream.\r\n * @param {Object} opts\r\n */\r\nclass Peer extends Duplex {\r\n  /** @type {RTCPeerConnection} */\r\n  _pc\r\n  constructor (opts) {\r\n    opts = Object.assign({\r\n      allowHalfOpen: false\r\n    }, opts)\r\n\r\n    super(opts)\r\n\r\n    this.__objectMode = !!opts.objectMode // streamx is objectMode by default, so implement readable's fuctionality\r\n\r\n    this._id = arr2hex(randomBytes(4)).slice(0, 7)\r\n    this._debug('new peer %o', opts)\r\n\r\n    this.channelName = opts.initiator\r\n      ? opts.channelName || arr2hex(randomBytes(20))\r\n      : null\r\n\r\n    this.initiator = opts.initiator || false\r\n    this.channelConfig = opts.channelConfig || Peer.channelConfig\r\n    this.channelNegotiated = this.channelConfig.negotiated\r\n    this.config = Object.assign({}, Peer.config, opts.config)\r\n    this.offerOptions = opts.offerOptions || {}\r\n    this.answerOptions = opts.answerOptions || {}\r\n    this.sdpTransform = opts.sdpTransform || (sdp => sdp)\r\n    this.trickle = opts.trickle !== undefined ? opts.trickle : true\r\n    this.allowHalfTrickle = opts.allowHalfTrickle !== undefined ? opts.allowHalfTrickle : false\r\n    this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT\r\n\r\n    this._destroying = false\r\n    this._connected = false\r\n\r\n    this.remoteAddress = undefined\r\n    this.remoteFamily = undefined\r\n    this.remotePort = undefined\r\n    this.localAddress = undefined\r\n    this.localFamily = undefined\r\n    this.localPort = undefined\r\n\r\n    if (!RTCPeerConnection) {\r\n      if (typeof window === 'undefined') {\r\n        throw errCode(new Error('No WebRTC support: Specify `opts.wrtc` option in this environment'), 'ERR_WEBRTC_SUPPORT')\r\n      } else {\r\n        throw errCode(new Error('No WebRTC support: Not a supported browser'), 'ERR_WEBRTC_SUPPORT')\r\n      }\r\n    }\r\n\r\n    this._pcReady = false\r\n    this._channelReady = false\r\n    this._iceComplete = false // ice candidate trickle done (got null candidate)\r\n    this._iceCompleteTimer = null // send an offer/answer anyway after some timeout\r\n    this._channel = null\r\n    this._pendingCandidates = []\r\n\r\n    this._isNegotiating = false // is this peer waiting for negotiation to complete?\r\n    this._firstNegotiation = true\r\n    this._batchedNegotiation = false // batch synchronous negotiations\r\n    this._queuedNegotiation = false // is there a queued negotiation request?\r\n    this._sendersAwaitingStable = []\r\n    this._closingInterval = null\r\n\r\n    this._remoteTracks = []\r\n    this._remoteStreams = []\r\n\r\n    this._chunk = null\r\n    this._cb = null\r\n    this._interval = null\r\n\r\n    try {\r\n      this._pc = new RTCPeerConnection(this.config)\r\n    } catch (err) {\r\n      this.__destroy(errCode(err, 'ERR_PC_CONSTRUCTOR'))\r\n      return\r\n    }\r\n\r\n    // We prefer feature detection whenever possible, but sometimes that's not\r\n    // possible for certain implementations.\r\n    this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === 'number'\r\n\r\n    this._pc.oniceconnectionstatechange = () => {\r\n      this._onIceStateChange()\r\n    }\r\n    this._pc.onicegatheringstatechange = () => {\r\n      this._onIceStateChange()\r\n    }\r\n    this._pc.onconnectionstatechange = () => {\r\n      this._onConnectionStateChange()\r\n    }\r\n    this._pc.onsignalingstatechange = () => {\r\n      this._onSignalingStateChange()\r\n    }\r\n    this._pc.onicecandidate = event => {\r\n      this._onIceCandidate(event)\r\n    }\r\n\r\n    // HACK: Fix for odd Firefox behavior, see: https://github.com/feross/simple-peer/pull/783\r\n    if (typeof this._pc.peerIdentity === 'object') {\r\n      this._pc.peerIdentity.catch(err => {\r\n        this.__destroy(errCode(err, 'ERR_PC_PEER_IDENTITY'))\r\n      })\r\n    }\r\n\r\n    // Other spec events, unused by this implementation:\r\n    // - onconnectionstatechange\r\n    // - onicecandidateerror\r\n    // - onfingerprintfailure\r\n    // - onnegotiationneeded\r\n\r\n    if (this.initiator || this.channelNegotiated) {\r\n      this._setupData({\r\n        channel: this._pc.createDataChannel(this.channelName, this.channelConfig)\r\n      })\r\n    } else {\r\n      this._pc.ondatachannel = event => {\r\n        this._setupData(event)\r\n      }\r\n    }\r\n\r\n    this._debug('initial negotiation')\r\n    this._needsNegotiation()\r\n\r\n    this._onFinishBound = () => {\r\n      this._onFinish()\r\n    }\r\n    this.once('finish', this._onFinishBound)\r\n  }\r\n\r\n  get bufferSize () {\r\n    return (this._channel && this._channel.bufferedAmount) || 0\r\n  }\r\n\r\n  // HACK: it's possible channel.readyState is \"closing\" before peer.destroy() fires\r\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\r\n  get connected () {\r\n    return (this._connected && this._channel.readyState === 'open')\r\n  }\r\n\r\n  address () {\r\n    return { port: this.localPort, family: this.localFamily, address: this.localAddress }\r\n  }\r\n\r\n  signal (data) {\r\n    if (this._destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot signal after peer is destroyed'), 'ERR_DESTROYED')\r\n    if (typeof data === 'string') {\r\n      try {\r\n        data = JSON.parse(data)\r\n      } catch (err) {\r\n        data = {}\r\n      }\r\n    }\r\n    this._debug('signal()')\r\n\r\n    if (data.renegotiate && this.initiator) {\r\n      this._debug('got request to renegotiate')\r\n      this._needsNegotiation()\r\n    }\r\n    if (data.transceiverRequest && this.initiator) {\r\n      this._debug('got request for transceiver')\r\n      this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init)\r\n    }\r\n    if (data.candidate) {\r\n      if (this._pc.remoteDescription && this._pc.remoteDescription.type) {\r\n        this._addIceCandidate(data.candidate)\r\n      } else {\r\n        this._pendingCandidates.push(data.candidate)\r\n      }\r\n    }\r\n    if (data.sdp) {\r\n      this._pc.setRemoteDescription(new RTCSessionDescription(data))\r\n        .then(() => {\r\n          if (this.destroyed) return\r\n\r\n          this._pendingCandidates.forEach(candidate => {\r\n            this._addIceCandidate(candidate)\r\n          })\r\n          this._pendingCandidates = []\r\n\r\n          if (this._pc.remoteDescription.type === 'offer') this._createAnswer()\r\n        })\r\n        .catch(err => {\r\n          this.__destroy(errCode(err, 'ERR_SET_REMOTE_DESCRIPTION'))\r\n        })\r\n    }\r\n    if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {\r\n      this.__destroy(errCode(new Error('signal() called with invalid signal data'), 'ERR_SIGNALING'))\r\n    }\r\n  }\r\n\r\n  _addIceCandidate (candidate) {\r\n    const iceCandidateObj = new RTCIceCandidate(candidate)\r\n    this._pc.addIceCandidate(iceCandidateObj)\r\n      .catch(err => {\r\n        if (!iceCandidateObj.address || iceCandidateObj.address.endsWith('.local')) {\r\n          warn('Ignoring unsupported ICE candidate.')\r\n        } else {\r\n          this.__destroy(errCode(err, 'ERR_ADD_ICE_CANDIDATE'))\r\n        }\r\n      })\r\n  }\r\n\r\n  /**\r\n   * Send text/binary data to the remote peer.\r\n   * @param {ArrayBufferView|ArrayBuffer|Uint8Array|string|Blob} chunk\r\n   */\r\n  send (chunk) {\r\n    if (this._destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot send after peer is destroyed'), 'ERR_DESTROYED')\r\n    this._channel.send(chunk)\r\n  }\r\n\r\n  _needsNegotiation () {\r\n    this._debug('_needsNegotiation')\r\n    if (this._batchedNegotiation) return // batch synchronous renegotiations\r\n    this._batchedNegotiation = true\r\n    queueMicrotask(() => {\r\n      this._batchedNegotiation = false\r\n      if (this.initiator || !this._firstNegotiation) {\r\n        this._debug('starting batched negotiation')\r\n        this.negotiate()\r\n      } else {\r\n        this._debug('non-initiator initial negotiation request discarded')\r\n      }\r\n      this._firstNegotiation = false\r\n    })\r\n  }\r\n\r\n  negotiate () {\r\n    if (this._destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot negotiate after peer is destroyed'), 'ERR_DESTROYED')\r\n\r\n    if (this.initiator) {\r\n      if (this._isNegotiating) {\r\n        this._queuedNegotiation = true\r\n        this._debug('already negotiating, queueing')\r\n      } else {\r\n        this._debug('start negotiation')\r\n        setTimeout(() => { // HACK: Chrome crashes if we immediately call createOffer\r\n          this._createOffer()\r\n        }, 0)\r\n      }\r\n    } else {\r\n      if (this._isNegotiating) {\r\n        this._queuedNegotiation = true\r\n        this._debug('already negotiating, queueing')\r\n      } else {\r\n        this._debug('requesting negotiation from initiator')\r\n        this.emit('signal', { // request initiator to renegotiate\r\n          type: 'renegotiate',\r\n          renegotiate: true\r\n        })\r\n      }\r\n    }\r\n    this._isNegotiating = true\r\n  }\r\n\r\n  _final (cb) {\r\n    if (!this._readableState.ended) this.push(null)\r\n    cb(null)\r\n  }\r\n\r\n  __destroy (err) {\r\n    this.end()\r\n    this._destroy(() => {}, err)\r\n  }\r\n\r\n  _destroy (cb, err) {\r\n    if (this.destroyed || this._destroying) return\r\n    this._destroying = true\r\n\r\n    this._debug('destroying (error: %s)', err && (err.message || err))\r\n\r\n    setTimeout(() => { // allow events concurrent with the call to _destroy() to fire (see #692)\r\n      if (this._connected) this.emit('disconnect')\r\n      this._connected = false\r\n      this._pcReady = false\r\n      this._channelReady = false\r\n      this._remoteTracks = null\r\n      this._remoteStreams = null\r\n      this._senderMap = null\r\n\r\n      clearInterval(this._closingInterval)\r\n      this._closingInterval = null\r\n\r\n      clearInterval(this._interval)\r\n      this._interval = null\r\n      this._chunk = null\r\n      this._cb = null\r\n\r\n      if (this._onFinishBound) this.removeListener('finish', this._onFinishBound)\r\n      this._onFinishBound = null\r\n\r\n      if (this._channel) {\r\n        try {\r\n          this._channel.close()\r\n        } catch (err) {}\r\n\r\n        // allow events concurrent with destruction to be handled\r\n        this._channel.onmessage = null\r\n        this._channel.onopen = null\r\n        this._channel.onclose = null\r\n        this._channel.onerror = null\r\n      }\r\n      if (this._pc) {\r\n        try {\r\n          this._pc.close()\r\n        } catch (err) {}\r\n\r\n        // allow events concurrent with destruction to be handled\r\n        this._pc.oniceconnectionstatechange = null\r\n        this._pc.onicegatheringstatechange = null\r\n        this._pc.onsignalingstatechange = null\r\n        this._pc.onicecandidate = null\r\n        this._pc.ontrack = null\r\n        this._pc.ondatachannel = null\r\n      }\r\n      this._pc = null\r\n      this._channel = null\r\n      if (err) this.emit('error', err)\r\n      cb()\r\n    }, 0)\r\n  }\r\n\r\n  _setupData (event) {\r\n    if (!event.channel) {\r\n      // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),\r\n      // which is invalid behavior. Handle it gracefully.\r\n      // See: https://github.com/feross/simple-peer/issues/163\r\n      return this.__destroy(errCode(new Error('Data channel event is missing `channel` property'), 'ERR_DATA_CHANNEL'))\r\n    }\r\n\r\n    this._channel = event.channel\r\n    this._channel.binaryType = 'arraybuffer'\r\n\r\n    if (typeof this._channel.bufferedAmountLowThreshold === 'number') {\r\n      this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT\r\n    }\r\n\r\n    this.channelName = this._channel.label\r\n\r\n    this._channel.onmessage = event => {\r\n      this._onChannelMessage(event)\r\n    }\r\n    this._channel.onbufferedamountlow = () => {\r\n      this._onChannelBufferedAmountLow()\r\n    }\r\n    this._channel.onopen = () => {\r\n      this._onChannelOpen()\r\n    }\r\n    this._channel.onclose = () => {\r\n      this._onChannelClose()\r\n    }\r\n    this._channel.onerror = event => {\r\n      const err = event.error instanceof Error\r\n        ? event.error\r\n        : new Error(`Datachannel error: ${event.message} ${event.filename}:${event.lineno}:${event.colno}`)\r\n      this.__destroy(errCode(err, 'ERR_DATA_CHANNEL'))\r\n    }\r\n\r\n    // HACK: Chrome will sometimes get stuck in readyState \"closing\", let's check for this condition\r\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\r\n    let isClosing = false\r\n    this._closingInterval = setInterval(() => { // No \"onclosing\" event\r\n      if (this._channel && this._channel.readyState === 'closing') {\r\n        if (isClosing) this._onChannelClose() // closing timed out: equivalent to onclose firing\r\n        isClosing = true\r\n      } else {\r\n        isClosing = false\r\n      }\r\n    }, CHANNEL_CLOSING_TIMEOUT)\r\n  }\r\n\r\n  _write (chunk, cb) {\r\n    if (this.destroyed) return cb(errCode(new Error('cannot write after peer is destroyed'), 'ERR_DATA_CHANNEL'))\r\n\r\n    if (this._connected) {\r\n      try {\r\n        this.send(chunk)\r\n      } catch (err) {\r\n        return this.__destroy(errCode(err, 'ERR_DATA_CHANNEL'))\r\n      }\r\n      if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n        this._debug('start backpressure: bufferedAmount %d', this._channel.bufferedAmount)\r\n        this._cb = cb\r\n      } else {\r\n        cb(null)\r\n      }\r\n    } else {\r\n      this._debug('write before connect')\r\n      this._chunk = chunk\r\n      this._cb = cb\r\n    }\r\n  }\r\n\r\n  // When stream finishes writing, close socket. Half open connections are not\r\n  // supported.\r\n  _onFinish () {\r\n    if (this.destroyed) return\r\n\r\n    // Wait a bit before destroying so the socket flushes.\r\n    // TODO: is there a more reliable way to accomplish this?\r\n    const destroySoon = () => {\r\n      setTimeout(() => this.__destroy(), 1000)\r\n    }\r\n\r\n    if (this._connected) {\r\n      destroySoon()\r\n    } else {\r\n      this.once('connect', destroySoon)\r\n    }\r\n  }\r\n\r\n  _startIceCompleteTimeout () {\r\n    if (this.destroyed) return\r\n    if (this._iceCompleteTimer) return\r\n    this._debug('started iceComplete timeout')\r\n    this._iceCompleteTimer = setTimeout(() => {\r\n      if (!this._iceComplete) {\r\n        this._iceComplete = true\r\n        this._debug('iceComplete timeout completed')\r\n        this.emit('iceTimeout')\r\n        this.emit('_iceComplete')\r\n      }\r\n    }, this.iceCompleteTimeout)\r\n  }\r\n\r\n  _createOffer () {\r\n    if (this.destroyed) return\r\n\r\n    this._pc.createOffer(this.offerOptions)\r\n      .then(offer => {\r\n        if (this.destroyed) return\r\n        if (!this.trickle && !this.allowHalfTrickle) offer.sdp = filterTrickle(offer.sdp)\r\n        offer.sdp = this.sdpTransform(offer.sdp)\r\n\r\n        const sendOffer = () => {\r\n          if (this.destroyed) return\r\n          const signal = this._pc.localDescription || offer\r\n          this._debug('signal')\r\n          this.emit('signal', {\r\n            type: signal.type,\r\n            sdp: signal.sdp\r\n          })\r\n        }\r\n\r\n        const onSuccess = () => {\r\n          this._debug('createOffer success')\r\n          if (this.destroyed) return\r\n          if (this.trickle || this._iceComplete) sendOffer()\r\n          else this.once('_iceComplete', sendOffer) // wait for candidates\r\n        }\r\n\r\n        const onError = err => {\r\n          this.__destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))\r\n        }\r\n\r\n        this._pc.setLocalDescription(offer)\r\n          .then(onSuccess)\r\n          .catch(onError)\r\n      })\r\n      .catch(err => {\r\n        this.__destroy(errCode(err, 'ERR_CREATE_OFFER'))\r\n      })\r\n  }\r\n\r\n  _createAnswer () {\r\n    if (this.destroyed) return\r\n\r\n    this._pc.createAnswer(this.answerOptions)\r\n      .then(answer => {\r\n        if (this.destroyed) return\r\n        if (!this.trickle && !this.allowHalfTrickle) answer.sdp = filterTrickle(answer.sdp)\r\n        answer.sdp = this.sdpTransform(answer.sdp)\r\n\r\n        const sendAnswer = () => {\r\n          if (this.destroyed) return\r\n          const signal = this._pc.localDescription || answer\r\n          this._debug('signal')\r\n          this.emit('signal', {\r\n            type: signal.type,\r\n            sdp: signal.sdp\r\n          })\r\n          if (!this.initiator) this._requestMissingTransceivers?.()\r\n        }\r\n\r\n        const onSuccess = () => {\r\n          if (this.destroyed) return\r\n          if (this.trickle || this._iceComplete) sendAnswer()\r\n          else this.once('_iceComplete', sendAnswer)\r\n        }\r\n\r\n        const onError = err => {\r\n          this.__destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))\r\n        }\r\n\r\n        this._pc.setLocalDescription(answer)\r\n          .then(onSuccess)\r\n          .catch(onError)\r\n      })\r\n      .catch(err => {\r\n        this.__destroy(errCode(err, 'ERR_CREATE_ANSWER'))\r\n      })\r\n  }\r\n\r\n  _onConnectionStateChange () {\r\n    if (this.destroyed || this._destroying) return\r\n    if (this._pc.connectionState === 'failed') {\r\n      this.__destroy(errCode(new Error('Connection failed.'), 'ERR_CONNECTION_FAILURE'))\r\n    }\r\n  }\r\n\r\n  _onIceStateChange () {\r\n    if (this.destroyed) return\r\n    const iceConnectionState = this._pc.iceConnectionState\r\n    const iceGatheringState = this._pc.iceGatheringState\r\n\r\n    this._debug(\r\n      'iceStateChange (connection: %s) (gathering: %s)',\r\n      iceConnectionState,\r\n      iceGatheringState\r\n    )\r\n    this.emit('iceStateChange', iceConnectionState, iceGatheringState)\r\n\r\n    if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {\r\n      this._pcReady = true\r\n      this._maybeReady()\r\n    }\r\n    if (iceConnectionState === 'failed') {\r\n      this.__destroy(errCode(new Error('Ice connection failed.'), 'ERR_ICE_CONNECTION_FAILURE'))\r\n    }\r\n    if (iceConnectionState === 'closed') {\r\n      this.__destroy(errCode(new Error('Ice connection closed.'), 'ERR_ICE_CONNECTION_CLOSED'))\r\n    }\r\n  }\r\n\r\n  getStats (cb) {\r\n    // statreports can come with a value array instead of properties\r\n    const flattenValues = report => {\r\n      if (Object.prototype.toString.call(report.values) === '[object Array]') {\r\n        report.values.forEach(value => {\r\n          Object.assign(report, value)\r\n        })\r\n      }\r\n      return report\r\n    }\r\n\r\n    // Promise-based getStats() (standard)\r\n    if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {\r\n      this._pc.getStats()\r\n        .then(res => {\r\n          const reports = []\r\n          res.forEach(report => {\r\n            reports.push(flattenValues(report))\r\n          })\r\n          cb(null, reports)\r\n        }, err => cb(err))\r\n\r\n    // Single-parameter callback-based getStats() (non-standard)\r\n    } else if (this._pc.getStats.length > 0) {\r\n      this._pc.getStats(res => {\r\n        // If we destroy connection in `connect` callback this code might happen to run when actual connection is already closed\r\n        if (this.destroyed) return\r\n\r\n        const reports = []\r\n        res.result().forEach(result => {\r\n          const report = {}\r\n          result.names().forEach(name => {\r\n            report[name] = result.stat(name)\r\n          })\r\n          report.id = result.id\r\n          report.type = result.type\r\n          report.timestamp = result.timestamp\r\n          reports.push(flattenValues(report))\r\n        })\r\n        cb(null, reports)\r\n      }, err => cb(err))\r\n\r\n    // Unknown browser, skip getStats() since it's anyone's guess which style of\r\n    // getStats() they implement.\r\n    } else {\r\n      cb(null, [])\r\n    }\r\n  }\r\n\r\n  _maybeReady () {\r\n    this._debug('maybeReady pc %s channel %s', this._pcReady, this._channelReady)\r\n    if (this._connected || this._connecting || !this._pcReady || !this._channelReady) return\r\n\r\n    this._connecting = true\r\n\r\n    // HACK: We can't rely on order here, for details see https://github.com/js-platform/node-webrtc/issues/339\r\n    const findCandidatePair = () => {\r\n      if (this.destroyed || this._destroying) return\r\n\r\n      this.getStats((err, items) => {\r\n        if (this.destroyed || this._destroying) return\r\n\r\n        // Treat getStats error as non-fatal. It's not essential.\r\n        if (err) items = []\r\n\r\n        const remoteCandidates = {}\r\n        const localCandidates = {}\r\n        const candidatePairs = {}\r\n        let foundSelectedCandidatePair = false\r\n\r\n        items.forEach(item => {\r\n          // TODO: Once all browsers support the hyphenated stats report types, remove\r\n          // the non-hypenated ones\r\n          if (item.type === 'remotecandidate' || item.type === 'remote-candidate') {\r\n            remoteCandidates[item.id] = item\r\n          }\r\n          if (item.type === 'localcandidate' || item.type === 'local-candidate') {\r\n            localCandidates[item.id] = item\r\n          }\r\n          if (item.type === 'candidatepair' || item.type === 'candidate-pair') {\r\n            candidatePairs[item.id] = item\r\n          }\r\n        })\r\n\r\n        const setSelectedCandidatePair = selectedCandidatePair => {\r\n          foundSelectedCandidatePair = true\r\n\r\n          let local = localCandidates[selectedCandidatePair.localCandidateId]\r\n\r\n          if (local && (local.ip || local.address)) {\r\n            // Spec\r\n            this.localAddress = local.ip || local.address\r\n            this.localPort = Number(local.port)\r\n          } else if (local && local.ipAddress) {\r\n            // Firefox\r\n            this.localAddress = local.ipAddress\r\n            this.localPort = Number(local.portNumber)\r\n          } else if (typeof selectedCandidatePair.googLocalAddress === 'string') {\r\n            // TODO: remove this once Chrome 58 is released\r\n            local = selectedCandidatePair.googLocalAddress.split(':')\r\n            this.localAddress = local[0]\r\n            this.localPort = Number(local[1])\r\n          }\r\n          if (this.localAddress) {\r\n            this.localFamily = this.localAddress.includes(':') ? 'IPv6' : 'IPv4'\r\n          }\r\n\r\n          let remote = remoteCandidates[selectedCandidatePair.remoteCandidateId]\r\n\r\n          if (remote && (remote.ip || remote.address)) {\r\n            // Spec\r\n            this.remoteAddress = remote.ip || remote.address\r\n            this.remotePort = Number(remote.port)\r\n          } else if (remote && remote.ipAddress) {\r\n            // Firefox\r\n            this.remoteAddress = remote.ipAddress\r\n            this.remotePort = Number(remote.portNumber)\r\n          } else if (typeof selectedCandidatePair.googRemoteAddress === 'string') {\r\n            // TODO: remove this once Chrome 58 is released\r\n            remote = selectedCandidatePair.googRemoteAddress.split(':')\r\n            this.remoteAddress = remote[0]\r\n            this.remotePort = Number(remote[1])\r\n          }\r\n          if (this.remoteAddress) {\r\n            this.remoteFamily = this.remoteAddress.includes(':') ? 'IPv6' : 'IPv4'\r\n          }\r\n\r\n          this._debug(\r\n            'connect local: %s:%s remote: %s:%s',\r\n            this.localAddress,\r\n            this.localPort,\r\n            this.remoteAddress,\r\n            this.remotePort\r\n          )\r\n        }\r\n\r\n        items.forEach(item => {\r\n          // Spec-compliant\r\n          if (item.type === 'transport' && item.selectedCandidatePairId) {\r\n            setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId])\r\n          }\r\n\r\n          // Old implementations\r\n          if (\r\n            (item.type === 'googCandidatePair' && item.googActiveConnection === 'true') ||\r\n            ((item.type === 'candidatepair' || item.type === 'candidate-pair') && item.selected)\r\n          ) {\r\n            setSelectedCandidatePair(item)\r\n          }\r\n        })\r\n\r\n        // Ignore candidate pair selection in browsers like Safari 11 that do not have any local or remote candidates\r\n        // But wait until at least 1 candidate pair is available\r\n        if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {\r\n          setTimeout(findCandidatePair, 100)\r\n          return\r\n        } else {\r\n          this._connecting = false\r\n          this._connected = true\r\n          this.emit('connect')\r\n        }\r\n\r\n        if (this._chunk) {\r\n          try {\r\n            this.send(this._chunk)\r\n          } catch (err) {\r\n            return this.__destroy(errCode(err, 'ERR_DATA_CHANNEL'))\r\n          }\r\n          this._chunk = null\r\n          this._debug('sent chunk from \"write before connect\"')\r\n\r\n          const cb = this._cb\r\n          this._cb = null\r\n          cb(null)\r\n        }\r\n\r\n        // If `bufferedAmountLowThreshold` and 'onbufferedamountlow' are unsupported,\r\n        // fallback to using setInterval to implement backpressure.\r\n        if (typeof this._channel.bufferedAmountLowThreshold !== 'number') {\r\n          this._interval = setInterval(() => this._onInterval(), 150)\r\n          if (this._interval.unref) this._interval.unref()\r\n        }\r\n\r\n        this._debug('connect')\r\n        this.emit('connect')\r\n      })\r\n    }\r\n    findCandidatePair()\r\n  }\r\n\r\n  _onInterval () {\r\n    if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n      return\r\n    }\r\n    this._onChannelBufferedAmountLow()\r\n  }\r\n\r\n  _onSignalingStateChange () {\r\n    if (this.destroyed) return\r\n\r\n    if (this._pc.signalingState === 'stable') {\r\n      this._isNegotiating = false\r\n\r\n      // HACK: Firefox doesn't yet support removing tracks when signalingState !== 'stable'\r\n      this._debug('flushing sender queue', this._sendersAwaitingStable)\r\n      this._sendersAwaitingStable.forEach(sender => {\r\n        this._pc.removeTrack(sender)\r\n        this._queuedNegotiation = true\r\n      })\r\n      this._sendersAwaitingStable = []\r\n\r\n      if (this._queuedNegotiation) {\r\n        this._debug('flushing negotiation queue')\r\n        this._queuedNegotiation = false\r\n        this._needsNegotiation() // negotiate again\r\n      } else {\r\n        this._debug('negotiated')\r\n        this.emit('negotiated')\r\n      }\r\n    }\r\n\r\n    this._debug('signalingStateChange %s', this._pc.signalingState)\r\n    this.emit('signalingStateChange', this._pc.signalingState)\r\n  }\r\n\r\n  _onIceCandidate (event) {\r\n    if (this.destroyed) return\r\n    if (event.candidate && this.trickle) {\r\n      this.emit('signal', {\r\n        type: 'candidate',\r\n        candidate: {\r\n          candidate: event.candidate.candidate,\r\n          sdpMLineIndex: event.candidate.sdpMLineIndex,\r\n          sdpMid: event.candidate.sdpMid\r\n        }\r\n      })\r\n    } else if (!event.candidate && !this._iceComplete) {\r\n      this._iceComplete = true\r\n      this.emit('_iceComplete')\r\n    }\r\n    // as soon as we've received one valid candidate start timeout\r\n    if (event.candidate) {\r\n      this._startIceCompleteTimeout()\r\n    }\r\n  }\r\n\r\n  _onChannelMessage (event) {\r\n    if (this.destroyed) return\r\n    let data = event.data\r\n    if (data instanceof ArrayBuffer) {\r\n      data = new Uint8Array(data)\r\n    } else if (this.__objectMode === false) {\r\n      data = text2arr(data)\r\n    }\r\n    this.push(data)\r\n  }\r\n\r\n  _onChannelBufferedAmountLow () {\r\n    if (this.destroyed || !this._cb) return\r\n    this._debug('ending backpressure: bufferedAmount %d', this._channel.bufferedAmount)\r\n    const cb = this._cb\r\n    this._cb = null\r\n    cb(null)\r\n  }\r\n\r\n  _onChannelOpen () {\r\n    if (this._connected || this.destroyed) return\r\n    this._debug('on channel open')\r\n    this._channelReady = true\r\n    this._maybeReady()\r\n  }\r\n\r\n  _onChannelClose () {\r\n    if (this.destroyed) return\r\n    this._debug('on channel close')\r\n    this.__destroy()\r\n  }\r\n\r\n  _debug () {\r\n    const args = [].slice.call(arguments)\r\n    args[0] = '[' + this._id + '] ' + args[0]\r\n    Debug.apply(null, args)\r\n  }\r\n}\r\n\r\nPeer.WEBRTC_SUPPORT = !!RTCPeerConnection\r\n\r\n/**\r\n * Expose peer and data channel config for overriding all Peer\r\n * instances. Otherwise, just set opts.config or opts.channelConfig\r\n * when constructing a Peer.\r\n */\r\nPeer.config = {\r\n  iceServers: [\r\n    {\r\n      urls: [\r\n        'stun:stun.l.google.com:19302',\r\n        'stun:global.stun.twilio.com:3478'\r\n      ]\r\n    }\r\n  ],\r\n  sdpSemantics: 'unified-plan'\r\n}\r\n\r\nPeer.channelConfig = {}\r\n\r\nexport default Peer\r\n","export default {}","/**\n * Functions/constants needed by both the client and server.\n */\nimport * as common from './common-node.js'\nexport * from './common-node.js'\n\nexport const DEFAULT_ANNOUNCE_PEERS = 50\nexport const MAX_ANNOUNCE_PEERS = 82\n\n// HACK: Fix for WHATWG URL object not parsing non-standard URL schemes like\n// 'udp:'. Just replace it with 'http:' since we only need a few properties.\n//\n// Note: Only affects Chrome and Firefox. Works fine in Node.js, Safari, and\n// Edge.\n//\n// Note: UDP trackers aren't used in the normal browser build, but they are\n// used in a Chrome App build (i.e. by Brave Browser).\n//\n// Bug reports:\n// - Chrome: https://bugs.chromium.org/p/chromium/issues/detail?id=734880\n// - Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1374505\nexport const parseUrl = str => {\n  const url = new URL(str.replace(/^udp:/, 'http:'))\n\n  if (str.match(/^udp:/)) {\n    Object.defineProperties(url, {\n      href: { value: url.href.replace(/^http/, 'udp') },\n      protocol: { value: url.protocol.replace(/^http/, 'udp') },\n      origin: { value: url.origin.replace(/^http/, 'udp') }\n    })\n  }\n\n  return url\n}\n\nexport default {\n  DEFAULT_ANNOUNCE_PEERS,\n  MAX_ANNOUNCE_PEERS,\n  parseUrl,\n  ...common\n}\n","/*! simple-websocket. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\r\n/* global WebSocket */\r\n\r\nimport Debug from 'debug'\r\nimport queueMicrotask from 'queue-microtask' // TODO: remove when Node 10 is not supported\r\nimport ws from 'ws' // websockets in node - will be empty object in browser\r\nimport { Duplex } from 'streamx'\r\nimport { text2arr, randomBytes, arr2hex } from 'uint8-util'\r\n\r\nconst debug = Debug('simple-websocket')\r\n\r\nconst _WebSocket = typeof ws !== 'function' ? WebSocket : ws\r\n\r\nconst MAX_BUFFERED_AMOUNT = 64 * 1024\r\n\r\n/**\r\n * WebSocket. Same API as node core `net.Socket`. Duplex stream.\r\n * @param {Object} opts\r\n * @param {string=} opts.url websocket server url\r\n * @param {string=} opts.socket raw websocket instance to wrap\r\n */\r\nexport default class Socket extends Duplex {\r\n  constructor (opts = {}) {\r\n    // Support simple usage: `new Socket(url)`\r\n    if (typeof opts === 'string') {\r\n      opts = { url: opts }\r\n    }\r\n\r\n    opts = Object.assign({\r\n      allowHalfOpen: false\r\n    }, opts)\r\n\r\n    super(opts)\r\n\r\n    this.__objectMode = !!opts.objectMode // streamx is objectMode by default, so implement readable's fuctionality\r\n    if (opts.objectMode != null) delete opts.objectMode // causes error with ws...\r\n\r\n    if (opts.url == null && opts.socket == null) {\r\n      throw new Error('Missing required `url` or `socket` option')\r\n    }\r\n    if (opts.url != null && opts.socket != null) {\r\n      throw new Error('Must specify either `url` or `socket` option, not both')\r\n    }\r\n\r\n    this._id = arr2hex(randomBytes(4)).slice(0, 7)\r\n    this._debug('new websocket: %o', opts)\r\n\r\n    this.connected = false\r\n\r\n    this._chunk = null\r\n    this._cb = null\r\n    this._interval = null\r\n\r\n    if (opts.socket) {\r\n      this.url = opts.socket.url\r\n      this._ws = opts.socket\r\n      this.connected = opts.socket.readyState === _WebSocket.OPEN\r\n    } else {\r\n      this.url = opts.url\r\n      try {\r\n        if (typeof ws === 'function') {\r\n          // `ws` package accepts options\r\n          this._ws = new _WebSocket(opts.url, {\r\n            ...opts,\r\n            encoding: undefined // encoding option breaks ws internals\r\n          })\r\n        } else {\r\n          this._ws = new _WebSocket(opts.url)\r\n        }\r\n      } catch (err) {\r\n        queueMicrotask(() => this.destroy(err))\r\n        return\r\n      }\r\n    }\r\n\r\n    this._ws.binaryType = 'arraybuffer'\r\n\r\n    if (opts.socket && this.connected) {\r\n      queueMicrotask(() => this._handleOpen())\r\n    } else {\r\n      this._ws.onopen = () => this._handleOpen()\r\n    }\r\n\r\n    this._ws.onmessage = event => this._handleMessage(event)\r\n    this._ws.onclose = () => this._handleClose()\r\n    this._ws.onerror = err => this._handleError(err)\r\n\r\n    this._handleFinishBound = () => this._handleFinish()\r\n    this.once('finish', this._handleFinishBound)\r\n  }\r\n\r\n  /**\r\n   * Send text/binary data to the WebSocket server.\r\n   * @param {TypedArrayView|ArrayBuffer|Uint8Array|string|Blob|Object} chunk\r\n   */\r\n  send (chunk) {\r\n    this._ws.send(chunk)\r\n  }\r\n\r\n  _final (cb) {\r\n    if (!this._readableState.ended) this.push(null)\r\n    cb(null)\r\n  }\r\n\r\n  _destroy (cb) {\r\n    if (this.destroyed) return\r\n    if (!this._writableState.ended) this.end()\r\n\r\n    this.connected = false\r\n\r\n    clearInterval(this._interval)\r\n    this._interval = null\r\n    this._chunk = null\r\n    this._cb = null\r\n\r\n    if (this._handleFinishBound) {\r\n      this.removeListener('finish', this._handleFinishBound)\r\n    }\r\n    this._handleFinishBound = null\r\n\r\n    if (this._ws) {\r\n      const ws = this._ws\r\n      const onClose = () => {\r\n        ws.onclose = null\r\n      }\r\n      if (ws.readyState === _WebSocket.CLOSED) {\r\n        onClose()\r\n      } else {\r\n        try {\r\n          ws.onclose = onClose\r\n          ws.close()\r\n        } catch (err) {\r\n          onClose()\r\n        }\r\n      }\r\n\r\n      ws.onopen = null\r\n      ws.onmessage = null\r\n      ws.onerror = () => {}\r\n    }\r\n    this._ws = null\r\n\r\n    cb()\r\n  }\r\n\r\n  _write (chunk, cb) {\r\n    if (this.destroyed) return cb(new Error('cannot write after socket is destroyed'))\r\n\r\n    if (this.connected) {\r\n      try {\r\n        this.send(chunk)\r\n      } catch (err) {\r\n        return this.destroy(err)\r\n      }\r\n      if (typeof ws !== 'function' && this._ws.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n        this._debug('start backpressure: bufferedAmount %d', this._ws.bufferedAmount)\r\n        this._cb = cb\r\n      } else {\r\n        cb(null)\r\n      }\r\n    } else {\r\n      this._debug('write before connect')\r\n      this._chunk = chunk\r\n      this._cb = cb\r\n    }\r\n  }\r\n\r\n  _handleOpen () {\r\n    if (this.connected || this.destroyed) return\r\n    this.connected = true\r\n\r\n    if (this._chunk) {\r\n      try {\r\n        this.send(this._chunk)\r\n      } catch (err) {\r\n        return this.destroy(err)\r\n      }\r\n      this._chunk = null\r\n      this._debug('sent chunk from \"write before connect\"')\r\n\r\n      const cb = this._cb\r\n      this._cb = null\r\n      cb(null)\r\n    }\r\n\r\n    // Backpressure is not implemented in Node.js. The `ws` module has a buggy\r\n    // `bufferedAmount` property. See: https://github.com/websockets/ws/issues/492\r\n    if (typeof ws !== 'function') {\r\n      this._interval = setInterval(() => this._onInterval(), 150)\r\n      if (this._interval.unref) this._interval.unref()\r\n    }\r\n\r\n    this._debug('connect')\r\n    this.emit('connect')\r\n  }\r\n\r\n  _handleMessage (event) {\r\n    if (this.destroyed) return\r\n    let data = event.data\r\n    if (data instanceof ArrayBuffer) data = new Uint8Array(data)\r\n    if (this.__objectMode === false) data = text2arr(data)\r\n    this.push(data)\r\n  }\r\n\r\n  _handleClose () {\r\n    if (this.destroyed) return\r\n    this._debug('on close')\r\n    this.destroy()\r\n  }\r\n\r\n  _handleError (_) {\r\n    this.destroy(new Error(`Error connecting to ${this.url}`))\r\n  }\r\n\r\n  // When stream finishes writing, close socket. Half open connections are not\r\n  // supported.\r\n  _handleFinish () {\r\n    if (this.destroyed) return\r\n\r\n    // Wait a bit before destroying so the socket flushes.\r\n    // TODO: is there a more reliable way to accomplish this?\r\n    const destroySoon = () => {\r\n      setTimeout(() => this.destroy(), 1000)\r\n    }\r\n\r\n    if (this.connected) {\r\n      destroySoon()\r\n    } else {\r\n      this.once('connect', destroySoon)\r\n    }\r\n  }\r\n\r\n  _onInterval () {\r\n    if (!this._cb || !this._ws || this._ws.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n      return\r\n    }\r\n    this._debug('ending backpressure: bufferedAmount %d', this._ws.bufferedAmount)\r\n    const cb = this._cb\r\n    this._cb = null\r\n    cb(null)\r\n  }\r\n\r\n  _debug () {\r\n    const args = [].slice.call(arguments)\r\n    args[0] = '[' + this._id + '] ' + args[0]\r\n    debug.apply(null, args)\r\n  }\r\n}\r\n\r\nSocket.WEBSOCKET_SUPPORT = !!_WebSocket\r\n","import EventEmitter from 'events'\n\nclass Tracker extends EventEmitter {\n  constructor (client, announceUrl) {\n    super()\n\n    this.client = client\n    this.announceUrl = announceUrl\n\n    this.interval = null\n    this.destroyed = false\n  }\n\n  setInterval (intervalMs) {\n    if (intervalMs == null) intervalMs = this.DEFAULT_ANNOUNCE_INTERVAL\n\n    clearInterval(this.interval)\n\n    if (intervalMs) {\n      this.interval = setInterval(() => {\n        this.announce(this.client._defaultAnnounceOpts())\n      }, intervalMs)\n      if (this.interval.unref) this.interval.unref()\n    }\n  }\n}\n\nexport default Tracker\n","import Debug from 'debug'\nimport Peer from '@thaunknown/simple-peer/lite.js'\nimport Socket from '@thaunknown/simple-websocket'\nimport { arr2text, arr2hex, hex2bin, bin2hex, randomBytes } from 'uint8-util'\n\nimport common from '../common.js'\nimport Tracker from './tracker.js'\n\nconst debug = Debug('bittorrent-tracker:websocket-tracker')\n\n// Use a socket pool, so tracker clients share WebSocket objects for the same server.\n// In practice, WebSockets are pretty slow to establish, so this gives a nice performance\n// boost, and saves browser resources.\nconst socketPool = {}\n\nconst RECONNECT_MINIMUM = 10 * 1000\nconst RECONNECT_MAXIMUM = 60 * 60 * 1000\nconst RECONNECT_VARIANCE = 5 * 60 * 1000\nconst OFFER_TIMEOUT = 50 * 1000\n\nclass WebSocketTracker extends Tracker {\n  constructor (client, announceUrl) {\n    super(client, announceUrl)\n    debug('new websocket tracker %s', announceUrl)\n\n    this.peers = {} // peers (offer id -> peer)\n    this.socket = null\n\n    this.reconnecting = false\n    this.retries = 0\n    this.reconnectTimer = null\n\n    // Simple boolean flag to track whether the socket has received data from\n    // the websocket server since the last time socket.send() was called.\n    this.expectingResponse = false\n\n    this._openSocket()\n  }\n\n  announce (opts) {\n    if (this.destroyed || this.reconnecting) return\n    if (!this.socket.connected) {\n      this.socket.once('connect', () => {\n        this.announce(opts)\n      })\n      return\n    }\n\n    const params = Object.assign({}, opts, {\n      action: 'announce',\n      info_hash: this.client._infoHashBinary,\n      peer_id: this.client._peerIdBinary\n    })\n    if (this._trackerId) params.trackerid = this._trackerId\n\n    if (opts.event === 'stopped' || opts.event === 'completed') {\n      // Don't include offers with 'stopped' or 'completed' event\n      this._send(params)\n    } else {\n      // Limit the number of offers that are generated, since it can be slow\n      const numwant = Math.min(opts.numwant, 15)\n\n      this._generateOffers(numwant, offers => {\n        params.numwant = numwant\n        params.offers = offers\n        this._send(params)\n      })\n    }\n  }\n\n  scrape (opts) {\n    if (this.destroyed || this.reconnecting) return\n    if (!this.socket.connected) {\n      this.socket.once('connect', () => {\n        this.scrape(opts)\n      })\n      return\n    }\n\n    const infoHashes = (Array.isArray(opts.infoHash) && opts.infoHash.length > 0)\n      ? opts.infoHash.map(infoHash => hex2bin(infoHash))\n      : (opts.infoHash && hex2bin(opts.infoHash)) || this.client._infoHashBinary\n    const params = {\n      action: 'scrape',\n      info_hash: infoHashes\n    }\n\n    this._send(params)\n  }\n\n  destroy (cb = noop) {\n    if (this.destroyed) return cb(null)\n\n    this.destroyed = true\n\n    clearInterval(this.interval)\n    clearTimeout(this.reconnectTimer)\n\n    // Destroy peers\n    for (const peerId in this.peers) {\n      const peer = this.peers[peerId]\n      clearTimeout(peer.trackerTimeout)\n      peer.destroy()\n    }\n    this.peers = null\n\n    if (this.socket) {\n      this.socket.removeListener('connect', this._onSocketConnectBound)\n      this.socket.removeListener('data', this._onSocketDataBound)\n      this.socket.removeListener('close', this._onSocketCloseBound)\n      this.socket.removeListener('error', this._onSocketErrorBound)\n      this.socket = null\n    }\n\n    this._onSocketConnectBound = null\n    this._onSocketErrorBound = null\n    this._onSocketDataBound = null\n    this._onSocketCloseBound = null\n\n    if (socketPool[this.announceUrl]) {\n      socketPool[this.announceUrl].consumers -= 1\n    }\n\n    // Other instances are using the socket, so there's nothing left to do here\n    if (socketPool[this.announceUrl].consumers > 0) return cb()\n\n    let socket = socketPool[this.announceUrl]\n    delete socketPool[this.announceUrl]\n    socket.on('error', noop) // ignore all future errors\n    socket.once('close', cb)\n\n    let timeout\n\n    // If there is no data response expected, destroy immediately.\n    if (!this.expectingResponse) return destroyCleanup()\n\n    // Otherwise, wait a short time for potential responses to come in from the\n    // server, then force close the socket.\n    timeout = setTimeout(destroyCleanup, common.DESTROY_TIMEOUT)\n\n    // But, if a response comes from the server before the timeout fires, do cleanup\n    // right away.\n    socket.once('data', destroyCleanup)\n\n    function destroyCleanup () {\n      if (timeout) {\n        clearTimeout(timeout)\n        timeout = null\n      }\n      socket.removeListener('data', destroyCleanup)\n      socket.destroy()\n      socket = null\n    }\n  }\n\n  _openSocket () {\n    this.destroyed = false\n\n    if (!this.peers) this.peers = {}\n\n    this._onSocketConnectBound = () => {\n      this._onSocketConnect()\n    }\n    this._onSocketErrorBound = err => {\n      this._onSocketError(err)\n    }\n    this._onSocketDataBound = data => {\n      this._onSocketData(data)\n    }\n    this._onSocketCloseBound = () => {\n      this._onSocketClose()\n    }\n\n    this.socket = socketPool[this.announceUrl]\n    if (this.socket) {\n      socketPool[this.announceUrl].consumers += 1\n      if (this.socket.connected) {\n        this._onSocketConnectBound()\n      }\n    } else {\n      const parsedUrl = new URL(this.announceUrl)\n      let agent\n      if (this.client._proxyOpts) {\n        agent = parsedUrl.protocol === 'wss:' ? this.client._proxyOpts.httpsAgent : this.client._proxyOpts.httpAgent\n        if (!agent && this.client._proxyOpts.socksProxy) {\n          agent = this.client._proxyOpts.socksProxy\n        }\n      }\n      this.socket = socketPool[this.announceUrl] = new Socket({ url: this.announceUrl, agent })\n      this.socket.consumers = 1\n      this.socket.once('connect', this._onSocketConnectBound)\n    }\n\n    this.socket.on('data', this._onSocketDataBound)\n    this.socket.once('close', this._onSocketCloseBound)\n    this.socket.once('error', this._onSocketErrorBound)\n  }\n\n  _onSocketConnect () {\n    if (this.destroyed) return\n\n    if (this.reconnecting) {\n      this.reconnecting = false\n      this.retries = 0\n      this.announce(this.client._defaultAnnounceOpts())\n    }\n  }\n\n  _onSocketData (data) {\n    if (this.destroyed) return\n\n    this.expectingResponse = false\n\n    try {\n      data = JSON.parse(arr2text(data))\n    } catch (err) {\n      this.client.emit('warning', new Error('Invalid tracker response'))\n      return\n    }\n\n    if (data.action === 'announce') {\n      this._onAnnounceResponse(data)\n    } else if (data.action === 'scrape') {\n      this._onScrapeResponse(data)\n    } else {\n      this._onSocketError(new Error(`invalid action in WS response: ${data.action}`))\n    }\n  }\n\n  _onAnnounceResponse (data) {\n    if (data.info_hash !== this.client._infoHashBinary) {\n      debug(\n        'ignoring websocket data from %s for %s (looking for %s: reused socket)',\n        this.announceUrl, bin2hex(data.info_hash), this.client.infoHash\n      )\n      return\n    }\n\n    if (data.peer_id && data.peer_id === this.client._peerIdBinary) {\n      // ignore offers/answers from this client\n      return\n    }\n\n    debug(\n      'received %s from %s for %s',\n      JSON.stringify(data), this.announceUrl, this.client.infoHash\n    )\n\n    const failure = data['failure reason']\n    if (failure) return this.client.emit('warning', new Error(failure))\n\n    const warning = data['warning message']\n    if (warning) this.client.emit('warning', new Error(warning))\n\n    const interval = data.interval || data['min interval']\n    if (interval) this.setInterval(interval * 1000)\n\n    const trackerId = data['tracker id']\n    if (trackerId) {\n      // If absent, do not discard previous trackerId value\n      this._trackerId = trackerId\n    }\n\n    if (data.complete != null) {\n      const response = Object.assign({}, data, {\n        announce: this.announceUrl,\n        infoHash: bin2hex(data.info_hash)\n      })\n      this.client.emit('update', response)\n    }\n\n    let peer\n    if (data.offer && data.peer_id) {\n      debug('creating peer (from remote offer)')\n      peer = this._createPeer()\n      peer.id = bin2hex(data.peer_id)\n      peer.once('signal', answer => {\n        const params = {\n          action: 'announce',\n          info_hash: this.client._infoHashBinary,\n          peer_id: this.client._peerIdBinary,\n          to_peer_id: data.peer_id,\n          answer,\n          offer_id: data.offer_id\n        }\n        if (this._trackerId) params.trackerid = this._trackerId\n        this._send(params)\n      })\n      this.client.emit('peer', peer)\n      peer.signal(data.offer)\n    }\n\n    if (data.answer && data.peer_id) {\n      const offerId = bin2hex(data.offer_id)\n      peer = this.peers[offerId]\n      if (peer) {\n        peer.id = bin2hex(data.peer_id)\n        this.client.emit('peer', peer)\n        peer.signal(data.answer)\n\n        clearTimeout(peer.trackerTimeout)\n        peer.trackerTimeout = null\n        delete this.peers[offerId]\n      } else {\n        debug(`got unexpected answer: ${JSON.stringify(data.answer)}`)\n      }\n    }\n  }\n\n  _onScrapeResponse (data) {\n    data = data.files || {}\n\n    const keys = Object.keys(data)\n    if (keys.length === 0) {\n      this.client.emit('warning', new Error('invalid scrape response'))\n      return\n    }\n\n    keys.forEach(infoHash => {\n      // TODO: optionally handle data.flags.min_request_interval\n      // (separate from announce interval)\n      const response = Object.assign(data[infoHash], {\n        announce: this.announceUrl,\n        infoHash: bin2hex(infoHash)\n      })\n      this.client.emit('scrape', response)\n    })\n  }\n\n  _onSocketClose () {\n    if (this.destroyed) return\n    this.destroy()\n    this._startReconnectTimer()\n  }\n\n  _onSocketError (err) {\n    if (this.destroyed) return\n    this.destroy()\n    // errors will often happen if a tracker is offline, so don't treat it as fatal\n    this.client.emit('warning', err)\n    this._startReconnectTimer()\n  }\n\n  _startReconnectTimer () {\n    const ms = Math.floor(Math.random() * RECONNECT_VARIANCE) + Math.min(Math.pow(2, this.retries) * RECONNECT_MINIMUM, RECONNECT_MAXIMUM)\n\n    this.reconnecting = true\n    clearTimeout(this.reconnectTimer)\n    this.reconnectTimer = setTimeout(() => {\n      this.retries++\n      this._openSocket()\n    }, ms)\n    if (this.reconnectTimer.unref) this.reconnectTimer.unref()\n\n    debug('reconnecting socket in %s ms', ms)\n  }\n\n  _send (params) {\n    if (this.destroyed) return\n    this.expectingResponse = true\n    const message = JSON.stringify(params)\n    debug('send %s', message)\n    this.socket.send(message)\n  }\n\n  _generateOffers (numwant, cb) {\n    const self = this\n    const offers = []\n    debug('generating %s offers', numwant)\n\n    for (let i = 0; i < numwant; ++i) {\n      generateOffer()\n    }\n    checkDone()\n\n    function generateOffer () {\n      const offerId = arr2hex(randomBytes(20))\n      debug('creating peer (from _generateOffers)')\n      const peer = self.peers[offerId] = self._createPeer({ initiator: true })\n      peer.once('signal', offer => {\n        offers.push({\n          offer,\n          offer_id: hex2bin(offerId)\n        })\n        checkDone()\n      })\n      peer.trackerTimeout = setTimeout(() => {\n        debug('tracker timeout: destroying peer')\n        peer.trackerTimeout = null\n        delete self.peers[offerId]\n        peer.destroy()\n      }, OFFER_TIMEOUT)\n      if (peer.trackerTimeout.unref) peer.trackerTimeout.unref()\n    }\n\n    function checkDone () {\n      if (offers.length === numwant) {\n        debug('generated %s offers', numwant)\n        cb(offers)\n      }\n    }\n  }\n\n  _createPeer (opts) {\n    const self = this\n\n    opts = Object.assign({\n      trickle: false,\n      config: self.client._rtcConfig,\n      wrtc: self.client._wrtc\n    }, opts)\n\n    const peer = new Peer(opts)\n\n    peer.once('error', onError)\n    peer.once('connect', onConnect)\n\n    return peer\n\n    // Handle peer 'error' events that are fired *before* the peer is emitted in\n    // a 'peer' event.\n    function onError (err) {\n      self.client.emit('warning', new Error(`Connection error: ${err.message}`))\n      peer.destroy()\n    }\n\n    // Once the peer is emitted in a 'peer' event, then it's the consumer's\n    // responsibility to listen for errors, so the listeners are removed here.\n    function onConnect () {\n      peer.removeListener('error', onError)\n      peer.removeListener('connect', onConnect)\n    }\n  }\n}\n\nWebSocketTracker.prototype.DEFAULT_ANNOUNCE_INTERVAL = 10 * 1000 // 30 seconds\n// Normally this shouldn't be accessed but is occasionally useful\nWebSocketTracker._socketPool = socketPool\n\nfunction noop () {}\n\nexport default WebSocketTracker\n","import Debug from 'debug'\nimport EventEmitter from 'events'\nimport once from 'once'\nimport parallel from 'run-parallel'\nimport Peer from '@thaunknown/simple-peer/lite.js'\nimport queueMicrotask from 'queue-microtask'\nimport { hex2arr, hex2bin, text2arr, arr2hex, arr2text } from 'uint8-util'\n\nimport common from './lib/common.js'\nimport HTTPTracker from './lib/client/http-tracker.js' // empty object in browser\nimport UDPTracker from './lib/client/udp-tracker.js' // empty object in browser\nimport WebSocketTracker from './lib/client/websocket-tracker.js'\n\nconst debug = Debug('bittorrent-tracker:client')\n\n/**\n * BitTorrent tracker client.\n *\n * Find torrent peers, to help a torrent client participate in a torrent swarm.\n *\n * @param {Object} opts                          options object\n * @param {string|Uint8Array} opts.infoHash          torrent info hash\n * @param {string|Uint8Array} opts.peerId            peer id\n * @param {string|Array.<string>} opts.announce  announce\n * @param {number} opts.port                     torrent client listening port\n * @param {function} opts.getAnnounceOpts        callback to provide data to tracker\n * @param {number} opts.rtcConfig                RTCPeerConnection configuration object\n * @param {number} opts.userAgent                User-Agent header for http requests\n * @param {number} opts.wrtc                     custom webrtc impl (useful in node.js)\n * @param {object} opts.proxyOpts                proxy options (useful in node.js)\n */\nclass Client extends EventEmitter {\n  constructor (opts = {}) {\n    super()\n\n    if (!opts.peerId) throw new Error('Option `peerId` is required')\n    if (!opts.infoHash) throw new Error('Option `infoHash` is required')\n    if (!opts.announce) throw new Error('Option `announce` is required')\n    if (!process.browser && !opts.port) throw new Error('Option `port` is required')\n\n    this.peerId = typeof opts.peerId === 'string'\n      ? opts.peerId\n      : arr2hex(opts.peerId)\n    this._peerIdBuffer = hex2arr(this.peerId)\n    this._peerIdBinary = hex2bin(this.peerId)\n\n    this.infoHash = typeof opts.infoHash === 'string'\n      ? opts.infoHash.toLowerCase()\n      : arr2hex(opts.infoHash)\n    this._infoHashBuffer = hex2arr(this.infoHash)\n    this._infoHashBinary = hex2bin(this.infoHash)\n\n    debug('new client %s', this.infoHash)\n\n    this.destroyed = false\n\n    this._port = opts.port\n    this._getAnnounceOpts = opts.getAnnounceOpts\n    this._rtcConfig = opts.rtcConfig\n    this._userAgent = opts.userAgent\n    this._proxyOpts = opts.proxyOpts\n\n    // Support lazy 'wrtc' module initialization\n    // See: https://github.com/webtorrent/webtorrent-hybrid/issues/46\n    this._wrtc = typeof opts.wrtc === 'function' ? opts.wrtc() : opts.wrtc\n\n    let announce = typeof opts.announce === 'string'\n      ? [opts.announce]\n      : opts.announce == null ? [] : opts.announce\n\n    // Remove trailing slash from trackers to catch duplicates\n    announce = announce.map(announceUrl => {\n      if (ArrayBuffer.isView(announceUrl)) announceUrl = arr2text(announceUrl)\n      if (announceUrl[announceUrl.length - 1] === '/') {\n        announceUrl = announceUrl.substring(0, announceUrl.length - 1)\n      }\n      return announceUrl\n    })\n    // remove duplicates by converting to Set and back\n    announce = Array.from(new Set(announce))\n\n    const webrtcSupport = this._wrtc !== false && (!!this._wrtc || Peer.WEBRTC_SUPPORT)\n\n    const nextTickWarn = err => {\n      queueMicrotask(() => {\n        this.emit('warning', err)\n      })\n    }\n\n    this._trackers = announce\n      .map(announceUrl => {\n        let parsedUrl\n        try {\n          parsedUrl = common.parseUrl(announceUrl)\n        } catch (err) {\n          nextTickWarn(new Error(`Invalid tracker URL: ${announceUrl}`))\n          return null\n        }\n\n        const port = parsedUrl.port\n        if (port < 0 || port > 65535) {\n          nextTickWarn(new Error(`Invalid tracker port: ${announceUrl}`))\n          return null\n        }\n\n        const protocol = parsedUrl.protocol\n        if ((protocol === 'http:' || protocol === 'https:') &&\n            typeof HTTPTracker === 'function') {\n          return new HTTPTracker(this, announceUrl)\n        } else if (protocol === 'udp:' && typeof UDPTracker === 'function') {\n          return new UDPTracker(this, announceUrl)\n        } else if ((protocol === 'ws:' || protocol === 'wss:') && webrtcSupport) {\n          // Skip ws:// trackers on https:// sites because they throw SecurityError\n          if (protocol === 'ws:' && typeof window !== 'undefined' &&\n              window.location.protocol === 'https:') {\n            nextTickWarn(new Error(`Unsupported tracker protocol: ${announceUrl}`))\n            return null\n          }\n          return new WebSocketTracker(this, announceUrl)\n        } else {\n          nextTickWarn(new Error(`Unsupported tracker protocol: ${announceUrl}`))\n          return null\n        }\n      })\n      .filter(Boolean)\n  }\n\n  /**\n   * Send a `start` announce to the trackers.\n   * @param {Object} opts\n   * @param {number=} opts.uploaded\n   * @param {number=} opts.downloaded\n   * @param {number=} opts.left (if not set, calculated automatically)\n   */\n  start (opts) {\n    opts = this._defaultAnnounceOpts(opts)\n    opts.event = 'started'\n    debug('send `start` %o', opts)\n    this._announce(opts)\n\n    // start announcing on intervals\n    this._trackers.forEach(tracker => {\n      tracker.setInterval()\n    })\n  }\n\n  /**\n   * Send a `stop` announce to the trackers.\n   * @param {Object} opts\n   * @param {number=} opts.uploaded\n   * @param {number=} opts.downloaded\n   * @param {number=} opts.numwant\n   * @param {number=} opts.left (if not set, calculated automatically)\n   */\n  stop (opts) {\n    opts = this._defaultAnnounceOpts(opts)\n    opts.event = 'stopped'\n    debug('send `stop` %o', opts)\n    this._announce(opts)\n  }\n\n  /**\n   * Send a `complete` announce to the trackers.\n   * @param {Object} opts\n   * @param {number=} opts.uploaded\n   * @param {number=} opts.downloaded\n   * @param {number=} opts.numwant\n   * @param {number=} opts.left (if not set, calculated automatically)\n   */\n  complete (opts) {\n    if (!opts) opts = {}\n    opts = this._defaultAnnounceOpts(opts)\n    opts.event = 'completed'\n    debug('send `complete` %o', opts)\n    this._announce(opts)\n  }\n\n  /**\n   * Send a `update` announce to the trackers.\n   * @param {Object} opts\n   * @param {number=} opts.uploaded\n   * @param {number=} opts.downloaded\n   * @param {number=} opts.numwant\n   * @param {number=} opts.left (if not set, calculated automatically)\n   */\n  update (opts) {\n    opts = this._defaultAnnounceOpts(opts)\n    if (opts.event) delete opts.event\n    debug('send `update` %o', opts)\n    this._announce(opts)\n  }\n\n  _announce (opts) {\n    this._trackers.forEach(tracker => {\n      // tracker should not modify `opts` object, it's passed to all trackers\n      tracker.announce(opts)\n    })\n  }\n\n  /**\n   * Send a scrape request to the trackers.\n   * @param {Object} opts\n   */\n  scrape (opts) {\n    debug('send `scrape`')\n    if (!opts) opts = {}\n    this._trackers.forEach(tracker => {\n      // tracker should not modify `opts` object, it's passed to all trackers\n      tracker.scrape(opts)\n    })\n  }\n\n  setInterval (intervalMs) {\n    debug('setInterval %d', intervalMs)\n    this._trackers.forEach(tracker => {\n      tracker.setInterval(intervalMs)\n    })\n  }\n\n  destroy (cb) {\n    if (this.destroyed) return\n    this.destroyed = true\n    debug('destroy')\n\n    const tasks = this._trackers.map(tracker => cb => {\n      tracker.destroy(cb)\n    })\n\n    parallel(tasks, cb)\n\n    this._trackers = []\n    this._getAnnounceOpts = null\n  }\n\n  _defaultAnnounceOpts (opts = {}) {\n    if (opts.numwant == null) opts.numwant = common.DEFAULT_ANNOUNCE_PEERS\n\n    if (opts.uploaded == null) opts.uploaded = 0\n    if (opts.downloaded == null) opts.downloaded = 0\n\n    if (this._getAnnounceOpts) opts = Object.assign({}, opts, this._getAnnounceOpts())\n\n    return opts\n  }\n}\n\n/**\n * Simple convenience function to scrape a tracker for an info hash without needing to\n * create a Client, pass it a parsed torrent, etc. Support scraping a tracker for multiple\n * torrents at the same time.\n * @params {Object} opts\n * @param  {string|Array.<string>} opts.infoHash\n * @param  {string} opts.announce\n * @param  {function} cb\n */\nClient.scrape = (opts, cb) => {\n  cb = once(cb)\n\n  if (!opts.infoHash) throw new Error('Option `infoHash` is required')\n  if (!opts.announce) throw new Error('Option `announce` is required')\n\n  const clientOpts = Object.assign({}, opts, {\n    infoHash: Array.isArray(opts.infoHash) ? opts.infoHash[0] : opts.infoHash,\n    peerId: text2arr('01234567890123456789'), // dummy value\n    port: 6881 // dummy value\n  })\n\n  const client = new Client(clientOpts)\n  client.once('error', cb)\n  client.once('warning', cb)\n\n  let len = Array.isArray(opts.infoHash) ? opts.infoHash.length : 1\n  const results = {}\n  client.on('scrape', data => {\n    len -= 1\n    results[data.infoHash] = data\n    if (len === 0) {\n      client.destroy()\n      const keys = Object.keys(results)\n      if (keys.length === 1) {\n        cb(null, results[keys[0]])\n      } else {\n        cb(null, results)\n      }\n    }\n  })\n\n  client.scrape({ infoHash: opts.infoHash })\n  return client\n}\n\nexport default Client\n","function FF(a, b, c, d, m, s, k) {\n\tvar n = a + (b & c | ~b & d) + (m >>> 0) + k;\n\treturn ((n << s) | (n >>> (32 - s))) + b;\n}\n\nfunction GG(a, b, c, d, m, s, k) {\n\tvar n = a + (b & d | c & ~d) + (m >>> 0) + k;\n\treturn ((n << s) | (n >>> (32 - s))) + b;\n}\n\nfunction HH(a, b, c, d, m, s, k) {\n\tvar n = a + (b ^ c ^ d) + (m >>> 0) + k;\n\treturn ((n << s) | (n >>> (32 - s))) + b;\n}\n\nfunction II(a, b, c, d, m, s, k) {\n\tvar n = a + (c ^ (b | ~d)) + (m >>> 0) + k;\n\treturn ((n << s) | (n >>> (32 - s))) + b;\n}\n\n\nfunction byteToHex(byte) {\n\treturn (256+(byte&255)).toString(16).substr(-2);\n}\n\n\nfunction bs(byte) {\n\treturn String.fromCharCode(byte & 255);\n}\n\nfunction wordToBytes(word) {\n\treturn bs(word) + bs(word >>> 8) + bs(word >>> 16) + bs(word >>> 24);\n}\n\n\n// converts utf8 string to bytes string\nvar utf8toBytes = function (utf8) {\n\treturn unescape(encodeURIComponent(utf8));\n};\n\n\n// converts bytes string to 32-bits words array padded with \"1\" and zeros and bits_length for MD5 message buffer\nfunction bytesToWords(bytes) {\n\tvar bytes_count = bytes.length,\n\t    bits_count = bytes_count << 3,\n\t    words = new Uint32Array((bytes_count + 72) >>> 6 << 4);\n\tfor (var i = 0, n = bytes.length; i < n; ++i)\n\t\twords[i >>> 2] |= bytes.charCodeAt(i) << ((i & 3) << 3);\n\twords[bytes_count >> 2] |= 0x80 << (bits_count & 31); // append \"1\" bit to message\n\twords[words.length - 2] = bits_count;\n\treturn words;\n}\n\n\nvar exports = module.exports = function md5(utf8) {\n\treturn utf8toMD5(utf8).toHex();\n};\n\nvar bytesToMD5 = exports.fromBytes = function (bytes) {\n\tvar words = bytesToWords(bytes),\n\t    a = 0x67452301,\n\t    b = 0xEFCDAB89,\n\t    c = 0x98BADCFE,\n\t    d = 0x10325476,\n\t    S11 = 7, S12 = 12, S13 = 17, S14 = 22,\n\t    S21 = 5, S22 = 9 , S23 = 14, S24 = 20,\n\t    S31 = 4, S32 = 11, S33 = 16, S34 = 23,\n\t    S41 = 6, S42 = 10, S43 = 15, S44 = 21;\n\n\tfor (var i = 0, ws = words.length; i < ws; i += 16) {\n\t\tvar AA = a, BB = b, CC = c, DD = d;\n\t\ta = FF(a, b, c, d, words[i+0], S11, 0xD76AA478);\n\t\td = FF(d, a, b, c, words[i+1], S12, 0xE8C7B756);\n\t\tc = FF(c, d, a, b, words[i+2], S13, 0x242070DB);\n\t\tb = FF(b, c, d, a, words[i+3], S14, 0xC1BDCEEE);\n\t\ta = FF(a, b, c, d, words[i+4], S11, 0xF57C0FAF);\n\t\td = FF(d, a, b, c, words[i+5], S12, 0x4787C62A);\n\t\tc = FF(c, d, a, b, words[i+6], S13, 0xA8304613);\n\t\tb = FF(b, c, d, a, words[i+7], S14, 0xFD469501);\n\t\ta = FF(a, b, c, d, words[i+8], S11, 0x698098D8);\n\t\td = FF(d, a, b, c, words[i+9], S12, 0x8B44F7AF);\n\t\tc = FF(c, d, a, b, words[i+10],S13, 0xFFFF5BB1);\n\t\tb = FF(b, c, d, a, words[i+11],S14, 0x895CD7BE);\n\t\ta = FF(a, b, c, d, words[i+12],S11, 0x6B901122);\n\t\td = FF(d, a, b, c, words[i+13],S12, 0xFD987193);\n\t\tc = FF(c, d, a, b, words[i+14],S13, 0xA679438E);\n\t\tb = FF(b, c, d, a, words[i+15],S14, 0x49B40821);\n\t\ta = GG(a, b, c, d, words[i+1], S21, 0xF61E2562);\n\t\td = GG(d, a, b, c, words[i+6], S22, 0xC040B340);\n\t\tc = GG(c, d, a, b, words[i+11],S23, 0x265E5A51);\n\t\tb = GG(b, c, d, a, words[i+0], S24, 0xE9B6C7AA);\n\t\ta = GG(a, b, c, d, words[i+5], S21, 0xD62F105D);\n\t\td = GG(d, a, b, c, words[i+10],S22, 0x2441453);\n\t\tc = GG(c, d, a, b, words[i+15],S23, 0xD8A1E681);\n\t\tb = GG(b, c, d, a, words[i+4], S24, 0xE7D3FBC8);\n\t\ta = GG(a, b, c, d, words[i+9], S21, 0x21E1CDE6);\n\t\td = GG(d, a, b, c, words[i+14],S22, 0xC33707D6);\n\t\tc = GG(c, d, a, b, words[i+3], S23, 0xF4D50D87);\n\t\tb = GG(b, c, d, a, words[i+8], S24, 0x455A14ED);\n\t\ta = GG(a, b, c, d, words[i+13],S21, 0xA9E3E905);\n\t\td = GG(d, a, b, c, words[i+2], S22, 0xFCEFA3F8);\n\t\tc = GG(c, d, a, b, words[i+7], S23, 0x676F02D9);\n\t\tb = GG(b, c, d, a, words[i+12],S24, 0x8D2A4C8A);\n\t\ta = HH(a, b, c, d, words[i+5], S31, 0xFFFA3942);\n\t\td = HH(d, a, b, c, words[i+8], S32, 0x8771F681);\n\t\tc = HH(c, d, a, b, words[i+11],S33, 0x6D9D6122);\n\t\tb = HH(b, c, d, a, words[i+14],S34, 0xFDE5380C);\n\t\ta = HH(a, b, c, d, words[i+1], S31, 0xA4BEEA44);\n\t\td = HH(d, a, b, c, words[i+4], S32, 0x4BDECFA9);\n\t\tc = HH(c, d, a, b, words[i+7], S33, 0xF6BB4B60);\n\t\tb = HH(b, c, d, a, words[i+10],S34, 0xBEBFBC70);\n\t\ta = HH(a, b, c, d, words[i+13],S31, 0x289B7EC6);\n\t\td = HH(d, a, b, c, words[i+0], S32, 0xEAA127FA);\n\t\tc = HH(c, d, a, b, words[i+3], S33, 0xD4EF3085);\n\t\tb = HH(b, c, d, a, words[i+6], S34, 0x4881D05);\n\t\ta = HH(a, b, c, d, words[i+9], S31, 0xD9D4D039);\n\t\td = HH(d, a, b, c, words[i+12],S32, 0xE6DB99E5);\n\t\tc = HH(c, d, a, b, words[i+15],S33, 0x1FA27CF8);\n\t\tb = HH(b, c, d, a, words[i+2], S34, 0xC4AC5665);\n\t\ta = II(a, b, c, d, words[i+0], S41, 0xF4292244);\n\t\td = II(d, a, b, c, words[i+7], S42, 0x432AFF97);\n\t\tc = II(c, d, a, b, words[i+14],S43, 0xAB9423A7);\n\t\tb = II(b, c, d, a, words[i+5], S44, 0xFC93A039);\n\t\ta = II(a, b, c, d, words[i+12],S41, 0x655B59C3);\n\t\td = II(d, a, b, c, words[i+3], S42, 0x8F0CCC92);\n\t\tc = II(c, d, a, b, words[i+10],S43, 0xFFEFF47D);\n\t\tb = II(b, c, d, a, words[i+1], S44, 0x85845DD1);\n\t\ta = II(a, b, c, d, words[i+8], S41, 0x6FA87E4F);\n\t\td = II(d, a, b, c, words[i+15],S42, 0xFE2CE6E0);\n\t\tc = II(c, d, a, b, words[i+6], S43, 0xA3014314);\n\t\tb = II(b, c, d, a, words[i+13],S44, 0x4E0811A1);\n\t\ta = II(a, b, c, d, words[i+4], S41, 0xF7537E82);\n\t\td = II(d, a, b, c, words[i+11],S42, 0xBD3AF235);\n\t\tc = II(c, d, a, b, words[i+2], S43, 0x2AD7D2BB);\n\t\tb = II(b, c, d, a, words[i+9], S44, 0xEB86D391);\n\t\ta = (a + AA) >>> 0;\n\t\tb = (b + BB) >>> 0;\n\t\tc = (c + CC) >>> 0;\n\t\td = (d + DD) >>> 0;\n\t}\n\n\tvar hash_bytes = new String(wordToBytes(a) + wordToBytes(b) + wordToBytes(c) + wordToBytes(d));\n\thash_bytes.toHex = function () {\n\t\tvar hex = '';\n\t\tfor (var i = 0, n = hash_bytes.length; i < n; ++i)\n\t\t\thex += byteToHex(hash_bytes.charCodeAt(i));\n\t\treturn hex;\n\t};\n\treturn hash_bytes;\n};\n\n\nvar utf8toMD5 = exports.fromUtf8 = function (utf8) {\n\treturn bytesToMD5(utf8toBytes(utf8));\n};\n\n\n\nvar b64 = './0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';\n\nfunction to64(u, n) {\n\tfor (var s = ''; --n >= 0; u >>>= 6)\n\t\ts += b64.charAt(u & 63);\n\treturn s;\n}\n\n\nvar MAX_KEY_LENGTH = 64,\n    b64_map = [ 0,6,12, 1,7,13, 2,8,14, 3,9,15, 4,10,5, 11 ];\n\n\nvar gen_salt = exports.salt = function (n) {\n\tvar s = '';\n\tif (!n)\n\t\tn = 8;\n\tdo {\n\t\ts += b64.charAt( 64*Math.random() >>> 0 );\n\t} while (--n);\n\treturn s;\n};\n\n\nexports.crypt = function (key, setting) {\n\n\tif (key.length > MAX_KEY_LENGTH)\n\t\tthrow Error(\"too long key\");\n\n\tif (!setting)\n\t\tsetting = '$1$'+gen_salt();\n\n\tkey = utf8toBytes(key);\n\n\tvar salt = utf8toBytes(setting.replace(/^\\$1\\$([^$]+)(?:\\$.*)?$/, '$1')),\n\t    md = bytesToMD5(key + salt + key),\n\t    s = key + '$1$' + salt;\n\n\tfor (var kl = key.length; kl > 16; kl -= 16)\n\t\ts += md;\n\n\ts += md.slice(0, kl);\n\n\tfor (var kl = key.length; kl; kl >>= 1)\n\t\ts += kl & 1 ? \"\\0\" : key.charAt(0);\n\n\tmd = bytesToMD5(s);\n\n\tfor (var i = 0; i < 1000; ++i)\n\t\tmd = bytesToMD5((i & 1 ? key : md) + (i % 3 ? salt : '') + (i % 7 ? key : '') + (i & 1 ? md : key));\n\n\tvar h = '$1$'+salt+'$';\n\n\tfor (var i = 0; i < 15; i += 3)\n\t\th += to64(\n\t\t\tmd.charCodeAt(b64_map[i+0]) << 16 |\n\t\t\tmd.charCodeAt(b64_map[i+1]) << 8 |\n\t\t\tmd.charCodeAt(b64_map[i+2]), 4);\n\n\treturn h + to64(md.charCodeAt(b64_map[15]), 2);\n};\n","import md5 from \"nano-md5\";\nimport { PACKAGE_VERSION } from \"./version.js\";\n\nexport const TRACKER_CLIENT_VERSION_PREFIX = `-PM${formatVersion(PACKAGE_VERSION)}-`;\n\nconst HASH_SYMBOLS =\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\nconst PEER_ID_LENGTH = 20;\n\nexport function getStreamHash(streamId: string): string {\n  // slice one byte to have 15 bytes binary string\n  const binary15BytesHashString = md5.fromUtf8(streamId).slice(1);\n  const base64Hash20CharsString = btoa(binary15BytesHashString);\n  return base64Hash20CharsString;\n}\n\nexport function generatePeerId(trackerClientVersionPrefix: string): string {\n  const trackerClientId = [trackerClientVersionPrefix];\n  const randomCharsCount = PEER_ID_LENGTH - trackerClientVersionPrefix.length;\n\n  for (let i = 0; i < randomCharsCount; i++) {\n    trackerClientId.push(\n      HASH_SYMBOLS[Math.floor(Math.random() * HASH_SYMBOLS.length)],\n    );\n  }\n\n  return trackerClientId.join(\"\");\n}\n\nfunction formatVersion(versionString: string) {\n  const splittedVersion = versionString.split(\".\");\n\n  return `${splittedVersion[0].padStart(2, \"0\")}${splittedVersion[1].padStart(2, \"0\")}`;\n}\n","export const PACKAGE_VERSION = \"2.2.2\";\n","import { SegmentWithStream, Stream } from \"../types.js\";\nimport { SegmentPlaybackStatuses } from \"./stream.js\";\n\nexport function getStreamString(stream: Stream) {\n  return `${stream.type}-${stream.index}`;\n}\n\nexport function getSegmentString(segment: SegmentWithStream) {\n  const { externalId } = segment;\n  return `(${getStreamString(segment.stream)} | ${externalId})`;\n}\n\nexport function getSegmentPlaybackStatusesString(\n  statuses: SegmentPlaybackStatuses,\n): string {\n  const { isHighDemand, isHttpDownloadable, isP2PDownloadable } = statuses;\n  if (isHighDemand) return \"high-demand\";\n  if (isHttpDownloadable && isP2PDownloadable) return \"http-p2p-window\";\n  if (isHttpDownloadable) return \"http-window\";\n  if (isP2PDownloadable) return \"p2p-window\";\n  return \"-\";\n}\n","import { CommonCoreConfig, CoreConfig, StreamConfig } from \"../types.js\";\n\nexport function getControlledPromise<T = void>() {\n  let resolve: (value: T) => void;\n  let reject: (reason?: unknown) => void;\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return {\n    promise,\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    resolve: resolve!,\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    reject: reject!,\n  };\n}\n\nexport function joinChunks(chunks: Uint8Array[], totalBytes?: number) {\n  totalBytes ??= chunks.reduce((sum, chunk) => sum + chunk.byteLength, 0);\n\n  const buffer = new Uint8Array(totalBytes);\n  let offset = 0;\n  for (const chunk of chunks) {\n    buffer.set(chunk, offset);\n    offset += chunk.byteLength;\n  }\n\n  return buffer;\n}\n\nexport function getPercent(numerator: number, denominator: number): number {\n  return (numerator / denominator) * 100;\n}\n\nexport function getRandomItem<T>(items: T[]): T {\n  return items[Math.floor(Math.random() * items.length)];\n}\n\nexport function utf8ToUintArray(utf8String: string): Uint8Array {\n  const encoder = new TextEncoder();\n  const bytes = new Uint8Array(utf8String.length);\n  encoder.encodeInto(utf8String, bytes);\n  return bytes;\n}\n\nexport function hexToUtf8(hexString: string) {\n  const bytes = new Uint8Array(hexString.length / 2);\n\n  for (let i = 0; i < hexString.length; i += 2) {\n    bytes[i / 2] = parseInt(hexString.slice(i, i + 2), 16);\n  }\n  const decoder = new TextDecoder();\n  return decoder.decode(bytes);\n}\n\nexport function* arrayBackwards<T>(arr: T[]) {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    yield arr[i];\n  }\n}\n\nfunction isObject(item: unknown): item is Record<string, unknown> {\n  return !!item && typeof item === \"object\" && !Array.isArray(item);\n}\n\nfunction isArray(item: unknown): item is unknown[] {\n  return Array.isArray(item);\n}\n\nexport function filterUndefinedProps<T extends object>(obj: T): Partial<T> {\n  function filter(obj: unknown): unknown {\n    if (isObject(obj)) {\n      const result: Record<string, unknown> = {};\n      Object.keys(obj).forEach((key) => {\n        if (obj[key] !== undefined) {\n          const value = filter(obj[key]);\n          if (value !== undefined) {\n            result[key] = value;\n          }\n        }\n      });\n      return result;\n    } else {\n      return obj;\n    }\n  }\n\n  return filter(obj) as Partial<T>;\n}\n\nexport function deepCopy<T>(item: T): T {\n  if (isArray(item)) {\n    return item.map((element) => deepCopy(element)) as T;\n  } else if (isObject(item)) {\n    const copy = {} as Record<string, unknown>;\n    for (const key of Object.keys(item)) {\n      copy[key] = deepCopy(item[key]);\n    }\n    return copy as T;\n  } else {\n    return item;\n  }\n}\n\nexport function shuffleArray<T>(array: T[]): T[] {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n  return array;\n}\n\ntype RecursivePartial<T> = {\n  [P in keyof T]?: T[P] extends object ? RecursivePartial<T[P]> : T[P];\n};\n\nexport function overrideConfig<T>(\n  target: T,\n  updates: RecursivePartial<T> | null,\n  defaults: RecursivePartial<T> = {} as RecursivePartial<T>,\n): T {\n  if (\n    typeof target !== \"object\" ||\n    target === null ||\n    typeof updates !== \"object\" ||\n    updates === null\n  ) {\n    return target;\n  }\n\n  (Object.keys(updates) as (keyof T)[]).forEach((key) => {\n    const keyStr = typeof key === \"symbol\" ? key.toString() : String(key);\n    if (key === \"__proto__\" || key === \"constructor\" || key === \"prototype\") {\n      throw new Error(`Attempt to modify restricted property '${keyStr}'`);\n    }\n\n    const updateValue = updates[key];\n    const defaultValue = defaults[key];\n\n    if (key in target) {\n      if (updateValue === undefined) {\n        target[key] =\n          defaultValue === undefined\n            ? (undefined as (T & object)[keyof T])\n            : (defaultValue as (T & object)[keyof T]);\n      } else {\n        target[key] = updateValue as (T & object)[keyof T];\n      }\n    }\n  });\n\n  return target;\n}\n\ntype MergeConfigsToTypeOptions = {\n  defaultConfig: StreamConfig | CommonCoreConfig | CoreConfig;\n  baseConfig?: Partial<CoreConfig>;\n  specificStreamConfig?: Partial<StreamConfig>;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-unnecessary-type-parameters\nexport function mergeAndFilterConfig<T>(options: MergeConfigsToTypeOptions) {\n  const { defaultConfig, baseConfig = {}, specificStreamConfig = {} } = options;\n\n  const mergedConfig = deepCopy({\n    ...defaultConfig,\n    ...baseConfig,\n    ...specificStreamConfig,\n  });\n\n  const keysOfT = Object.keys(defaultConfig) as (keyof T)[];\n  const filteredConfig: Partial<T> = {};\n\n  keysOfT.forEach((key) => {\n    if (key in mergedConfig) {\n      filteredConfig[key] = mergedConfig[\n        key as keyof typeof mergedConfig\n      ] as T[keyof T];\n    }\n  });\n\n  return filteredConfig as T;\n}\n","type BasePeerCommand<T extends PeerCommandType = PeerCommandType> = {\n  c: T;\n};\n\nexport const enum PeerCommandType {\n  SegmentsAnnouncement,\n  SegmentRequest,\n  SegmentData,\n  SegmentDataSendingCompleted,\n  SegmentAbsent,\n  CancelSegmentRequest,\n}\n\nexport type PeerSegmentCommand = BasePeerCommand<\n  | PeerCommandType.SegmentAbsent\n  | PeerCommandType.CancelSegmentRequest\n  | PeerCommandType.SegmentDataSendingCompleted\n> & {\n  i: number; // segment id\n  r: number; // request id\n};\n\nexport type PeerRequestSegmentCommand =\n  BasePeerCommand<PeerCommandType.SegmentRequest> & {\n    i: number; // segment id\n    r: number; // request id\n    b?: number; // byte from\n  };\n\nexport type PeerSegmentAnnouncementCommand =\n  BasePeerCommand<PeerCommandType.SegmentsAnnouncement> & {\n    l?: number[]; // loaded segments\n    p?: number[]; // segments loading by http\n  };\n\nexport type PeerSendSegmentCommand =\n  BasePeerCommand<PeerCommandType.SegmentData> & {\n    i: number; // segment id\n    r: number; // request id\n    s: number; // size in bytes\n  };\n\nexport type PeerCommand =\n  | PeerSegmentCommand\n  | PeerRequestSegmentCommand\n  | PeerSegmentAnnouncementCommand\n  | PeerSendSegmentCommand;\n","import { joinChunks } from \"../../utils/utils.js\";\n\n// restricted up to 16 item types (4 bits to type definition)\nexport const enum SerializedItem {\n  Min = -1,\n  Int,\n  SimilarIntArray,\n  String,\n  Max,\n}\n\nfunction abs(num: bigint): bigint {\n  return num < 0 ? -num : num;\n}\n\nfunction getRequiredBytesForInt(num: bigint): number {\n  const binaryString = num.toString(2);\n  const necessaryBits = num < 0 ? binaryString.length : binaryString.length + 1;\n  return Math.ceil(necessaryBits / 8);\n}\n\nfunction intToBytes(num: bigint): Uint8Array {\n  const isNegative = num < 0;\n  const bytesAmountNumber = getRequiredBytesForInt(num);\n  const bytes = new Uint8Array(bytesAmountNumber);\n  const bytesAmount = BigInt(bytesAmountNumber);\n\n  num = abs(num);\n  for (let i = 0; i < bytesAmountNumber; i++) {\n    const shift = 8n * (bytesAmount - 1n - BigInt(i));\n    const byte = (num >> shift) & 0xffn;\n    bytes[i] = Number(byte);\n  }\n\n  if (isNegative) bytes[0] = bytes[0] | 0b10000000;\n  return bytes;\n}\n\nfunction bytesToInt(bytes: Uint8Array): bigint {\n  const byteLength = BigInt(bytes.length);\n  const getNumberPart = (byte: number, i: number): bigint => {\n    const shift = 8n * (byteLength - 1n - BigInt(i));\n    return BigInt(byte) << shift;\n  };\n\n  // ignore first bit of first byte as it is sign bit\n  let number = getNumberPart(bytes[0] & 0b01111111, 0);\n  for (let i = 1; i < byteLength; i++) {\n    number = getNumberPart(bytes[i], i) | number;\n  }\n  if ((bytes[0] & 0b10000000) >> 7 !== 0) number = -number;\n\n  return number;\n}\n\nexport function serializeInt(num: bigint): Uint8Array {\n  const numBytes = intToBytes(num);\n  const numberMetadata = (SerializedItem.Int << 4) | numBytes.length;\n  return new Uint8Array([numberMetadata, ...numBytes]);\n}\n\nexport function deserializeInt(bytes: Uint8Array) {\n  const metadata = bytes[0];\n  const code: SerializedItem = metadata >> 4;\n  if (code !== SerializedItem.Int) {\n    throw new Error(\n      \"Trying to deserialize integer with invalid serialized item code\",\n    );\n  }\n  const numberBytesLength = metadata & 0b1111;\n  const start = 1;\n  const end = start + numberBytesLength;\n  return {\n    number: bytesToInt(bytes.slice(start, end)),\n    byteLength: numberBytesLength + 1,\n  };\n}\n\nexport function serializeSimilarIntArray(numbers: bigint[]) {\n  const commonPartNumbersMap = new Map<bigint, ResizableUint8Array>();\n\n  for (const number of numbers) {\n    const common = number & ~0xffn;\n    const diffByte = number & 0xffn;\n    const bytes = commonPartNumbersMap.get(common) ?? new ResizableUint8Array();\n    if (!bytes.length) commonPartNumbersMap.set(common, bytes);\n    bytes.push(Number(diffByte));\n  }\n\n  const result = new ResizableUint8Array();\n  result.push([SerializedItem.SimilarIntArray << 4, commonPartNumbersMap.size]);\n\n  for (const [commonPart, binaryArray] of commonPartNumbersMap) {\n    const { length } = binaryArray.getBytesChunks();\n    const commonPartWithLength = commonPart | (BigInt(length) & 0xffn);\n    binaryArray.unshift(serializeInt(commonPartWithLength));\n    result.push(binaryArray.getBuffer());\n  }\n\n  return result.getBuffer();\n}\n\nexport function deserializeSimilarIntArray(bytes: Uint8Array) {\n  const [codeByte, commonPartArraysAmount] = bytes;\n  const code: SerializedItem = codeByte >> 4;\n  if (code !== SerializedItem.SimilarIntArray) {\n    throw new Error(\n      \"Trying to deserialize similar int array with invalid serialized item code\",\n    );\n  }\n\n  let offset = 2;\n  const originalIntArr: bigint[] = [];\n  for (let i = 0; i < commonPartArraysAmount; i++) {\n    const { number: commonPartWithLength, byteLength } = deserializeInt(\n      bytes.slice(offset),\n    );\n    offset += byteLength;\n    const arrayLength = commonPartWithLength & 0xffn;\n    const commonPart = commonPartWithLength & ~0xffn;\n\n    for (let j = 0; j < arrayLength; j++) {\n      const diffPart = BigInt(bytes[offset]);\n      originalIntArr.push(commonPart | diffPart);\n      offset++;\n    }\n  }\n\n  return { numbers: originalIntArr, byteLength: offset };\n}\n\nexport function serializeString(string: string) {\n  const { length } = string;\n  const bytes = new ResizableUint8Array();\n  bytes.push([\n    (SerializedItem.String << 4) | ((length >> 8) & 0x0f),\n    length & 0xff,\n  ]);\n  bytes.push(new TextEncoder().encode(string));\n  return bytes.getBuffer();\n}\n\nexport function deserializeString(bytes: Uint8Array) {\n  const [codeByte, lengthByte] = bytes;\n  const code: SerializedItem = codeByte >> 4;\n  if (code !== SerializedItem.String) {\n    throw new Error(\n      \"Trying to deserialize bytes (sting) with invalid serialized item code.\",\n    );\n  }\n  const length = ((codeByte & 0x0f) << 8) | lengthByte;\n  const stringBytes = bytes.slice(2, length + 2);\n  const string = new TextDecoder(\"utf8\").decode(stringBytes);\n  return { string, byteLength: length + 2 };\n}\n\nexport class ResizableUint8Array {\n  private bytes: Uint8Array[] = [];\n  private _length = 0;\n\n  push(bytes: Uint8Array | number | number[]) {\n    this.addBytes(bytes, \"end\");\n  }\n\n  unshift(bytes: Uint8Array | number | number[]) {\n    this.addBytes(bytes, \"start\");\n  }\n\n  private addBytes(\n    bytes: Uint8Array | number | number[],\n    position: \"start\" | \"end\",\n  ) {\n    let bytesToAdd: Uint8Array;\n    if (bytes instanceof Uint8Array) {\n      bytesToAdd = bytes;\n    } else if (Array.isArray(bytes)) {\n      bytesToAdd = new Uint8Array(bytes);\n    } else {\n      bytesToAdd = new Uint8Array([bytes]);\n    }\n    this._length += bytesToAdd.length;\n    this.bytes[position === \"start\" ? \"unshift\" : \"push\"](bytesToAdd);\n  }\n\n  getBytesChunks(): readonly Uint8Array[] {\n    return this.bytes;\n  }\n\n  getBuffer(): Uint8Array {\n    return joinChunks(this.bytes, this._length);\n  }\n\n  get length() {\n    return this._length;\n  }\n}\n","import * as Serialization from \"./binary-serialization.js\";\nimport { PeerCommandType, PeerCommand } from \"./types.js\";\n\nconst FRAME_PART_LENGTH = 4;\nconst commandFrameStart = stringToUtf8CodesBuffer(\"cstr\", FRAME_PART_LENGTH);\nconst commandFrameEnd = stringToUtf8CodesBuffer(\"cend\", FRAME_PART_LENGTH);\nconst commandDivFrameStart = stringToUtf8CodesBuffer(\"dstr\", FRAME_PART_LENGTH);\nconst commandDivFrameEnd = stringToUtf8CodesBuffer(\"dend\", FRAME_PART_LENGTH);\nconst startFrames = [commandFrameStart, commandDivFrameStart];\nconst endFrames = [commandFrameEnd, commandDivFrameEnd];\nconst commandFramesLength = commandFrameStart.length + commandFrameEnd.length;\n\nexport function isCommandChunk(buffer: Uint8Array) {\n  const { length } = commandFrameStart;\n  const bufferEndingToCompare = buffer.slice(-length);\n  return (\n    startFrames.some((frame) =>\n      areBuffersEqual(buffer, frame, FRAME_PART_LENGTH),\n    ) &&\n    endFrames.some((frame) =>\n      areBuffersEqual(bufferEndingToCompare, frame, FRAME_PART_LENGTH),\n    )\n  );\n}\n\nfunction isFirstCommandChunk(buffer: Uint8Array) {\n  return areBuffersEqual(buffer, commandFrameStart, FRAME_PART_LENGTH);\n}\n\nfunction isLastCommandChunk(buffer: Uint8Array) {\n  return areBuffersEqual(\n    buffer.slice(-FRAME_PART_LENGTH),\n    commandFrameEnd,\n    FRAME_PART_LENGTH,\n  );\n}\n\nexport class BinaryCommandJoiningError extends Error {\n  constructor(readonly type: \"incomplete-joining\" | \"no-first-chunk\") {\n    super();\n  }\n}\n\nexport class BinaryCommandChunksJoiner {\n  private readonly chunks = new Serialization.ResizableUint8Array();\n  private status: \"joining\" | \"completed\" = \"joining\";\n\n  constructor(\n    private readonly onComplete: (commandBuffer: Uint8Array) => void,\n  ) {}\n\n  addCommandChunk(chunk: Uint8Array) {\n    if (this.status === \"completed\") return;\n\n    const isFirstChunk = isFirstCommandChunk(chunk);\n    if (!this.chunks.length && !isFirstChunk) {\n      throw new BinaryCommandJoiningError(\"no-first-chunk\");\n    }\n    if (this.chunks.length && isFirstChunk) {\n      throw new BinaryCommandJoiningError(\"incomplete-joining\");\n    }\n    this.chunks.push(this.unframeCommandChunk(chunk));\n\n    if (!isLastCommandChunk(chunk)) return;\n    this.status = \"completed\";\n    this.onComplete(this.chunks.getBuffer());\n  }\n\n  private unframeCommandChunk(chunk: Uint8Array) {\n    return chunk.slice(FRAME_PART_LENGTH, chunk.length - FRAME_PART_LENGTH);\n  }\n}\n\nexport class BinaryCommandCreator {\n  private readonly bytes = new Serialization.ResizableUint8Array();\n  private resultBuffers: Uint8Array[] = [];\n  private status: \"creating\" | \"completed\" = \"creating\";\n\n  constructor(\n    commandType: PeerCommandType,\n    private readonly maxChunkLength: number,\n  ) {\n    this.bytes.push(commandType);\n  }\n\n  addInteger(name: string, value: number) {\n    this.bytes.push(name.charCodeAt(0));\n    const bytes = Serialization.serializeInt(BigInt(value));\n    this.bytes.push(bytes);\n  }\n\n  addSimilarIntArr(name: string, arr: number[]) {\n    this.bytes.push(name.charCodeAt(0));\n    const bytes = Serialization.serializeSimilarIntArray(\n      arr.map((num) => BigInt(num)),\n    );\n    this.bytes.push(bytes);\n  }\n\n  addString(name: string, string: string) {\n    this.bytes.push(name.charCodeAt(0));\n    const bytes = Serialization.serializeString(string);\n    this.bytes.push(bytes);\n  }\n\n  complete() {\n    if (!this.bytes.length) throw new Error(\"Buffer is empty\");\n    if (this.status === \"completed\") return;\n    this.status = \"completed\";\n\n    const unframedBuffer = this.bytes.getBuffer();\n    if (unframedBuffer.length + commandFramesLength <= this.maxChunkLength) {\n      this.resultBuffers.push(\n        frameBuffer(unframedBuffer, commandFrameStart, commandFrameEnd),\n      );\n      return;\n    }\n\n    let chunksCount = Math.ceil(unframedBuffer.length / this.maxChunkLength);\n    if (\n      Math.ceil(unframedBuffer.length / chunksCount) + commandFramesLength >\n      this.maxChunkLength\n    ) {\n      chunksCount++;\n    }\n\n    for (const [i, chunk] of splitBufferToEqualChunks(\n      unframedBuffer,\n      chunksCount,\n    )) {\n      if (i === 0) {\n        this.resultBuffers.push(\n          frameBuffer(chunk, commandFrameStart, commandDivFrameEnd),\n        );\n      } else if (i === chunksCount - 1) {\n        this.resultBuffers.push(\n          frameBuffer(chunk, commandDivFrameStart, commandFrameEnd),\n        );\n      } else {\n        this.resultBuffers.push(\n          frameBuffer(chunk, commandDivFrameStart, commandDivFrameEnd),\n        );\n      }\n    }\n  }\n\n  getResultBuffers(): Uint8Array[] {\n    if (this.status === \"creating\" || !this.resultBuffers.length) {\n      throw new Error(\"Command is not complete.\");\n    }\n    return this.resultBuffers;\n  }\n}\n\nexport function deserializeCommand(bytes: Uint8Array): PeerCommand {\n  const [commandCode] = bytes;\n  const deserializedCommand: Record<string, unknown> = {\n    c: commandCode,\n  };\n\n  let offset = 1;\n  while (offset < bytes.length) {\n    const name = String.fromCharCode(bytes[offset]);\n    offset++;\n    const dataType = getDataTypeFromByte(bytes[offset]);\n\n    switch (dataType) {\n      case Serialization.SerializedItem.Int:\n        {\n          const { number, byteLength } = Serialization.deserializeInt(\n            bytes.slice(offset),\n          );\n          deserializedCommand[name] = Number(number);\n          offset += byteLength;\n        }\n        break;\n      case Serialization.SerializedItem.SimilarIntArray:\n        {\n          const { numbers, byteLength } =\n            Serialization.deserializeSimilarIntArray(bytes.slice(offset));\n          deserializedCommand[name] = numbers.map((n) => Number(n));\n          offset += byteLength;\n        }\n        break;\n      case Serialization.SerializedItem.String:\n        {\n          const { string, byteLength } = Serialization.deserializeString(\n            bytes.slice(offset),\n          );\n          deserializedCommand[name] = string;\n          offset += byteLength;\n        }\n        break;\n    }\n  }\n  return deserializedCommand as unknown as PeerCommand;\n}\n\nfunction getDataTypeFromByte(byte: number): Serialization.SerializedItem {\n  const typeCode: Serialization.SerializedItem = byte >> 4;\n  if (\n    typeCode <= Serialization.SerializedItem.Min ||\n    typeCode >= Serialization.SerializedItem.Max\n  ) {\n    throw new Error(\"Not existing type\");\n  }\n\n  return typeCode;\n}\n\nfunction stringToUtf8CodesBuffer(string: string, length?: number): Uint8Array {\n  if (length && string.length !== length) {\n    throw new Error(\"Wrong string length\");\n  }\n  const buffer = new Uint8Array(length ?? string.length);\n  for (let i = 0; i < string.length; i++) buffer[i] = string.charCodeAt(i);\n  return buffer;\n}\n\nfunction* splitBufferToEqualChunks(\n  buffer: Uint8Array,\n  chunksCount: number,\n): Generator<[number, Uint8Array], void> {\n  const chunkLength = Math.ceil(buffer.length / chunksCount);\n  for (let i = 0; i < chunksCount; i++) {\n    yield [i, buffer.slice(i * chunkLength, (i + 1) * chunkLength)];\n  }\n}\n\nfunction frameBuffer(\n  buffer: Uint8Array,\n  frameStart: Uint8Array,\n  frameEnd: Uint8Array,\n) {\n  const result = new Uint8Array(\n    buffer.length + frameStart.length + frameEnd.length,\n  );\n  result.set(frameStart);\n  result.set(buffer, frameStart.length);\n  result.set(frameEnd, frameStart.length + buffer.length);\n\n  return result;\n}\n\nfunction areBuffersEqual(\n  buffer1: Uint8Array,\n  buffer2: Uint8Array,\n  length: number,\n) {\n  for (let i = 0; i < length; i++) {\n    if (buffer1[i] !== buffer2[i]) return false;\n  }\n  return true;\n}\n","import { BinaryCommandCreator } from \"./binary-command-creator.js\";\nimport {\n  PeerSegmentCommand,\n  PeerSendSegmentCommand,\n  PeerSegmentAnnouncementCommand,\n  PeerRequestSegmentCommand,\n  PeerCommand,\n  PeerCommandType,\n} from \"./types.js\";\n\nfunction serializeSegmentAnnouncementCommand(\n  command: PeerSegmentAnnouncementCommand,\n  maxChunkSize: number,\n) {\n  const { c: commandCode, p: loadingByHttp, l: loaded } = command;\n  const creator = new BinaryCommandCreator(commandCode, maxChunkSize);\n  if (loaded?.length) creator.addSimilarIntArr(\"l\", loaded);\n  if (loadingByHttp?.length) {\n    creator.addSimilarIntArr(\"p\", loadingByHttp);\n  }\n  creator.complete();\n  return creator.getResultBuffers();\n}\n\nfunction serializePeerSegmentCommand(\n  command: PeerSegmentCommand,\n  maxChunkSize: number,\n) {\n  const creator = new BinaryCommandCreator(command.c, maxChunkSize);\n  creator.addInteger(\"i\", command.i);\n  creator.addInteger(\"r\", command.r);\n  creator.complete();\n  return creator.getResultBuffers();\n}\n\nfunction serializePeerSendSegmentCommand(\n  command: PeerSendSegmentCommand,\n  maxChunkSize: number,\n) {\n  const creator = new BinaryCommandCreator(command.c, maxChunkSize);\n  creator.addInteger(\"i\", command.i);\n  creator.addInteger(\"s\", command.s);\n  creator.addInteger(\"r\", command.r);\n  creator.complete();\n  return creator.getResultBuffers();\n}\n\nfunction serializePeerSegmentRequestCommand(\n  command: PeerRequestSegmentCommand,\n  maxChunkSize: number,\n) {\n  const creator = new BinaryCommandCreator(command.c, maxChunkSize);\n  creator.addInteger(\"i\", command.i);\n  creator.addInteger(\"r\", command.r);\n  if (command.b) creator.addInteger(\"b\", command.b);\n  creator.complete();\n  return creator.getResultBuffers();\n}\n\nexport function serializePeerCommand(\n  command: PeerCommand,\n  maxChunkSize: number,\n) {\n  switch (command.c) {\n    case PeerCommandType.CancelSegmentRequest:\n    case PeerCommandType.SegmentAbsent:\n    case PeerCommandType.SegmentDataSendingCompleted:\n      return serializePeerSegmentCommand(command, maxChunkSize);\n    case PeerCommandType.SegmentRequest:\n      return serializePeerSegmentRequestCommand(command, maxChunkSize);\n    case PeerCommandType.SegmentsAnnouncement:\n      return serializeSegmentAnnouncementCommand(command, maxChunkSize);\n    case PeerCommandType.SegmentData:\n      return serializePeerSendSegmentCommand(command, maxChunkSize);\n  }\n}\n","import { PeerConnection } from \"bittorrent-tracker\";\nimport { CoreEventMap, StreamConfig } from \"../types.js\";\nimport * as Utils from \"../utils/utils.js\";\nimport * as Command from \"./commands/index.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\n\nexport type PeerConfig = Pick<\n  StreamConfig,\n  | \"p2pNotReceivingBytesTimeoutMs\"\n  | \"webRtcMaxMessageSize\"\n  | \"p2pErrorRetries\"\n  | \"validateP2PSegment\"\n>;\n\nexport class PeerProtocol {\n  private commandChunks?: Command.BinaryCommandChunksJoiner;\n  private uploadingContext?: { stopUploading: () => void; requestId: number };\n  private readonly onChunkDownloaded: CoreEventMap[\"onChunkDownloaded\"];\n  private readonly onChunkUploaded: CoreEventMap[\"onChunkUploaded\"];\n\n  constructor(\n    private readonly connection: PeerConnection,\n    private readonly peerConfig: PeerConfig,\n    private readonly eventHandlers: {\n      onCommandReceived: (command: Command.PeerCommand) => void;\n      onSegmentChunkReceived: (data: Uint8Array) => void;\n    },\n    eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    this.onChunkDownloaded =\n      eventTarget.getEventDispatcher(\"onChunkDownloaded\");\n    this.onChunkUploaded = eventTarget.getEventDispatcher(\"onChunkUploaded\");\n    connection.on(\"data\", this.onDataReceived);\n  }\n\n  private onDataReceived = (data: Uint8Array) => {\n    if (Command.isCommandChunk(data)) {\n      this.receivingCommandBytes(data);\n    } else {\n      this.eventHandlers.onSegmentChunkReceived(data);\n\n      this.onChunkDownloaded(data.byteLength, \"p2p\", this.connection.idUtf8);\n    }\n  };\n\n  sendCommand(command: Command.PeerCommand) {\n    const binaryCommandBuffers = Command.serializePeerCommand(\n      command,\n      this.peerConfig.webRtcMaxMessageSize,\n    );\n    for (const buffer of binaryCommandBuffers) {\n      this.connection.write(buffer);\n    }\n  }\n\n  stopUploadingSegmentData() {\n    this.uploadingContext?.stopUploading();\n    this.uploadingContext = undefined;\n  }\n\n  getUploadingRequestId() {\n    return this.uploadingContext?.requestId;\n  }\n\n  async splitSegmentDataToChunksAndUploadAsync(\n    data: ArrayBuffer,\n    requestId: number,\n  ) {\n    if (this.uploadingContext) {\n      throw new Error(`Some segment data is already uploading.`);\n    }\n    const chunks = getBufferChunks(data, this.peerConfig.webRtcMaxMessageSize);\n    const { promise, resolve, reject } = Utils.getControlledPromise();\n\n    let isUploadingSegmentData = false;\n\n    const uploadingContext = {\n      stopUploading: () => {\n        isUploadingSegmentData = false;\n      },\n      requestId,\n    };\n\n    this.uploadingContext = uploadingContext;\n\n    const sendChunk = () => {\n      if (!isUploadingSegmentData) {\n        reject();\n        return;\n      }\n\n      while (true) {\n        const chunk = chunks.next().value;\n\n        if (!chunk) {\n          resolve();\n          break;\n        }\n\n        const drained = this.connection.write(chunk);\n        this.onChunkUploaded(chunk.byteLength, this.connection.idUtf8);\n        if (!drained) break;\n      }\n    };\n\n    try {\n      this.connection.on(\"drain\", sendChunk);\n      isUploadingSegmentData = true;\n      sendChunk();\n      await promise;\n    } finally {\n      this.connection.off(\"drain\", sendChunk);\n\n      if (this.uploadingContext === uploadingContext) {\n        this.uploadingContext = undefined;\n      }\n    }\n  }\n\n  private receivingCommandBytes(buffer: Uint8Array) {\n    this.commandChunks ??= new Command.BinaryCommandChunksJoiner(\n      (commandBuffer) => {\n        this.commandChunks = undefined;\n        const command = Command.deserializeCommand(commandBuffer);\n        this.eventHandlers.onCommandReceived(command);\n      },\n    );\n    try {\n      this.commandChunks.addCommandChunk(buffer);\n    } catch (err) {\n      if (!(err instanceof Command.BinaryCommandJoiningError)) return;\n      this.commandChunks = undefined;\n    }\n  }\n}\n\nfunction* getBufferChunks(\n  data: ArrayBuffer,\n  maxChunkSize: number,\n): Generator<ArrayBuffer, void> {\n  let bytesLeft = data.byteLength;\n  while (bytesLeft > 0) {\n    const bytesToSend = bytesLeft >= maxChunkSize ? maxChunkSize : bytesLeft;\n    const from = data.byteLength - bytesLeft;\n    const buffer = data.slice(from, from + bytesToSend);\n    bytesLeft -= bytesToSend;\n    yield buffer;\n  }\n}\n","import { PeerConnection } from \"bittorrent-tracker\";\nimport debug from \"debug\";\nimport { Request, RequestControls } from \"../requests/request.js\";\nimport {\n  CoreEventMap,\n  PeerRequestErrorType,\n  RequestError,\n  RequestAbortErrorType,\n  SegmentWithStream,\n  StreamType,\n} from \"../types.js\";\nimport * as Utils from \"../utils/utils.js\";\nimport * as Command from \"./commands/index.js\";\nimport { PeerProtocol, PeerConfig } from \"./peer-protocol.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\n\nconst { PeerCommandType } = Command;\ntype PeerEventHandlers = {\n  onPeerClosed: (peer: Peer) => void;\n  onSegmentRequested: (\n    peer: Peer,\n    segmentId: number,\n    requestId: number,\n    byteFrom?: number,\n  ) => void;\n  onSegmentsAnnouncement: () => void;\n};\n\nexport class Peer {\n  readonly id: string;\n  private readonly peerProtocol;\n  private downloadingContext?: {\n    request: Request;\n    controls: RequestControls;\n    isSegmentDataCommandReceived: boolean;\n    requestId: number;\n  };\n  private loadedSegments = new Set<number>();\n  private httpLoadingSegments = new Set<number>();\n  private downloadingErrors: RequestError<\n    PeerRequestErrorType | RequestAbortErrorType\n  >[] = [];\n  private logger = debug(\"p2pml-core:peer\");\n  private readonly onPeerClosed: CoreEventMap[\"onPeerClose\"];\n\n  constructor(\n    private readonly connection: PeerConnection,\n    private readonly eventHandlers: PeerEventHandlers,\n    private readonly peerConfig: PeerConfig,\n    private readonly streamType: StreamType,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    this.onPeerClosed = eventTarget.getEventDispatcher(\"onPeerClose\");\n\n    this.id = Peer.getPeerIdFromConnection(connection);\n    this.peerProtocol = new PeerProtocol(\n      connection,\n      peerConfig,\n      {\n        onSegmentChunkReceived: this.onSegmentChunkReceived,\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        onCommandReceived: this.onCommandReceived,\n      },\n      eventTarget,\n    );\n    eventTarget.getEventDispatcher(\"onPeerConnect\")({\n      peerId: this.id,\n      streamType,\n    });\n\n    connection.on(\"error\", this.onConnectionError);\n    connection.on(\"close\", this.onPeerConnectionClosed);\n    connection.on(\"end\", this.onPeerConnectionClosed);\n    connection.on(\"finish\", this.onPeerConnectionClosed);\n  }\n\n  get downloadingSegment(): SegmentWithStream | undefined {\n    return this.downloadingContext?.request.segment;\n  }\n\n  getSegmentStatus(\n    segment: SegmentWithStream,\n  ): \"loaded\" | \"http-loading\" | undefined {\n    const { externalId } = segment;\n    if (this.loadedSegments.has(externalId)) return \"loaded\";\n    if (this.httpLoadingSegments.has(externalId)) return \"http-loading\";\n  }\n\n  private onCommandReceived = async (command: Command.PeerCommand) => {\n    switch (command.c) {\n      case PeerCommandType.SegmentsAnnouncement:\n        this.loadedSegments = new Set(command.l);\n        this.httpLoadingSegments = new Set(command.p);\n        this.eventHandlers.onSegmentsAnnouncement();\n        break;\n\n      case PeerCommandType.SegmentRequest:\n        this.peerProtocol.stopUploadingSegmentData();\n        this.eventHandlers.onSegmentRequested(\n          this,\n          command.i,\n          command.r,\n          command.b,\n        );\n        break;\n\n      case PeerCommandType.SegmentData:\n        {\n          if (!this.downloadingContext) break;\n          if (this.downloadingContext.isSegmentDataCommandReceived) break;\n\n          const { request, controls, requestId } = this.downloadingContext;\n          if (\n            request.segment.externalId !== command.i ||\n            requestId !== command.r\n          ) {\n            break;\n          }\n\n          this.downloadingContext.isSegmentDataCommandReceived = true;\n          controls.firstBytesReceived();\n\n          if (request.totalBytes === undefined) {\n            request.setTotalBytes(command.s);\n          } else if (request.totalBytes - request.loadedBytes !== command.s) {\n            request.clearLoadedBytes();\n            this.sendCancelSegmentRequestCommand(request.segment, requestId);\n            this.cancelSegmentDownloading(\n              \"peer-response-bytes-length-mismatch\",\n            );\n            this.destroy();\n          }\n        }\n        break;\n\n      case PeerCommandType.SegmentDataSendingCompleted: {\n        const { downloadingContext } = this;\n\n        if (!downloadingContext?.isSegmentDataCommandReceived) return;\n\n        const { request, controls } = downloadingContext;\n\n        const isWrongSegment =\n          downloadingContext.request.segment.externalId !== command.i ||\n          downloadingContext.requestId !== command.r;\n\n        if (isWrongSegment) {\n          request.clearLoadedBytes();\n          this.cancelSegmentDownloading(\"peer-protocol-violation\");\n          this.destroy();\n          return;\n        }\n\n        const isWrongBytes = request.loadedBytes !== request.totalBytes;\n\n        if (isWrongBytes) {\n          request.clearLoadedBytes();\n          this.cancelSegmentDownloading(\"peer-response-bytes-length-mismatch\");\n          this.destroy();\n          return;\n        }\n\n        const isValid =\n          (await this.peerConfig.validateP2PSegment?.(\n            request.segment.url,\n            request.segment.byteRange,\n            request.data,\n          )) ?? true;\n\n        if (this.downloadingContext !== downloadingContext) return;\n\n        if (!isValid) {\n          request.clearLoadedBytes();\n          this.cancelSegmentDownloading(\"p2p-segment-validation-failed\");\n          this.destroy();\n          return;\n        }\n\n        this.downloadingErrors = [];\n        controls.completeOnSuccess();\n        this.downloadingContext = undefined;\n        break;\n      }\n\n      case PeerCommandType.SegmentAbsent:\n        if (\n          this.downloadingContext?.request.segment.externalId === command.i &&\n          this.downloadingContext.requestId === command.r\n        ) {\n          this.cancelSegmentDownloading(\"peer-segment-absent\");\n          this.loadedSegments.delete(command.i);\n        }\n        break;\n\n      case PeerCommandType.CancelSegmentRequest: {\n        const uploadingRequestId = this.peerProtocol.getUploadingRequestId();\n\n        if (uploadingRequestId !== command.r) break;\n\n        this.peerProtocol.stopUploadingSegmentData();\n        break;\n      }\n    }\n  };\n\n  protected onSegmentChunkReceived = (chunk: Uint8Array) => {\n    if (!this.downloadingContext?.isSegmentDataCommandReceived) return;\n\n    const { request, controls } = this.downloadingContext;\n\n    const isOverflow =\n      request.totalBytes !== undefined &&\n      request.loadedBytes + chunk.byteLength > request.totalBytes;\n\n    if (isOverflow) {\n      request.clearLoadedBytes();\n      this.cancelSegmentDownloading(\"peer-response-bytes-length-mismatch\");\n      this.destroy();\n      return;\n    }\n\n    controls.addLoadedChunk(chunk);\n  };\n\n  downloadSegment(segmentRequest: Request) {\n    if (this.downloadingContext) {\n      throw new Error(\"Some segment already is downloading\");\n    }\n    this.downloadingContext = {\n      request: segmentRequest,\n      requestId: Math.floor(Math.random() * 1000),\n      isSegmentDataCommandReceived: false,\n      controls: segmentRequest.start(\n        { downloadSource: \"p2p\", peerId: this.id },\n        {\n          notReceivingBytesTimeoutMs:\n            this.peerConfig.p2pNotReceivingBytesTimeoutMs,\n          abort: (error) => {\n            if (!this.downloadingContext) return;\n            const { request, requestId } = this.downloadingContext;\n            this.sendCancelSegmentRequestCommand(request.segment, requestId);\n            this.downloadingErrors.push(error);\n            this.downloadingContext = undefined;\n\n            const timeoutErrors = this.downloadingErrors.filter(\n              (error) => error.type === \"bytes-receiving-timeout\",\n            );\n\n            if (timeoutErrors.length >= this.peerConfig.p2pErrorRetries) {\n              this.destroy();\n            }\n          },\n        },\n      ),\n    };\n    const command: Command.PeerRequestSegmentCommand = {\n      c: PeerCommandType.SegmentRequest,\n      r: this.downloadingContext.requestId,\n      i: segmentRequest.segment.externalId,\n    };\n    if (segmentRequest.loadedBytes) command.b = segmentRequest.loadedBytes;\n    this.peerProtocol.sendCommand(command);\n  }\n\n  async uploadSegmentData(\n    segment: SegmentWithStream,\n    requestId: number,\n    data: ArrayBuffer,\n  ) {\n    const { externalId } = segment;\n    this.logger(`send segment ${segment.externalId} to ${this.id}`);\n    const command: Command.PeerSendSegmentCommand = {\n      c: PeerCommandType.SegmentData,\n      i: externalId,\n      r: requestId,\n      s: data.byteLength,\n    };\n    this.peerProtocol.sendCommand(command);\n    try {\n      await this.peerProtocol.splitSegmentDataToChunksAndUploadAsync(\n        data,\n        requestId,\n      );\n      this.sendSegmentDataSendingCompletedCommand(segment, requestId);\n      this.logger(`segment ${externalId} has been sent to ${this.id}`);\n    } catch {\n      this.logger(`cancel segment uploading ${externalId}`);\n    }\n  }\n\n  private cancelSegmentDownloading(type: PeerRequestErrorType) {\n    if (!this.downloadingContext) return;\n    const { request, controls } = this.downloadingContext;\n    const { segment } = request;\n    this.logger(`cancel segment request ${segment.externalId} (${type})`);\n    const error = new RequestError(type);\n    controls.abortOnError(error);\n    this.downloadingContext = undefined;\n    this.downloadingErrors.push(error);\n  }\n\n  sendSegmentsAnnouncementCommand(\n    loadedSegmentsIds: number[],\n    httpLoadingSegmentsIds: number[],\n  ) {\n    const command: Command.PeerSegmentAnnouncementCommand = {\n      c: PeerCommandType.SegmentsAnnouncement,\n      p: httpLoadingSegmentsIds,\n      l: loadedSegmentsIds,\n    };\n    this.peerProtocol.sendCommand(command);\n  }\n\n  sendSegmentAbsentCommand(segmentExternalId: number, requestId: number) {\n    this.peerProtocol.sendCommand({\n      c: PeerCommandType.SegmentAbsent,\n      i: segmentExternalId,\n      r: requestId,\n    });\n  }\n\n  private sendCancelSegmentRequestCommand(\n    segment: SegmentWithStream,\n    requestId: number,\n  ) {\n    this.peerProtocol.sendCommand({\n      c: PeerCommandType.CancelSegmentRequest,\n      i: segment.externalId,\n      r: requestId,\n    });\n  }\n\n  private sendSegmentDataSendingCompletedCommand(\n    segment: SegmentWithStream,\n    requestId: number,\n  ) {\n    this.peerProtocol.sendCommand({\n      c: PeerCommandType.SegmentDataSendingCompleted,\n      r: requestId,\n      i: segment.externalId,\n    });\n  }\n\n  private onPeerConnectionClosed = () => {\n    this.destroy();\n  };\n\n  private onConnectionError = (error: Error) => {\n    this.logger(`peer connection error ${this.id} %O`, error);\n    this.eventTarget.getEventDispatcher(\"onPeerError\")({\n      peerId: this.id,\n      streamType: this.streamType,\n      error,\n    });\n\n    const { code } = error as { code?: string };\n\n    if (code === \"ERR_DATA_CHANNEL\") {\n      this.destroy();\n    } else if (code === \"ERR_CONNECTION_FAILURE\") {\n      this.destroy();\n    }\n  };\n\n  destroy = () => {\n    this.cancelSegmentDownloading(\"peer-closed\");\n    this.connection.destroy();\n    this.eventHandlers.onPeerClosed(this);\n    this.onPeerClosed({\n      peerId: this.id,\n      streamType: this.streamType,\n    });\n    this.logger(`peer closed ${this.id}`);\n  };\n\n  static getPeerIdFromConnection(connection: PeerConnection) {\n    return Utils.hexToUtf8(connection.id);\n  }\n}\n","import TrackerClient, {\n  PeerConnection,\n  TrackerClientEvents,\n} from \"bittorrent-tracker\";\nimport { CoreEventMap, StreamConfig, StreamWithSegments } from \"../types.js\";\nimport debug from \"debug\";\nimport * as PeerUtil from \"../utils/peer.js\";\nimport * as LoggerUtils from \"../utils/logger.js\";\nimport { Peer } from \"./peer.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\nimport { utf8ToUintArray } from \"../utils/utils.js\";\n\ntype PeerItem = {\n  peer?: Peer;\n  potentialConnections: Set<PeerConnection>;\n};\n\ntype P2PTrackerClientEventHandlers = {\n  onPeerConnected: (peer: Peer) => void;\n  onSegmentRequested: (\n    peer: Peer,\n    segmentExternalId: number,\n    requestId: number,\n    bytesFrom?: number,\n  ) => void;\n  onSegmentsAnnouncement: () => void;\n};\n\nfunction isSafariOrWkWebview() {\n  const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n  const isWkWebview =\n    /\\b(iPad|iPhone|Macintosh).*AppleWebKit(?!.*Safari)/i.test(\n      navigator.userAgent,\n    );\n\n  return isSafari || isWkWebview;\n}\n\nexport class P2PTrackerClient {\n  private static readonly PEER_ID_BY_INFO_HASH = new Map<string, string>();\n\n  private readonly streamShortId: string;\n  private readonly client: TrackerClient;\n  private readonly _peers = new Map<string, PeerItem>();\n  private readonly logger = debug(\"p2pml-core:p2p-tracker-client\");\n\n  constructor(\n    streamSwarmId: string,\n    private readonly stream: StreamWithSegments,\n    private readonly eventHandlers: P2PTrackerClientEventHandlers,\n    private readonly config: StreamConfig,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    const streamHash = PeerUtil.getStreamHash(streamSwarmId);\n    this.streamShortId = LoggerUtils.getStreamString(stream);\n\n    let peerId = P2PTrackerClient.PEER_ID_BY_INFO_HASH.get(streamHash);\n    if (!peerId) {\n      peerId = PeerUtil.generatePeerId(config.trackerClientVersionPrefix);\n      P2PTrackerClient.PEER_ID_BY_INFO_HASH.set(streamHash, peerId);\n    }\n\n    this.client = new TrackerClient({\n      infoHash: utf8ToUintArray(streamHash),\n      peerId: utf8ToUintArray(peerId),\n      announce: isSafariOrWkWebview()\n        ? config.announceTrackers.slice(0, 1) // Safari has issues with multiple trackers\n        : config.announceTrackers,\n      rtcConfig: this.config.rtcConfig,\n    });\n    this.client.on(\"peer\", this.onReceivePeerConnection);\n    this.client.on(\"warning\", this.onTrackerClientWarning);\n    this.client.on(\"error\", this.onTrackerClientError);\n    this.logger(\n      `create new client; \\nstream: ${this.streamShortId}; hash: ${streamHash}\\npeerId: ${peerId}`,\n    );\n  }\n\n  start() {\n    this.client.start();\n  }\n\n  destroy() {\n    this.client.destroy();\n\n    for (const { peer, potentialConnections } of this._peers.values()) {\n      peer?.destroy();\n      for (const connection of potentialConnections) {\n        connection.destroy();\n      }\n    }\n\n    this._peers.clear();\n    this.logger(\"destroy client; stream:\", this.streamShortId);\n  }\n\n  private onReceivePeerConnection: TrackerClientEvents[\"peer\"] = (\n    peerConnection,\n  ) => {\n    const itemId = Peer.getPeerIdFromConnection(peerConnection);\n    let peerItem = this._peers.get(itemId);\n\n    if (peerItem?.peer) {\n      peerConnection.destroy();\n      return;\n    }\n\n    if (!peerItem) {\n      peerItem = { potentialConnections: new Set() };\n      peerConnection.idUtf8 = itemId;\n      this._peers.set(itemId, peerItem);\n    }\n\n    peerItem.potentialConnections.add(peerConnection);\n\n    peerConnection.on(\"connect\", () => {\n      if (peerItem.peer) return;\n\n      for (const connection of peerItem.potentialConnections) {\n        if (connection !== peerConnection) connection.destroy();\n      }\n\n      peerItem.potentialConnections.clear();\n\n      peerItem.peer = new Peer(\n        peerConnection,\n        {\n          onPeerClosed: this.onPeerClosed,\n          onSegmentRequested: this.eventHandlers.onSegmentRequested,\n          onSegmentsAnnouncement: this.eventHandlers.onSegmentsAnnouncement,\n        },\n        this.config,\n        this.stream.type,\n        this.eventTarget,\n      );\n      this.logger(\n        `connected with peer: ${peerItem.peer.id} ${this.streamShortId}`,\n      );\n      this.eventHandlers.onPeerConnected(peerItem.peer);\n    });\n  };\n\n  private onTrackerClientWarning: TrackerClientEvents[\"warning\"] = (\n    warning,\n  ) => {\n    this.logger(\"tracker warning %s:\", this.streamShortId, warning);\n    this.eventTarget.getEventDispatcher(\"onTrackerWarning\")({\n      streamType: this.stream.type,\n      warning,\n    });\n  };\n\n  private onTrackerClientError: TrackerClientEvents[\"error\"] = (error) => {\n    this.logger(\"tracker error in stream %s:\", this.streamShortId, error);\n    this.eventTarget.getEventDispatcher(\"onTrackerError\")({\n      streamType: this.stream.type,\n      error,\n    });\n  };\n\n  *peers() {\n    for (const peerItem of this._peers.values()) {\n      if (peerItem.peer) yield peerItem.peer;\n    }\n  }\n\n  private onPeerClosed = (peer: Peer) => {\n    this.logger(`peer closed: ${peer.id}`);\n    this._peers.delete(peer.id);\n  };\n\n  static clearPeerIdCache() {\n    P2PTrackerClient.PEER_ID_BY_INFO_HASH.clear();\n  }\n}\n","import {\n  SegmentWithStream,\n  Stream,\n  StreamConfig,\n  StreamWithSegments,\n} from \"../types.js\";\nimport { Playback } from \"../internal-types.js\";\nimport { P2PLoader } from \"../p2p/loader.js\";\n\nexport type SegmentPlaybackStatuses = {\n  isHighDemand: boolean;\n  isHttpDownloadable: boolean;\n  isP2PDownloadable: boolean;\n};\n\nexport type PlaybackTimeWindowsConfig = Pick<\n  StreamConfig,\n  \"highDemandTimeWindow\" | \"httpDownloadTimeWindow\" | \"p2pDownloadTimeWindow\"\n>;\n\nconst PEER_PROTOCOL_VERSION = \"v2\";\n\nexport function getStreamSwarmId(\n  swarmId: string,\n  stream: Readonly<Stream>,\n): string {\n  return `${PEER_PROTOCOL_VERSION}-${swarmId}-${getStreamId(stream)}`;\n}\n\nexport function getSegmentFromStreamsMap(\n  streams: Map<string, StreamWithSegments>,\n  segmentRuntimeId: string,\n): SegmentWithStream | undefined {\n  for (const stream of streams.values()) {\n    const segment = stream.segments.get(segmentRuntimeId);\n    if (segment) return segment;\n  }\n}\n\nexport function getSegmentFromStreamByExternalId(\n  stream: StreamWithSegments,\n  segmentExternalId: number,\n): SegmentWithStream | undefined {\n  for (const segment of stream.segments.values()) {\n    if (segment.externalId === segmentExternalId) return segment;\n  }\n}\n\nexport function getStreamId(stream: Stream) {\n  return `${stream.type}-${stream.index}`;\n}\n\nexport function getSegmentAvgDuration(stream: StreamWithSegments) {\n  const { segments } = stream;\n  let sumDuration = 0;\n  const { size } = segments;\n  for (const segment of segments.values()) {\n    const duration = segment.endTime - segment.startTime;\n    sumDuration += duration;\n  }\n\n  return sumDuration / size;\n}\n\nfunction calculateTimeWindows(\n  timeWindowsConfig: PlaybackTimeWindowsConfig,\n  availableMemoryInPercent: number,\n) {\n  const {\n    highDemandTimeWindow,\n    httpDownloadTimeWindow,\n    p2pDownloadTimeWindow,\n  } = timeWindowsConfig;\n\n  const result = {\n    highDemandTimeWindow,\n    httpDownloadTimeWindow,\n    p2pDownloadTimeWindow,\n  };\n\n  if (availableMemoryInPercent <= 5) {\n    result.httpDownloadTimeWindow = 0;\n    result.p2pDownloadTimeWindow = 0;\n  } else if (availableMemoryInPercent <= 10) {\n    result.p2pDownloadTimeWindow = result.httpDownloadTimeWindow;\n  }\n\n  return result;\n}\n\nexport function getSegmentPlaybackStatuses(\n  segment: SegmentWithStream,\n  playback: Playback,\n  timeWindowsConfig: PlaybackTimeWindowsConfig,\n  currentP2PLoader: P2PLoader,\n  availableMemoryPercent: number,\n): SegmentPlaybackStatuses {\n  const {\n    highDemandTimeWindow,\n    httpDownloadTimeWindow,\n    p2pDownloadTimeWindow,\n  } = calculateTimeWindows(timeWindowsConfig, availableMemoryPercent);\n\n  return {\n    isHighDemand: isSegmentInTimeWindow(\n      segment,\n      playback,\n      highDemandTimeWindow,\n    ),\n    isHttpDownloadable: isSegmentInTimeWindow(\n      segment,\n      playback,\n      httpDownloadTimeWindow,\n    ),\n    isP2PDownloadable:\n      isSegmentInTimeWindow(segment, playback, p2pDownloadTimeWindow) &&\n      currentP2PLoader.isSegmentLoadingOrLoadedBySomeone(segment),\n  };\n}\n\nfunction isSegmentInTimeWindow(\n  segment: SegmentWithStream,\n  playback: Playback,\n  timeWindowLength: number,\n) {\n  const { startTime, endTime } = segment;\n  const { position, rate } = playback;\n  const rightMargin = position + timeWindowLength * rate;\n  return !(rightMargin < startTime || position > endTime);\n}\n","import { Peer } from \"./peer.js\";\nimport {\n  CoreEventMap,\n  SegmentWithStream,\n  StreamConfig,\n  StreamWithSegments,\n} from \"../types.js\";\nimport { RequestsContainer } from \"../requests/request-container.js\";\nimport { P2PTrackerClient } from \"./tracker-client.js\";\nimport * as StreamUtils from \"../utils/stream.js\";\nimport * as Utils from \"../utils/utils.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\nimport { SegmentStorage } from \"../segment-storage/index.js\";\n\nexport type EventTargetMap = Record<`onStorageUpdated-${string}`, () => void> &\n  CoreEventMap;\n\nexport class P2PLoader {\n  private readonly trackerClient: P2PTrackerClient;\n  private isAnnounceMicrotaskCreated = false;\n\n  constructor(\n    private streamManifestUrl: string,\n    private readonly stream: StreamWithSegments,\n    private readonly requests: RequestsContainer,\n    private readonly segmentStorage: SegmentStorage,\n    private readonly config: StreamConfig,\n    private readonly eventTarget: EventTarget<EventTargetMap>,\n    private readonly onSegmentAnnouncement: () => void,\n  ) {\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, this.stream);\n\n    this.trackerClient = new P2PTrackerClient(\n      streamSwarmId,\n      this.stream,\n      {\n        onPeerConnected: this.onPeerConnected,\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        onSegmentRequested: this.onSegmentRequested,\n        onSegmentsAnnouncement: this.onSegmentAnnouncement,\n      },\n      this.config,\n      this.eventTarget,\n    );\n\n    this.eventTarget.addEventListener(\n      `onStorageUpdated-${streamSwarmId}`,\n      this.broadcastAnnouncement,\n    );\n    this.segmentStorage.setSegmentChangeCallback((streamId: string) => {\n      this.eventTarget.dispatchEvent(`onStorageUpdated-${streamId}`);\n    });\n\n    this.trackerClient.start();\n  }\n\n  downloadSegment(segment: SegmentWithStream) {\n    const peersWithSegment: Peer[] = [];\n    for (const peer of this.trackerClient.peers()) {\n      if (\n        !peer.downloadingSegment &&\n        peer.getSegmentStatus(segment) === \"loaded\"\n      ) {\n        peersWithSegment.push(peer);\n      }\n    }\n\n    if (peersWithSegment.length === 0) return;\n    const peer = Utils.getRandomItem(peersWithSegment);\n\n    const request = this.requests.getOrCreateRequest(segment);\n    peer.downloadSegment(request);\n  }\n\n  isSegmentLoadingOrLoadedBySomeone(segment: SegmentWithStream): boolean {\n    for (const peer of this.trackerClient.peers()) {\n      if (peer.getSegmentStatus(segment)) return true;\n    }\n    return false;\n  }\n\n  isSegmentLoadedBySomeone(segment: SegmentWithStream): boolean {\n    for (const peer of this.trackerClient.peers()) {\n      if (peer.getSegmentStatus(segment) === \"loaded\") return true;\n    }\n    return false;\n  }\n\n  get connectedPeerCount() {\n    let count = 0;\n    const iterator = this.trackerClient.peers();\n    while (!iterator.next().done) count++;\n    return count;\n  }\n\n  private getSegmentsAnnouncement() {\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, this.stream);\n\n    const loaded: number[] = this.segmentStorage.getStoredSegmentIds(\n      swarmId,\n      streamSwarmId,\n    );\n    const httpLoading: number[] = [];\n\n    for (const request of this.requests.httpRequests()) {\n      const segment = this.stream.segments.get(request.segment.runtimeId);\n      if (!segment) continue;\n\n      httpLoading.push(segment.externalId);\n    }\n    return { loaded, httpLoading };\n  }\n\n  private onPeerConnected = (peer: Peer) => {\n    if (this.config.isP2PUploadDisabled) return;\n\n    const { httpLoading, loaded } = this.getSegmentsAnnouncement();\n    peer.sendSegmentsAnnouncementCommand(loaded, httpLoading);\n  };\n\n  broadcastAnnouncement = (sendEmptyAnnouncement = false) => {\n    if (sendEmptyAnnouncement) {\n      this.sendSegmentsAnnouncement([], []);\n      return;\n    }\n\n    if (this.isAnnounceMicrotaskCreated || this.config.isP2PUploadDisabled) {\n      return;\n    }\n\n    const { loaded, httpLoading } = this.getSegmentsAnnouncement();\n    this.sendSegmentsAnnouncement(loaded, httpLoading);\n  };\n\n  private sendSegmentsAnnouncement = (\n    loaded: number[],\n    httpLoading: number[],\n  ) => {\n    this.isAnnounceMicrotaskCreated = true;\n\n    queueMicrotask(() => {\n      for (const peer of this.trackerClient.peers()) {\n        peer.sendSegmentsAnnouncementCommand(loaded, httpLoading);\n      }\n      this.isAnnounceMicrotaskCreated = false;\n    });\n  };\n\n  private onSegmentRequested = async (\n    peer: Peer,\n    segmentExternalId: number,\n    requestId: number,\n    byteFrom?: number,\n  ) => {\n    const segment = StreamUtils.getSegmentFromStreamByExternalId(\n      this.stream,\n      segmentExternalId,\n    );\n    if (!segment) return;\n    if (this.config.isP2PUploadDisabled) {\n      peer.sendSegmentAbsentCommand(segmentExternalId, requestId);\n      return;\n    }\n\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, this.stream);\n\n    const segmentData = await this.segmentStorage.getSegmentData(\n      swarmId,\n      streamSwarmId,\n      segment.externalId,\n    );\n    if (!segmentData) {\n      peer.sendSegmentAbsentCommand(segmentExternalId, requestId);\n      return;\n    }\n    await peer.uploadSegmentData(\n      segment,\n      requestId,\n      byteFrom !== undefined ? segmentData.slice(byteFrom) : segmentData,\n    );\n  };\n\n  destroy() {\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, this.stream);\n\n    this.eventTarget.removeEventListener(\n      `onStorageUpdated-${streamSwarmId}`,\n      this.broadcastAnnouncement,\n    );\n    this.trackerClient.destroy();\n  }\n}\n","import { P2PLoader } from \"./loader.js\";\nimport debug from \"debug\";\nimport {\n  CoreEventMap,\n  Stream,\n  StreamConfig,\n  StreamWithSegments,\n  SegmentStorage,\n} from \"../index.js\";\nimport { RequestsContainer } from \"../requests/request-container.js\";\nimport * as LoggerUtils from \"../utils/logger.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\nimport * as StreamUtils from \"../utils/stream.js\";\n\ntype P2PLoaderContainerItem = {\n  stream: Stream;\n  loader: P2PLoader;\n  destroyTimeoutId?: number;\n  loggerInfo: string;\n};\n\nexport class P2PLoadersContainer {\n  private readonly loaders = new Map<string, P2PLoaderContainerItem>();\n  private _currentLoaderItem: P2PLoaderContainerItem;\n  private readonly logger = debug(\"p2pml-core:p2p-loaders-container\");\n\n  constructor(\n    private readonly streamManifestUrl: string,\n    stream: StreamWithSegments,\n    private readonly requests: RequestsContainer,\n    private readonly segmentStorage: SegmentStorage,\n    private readonly config: StreamConfig,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n    private onSegmentAnnouncement: () => void,\n  ) {\n    this._currentLoaderItem = this.findOrCreateLoaderForStream(stream);\n    this.logger(\n      `set current p2p loader: ${LoggerUtils.getStreamString(stream)}`,\n    );\n  }\n\n  private createLoader(stream: StreamWithSegments): P2PLoaderContainerItem {\n    if (this.loaders.has(stream.runtimeId)) {\n      throw new Error(\"Loader for this stream already exists\");\n    }\n    const loader = new P2PLoader(\n      this.streamManifestUrl,\n      stream,\n      this.requests,\n      this.segmentStorage,\n      this.config,\n      this.eventTarget,\n      () => {\n        if (this._currentLoaderItem.loader === loader) {\n          this.onSegmentAnnouncement();\n        }\n      },\n    );\n    const loggerInfo = LoggerUtils.getStreamString(stream);\n    this.logger(`created new loader: ${loggerInfo}`);\n    return {\n      loader,\n      stream,\n      loggerInfo: LoggerUtils.getStreamString(stream),\n    };\n  }\n\n  private findOrCreateLoaderForStream(stream: StreamWithSegments) {\n    const loaderItem = this.loaders.get(stream.runtimeId);\n    if (loaderItem) {\n      clearTimeout(loaderItem.destroyTimeoutId);\n      loaderItem.destroyTimeoutId = undefined;\n      return loaderItem;\n    } else {\n      const loader = this.createLoader(stream);\n      this.loaders.set(stream.runtimeId, loader);\n      return loader;\n    }\n  }\n\n  changeCurrentLoader(stream: StreamWithSegments) {\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(\n      swarmId,\n      this._currentLoaderItem.stream,\n    );\n    const ids = this.segmentStorage.getStoredSegmentIds(swarmId, streamSwarmId);\n    if (!ids.length) this.destroyAndRemoveLoader(this._currentLoaderItem);\n    else this.setLoaderDestroyTimeout(this._currentLoaderItem);\n\n    this._currentLoaderItem = this.findOrCreateLoaderForStream(stream);\n\n    this.logger(\n      `change current p2p loader: ${LoggerUtils.getStreamString(stream)}`,\n    );\n  }\n\n  private setLoaderDestroyTimeout(item: P2PLoaderContainerItem) {\n    item.destroyTimeoutId = window.setTimeout(\n      () => this.destroyAndRemoveLoader(item),\n      this.config.p2pInactiveLoaderDestroyTimeoutMs,\n    );\n  }\n\n  private destroyAndRemoveLoader(item: P2PLoaderContainerItem) {\n    item.loader.destroy();\n    this.loaders.delete(item.stream.runtimeId);\n    this.logger(`destroy p2p loader: `, item.loggerInfo);\n  }\n\n  get currentLoader() {\n    return this._currentLoaderItem.loader;\n  }\n\n  destroy() {\n    for (const { loader, destroyTimeoutId } of this.loaders.values()) {\n      loader.destroy();\n      clearTimeout(destroyTimeoutId);\n    }\n    this.loaders.clear();\n  }\n}\n","import debug from \"debug\";\nimport { BandwidthCalculators, Playback } from \"../internal-types.js\";\nimport {\n  CoreEventMap,\n  RequestError,\n  RequestAbortErrorType,\n  SegmentWithStream,\n  Segment,\n} from \"../types.js\";\nimport * as StreamUtils from \"../utils/stream.js\";\nimport * as Utils from \"../utils/utils.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\n\nexport type LoadProgress = {\n  startTimestamp: number;\n  lastLoadedChunkTimestamp?: number;\n  startFromByte?: number;\n  loadedBytes: number;\n};\n\ntype HttpRequestAttempt = {\n  downloadSource: \"http\";\n  error?: RequestError;\n};\n\ntype P2PRequestAttempt = {\n  downloadSource: \"p2p\";\n  peerId: string;\n  error?: RequestError;\n};\n\nexport type RequestAttempt = HttpRequestAttempt | P2PRequestAttempt;\n\nexport type RequestControls = Readonly<{\n  firstBytesReceived: Request[\"firstBytesReceived\"];\n  addLoadedChunk: Request[\"addLoadedChunk\"];\n  completeOnSuccess: Request[\"completeOnSuccess\"];\n  abortOnError: Request[\"abortOnError\"];\n}>;\n\ntype OmitEncapsulated<T extends RequestAttempt> = Omit<\n  T,\n  \"error\" | \"errorTimestamp\"\n>;\ntype StartRequestParameters =\n  | OmitEncapsulated<HttpRequestAttempt>\n  | OmitEncapsulated<P2PRequestAttempt>;\n\nexport type RequestStatus =\n  | \"not-started\"\n  | \"loading\"\n  | \"succeed\"\n  | \"failed\"\n  | \"aborted\";\n\nfunction mapSegmentWithStreamToSegment(segment: SegmentWithStream): Segment {\n  return {\n    runtimeId: segment.runtimeId,\n    externalId: segment.externalId,\n    url: segment.url,\n    byteRange: segment.byteRange,\n    startTime: segment.startTime,\n    endTime: segment.endTime,\n  };\n}\n\nexport class Request {\n  private currentAttempt?: RequestAttempt;\n  private _failedAttempts = new FailedRequestAttempts();\n  private finalData?: ArrayBuffer;\n  private bytes: Uint8Array[] = [];\n  private _loadedBytes = 0;\n  private _totalBytes?: number;\n  private _status: RequestStatus = \"not-started\";\n  private progress?: LoadProgress;\n  private notReceivingBytesTimeout: Timeout;\n  private _abortRequestCallback?: (\n    error: RequestError<RequestAbortErrorType>,\n  ) => void;\n  private readonly _logger: debug.Debugger;\n  private _isHandledByProcessQueue = false;\n  private readonly onSegmentError: CoreEventMap[\"onSegmentError\"];\n  private readonly onSegmentAbort: CoreEventMap[\"onSegmentAbort\"];\n  private readonly onSegmentStart: CoreEventMap[\"onSegmentStart\"];\n  private readonly onSegmentLoaded: CoreEventMap[\"onSegmentLoaded\"];\n\n  constructor(\n    readonly segment: SegmentWithStream,\n    private readonly requestProcessQueueCallback: () => void,\n    private readonly bandwidthCalculators: BandwidthCalculators,\n    private readonly playback: Playback,\n    private readonly playbackConfig: StreamUtils.PlaybackTimeWindowsConfig,\n    eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    this.onSegmentError = eventTarget.getEventDispatcher(\"onSegmentError\");\n    this.onSegmentAbort = eventTarget.getEventDispatcher(\"onSegmentAbort\");\n    this.onSegmentStart = eventTarget.getEventDispatcher(\"onSegmentStart\");\n    this.onSegmentLoaded = eventTarget.getEventDispatcher(\"onSegmentLoaded\");\n\n    const { byteRange } = this.segment;\n    if (byteRange) {\n      const { end, start } = byteRange;\n      this._totalBytes = end - start + 1;\n    }\n    this.notReceivingBytesTimeout = new Timeout(this.abortOnTimeout);\n\n    const { type } = this.segment.stream;\n    this._logger = debug(`p2pml-core:request-${type}`);\n  }\n\n  clearLoadedBytes() {\n    this._loadedBytes = 0;\n    this.bytes = [];\n    this._totalBytes = undefined;\n    this.finalData = undefined;\n  }\n\n  get status() {\n    return this._status;\n  }\n\n  private setStatus(status: RequestStatus) {\n    this._status = status;\n    this._isHandledByProcessQueue = false;\n  }\n\n  get downloadSource() {\n    return this.currentAttempt?.downloadSource;\n  }\n\n  get loadedBytes() {\n    return this._loadedBytes;\n  }\n\n  get totalBytes(): number | undefined {\n    return this._totalBytes;\n  }\n\n  get data(): ArrayBuffer {\n    this.finalData ??= Utils.joinChunks(this.bytes).buffer;\n    return this.finalData;\n  }\n\n  get failedAttempts() {\n    return this._failedAttempts;\n  }\n\n  get isHandledByProcessQueue() {\n    return this._isHandledByProcessQueue;\n  }\n\n  markHandledByProcessQueue() {\n    this._isHandledByProcessQueue = true;\n  }\n\n  setTotalBytes(value: number) {\n    if (this._totalBytes !== undefined) {\n      throw new Error(\"Request total bytes value is already set\");\n    }\n    this._totalBytes = value;\n  }\n\n  start(\n    requestData: StartRequestParameters,\n    controls: {\n      notReceivingBytesTimeoutMs?: number;\n      abort: (errorType: RequestError<RequestAbortErrorType>) => void;\n    },\n  ): RequestControls {\n    if (this._status === \"succeed\") {\n      throw new Error(\n        `Request ${this.segment.externalId} has been already succeed.`,\n      );\n    }\n    if (this._status === \"loading\") {\n      throw new Error(\n        `Request ${this.segment.externalId} has been already started.`,\n      );\n    }\n\n    this.setStatus(\"loading\");\n    this.currentAttempt = { ...requestData };\n    this.progress = {\n      startFromByte: this._loadedBytes,\n      loadedBytes: 0,\n      startTimestamp: performance.now(),\n    };\n    this.manageBandwidthCalculatorsState(\"start\");\n\n    const { notReceivingBytesTimeoutMs, abort } = controls;\n    this._abortRequestCallback = abort;\n\n    if (notReceivingBytesTimeoutMs !== undefined) {\n      this.notReceivingBytesTimeout.start(notReceivingBytesTimeoutMs);\n    }\n\n    this.logger(\n      `${requestData.downloadSource} ${this.segment.externalId} started`,\n    );\n\n    this.onSegmentStart({\n      segment: mapSegmentWithStreamToSegment(this.segment),\n      downloadSource: requestData.downloadSource,\n      peerId:\n        requestData.downloadSource === \"p2p\" ? requestData.peerId : undefined,\n    });\n\n    return {\n      firstBytesReceived: this.firstBytesReceived,\n      addLoadedChunk: this.addLoadedChunk,\n      completeOnSuccess: this.completeOnSuccess,\n      abortOnError: this.abortOnError,\n    };\n  }\n\n  abortFromProcessQueue() {\n    this.throwErrorIfNotLoadingStatus();\n    this.setStatus(\"aborted\");\n    this.logger(\n      `${this.currentAttempt?.downloadSource} ${this.segment.externalId} aborted`,\n    );\n    this._abortRequestCallback?.(new RequestError(\"abort\"));\n    this.onSegmentAbort({\n      segment: mapSegmentWithStreamToSegment(this.segment),\n      downloadSource: this.currentAttempt?.downloadSource,\n      peerId:\n        this.currentAttempt?.downloadSource === \"p2p\"\n          ? this.currentAttempt.peerId\n          : undefined,\n      streamType: this.segment.stream.type,\n    });\n    this._abortRequestCallback = undefined;\n    this.manageBandwidthCalculatorsState(\"stop\");\n    this.notReceivingBytesTimeout.clear();\n  }\n\n  private abortOnTimeout = () => {\n    this.throwErrorIfNotLoadingStatus();\n    if (!this.currentAttempt) return;\n\n    this.setStatus(\"failed\");\n    const error = new RequestError(\"bytes-receiving-timeout\");\n    this._abortRequestCallback?.(error);\n    this.logger(\n      `${this.downloadSource} ${this.segment.externalId} failed ${error.type}`,\n    );\n    this._failedAttempts.add({\n      ...this.currentAttempt,\n      error,\n    });\n    this.onSegmentError({\n      segment: mapSegmentWithStreamToSegment(this.segment),\n      error,\n      downloadSource: this.currentAttempt.downloadSource,\n      peerId:\n        this.currentAttempt.downloadSource === \"p2p\"\n          ? this.currentAttempt.peerId\n          : undefined,\n      streamType: this.segment.stream.type,\n    });\n    this.notReceivingBytesTimeout.clear();\n    this.manageBandwidthCalculatorsState(\"stop\");\n    this.requestProcessQueueCallback();\n  };\n\n  private abortOnError = (error: RequestError) => {\n    this.throwErrorIfNotLoadingStatus();\n    if (!this.currentAttempt) return;\n\n    this.setStatus(\"failed\");\n    this.logger(\n      `${this.downloadSource} ${this.segment.externalId} failed ${error.type}`,\n    );\n    this._failedAttempts.add({\n      ...this.currentAttempt,\n      error,\n    });\n    this.onSegmentError({\n      segment: mapSegmentWithStreamToSegment(this.segment),\n      error,\n      downloadSource: this.currentAttempt.downloadSource,\n      peerId:\n        this.currentAttempt.downloadSource === \"p2p\"\n          ? this.currentAttempt.peerId\n          : undefined,\n      streamType: this.segment.stream.type,\n    });\n    this.notReceivingBytesTimeout.clear();\n    this.manageBandwidthCalculatorsState(\"stop\");\n    this.requestProcessQueueCallback();\n  };\n\n  private completeOnSuccess = () => {\n    this.throwErrorIfNotLoadingStatus();\n    if (!this.currentAttempt) return;\n\n    this.manageBandwidthCalculatorsState(\"stop\");\n    this.notReceivingBytesTimeout.clear();\n    this.setStatus(\"succeed\");\n    this._totalBytes = this._loadedBytes;\n    this.onSegmentLoaded({\n      segmentUrl: this.segment.url,\n      bytesLength: this.data.byteLength,\n      downloadSource: this.currentAttempt.downloadSource,\n      peerId:\n        this.currentAttempt.downloadSource === \"p2p\"\n          ? this.currentAttempt.peerId\n          : undefined,\n      streamType: this.segment.stream.type,\n    });\n\n    this.logger(\n      `${this.currentAttempt.downloadSource} ${this.segment.externalId} succeed`,\n    );\n    this.requestProcessQueueCallback();\n  };\n\n  private addLoadedChunk = (chunk: Uint8Array) => {\n    this.throwErrorIfNotLoadingStatus();\n    if (!this.currentAttempt || !this.progress) return;\n    this.notReceivingBytesTimeout.restart();\n\n    const { byteLength } = chunk;\n    const { all: allBC, http: httpBC } = this.bandwidthCalculators;\n    allBC.addBytes(byteLength);\n    if (this.currentAttempt.downloadSource === \"http\") {\n      httpBC.addBytes(byteLength);\n    }\n\n    this.bytes.push(chunk);\n    this.progress.lastLoadedChunkTimestamp = performance.now();\n    this.progress.loadedBytes += byteLength;\n    this._loadedBytes += byteLength;\n  };\n\n  private firstBytesReceived = () => {\n    this.throwErrorIfNotLoadingStatus();\n    this.notReceivingBytesTimeout.restart();\n  };\n\n  private throwErrorIfNotLoadingStatus() {\n    if (this._status !== \"loading\") {\n      throw new Error(`Request has been already ${this.status}.`);\n    }\n  }\n\n  private logger(message: string) {\n    this._logger.color =\n      this.currentAttempt?.downloadSource === \"http\" ? \"green\" : \"red\";\n    this._logger(message);\n    this._logger.color = \"\";\n  }\n\n  private manageBandwidthCalculatorsState(state: \"start\" | \"stop\") {\n    const { all, http } = this.bandwidthCalculators;\n    const method = state === \"start\" ? \"startLoading\" : \"stopLoading\";\n    if (this.currentAttempt?.downloadSource === \"http\") http[method]();\n    all[method]();\n  }\n}\n\nclass FailedRequestAttempts {\n  private attempts: Required<RequestAttempt>[] = [];\n\n  add(attempt: Required<RequestAttempt>) {\n    this.attempts.push(attempt);\n  }\n\n  get httpAttemptsCount() {\n    return this.attempts.reduce(\n      (sum, attempt) => (attempt.downloadSource === \"http\" ? sum + 1 : sum),\n      0,\n    );\n  }\n\n  get lastAttempt(): Readonly<Required<RequestAttempt>> | undefined {\n    return this.attempts[this.attempts.length - 1];\n  }\n\n  clear() {\n    this.attempts = [];\n  }\n}\n\nexport class Timeout {\n  private timeoutId?: number;\n  private ms?: number;\n\n  constructor(private readonly action: () => void) {}\n\n  start(ms: number) {\n    if (this.timeoutId) {\n      throw new Error(\"Timeout is already started.\");\n    }\n    this.ms = ms;\n    this.timeoutId = window.setTimeout(this.action, this.ms);\n  }\n\n  restart(ms?: number) {\n    if (this.timeoutId) clearTimeout(this.timeoutId);\n    if (ms) this.ms = ms;\n    if (!this.ms) return;\n    this.timeoutId = window.setTimeout(this.action, this.ms);\n  }\n\n  clear() {\n    clearTimeout(this.timeoutId);\n    this.timeoutId = undefined;\n  }\n}\n","import { Playback, BandwidthCalculators } from \"../internal-types.js\";\nimport { CoreEventMap, SegmentWithStream, StreamConfig } from \"../types.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\nimport { Request } from \"./request.js\";\n\nexport class RequestsContainer {\n  private readonly requests = new Map<SegmentWithStream, Request>();\n\n  constructor(\n    private readonly requestProcessQueueCallback: () => void,\n    private readonly bandwidthCalculators: BandwidthCalculators,\n    private readonly playback: Playback,\n    private readonly config: StreamConfig,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n  ) {}\n\n  get executingHttpCount() {\n    let count = 0;\n    for (const request of this.httpRequests()) {\n      if (request.status === \"loading\") count++;\n    }\n    return count;\n  }\n\n  get executingP2PCount() {\n    let count = 0;\n    for (const request of this.p2pRequests()) {\n      if (request.status === \"loading\") count++;\n    }\n    return count;\n  }\n\n  get(segment: SegmentWithStream) {\n    return this.requests.get(segment);\n  }\n\n  getOrCreateRequest(segment: SegmentWithStream) {\n    let request = this.requests.get(segment);\n    if (!request) {\n      request = new Request(\n        segment,\n        this.requestProcessQueueCallback,\n        this.bandwidthCalculators,\n        this.playback,\n        this.config,\n        this.eventTarget,\n      );\n      this.requests.set(segment, request);\n    }\n    return request;\n  }\n\n  remove(request: Request) {\n    this.requests.delete(request.segment);\n  }\n\n  items() {\n    return this.requests.values();\n  }\n\n  *httpRequests(): Generator<Request, void> {\n    for (const request of this.requests.values()) {\n      if (request.downloadSource === \"http\") yield request;\n    }\n  }\n\n  *p2pRequests(): Generator<Request, void> {\n    for (const request of this.requests.values()) {\n      if (request.downloadSource === \"p2p\") yield request;\n    }\n  }\n\n  destroy() {\n    for (const request of this.requests.values()) {\n      if (request.status !== \"loading\") continue;\n      request.abortFromProcessQueue();\n    }\n    this.requests.clear();\n  }\n}\n","import {\n  CoreRequestError,\n  EngineCallbacks,\n  SegmentWithStream,\n} from \"../types.js\";\n\nexport class EngineRequest {\n  private _status: \"pending\" | \"succeed\" | \"failed\" | \"aborted\" = \"pending\";\n  private _shouldBeStartedImmediately = false;\n\n  constructor(\n    readonly segment: SegmentWithStream,\n    readonly engineCallbacks: EngineCallbacks,\n  ) {}\n\n  get status() {\n    return this._status;\n  }\n\n  get shouldBeStartedImmediately() {\n    return this._shouldBeStartedImmediately;\n  }\n\n  resolve(data: ArrayBuffer, bandwidth: number) {\n    if (this._status !== \"pending\") return;\n    this._status = \"succeed\";\n    this.engineCallbacks.onSuccess({ data, bandwidth });\n  }\n\n  reject() {\n    if (this._status !== \"pending\") return;\n    this._status = \"failed\";\n    this.engineCallbacks.onError(new CoreRequestError(\"failed\"));\n  }\n\n  abort() {\n    if (this._status !== \"pending\") return;\n    this._status = \"aborted\";\n    this.engineCallbacks.onError(new CoreRequestError(\"aborted\"));\n  }\n\n  markAsShouldBeStartedImmediately() {\n    this._shouldBeStartedImmediately = true;\n  }\n}\n","import { Playback } from \"../internal-types.js\";\nimport { P2PLoader } from \"../p2p/loader.js\";\nimport { SegmentWithStream } from \"../types.js\";\nimport {\n  getSegmentPlaybackStatuses,\n  SegmentPlaybackStatuses,\n  PlaybackTimeWindowsConfig,\n} from \"./stream.js\";\n\nexport type QueueItem = {\n  segment: SegmentWithStream;\n  statuses: SegmentPlaybackStatuses;\n};\n\nexport function* generateQueue(\n  lastRequestedSegment: Readonly<SegmentWithStream>,\n  playback: Readonly<Playback>,\n  playbackConfig: PlaybackTimeWindowsConfig,\n  currentP2PLoader: P2PLoader,\n  availablePercentMemory: number,\n): Generator<QueueItem, void> {\n  const { runtimeId, stream } = lastRequestedSegment;\n\n  const requestedSegment = stream.segments.get(runtimeId);\n  if (!requestedSegment) return;\n\n  const queueSegments = stream.segments.values();\n\n  let first: SegmentWithStream;\n\n  do {\n    const next = queueSegments.next();\n    if (next.done) return; // should never happen\n    first = next.value;\n  } while (first !== requestedSegment);\n\n  const firstStatuses = getSegmentPlaybackStatuses(\n    first,\n    playback,\n    playbackConfig,\n    currentP2PLoader,\n    availablePercentMemory,\n  );\n  if (isNotActualStatuses(firstStatuses)) {\n    const next = queueSegments.next();\n\n    // for cases when engine requests segment that is a little bit\n    // earlier than current playhead position\n    // it could happen when playhead position is significantly changed by user\n    if (next.done) return;\n\n    const second = next.value;\n\n    const secondStatuses = getSegmentPlaybackStatuses(\n      second,\n      playback,\n      playbackConfig,\n      currentP2PLoader,\n      availablePercentMemory,\n    );\n\n    if (isNotActualStatuses(secondStatuses)) return;\n    firstStatuses.isHighDemand = true;\n    yield { segment: first, statuses: firstStatuses };\n    yield { segment: second, statuses: secondStatuses };\n  } else {\n    yield { segment: first, statuses: firstStatuses };\n  }\n\n  for (const segment of queueSegments) {\n    const statuses = getSegmentPlaybackStatuses(\n      segment,\n      playback,\n      playbackConfig,\n      currentP2PLoader,\n      availablePercentMemory,\n    );\n    if (isNotActualStatuses(statuses)) break;\n    yield { segment, statuses };\n  }\n}\n\nfunction isNotActualStatuses(statuses: SegmentPlaybackStatuses) {\n  const {\n    isHighDemand = false,\n    isHttpDownloadable = false,\n    isP2PDownloadable = false,\n  } = statuses;\n  return !isHighDemand && !isHttpDownloadable && !isP2PDownloadable;\n}\n","import { HttpRequestExecutor } from \"./http-loader.js\";\nimport {\n  CoreEventMap,\n  EngineCallbacks,\n  SegmentWithStream,\n  StreamConfig,\n  StreamWithSegments,\n} from \"./types.js\";\nimport {\n  Playback,\n  BandwidthCalculators,\n  StreamDetails,\n} from \"./internal-types.js\";\nimport { P2PLoadersContainer } from \"./p2p/loaders-container.js\";\nimport { RequestsContainer } from \"./requests/request-container.js\";\nimport { EngineRequest } from \"./requests/engine-request.js\";\nimport * as QueueUtils from \"./utils/queue.js\";\nimport * as LoggerUtils from \"./utils/logger.js\";\nimport * as StreamUtils from \"./utils/stream.js\";\nimport * as Utils from \"./utils/utils.js\";\nimport debug from \"debug\";\nimport { QueueItem } from \"./utils/queue.js\";\nimport { EventTarget } from \"./utils/event-target.js\";\nimport { SegmentStorage } from \"./segment-storage/index.js\";\n\nconst FAILED_ATTEMPTS_CLEAR_INTERVAL = 60000;\nconst PEER_UPDATE_LATENCY = 1000;\n\nexport class HybridLoader {\n  private readonly requests: RequestsContainer;\n  private engineRequest?: EngineRequest;\n  private readonly p2pLoaders: P2PLoadersContainer;\n  private readonly playback: Playback;\n  private readonly segmentAvgDuration: number;\n  private readonly logger: debug.Debugger;\n  private storageCleanUpIntervalId?: number;\n  private levelChangedTimestamp?: number;\n  private lastQueueProcessingTimeStamp?: number;\n  private randomHttpDownloadInterval?: number;\n  private isProcessQueueMicrotaskCreated = false;\n\n  constructor(\n    private streamManifestUrl: string,\n    private lastRequestedSegment: Readonly<SegmentWithStream>,\n    private readonly streamDetails: Required<Readonly<StreamDetails>>,\n    private readonly config: StreamConfig,\n    private readonly bandwidthCalculators: BandwidthCalculators,\n    private readonly segmentStorage: SegmentStorage,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    const activeStream = this.lastRequestedSegment.stream;\n    this.playback = { position: this.lastRequestedSegment.startTime, rate: 1 };\n    this.segmentAvgDuration = StreamUtils.getSegmentAvgDuration(activeStream);\n    this.requests = new RequestsContainer(\n      this.requestProcessQueueMicrotask,\n      this.bandwidthCalculators,\n      this.playback,\n      this.config,\n      this.eventTarget,\n    );\n\n    this.p2pLoaders = new P2PLoadersContainer(\n      this.streamManifestUrl,\n      this.lastRequestedSegment.stream,\n      this.requests,\n      this.segmentStorage,\n      this.config,\n      this.eventTarget,\n      this.requestProcessQueueMicrotask,\n    );\n\n    this.logger = debug(`p2pml-core:hybrid-loader-${activeStream.type}`);\n    this.logger.color = \"coral\";\n\n    this.setIntervalLoading();\n  }\n\n  private setIntervalLoading() {\n    const peersCount = this.p2pLoaders.currentLoader.connectedPeerCount;\n    const randomTimeout =\n      Math.random() * PEER_UPDATE_LATENCY * peersCount + PEER_UPDATE_LATENCY;\n    this.randomHttpDownloadInterval = window.setTimeout(() => {\n      this.loadRandomThroughHttp();\n      this.setIntervalLoading();\n    }, randomTimeout);\n  }\n\n  // api method for engines\n  async loadSegment(\n    segment: Readonly<SegmentWithStream>,\n    callbacks: EngineCallbacks,\n  ) {\n    this.logger(`requests: ${LoggerUtils.getSegmentString(segment)}`);\n    const { stream } = segment;\n    if (stream !== this.lastRequestedSegment.stream) {\n      this.logger(`stream changed to ${LoggerUtils.getStreamString(stream)}`);\n      this.p2pLoaders.changeCurrentLoader(stream);\n    }\n    this.lastRequestedSegment = segment;\n\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, stream);\n\n    this.segmentStorage.onSegmentRequested(\n      swarmId,\n      streamSwarmId,\n      segment.externalId,\n      segment.startTime,\n      segment.endTime,\n      stream.type,\n      this.streamDetails.isLive,\n    );\n    const engineRequest = new EngineRequest(segment, callbacks);\n\n    try {\n      const hasSegment = this.segmentStorage.hasSegment(\n        swarmId,\n        streamSwarmId,\n        segment.externalId,\n      );\n\n      if (hasSegment) {\n        const data = await this.segmentStorage.getSegmentData(\n          swarmId,\n          streamSwarmId,\n          segment.externalId,\n        );\n        if (data) {\n          const { queueDownloadRatio } = this.generateQueue();\n          engineRequest.resolve(data, this.getBandwidth(queueDownloadRatio));\n          return;\n        }\n      }\n\n      this.engineRequest?.abort();\n      this.engineRequest = engineRequest;\n    } catch {\n      engineRequest.reject();\n    } finally {\n      this.requestProcessQueueMicrotask();\n    }\n  }\n\n  private requestProcessQueueMicrotask = (force = true) => {\n    const now = performance.now();\n    if (\n      (!force &&\n        this.lastQueueProcessingTimeStamp !== undefined &&\n        now - this.lastQueueProcessingTimeStamp <= 1000) ||\n      this.isProcessQueueMicrotaskCreated\n    ) {\n      return;\n    }\n\n    this.isProcessQueueMicrotaskCreated = true;\n    queueMicrotask(() => {\n      try {\n        this.processQueue();\n        this.lastQueueProcessingTimeStamp = now;\n      } finally {\n        this.isProcessQueueMicrotaskCreated = false;\n      }\n    });\n  };\n\n  private processRequests(\n    queueSegmentIds: Set<string>,\n    queueDownloadRatio: number,\n  ) {\n    const { stream } = this.lastRequestedSegment;\n    const { httpErrorRetries } = this.config;\n    const now = performance.now();\n    for (const request of this.requests.items()) {\n      const {\n        downloadSource: type,\n        status,\n        segment,\n        isHandledByProcessQueue,\n      } = request;\n      const engineRequest =\n        this.engineRequest?.segment === segment\n          ? this.engineRequest\n          : undefined;\n\n      switch (status) {\n        case \"loading\":\n          if (!queueSegmentIds.has(segment.runtimeId) && !engineRequest) {\n            request.abortFromProcessQueue();\n            this.requests.remove(request);\n          }\n          break;\n\n        case \"succeed\": {\n          if (!type) break;\n          if (type === \"http\") {\n            this.p2pLoaders.currentLoader.broadcastAnnouncement();\n          }\n          if (engineRequest) {\n            engineRequest.resolve(\n              request.data,\n              this.getBandwidth(queueDownloadRatio),\n            );\n            this.engineRequest = undefined;\n          }\n          this.requests.remove(request);\n\n          const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n          const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, stream);\n\n          void this.segmentStorage.storeSegment(\n            swarmId,\n            streamSwarmId,\n            segment.externalId,\n            request.data,\n            segment.startTime,\n            segment.endTime,\n            segment.stream.type,\n            this.streamDetails.isLive,\n          );\n          break;\n        }\n\n        case \"failed\":\n          if (type === \"http\" && !isHandledByProcessQueue) {\n            this.p2pLoaders.currentLoader.broadcastAnnouncement();\n          }\n          if (\n            !engineRequest &&\n            !stream.segments.has(request.segment.runtimeId)\n          ) {\n            this.requests.remove(request);\n          }\n          if (\n            request.failedAttempts.httpAttemptsCount >= httpErrorRetries &&\n            engineRequest\n          ) {\n            this.engineRequest = undefined;\n            engineRequest.reject();\n          }\n          break;\n\n        case \"not-started\":\n          this.requests.remove(request);\n          break;\n\n        case \"aborted\":\n          this.requests.remove(request);\n          break;\n      }\n\n      request.markHandledByProcessQueue();\n      const { lastAttempt } = request.failedAttempts;\n      if (\n        lastAttempt &&\n        now - lastAttempt.error.timestamp > FAILED_ATTEMPTS_CLEAR_INTERVAL\n      ) {\n        request.failedAttempts.clear();\n      }\n    }\n  }\n\n  private processQueue() {\n    const { queue, queueSegmentIds, queueDownloadRatio } = this.generateQueue();\n    this.processRequests(queueSegmentIds, queueDownloadRatio);\n\n    const {\n      simultaneousHttpDownloads,\n      simultaneousP2PDownloads,\n      httpErrorRetries,\n    } = this.config;\n\n    if (\n      this.engineRequest?.shouldBeStartedImmediately &&\n      this.engineRequest.status === \"pending\" &&\n      this.requests.executingHttpCount < simultaneousHttpDownloads\n    ) {\n      const { segment } = this.engineRequest;\n      const request = this.requests.get(segment);\n      if (\n        !request ||\n        request.status === \"not-started\" ||\n        (request.status === \"failed\" &&\n          request.failedAttempts.httpAttemptsCount <\n            this.config.httpErrorRetries)\n      ) {\n        this.loadThroughHttp(segment);\n      }\n    }\n\n    for (const item of queue) {\n      const { statuses, segment } = item;\n      const request = this.requests.get(segment);\n\n      if (statuses.isHighDemand) {\n        if (\n          request?.downloadSource === \"http\" &&\n          request.status === \"loading\"\n        ) {\n          continue;\n        }\n\n        if (\n          request?.downloadSource === \"http\" &&\n          request.status === \"failed\" &&\n          request.failedAttempts.httpAttemptsCount >= httpErrorRetries\n        ) {\n          continue;\n        }\n\n        const isP2PLoadingRequest =\n          request?.status === \"loading\" && request.downloadSource === \"p2p\";\n\n        if (this.requests.executingHttpCount < simultaneousHttpDownloads) {\n          if (isP2PLoadingRequest) request.abortFromProcessQueue();\n          this.loadThroughHttp(segment);\n          continue;\n        }\n\n        if (\n          this.abortLastHttpLoadingInQueueAfterItem(queue, segment) &&\n          this.requests.executingHttpCount < simultaneousHttpDownloads\n        ) {\n          if (isP2PLoadingRequest) request.abortFromProcessQueue();\n          this.loadThroughHttp(segment);\n          continue;\n        }\n\n        if (isP2PLoadingRequest) continue;\n\n        if (this.requests.executingP2PCount < simultaneousP2PDownloads) {\n          this.loadThroughP2P(segment);\n          continue;\n        }\n\n        if (\n          this.abortLastP2PLoadingInQueueAfterItem(queue, segment) &&\n          this.requests.executingP2PCount < simultaneousP2PDownloads\n        ) {\n          this.loadThroughP2P(segment);\n          continue;\n        }\n      } else if (statuses.isP2PDownloadable) {\n        if (request?.status === \"loading\") continue;\n\n        if (this.requests.executingP2PCount < simultaneousP2PDownloads) {\n          this.loadThroughP2P(segment);\n        } else if (\n          this.p2pLoaders.currentLoader.isSegmentLoadedBySomeone(segment)\n        ) {\n          if (\n            this.abortLastP2PLoadingInQueueAfterItem(queue, segment) &&\n            this.requests.executingP2PCount < simultaneousP2PDownloads\n          ) {\n            this.loadThroughP2P(segment);\n          }\n        }\n      }\n    }\n  }\n\n  // api method for engines\n  abortSegmentRequest(segmentRuntimeId: string) {\n    if (this.engineRequest?.segment.runtimeId !== segmentRuntimeId) return;\n    this.engineRequest.abort();\n    this.logger(\n      \"abort: \",\n      LoggerUtils.getSegmentString(this.engineRequest.segment),\n    );\n    this.engineRequest = undefined;\n    this.requestProcessQueueMicrotask();\n  }\n\n  private loadThroughHttp(segment: SegmentWithStream) {\n    const request = this.requests.getOrCreateRequest(segment);\n    new HttpRequestExecutor(request, this.config, this.eventTarget);\n    this.p2pLoaders.currentLoader.broadcastAnnouncement();\n  }\n\n  private loadThroughP2P(segment: SegmentWithStream) {\n    this.p2pLoaders.currentLoader.downloadSegment(segment);\n  }\n\n  private loadRandomThroughHttp() {\n    const availableStorageCapacityPercent =\n      this.getAvailableStorageCapacityPercent();\n    if (availableStorageCapacityPercent <= 10) return;\n\n    const { simultaneousHttpDownloads, httpErrorRetries } = this.config;\n    const p2pLoader = this.p2pLoaders.currentLoader;\n\n    if (\n      this.requests.executingHttpCount >= simultaneousHttpDownloads ||\n      !p2pLoader.connectedPeerCount\n    ) {\n      return;\n    }\n\n    const segmentsToLoad: SegmentWithStream[] = [];\n    for (const { segment, statuses } of QueueUtils.generateQueue(\n      this.lastRequestedSegment,\n      this.playback,\n      this.config,\n      this.p2pLoaders.currentLoader,\n      availableStorageCapacityPercent,\n    )) {\n      const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n      const streamSwarmId = StreamUtils.getStreamSwarmId(\n        swarmId,\n        segment.stream,\n      );\n\n      if (\n        !statuses.isHttpDownloadable ||\n        statuses.isP2PDownloadable ||\n        this.segmentStorage.hasSegment(\n          swarmId,\n          streamSwarmId,\n          segment.externalId,\n        )\n      ) {\n        continue;\n      }\n      const request = this.requests.get(segment);\n      if (\n        request &&\n        (request.status === \"loading\" ||\n          request.status === \"succeed\" ||\n          request.failedAttempts.httpAttemptsCount >= httpErrorRetries)\n      ) {\n        continue;\n      }\n      segmentsToLoad.push(segment);\n    }\n\n    if (!segmentsToLoad.length) return;\n\n    const availableHttpDownloads =\n      simultaneousHttpDownloads - this.requests.executingHttpCount;\n\n    if (availableHttpDownloads === 0) return;\n\n    const peersCount = p2pLoader.connectedPeerCount + 1;\n    const safeRandomSegmentsCount = Math.min(\n      segmentsToLoad.length,\n      simultaneousHttpDownloads * peersCount,\n    );\n\n    const randomIndices = Utils.shuffleArray(\n      Array.from({ length: safeRandomSegmentsCount }, (_, i) => i),\n    );\n\n    let probability = safeRandomSegmentsCount / peersCount;\n\n    for (const randomIndex of randomIndices) {\n      if (this.requests.executingHttpCount >= simultaneousHttpDownloads) {\n        break;\n      }\n\n      if (probability >= 1 || Math.random() <= probability) {\n        const segment = segmentsToLoad[randomIndex];\n        this.loadThroughHttp(segment);\n      }\n\n      probability--;\n      if (probability <= 0) break;\n    }\n  }\n\n  private abortLastHttpLoadingInQueueAfterItem(\n    queue: QueueUtils.QueueItem[],\n    segment: SegmentWithStream,\n  ): boolean {\n    for (const { segment: itemSegment } of Utils.arrayBackwards(queue)) {\n      if (itemSegment === segment) break;\n      const request = this.requests.get(itemSegment);\n      if (request?.downloadSource === \"http\" && request.status === \"loading\") {\n        request.abortFromProcessQueue();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private abortLastP2PLoadingInQueueAfterItem(\n    queue: QueueUtils.QueueItem[],\n    segment: SegmentWithStream,\n  ): boolean {\n    for (const { segment: itemSegment } of Utils.arrayBackwards(queue)) {\n      if (itemSegment === segment) break;\n      const request = this.requests.get(itemSegment);\n      if (request?.downloadSource === \"p2p\" && request.status === \"loading\") {\n        request.abortFromProcessQueue();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private getAvailableStorageCapacityPercent(): number {\n    const { totalCapacity, usedCapacity } = this.segmentStorage.getUsage();\n    return 100 - (usedCapacity / totalCapacity) * 100;\n  }\n\n  private generateQueue() {\n    const queue: QueueItem[] = [];\n    const queueSegmentIds = new Set<string>();\n    let maxPossibleLength = 0;\n    let alreadyLoadedCount = 0;\n\n    const availableStorageCapacityPercent =\n      this.getAvailableStorageCapacityPercent();\n    for (const item of QueueUtils.generateQueue(\n      this.lastRequestedSegment,\n      this.playback,\n      this.config,\n      this.p2pLoaders.currentLoader,\n      availableStorageCapacityPercent,\n    )) {\n      maxPossibleLength++;\n      const { segment } = item;\n\n      const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n      const streamSwarmId = StreamUtils.getStreamSwarmId(\n        swarmId,\n        segment.stream,\n      );\n\n      if (\n        this.segmentStorage.hasSegment(\n          swarmId,\n          streamSwarmId,\n          segment.externalId,\n        ) ||\n        this.requests.get(segment)?.status === \"succeed\"\n      ) {\n        alreadyLoadedCount++;\n        continue;\n      }\n      queue.push(item);\n      queueSegmentIds.add(segment.runtimeId);\n    }\n\n    return {\n      queue,\n      queueSegmentIds,\n      maxPossibleLength,\n      alreadyLoadedCount,\n      queueDownloadRatio:\n        maxPossibleLength !== 0 ? alreadyLoadedCount / maxPossibleLength : 0,\n    };\n  }\n\n  private getBandwidth(queueDownloadRatio: number) {\n    const { http, all } = this.bandwidthCalculators;\n    const { activeLevelBitrate } = this.streamDetails;\n    if (this.streamDetails.activeLevelBitrate === 0) {\n      return all.getBandwidthLoadingOnly(3);\n    }\n\n    const bandwidth = Math.max(\n      all.getBandwidth(30, this.levelChangedTimestamp),\n      all.getBandwidth(60, this.levelChangedTimestamp),\n      all.getBandwidth(90, this.levelChangedTimestamp),\n    );\n\n    if (queueDownloadRatio >= 0.8 || bandwidth >= activeLevelBitrate * 0.9) {\n      return Math.max(\n        all.getBandwidthLoadingOnly(1),\n        all.getBandwidthLoadingOnly(3),\n        all.getBandwidthLoadingOnly(5),\n      );\n    }\n\n    const httpRealBandwidth = Math.max(\n      http.getBandwidthLoadingOnly(1),\n      http.getBandwidthLoadingOnly(3),\n      http.getBandwidthLoadingOnly(5),\n    );\n\n    return Math.max(bandwidth, httpRealBandwidth);\n  }\n\n  notifyLevelChanged() {\n    this.levelChangedTimestamp = performance.now();\n  }\n\n  sendBroadcastAnnouncement(sendEmptySegmentsAnnouncement = false) {\n    this.p2pLoaders.currentLoader.broadcastAnnouncement(\n      sendEmptySegmentsAnnouncement,\n    );\n  }\n\n  updatePlayback(position: number, rate: number) {\n    const isRateChanged = this.playback.rate !== rate;\n    const isPositionChanged = this.playback.position !== position;\n\n    if (!isRateChanged && !isPositionChanged) return;\n\n    const isPositionSignificantlyChanged =\n      Math.abs(position - this.playback.position) / this.segmentAvgDuration >\n      0.5;\n\n    if (isPositionChanged) this.playback.position = position;\n    if (isRateChanged && rate !== 0) this.playback.rate = rate;\n    if (isPositionSignificantlyChanged) {\n      this.logger(\"position significantly changed\");\n      this.engineRequest?.markAsShouldBeStartedImmediately();\n    }\n    this.segmentStorage.onPlaybackUpdated(position, rate);\n    this.requestProcessQueueMicrotask(isPositionSignificantlyChanged);\n  }\n\n  updateStream(stream: StreamWithSegments) {\n    if (stream !== this.lastRequestedSegment.stream) return;\n    this.logger(`update stream: ${LoggerUtils.getStreamString(stream)}`);\n    this.requestProcessQueueMicrotask();\n  }\n\n  destroy() {\n    clearInterval(this.storageCleanUpIntervalId);\n    clearInterval(this.randomHttpDownloadInterval);\n    this.storageCleanUpIntervalId = undefined;\n    this.engineRequest?.abort();\n    this.requests.destroy();\n    this.p2pLoaders.destroy();\n  }\n}\n","export class BandwidthCalculator {\n  private loadingsCount = 0;\n  private readonly bytes: number[] = [];\n  private readonly loadingOnlyTimestamps: number[] = [];\n  private readonly timestamps: number[] = [];\n  private noLoadingsTime = 0;\n  private loadingsStoppedAt = 0;\n\n  constructor(private readonly clearThresholdMs = 20000) {}\n\n  addBytes(bytesLength: number, now = performance.now()) {\n    this.bytes.push(bytesLength);\n    this.loadingOnlyTimestamps.push(now - this.noLoadingsTime);\n    this.timestamps.push(now);\n  }\n\n  startLoading(now = performance.now()) {\n    this.clearStale();\n    if (this.loadingsCount === 0 && this.loadingsStoppedAt !== 0) {\n      this.noLoadingsTime += now - this.loadingsStoppedAt;\n    }\n    this.loadingsCount++;\n  }\n\n  stopLoading(now = performance.now()) {\n    if (this.loadingsCount > 0) {\n      this.loadingsCount--;\n      if (this.loadingsCount === 0) this.loadingsStoppedAt = now;\n    }\n  }\n\n  getBandwidthLoadingOnly(\n    seconds: number,\n    ignoreThresholdTimestamp = Number.NEGATIVE_INFINITY,\n  ) {\n    if (!this.loadingOnlyTimestamps.length) return 0;\n    const milliseconds = seconds * 1000;\n    const lastItemTimestamp =\n      this.loadingOnlyTimestamps[this.loadingOnlyTimestamps.length - 1];\n    let lastCountedTimestamp = lastItemTimestamp;\n    const threshold = lastItemTimestamp - milliseconds;\n    let totalBytes = 0;\n\n    for (let i = this.bytes.length - 1; i >= 0; i--) {\n      const timestamp = this.loadingOnlyTimestamps[i];\n      if (\n        timestamp < threshold ||\n        this.timestamps[i] < ignoreThresholdTimestamp\n      ) {\n        break;\n      }\n      lastCountedTimestamp = timestamp;\n      totalBytes += this.bytes[i];\n    }\n\n    return (totalBytes * 8000) / (lastItemTimestamp - lastCountedTimestamp);\n  }\n\n  getBandwidth(\n    seconds: number,\n    ignoreThresholdTimestamp = Number.NEGATIVE_INFINITY,\n    now = performance.now(),\n  ) {\n    if (!this.timestamps.length) return 0;\n    const milliseconds = seconds * 1000;\n    const threshold = now - milliseconds;\n    let lastCountedTimestamp = now;\n    let totalBytes = 0;\n\n    for (let i = this.bytes.length - 1; i >= 0; i--) {\n      const timestamp = this.timestamps[i];\n      if (timestamp < threshold || timestamp < ignoreThresholdTimestamp) break;\n      lastCountedTimestamp = timestamp;\n      totalBytes += this.bytes[i];\n    }\n\n    return (totalBytes * 8000) / (now - lastCountedTimestamp);\n  }\n\n  clearStale() {\n    if (!this.loadingOnlyTimestamps.length) return;\n    const threshold =\n      this.loadingOnlyTimestamps[this.loadingOnlyTimestamps.length - 1] -\n      this.clearThresholdMs;\n\n    let samplesToRemove = 0;\n    for (const timestamp of this.loadingOnlyTimestamps) {\n      if (timestamp > threshold) break;\n      samplesToRemove++;\n    }\n\n    this.bytes.splice(0, samplesToRemove);\n    this.loadingOnlyTimestamps.splice(0, samplesToRemove);\n    this.timestamps.splice(0, samplesToRemove);\n  }\n}\n","export const getStorageItemId = (streamId: string, segmentId: number) =>\n  `${streamId}|${segmentId}`;\n\nexport const isAndroid = (userAgent: string) => /Android/i.test(userAgent);\n\nexport const isIPadOrIPhone = (userAgent: string) =>\n  /iPad|iPhone/i.test(userAgent);\n\nexport const isAndroidWebview = (userAgent: string) =>\n  /Android/i.test(userAgent) && !/Chrome|Firefox/i.test(userAgent);\n","import { CommonCoreConfig, StreamConfig, StreamType } from \"../types.js\";\nimport debug from \"debug\";\nimport { SegmentStorage } from \"./index.js\";\nimport {\n  isAndroid,\n  isIPadOrIPhone,\n  isAndroidWebview,\n  getStorageItemId,\n} from \"./utils.js\";\n\ntype SegmentDataItem = {\n  segmentId: number;\n  streamId: string;\n  data: ArrayBuffer;\n  startTime: number;\n  endTime: number;\n  streamType: StreamType;\n};\n\ntype Playback = {\n  position: number;\n  rate: number;\n};\n\ntype LastRequestedSegmentInfo = {\n  streamId: string;\n  segmentId: number;\n  startTime: number;\n  endTime: number;\n  swarmId: string;\n  streamType: StreamType;\n  isLiveStream: boolean;\n};\n\nconst BYTES_PER_MiB = 1048576;\n\nexport class SegmentMemoryStorage implements SegmentStorage {\n  private readonly userAgent = navigator.userAgent;\n  private segmentMemoryStorageLimit = 4 * 1024;\n  private currentStorageUsage = 0;\n\n  private cache = new Map<string, SegmentDataItem>();\n  private readonly logger: debug.Debugger;\n  private coreConfig?: CommonCoreConfig;\n  private mainStreamConfig?: StreamConfig;\n  private secondaryStreamConfig?: StreamConfig;\n  private currentPlayback?: Playback;\n  private lastRequestedSegment?: LastRequestedSegmentInfo;\n  private segmentChangeCallback?: (streamId: string) => void;\n\n  constructor() {\n    this.logger = debug(\"p2pml-core:segment-memory-storage\");\n    this.logger.color = \"RebeccaPurple\";\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async initialize(\n    coreConfig: CommonCoreConfig,\n    mainStreamConfig: StreamConfig,\n    secondaryStreamConfig: StreamConfig,\n  ) {\n    this.coreConfig = coreConfig;\n    this.mainStreamConfig = mainStreamConfig;\n    this.secondaryStreamConfig = secondaryStreamConfig;\n\n    this.setMemoryStorageLimit();\n    this.logger(\"initialized\");\n  }\n\n  onPlaybackUpdated(position: number, rate: number) {\n    this.currentPlayback = { position, rate };\n  }\n\n  onSegmentRequested(\n    swarmId: string,\n    streamId: string,\n    segmentId: number,\n    startTime: number,\n    endTime: number,\n    streamType: StreamType,\n    isLiveStream: boolean,\n  ): void {\n    this.lastRequestedSegment = {\n      streamId,\n      segmentId,\n      startTime,\n      endTime,\n      swarmId,\n      streamType,\n      isLiveStream,\n    };\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async storeSegment(\n    _swarmId: string,\n    streamId: string,\n    segmentId: number,\n    data: ArrayBuffer,\n    startTime: number,\n    endTime: number,\n    streamType: StreamType,\n    isLiveStream: boolean,\n  ) {\n    this.clear(isLiveStream, data.byteLength);\n\n    const storageId = getStorageItemId(streamId, segmentId);\n    this.cache.set(storageId, {\n      data,\n      segmentId,\n      streamId,\n      startTime,\n      endTime,\n      streamType,\n    });\n    this.increaseStorageUsage(data.byteLength);\n\n    this.logger(`add segment: ${segmentId} to ${streamId}`);\n\n    if (!this.segmentChangeCallback) {\n      throw new Error(\"dispatchStorageUpdatedEvent is not set\");\n    }\n\n    this.segmentChangeCallback(streamId);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async getSegmentData(_swarmId: string, streamId: string, segmentId: number) {\n    const segmentStorageId = getStorageItemId(streamId, segmentId);\n    const dataItem = this.cache.get(segmentStorageId);\n\n    if (dataItem === undefined) return undefined;\n\n    return dataItem.data;\n  }\n\n  getUsage() {\n    if (!this.lastRequestedSegment || !this.currentPlayback) {\n      return {\n        totalCapacity: this.segmentMemoryStorageLimit,\n        usedCapacity: this.currentStorageUsage,\n      };\n    }\n    const playbackPosition = this.currentPlayback.position;\n\n    let calculatedUsedCapacity = 0;\n    for (const { endTime, data } of this.cache.values()) {\n      if (playbackPosition > endTime) continue;\n\n      calculatedUsedCapacity += data.byteLength;\n    }\n\n    return {\n      totalCapacity: this.segmentMemoryStorageLimit,\n      usedCapacity: calculatedUsedCapacity / BYTES_PER_MiB,\n    };\n  }\n\n  hasSegment(_swarmId: string, streamId: string, externalId: number) {\n    const segmentStorageId = getStorageItemId(streamId, externalId);\n    const segment = this.cache.get(segmentStorageId);\n\n    return segment !== undefined;\n  }\n\n  getStoredSegmentIds(_swarmId: string, streamId: string) {\n    const externalIds: number[] = [];\n\n    for (const { segmentId, streamId: streamCacheId } of this.cache.values()) {\n      if (streamCacheId !== streamId) continue;\n      externalIds.push(segmentId);\n    }\n\n    return externalIds;\n  }\n\n  private clear(isLiveStream: boolean, newSegmentSize: number) {\n    if (\n      !this.currentPlayback ||\n      !this.mainStreamConfig ||\n      !this.secondaryStreamConfig ||\n      !this.coreConfig\n    ) {\n      return;\n    }\n\n    const isMemoryLimitReached = this.isMemoryLimitReached(newSegmentSize);\n\n    if (!isMemoryLimitReached && !isLiveStream) return;\n\n    const affectedStreams = new Set<string>();\n    const sortedCache = Array.from(this.cache.values()).sort(\n      (a, b) => a.startTime - b.startTime,\n    );\n\n    for (const segmentData of sortedCache) {\n      const { streamId, segmentId, data } = segmentData;\n      const storageId = getStorageItemId(streamId, segmentId);\n\n      const shouldRemove = this.shouldRemoveSegment(\n        segmentData,\n        isLiveStream,\n        this.currentPlayback.position,\n      );\n\n      if (!shouldRemove) continue;\n\n      this.cache.delete(storageId);\n      affectedStreams.add(streamId);\n      this.decreaseStorageUsage(data.byteLength);\n\n      this.logger(`Removed segment ${segmentId} from stream ${streamId}`);\n\n      if (!this.isMemoryLimitReached(newSegmentSize) && !isLiveStream) break;\n    }\n\n    this.sendUpdatesToAffectedStreams(affectedStreams);\n  }\n\n  private isMemoryLimitReached(segmentByteLength: number) {\n    return (\n      this.currentStorageUsage + segmentByteLength / BYTES_PER_MiB >\n      this.segmentMemoryStorageLimit\n    );\n  }\n\n  setSegmentChangeCallback(callback: (streamId: string) => void) {\n    this.segmentChangeCallback = callback;\n  }\n\n  private sendUpdatesToAffectedStreams(affectedStreams: Set<string>) {\n    if (affectedStreams.size === 0) return;\n\n    affectedStreams.forEach((stream) => {\n      if (!this.segmentChangeCallback) {\n        throw new Error(\"dispatchStorageUpdatedEvent is not set\");\n      }\n\n      this.segmentChangeCallback(stream);\n    });\n  }\n\n  private shouldRemoveSegment(\n    segmentData: SegmentDataItem,\n    isLiveStream: boolean,\n    currentPlaybackPosition: number,\n  ): boolean {\n    const { endTime, streamType } = segmentData;\n    const highDemandTimeWindow = this.getStreamTimeWindow(\n      streamType,\n      \"highDemandTimeWindow\",\n    );\n\n    if (currentPlaybackPosition <= endTime) return false;\n\n    if (isLiveStream) {\n      return currentPlaybackPosition > highDemandTimeWindow + endTime;\n    }\n\n    return true;\n  }\n\n  private increaseStorageUsage(segmentByteLength: number) {\n    this.currentStorageUsage += segmentByteLength / BYTES_PER_MiB;\n  }\n\n  private decreaseStorageUsage(segmentByteLength: number) {\n    this.currentStorageUsage -= segmentByteLength / BYTES_PER_MiB;\n  }\n\n  private setMemoryStorageLimit() {\n    if (this.coreConfig?.segmentMemoryStorageLimit) {\n      this.segmentMemoryStorageLimit =\n        this.coreConfig.segmentMemoryStorageLimit;\n      return;\n    }\n\n    if (isAndroidWebview(this.userAgent) || isIPadOrIPhone(this.userAgent)) {\n      this.segmentMemoryStorageLimit = 1024;\n    } else if (isAndroid(this.userAgent)) {\n      this.segmentMemoryStorageLimit = 2 * 1024;\n    }\n  }\n\n  private getStreamTimeWindow(\n    streamType: string,\n    configKey: \"highDemandTimeWindow\" | \"httpDownloadTimeWindow\",\n  ): number {\n    const config =\n      streamType === \"main\"\n        ? this.mainStreamConfig\n        : this.secondaryStreamConfig;\n\n    return config?.[configKey] ?? 0;\n  }\n\n  public destroy() {\n    this.cache.clear();\n  }\n}\n","export class EventTarget<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  EventTypesMap extends Record<string, (...args: any[]) => unknown>,\n> {\n  private events = new Map<\n    keyof EventTypesMap,\n    EventTypesMap[keyof EventTypesMap][]\n  >();\n\n  public dispatchEvent<K extends keyof EventTypesMap>(\n    eventName: K,\n    ...args: Parameters<EventTypesMap[K]>\n  ) {\n    const listeners = this.events.get(eventName);\n    if (!listeners) return;\n    for (const listener of listeners) {\n      listener(...args);\n    }\n  }\n\n  public getEventDispatcher<K extends keyof EventTypesMap>(eventName: K) {\n    let listeners = this.events.get(eventName);\n    if (!listeners) {\n      listeners = [];\n      this.events.set(eventName, listeners);\n    }\n\n    const definedListeners = listeners;\n\n    return (...args: Parameters<EventTypesMap[K]>) => {\n      for (const listener of definedListeners) {\n        listener(...args);\n      }\n    };\n  }\n\n  public addEventListener<K extends keyof EventTypesMap>(\n    eventName: K,\n    listener: EventTypesMap[K],\n  ) {\n    const listeners = this.events.get(eventName);\n    if (!listeners) {\n      this.events.set(eventName, [listener]);\n    } else {\n      listeners.push(listener);\n    }\n  }\n\n  public removeEventListener<K extends keyof EventTypesMap>(\n    eventName: K,\n    listener: EventTypesMap[K],\n  ) {\n    const listeners = this.events.get(eventName);\n    if (listeners) {\n      const index = listeners.indexOf(listener);\n      if (index !== -1) {\n        listeners.splice(index, 1);\n      }\n    }\n  }\n}\n","import { HybridLoader } from \"./hybrid-loader.js\";\nimport {\n  Stream,\n  CoreConfig,\n  Segment,\n  CoreEventMap,\n  DynamicCoreConfig,\n  EngineCallbacks,\n  StreamWithSegments,\n  SegmentWithStream,\n  CommonCoreConfig,\n  StreamConfig,\n  DefinedCoreConfig,\n  StreamType,\n  DynamicStreamConfig,\n} from \"./types.js\";\nimport { BandwidthCalculators, StreamDetails } from \"./internal-types.js\";\nimport * as StreamUtils from \"./utils/stream.js\";\nimport { BandwidthCalculator } from \"./bandwidth-calculator.js\";\nimport { SegmentMemoryStorage } from \"./segment-storage/segment-memory-storage.js\";\nimport { EventTarget } from \"./utils/event-target.js\";\nimport {\n  overrideConfig,\n  mergeAndFilterConfig,\n  deepCopy,\n  filterUndefinedProps,\n} from \"./utils/utils.js\";\nimport { TRACKER_CLIENT_VERSION_PREFIX } from \"./utils/peer.js\";\nimport { SegmentStorage } from \"./segment-storage/index.js\";\nimport { P2PTrackerClient } from \"./p2p/tracker-client.js\";\n\n/** Core class for managing media streams loading via P2P. */\nexport class Core<TStream extends Stream = Stream> {\n  /** Default configuration for common core settings. */\n  static readonly DEFAULT_COMMON_CORE_CONFIG: CommonCoreConfig = {\n    segmentMemoryStorageLimit: undefined,\n    customSegmentStorageFactory: undefined,\n  };\n\n  /** Default configuration for stream settings. */\n  static readonly DEFAULT_STREAM_CONFIG: StreamConfig = {\n    isP2PUploadDisabled: false,\n    isP2PDisabled: false,\n    simultaneousHttpDownloads: 2,\n    simultaneousP2PDownloads: 3,\n    highDemandTimeWindow: 15,\n    httpDownloadTimeWindow: 3000,\n    p2pDownloadTimeWindow: 6000,\n    webRtcMaxMessageSize: 64 * 1024 - 1,\n    p2pNotReceivingBytesTimeoutMs: 2000,\n    p2pInactiveLoaderDestroyTimeoutMs: 30 * 1000,\n    httpNotReceivingBytesTimeoutMs: 3000,\n    httpErrorRetries: 3,\n    p2pErrorRetries: 3,\n    trackerClientVersionPrefix: TRACKER_CLIENT_VERSION_PREFIX,\n    announceTrackers: [\n      \"wss://tracker.novage.com.ua\",\n      \"wss://tracker.webtorrent.dev\",\n      \"wss://tracker.openwebtorrent.com\",\n    ],\n    rtcConfig: {\n      iceServers: [\n        { urls: \"stun:stun.l.google.com:19302\" },\n        { urls: \"stun:global.stun.twilio.com:3478\" },\n      ],\n    },\n    validateP2PSegment: undefined,\n    validateHTTPSegment: undefined,\n    httpRequestSetup: undefined,\n    swarmId: undefined,\n  };\n\n  private readonly eventTarget = new EventTarget<CoreEventMap>();\n  private manifestResponseUrl?: string;\n  private readonly streams = new Map<string, StreamWithSegments<TStream>>();\n  private mainStreamConfig: StreamConfig;\n  private secondaryStreamConfig: StreamConfig;\n  private commonCoreConfig: CommonCoreConfig;\n  private readonly bandwidthCalculators: BandwidthCalculators = {\n    all: new BandwidthCalculator(),\n    http: new BandwidthCalculator(),\n  };\n  private segmentStorage?: SegmentStorage;\n  private mainStreamLoader?: HybridLoader;\n  private secondaryStreamLoader?: HybridLoader;\n  private streamDetails: StreamDetails = {\n    isLive: false,\n    activeLevelBitrate: 0,\n  };\n\n  /**\n   * Constructs a new Core instance with optional initial configuration.\n   *\n   * @param config - Optional partial configuration to override default settings.\n   *\n   * @example\n   * // Create a Core instance with custom configuration for HTTP and P2P downloads.\n   * const core = new Core({\n   *   simultaneousHttpDownloads: 5,\n   *   simultaneousP2PDownloads: 5,\n   *   httpErrorRetries: 5,\n   *   p2pErrorRetries: 5\n   * });\n   *\n   * @example\n   * // Create a Core instance using the default configuration.\n   * const core = new Core();\n   */\n  constructor(config?: Partial<CoreConfig>) {\n    const filteredConfig = filterUndefinedProps(config ?? {});\n\n    this.commonCoreConfig = mergeAndFilterConfig<CommonCoreConfig>({\n      defaultConfig: Core.DEFAULT_COMMON_CORE_CONFIG,\n      baseConfig: filteredConfig,\n    });\n\n    this.mainStreamConfig = mergeAndFilterConfig<StreamConfig>({\n      defaultConfig: Core.DEFAULT_STREAM_CONFIG,\n      baseConfig: filteredConfig,\n      specificStreamConfig: filteredConfig.mainStream,\n    });\n\n    this.secondaryStreamConfig = mergeAndFilterConfig<StreamConfig>({\n      defaultConfig: Core.DEFAULT_STREAM_CONFIG,\n      baseConfig: filteredConfig,\n      specificStreamConfig: filteredConfig.secondaryStream,\n    });\n  }\n\n  /**\n   * Retrieves the current configuration for the core instance, ensuring immutability.\n   *\n   * @returns A deep readonly version of the core configuration.\n   */\n  getConfig(): DefinedCoreConfig {\n    return {\n      ...deepCopy(this.commonCoreConfig),\n      mainStream: deepCopy(this.mainStreamConfig),\n      secondaryStream: deepCopy(this.secondaryStreamConfig),\n    };\n  }\n\n  /**\n   * Applies a set of dynamic configuration updates to the core, merging with the existing configuration.\n   *\n   * @param dynamicConfig - A set of configuration changes to apply.\n   *\n   * @example\n   * // Example of dynamically updating the download time windows and timeout settings.\n   * const dynamicConfig = {\n   *   httpDownloadTimeWindow: 60,  // Set HTTP download time window to 60 seconds\n   *   p2pDownloadTimeWindow: 60,   // Set P2P download time window to 60 seconds\n   *   httpNotReceivingBytesTimeoutMs: 1500,  // Set HTTP timeout to 1500 milliseconds\n   *   p2pNotReceivingBytesTimeoutMs: 1500    // Set P2P timeout to 1500 milliseconds\n   * };\n   * core.applyDynamicConfig(dynamicConfig);\n   */\n  applyDynamicConfig(dynamicConfig: DynamicCoreConfig) {\n    const { mainStream, secondaryStream } = dynamicConfig;\n\n    const mainStreamConfigCopy = deepCopy(this.mainStreamConfig);\n    const secondaryStreamConfigCopy = deepCopy(this.secondaryStreamConfig);\n\n    this.overrideAllConfigs(dynamicConfig, mainStream, secondaryStream);\n\n    this.processSpecificDynamicConfigParams(\n      mainStreamConfigCopy,\n      dynamicConfig,\n      \"main\",\n    );\n    this.processSpecificDynamicConfigParams(\n      secondaryStreamConfigCopy,\n      dynamicConfig,\n      \"secondary\",\n    );\n  }\n\n  private processSpecificDynamicConfigParams(\n    prevConfig: StreamConfig,\n    updatedConfig: DynamicCoreConfig,\n    streamType: StreamType,\n  ) {\n    const isP2PDisabled = this.getUpdatedStreamProperty(\n      \"isP2PDisabled\",\n      updatedConfig,\n      streamType,\n    );\n\n    if (isP2PDisabled && prevConfig.isP2PDisabled !== isP2PDisabled) {\n      this.destroyStreamLoader(streamType);\n    }\n\n    const isP2PUploadDisabled = this.getUpdatedStreamProperty(\n      \"isP2PUploadDisabled\",\n      updatedConfig,\n      streamType,\n    );\n\n    if (\n      isP2PUploadDisabled !== undefined &&\n      prevConfig.isP2PUploadDisabled !== isP2PUploadDisabled\n    ) {\n      const streamLoader =\n        streamType === \"main\"\n          ? this.mainStreamLoader\n          : this.secondaryStreamLoader;\n\n      streamLoader?.sendBroadcastAnnouncement(isP2PUploadDisabled);\n    }\n  }\n\n  private getUpdatedStreamProperty<K extends keyof DynamicStreamConfig>(\n    propertyName: K,\n    updatedConfig: DynamicCoreConfig,\n    streamType: StreamType,\n  ): DynamicStreamConfig[K] | undefined {\n    const updatedStreamConfig =\n      streamType === \"main\"\n        ? updatedConfig.mainStream\n        : updatedConfig.secondaryStream;\n\n    return updatedStreamConfig?.[propertyName] ?? updatedConfig[propertyName];\n  }\n\n  /**\n   * Adds an event listener for the specified event type on the core event target.\n   *\n   * @param eventName - The name of the event to listen for.\n   * @param listener - The callback function to invoke when the event is fired.\n   */\n  addEventListener<K extends keyof CoreEventMap>(\n    eventName: K,\n    listener: CoreEventMap[K],\n  ) {\n    this.eventTarget.addEventListener(eventName, listener);\n  }\n\n  /**\n   * Removes an event listener for the specified event type on the core event target.\n   *\n   * @param eventName - The name of the event to listen for.\n   * @param listener - The callback function to be removed.\n   */\n  removeEventListener<K extends keyof CoreEventMap>(\n    eventName: K,\n    listener: CoreEventMap[K],\n  ) {\n    this.eventTarget.removeEventListener(eventName, listener);\n  }\n\n  /**\n   * Sets the response URL for the manifest, stripping any query parameters.\n   *\n   * @param url - The full URL to the manifest response.\n   */\n  setManifestResponseUrl(url: string): void {\n    this.manifestResponseUrl = url.split(\"?\")[0];\n  }\n\n  /**\n   * Checks if a segment is already stored within the core.\n   *\n   * @param segmentRuntimeId - The runtime identifier of the segment to check.\n   * @returns `true` if the segment is present, otherwise `false`.\n   */\n  hasSegment(segmentRuntimeId: string): boolean {\n    return !!StreamUtils.getSegmentFromStreamsMap(\n      this.streams,\n      segmentRuntimeId,\n    );\n  }\n\n  /**\n   * Retrieves a specific stream by its runtime identifier, if it exists.\n   *\n   * @param streamRuntimeId - The runtime identifier of the stream to retrieve.\n   * @returns The stream with its segments, or `undefined` if not found.\n   */\n  getStream(streamRuntimeId: string): StreamWithSegments<TStream> | undefined {\n    return this.streams.get(streamRuntimeId);\n  }\n\n  /**\n   * Ensures a stream exists in the map; adds it if it does not.\n   *\n   * @param stream - The stream to potentially add to the map.\n   */\n  addStreamIfNoneExists(stream: TStream): void {\n    if (this.streams.has(stream.runtimeId)) return;\n\n    this.streams.set(stream.runtimeId, {\n      ...stream,\n      segments: new Map<string, SegmentWithStream<TStream>>(),\n    });\n  }\n\n  /**\n   * Updates the segments associated with a specific stream.\n   *\n   * @param streamRuntimeId - The runtime identifier of the stream to update.\n   * @param addSegments - Optional segments to add to the stream.\n   * @param removeSegmentIds - Optional segment IDs to remove from the stream.\n   */\n  updateStream(\n    streamRuntimeId: string,\n    addSegments?: Iterable<Segment>,\n    removeSegmentIds?: Iterable<string>,\n  ): void {\n    const stream = this.streams.get(streamRuntimeId);\n    if (!stream) return;\n\n    if (addSegments) {\n      for (const segment of addSegments) {\n        if (stream.segments.has(segment.runtimeId)) continue; // should not happen\n        stream.segments.set(segment.runtimeId, { ...segment, stream });\n      }\n    }\n\n    if (removeSegmentIds) {\n      for (const id of removeSegmentIds) {\n        stream.segments.delete(id);\n      }\n    }\n\n    this.mainStreamLoader?.updateStream(stream);\n    this.secondaryStreamLoader?.updateStream(stream);\n  }\n\n  /**\n   * Loads a segment given its runtime identifier and invokes the provided callbacks during the process.\n   * Initializes segment storage if it has not been initialized yet.\n   *\n   * @param segmentRuntimeId - The runtime identifier of the segment to load.\n   * @param callbacks - The callbacks to be invoked during segment loading.\n   * @throws {Error} - Throws if the manifest response URL is not defined.\n   */\n  async loadSegment(segmentRuntimeId: string, callbacks: EngineCallbacks) {\n    if (!this.manifestResponseUrl) {\n      throw new Error(\"Manifest response url is not defined\");\n    }\n\n    await this.initializeSegmentStorage();\n\n    const segment = this.identifySegment(segmentRuntimeId);\n\n    const loader = this.getStreamHybridLoader(segment);\n    void loader.loadSegment(segment, callbacks);\n  }\n\n  /**\n   * Aborts the loading of a segment specified by its runtime identifier.\n   *\n   * @param segmentRuntimeId - The runtime identifier of the segment whose loading is to be aborted.\n   */\n  abortSegmentLoading(segmentRuntimeId: string): void {\n    this.mainStreamLoader?.abortSegmentRequest(segmentRuntimeId);\n    this.secondaryStreamLoader?.abortSegmentRequest(segmentRuntimeId);\n  }\n\n  /**\n   * Updates the playback parameters while play head moves, specifically position and playback rate, for stream loaders.\n   *\n   * @param position - The new position in the stream, in seconds.\n   * @param rate - The new playback rate.\n   */\n  updatePlayback(position: number, rate: number): void {\n    this.mainStreamLoader?.updatePlayback(position, rate);\n    this.secondaryStreamLoader?.updatePlayback(position, rate);\n  }\n\n  /**\n   * Sets the active level bitrate, used for adjusting quality levels in adaptive streaming.\n   * Notifies the stream loaders if a change occurs.\n   *\n   * @param bitrate - The new bitrate to set as active.\n   */\n  setActiveLevelBitrate(bitrate: number) {\n    if (bitrate !== this.streamDetails.activeLevelBitrate) {\n      this.streamDetails.activeLevelBitrate = bitrate;\n      this.mainStreamLoader?.notifyLevelChanged();\n      this.secondaryStreamLoader?.notifyLevelChanged();\n    }\n  }\n\n  /**\n   * Updates the 'isLive' status of the stream\n   *\n   * @param isLive - Boolean indicating whether the stream is live.\n   */\n  setIsLive(isLive: boolean) {\n    this.streamDetails.isLive = isLive;\n  }\n\n  /**\n   * Identify if a segment is loadable by the P2P core based on the segment's stream type and configuration.\n   * @param segmentRuntimeId Segment runtime identifier to check.\n   * @returns `true` if the segment is loadable by the P2P core, otherwise `false`.\n   */\n  isSegmentLoadable(segmentRuntimeId: string): boolean {\n    try {\n      const segment = this.identifySegment(segmentRuntimeId);\n\n      if (\n        segment.stream.type === \"main\" &&\n        this.mainStreamConfig.isP2PDisabled\n      ) {\n        return false;\n      }\n\n      if (\n        segment.stream.type === \"secondary\" &&\n        this.secondaryStreamConfig.isP2PDisabled\n      ) {\n        return false;\n      }\n\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Cleans up resources used by the Core instance, including destroying any active stream loaders\n   * and clearing stored segments.\n   */\n  destroy(): void {\n    this.streams.clear();\n    this.mainStreamLoader?.destroy();\n    this.secondaryStreamLoader?.destroy();\n    this.segmentStorage?.destroy();\n    this.mainStreamLoader = undefined;\n    this.secondaryStreamLoader = undefined;\n    this.segmentStorage = undefined;\n    this.manifestResponseUrl = undefined;\n    this.streamDetails = { isLive: false, activeLevelBitrate: 0 };\n    P2PTrackerClient.clearPeerIdCache();\n  }\n\n  private async initializeSegmentStorage() {\n    if (this.segmentStorage) return;\n\n    const { isLive } = this.streamDetails;\n    const createCustomStorage =\n      this.commonCoreConfig.customSegmentStorageFactory;\n\n    if (createCustomStorage && typeof createCustomStorage !== \"function\") {\n      throw new Error(\"Storage configuration is invalid\");\n    }\n\n    const segmentStorage = createCustomStorage\n      ? createCustomStorage(isLive)\n      : new SegmentMemoryStorage();\n\n    await segmentStorage.initialize(\n      this.commonCoreConfig,\n      this.mainStreamConfig,\n      this.secondaryStreamConfig,\n    );\n\n    this.segmentStorage = segmentStorage;\n  }\n\n  private identifySegment(segmentRuntimeId: string): SegmentWithStream {\n    if (!this.manifestResponseUrl) {\n      throw new Error(\"Manifest response url is undefined\");\n    }\n\n    const segment = StreamUtils.getSegmentFromStreamsMap(\n      this.streams,\n      segmentRuntimeId,\n    );\n    if (!segment) {\n      throw new Error(`Not found segment with id: ${segmentRuntimeId}`);\n    }\n\n    return segment;\n  }\n\n  private overrideAllConfigs(\n    dynamicConfig: DynamicCoreConfig,\n    mainStream?: Partial<StreamConfig>,\n    secondaryStream?: Partial<StreamConfig>,\n  ) {\n    overrideConfig(this.commonCoreConfig, dynamicConfig);\n    overrideConfig(this.mainStreamConfig, dynamicConfig);\n    overrideConfig(this.secondaryStreamConfig, dynamicConfig);\n\n    if (mainStream) {\n      overrideConfig(this.mainStreamConfig, mainStream);\n    }\n\n    if (secondaryStream) {\n      overrideConfig(this.secondaryStreamConfig, secondaryStream);\n    }\n  }\n\n  private destroyStreamLoader(streamType: StreamType) {\n    if (streamType === \"main\") {\n      this.mainStreamLoader?.destroy();\n      this.mainStreamLoader = undefined;\n    } else {\n      this.secondaryStreamLoader?.destroy();\n      this.secondaryStreamLoader = undefined;\n    }\n  }\n\n  private getStreamHybridLoader(segment: SegmentWithStream) {\n    if (segment.stream.type === \"main\") {\n      this.mainStreamLoader ??= this.createNewHybridLoader(segment);\n      return this.mainStreamLoader;\n    } else {\n      this.secondaryStreamLoader ??= this.createNewHybridLoader(segment);\n      return this.secondaryStreamLoader;\n    }\n  }\n\n  private createNewHybridLoader(segment: SegmentWithStream) {\n    if (!this.manifestResponseUrl) {\n      throw new Error(\"Manifest response url is not defined\");\n    }\n\n    if (!this.segmentStorage) {\n      throw new Error(\"Segment storage is not initialized\");\n    }\n\n    const streamConfig =\n      segment.stream.type === \"main\"\n        ? this.mainStreamConfig\n        : this.secondaryStreamConfig;\n\n    return new HybridLoader(\n      this.manifestResponseUrl,\n      segment,\n      this.streamDetails,\n      streamConfig,\n      this.bandwidthCalculators,\n      this.segmentStorage,\n      this.eventTarget,\n    );\n  }\n}\n"],"names":["RequestError","Error","type","message","super","this","timestamp","performance","now","CoreRequestError","HttpRequestExecutor","request","httpConfig","eventTarget","onChunkDownloaded","getEventDispatcher","byteRange","segment","requestByteRange","loadedBytes","start","totalBytes","expectedBytesLength","requestControls","downloadSource","abort","abortController","notReceivingBytesTimeoutMs","httpNotReceivingBytesTimeoutMs","fetch","AbortController","httpRequestSetup","url","signal","headers","Headers","Range","end","Request","aborted","DOMException","response","window","handleResponseHeaders","body","firstBytesReceived","reader","getReader","chunk","async","done","value","read","addLoadedChunk","byteLength","validateHTTPSegment","data","clearLoadedBytes","completeOnSuccess","error","handleError","ok","status","statusText","contentLengthHeader","get","contentRangeHeader","contentRange","headerValue","match","rangeHeaderRegex","exec","trim","from","to","total","parseInt","responseExpectedBytesLength","setTotalBytes","name","httpLoaderError","abortOnError","getDefaultExportFromCjs","x","__esModule","Object","prototype","hasOwnProperty","call","cachedSetTimeout","cachedClearTimeout","browser","exports","process","defaultSetTimout","defaultClearTimeout","runTimeout","fun","setTimeout","e","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","marker","Item","array","noop","nextTick","args","Array","arguments","i","push","apply","title","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","process$1","s","m","h","d","w","y","plural","ms","msAbs","n","isPlural","Math","round","val","options","str","String","parseFloat","toLowerCase","isFinite","long","abs","JSON","stringify","formatArgs","useColors","namespace","module","humanize","diff","c","color","splice","index","lastC","replace","save","namespaces","storage","setItem","removeItem","load","r","getItem","DEBUG","__nwjs","navigator","userAgent","document","documentElement","style","WebkitAppearance","console","firebug","exception","table","localStorage","destroy","warned","warn","colors","log","debug","common","createDebug","prevTime","namespacesCache","enabledCache","enableOverride","enabled","self","curr","Number","Date","prev","coerce","unshift","format","formatter","formatters","selectColor","extend","defineProperty","enumerable","configurable","set","v","init","delimiter","newDebug","matchesTemplate","search","template","searchIndex","templateIndex","starIndex","matchIndex","default","stack","disable","names","skips","map","join","enable","split","filter","Boolean","ns","slice","skip","require$$0","keys","forEach","key","hash","charCodeAt","j","ReflectOwnKeys","R","Reflect","ReflectApply","target","receiver","Function","ownKeys","getOwnPropertySymbols","getOwnPropertyNames","NumberIsNaN","isNaN","EventEmitter","eventsModule","emitter","Promise","resolve","reject","errorListener","err","resolver","eventTargetAgnosticAddListener","handler","flags","_events","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","TypeError","_getMaxListeners","that","_addListener","prepend","events","existing","warning","create","newListener","count","onceWrapper","fired","wrapFn","_onceWrap","state","wrapped","bind","_listeners","unwrap","evlistener","arr","ret","arrayClone","listenerCount","copy","addEventListener","wrapListener","arg","removeEventListener","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","doError","er","context","list","position","originalListener","shift","pop","rawListeners","eventNames","wrappy","wrappy_1","fn","cb","k","wrapper","f","called","onceStrict","onceError","onceModule","strict","proto","promise","queueMicrotask_1","queueMicrotask","global","then","catch","runParallel_1","tasks","results","pending","isSync","isArray","each","result","task","scope","RTCPeerConnection","mozRTCPeerConnection","webkitRTCPeerConnection","RTCSessionDescription","mozRTCSessionDescription","webkitRTCSessionDescription","RTCIceCandidate","mozRTCIceCandidate","webkitRTCIceCandidate","FixedFIFO","fixedSize","hwm","buffer","mask","top","btm","next","clear","fill","undefined","last","peek","isEmpty","fastFifo","head","tail","browserDecoder","encoding","decoder","TextDecoder","remaining","decode","stream","flush","Uint8Array","PassThroughDecoder","UTF8Decoder","require$$1","textDecoder","_default","STREAM_DESTROYED","PREMATURE_CLOSE","FIFO","require$$2","qmt","MAX","NOT_OPENING","NOT_PREDESTROYING","READ_UPDATING","READ_PRIMARY","READ_QUEUED","READ_RESUMED","READ_ENDING","READ_EMIT_DATA","READ_EMIT_READABLE","READ_EMITTED_READABLE","READ_DONE","READ_NEXT_TICK","READ_READ_AHEAD","READ_RESUMED_READ_AHEAD","READ_NOT_ACTIVE","READ_PUSHED","READ_PIPE_NOT_DRAINED","READ_NOT_NEXT_TICK","READ_NO_READ_AHEAD","WRITE_ACTIVE","WRITE_UPDATING","WRITE_PRIMARY","WRITE_QUEUED","WRITE_UNDRAINED","WRITE_DONE","WRITE_EMIT_DRAIN","WRITE_NEXT_TICK","WRITE_WRITING","WRITE_FINISHING","WRITE_CORKED","WRITE_NON_PRIMARY","WRITE_NOT_NEXT_TICK","WRITE_NOT_CORKED","ACTIVE","READ_ACTIVE","NOT_ACTIVE","DONE","DESTROY_STATUS","DESTROYING","OPEN_STATUS","AUTO_DESTROY","ACTIVE_OR_TICKING","IS_OPENING","WRITE_QUEUED_AND_ACTIVE","WRITE_STATUS","asyncIterator","Symbol","WritableState","highWaterMark","mapWritable","byteLengthWritable","buffered","pipeline","drains","defaultByteLength","afterWrite","afterUpdateNextTick","updateWriteNT","_duplexState","_writableState","_writev","update","_write","updateNonPrimary","continueUpdate","_final","afterFinal","_open","afterOpen","_destroy","afterDestroy","updateNextTick","ReadableState","mapReadable","byteLengthReadable","readAhead","pipeTo","afterRead","updateReadNT","Pipeline","isStreamx","finished","onerror","onclose","afterDrain","write","drain","_read","updateCallback","updateNextTickIfOpen","TransformState","afterTransform","src","dst","afterPipe","pipeToFinished","rs","_readableState","ws","writes","Stream","opts","open","predestroy","_predestroy","readable","destroyed","Readable","OPENING","eagerOpen","setEncoding","dec","echo","dest","pipe","resume","ite","return","_fromAsyncIterator","promiseResolve","promiseReject","ondata","throw","Writable","writev","final","cork","uncork","batch","autoBatch","Duplex","min","Transform","_transformState","transform","_transform","_flush","transformAfterFlush","streams","all","errorHandle","fin","autoDestroy","rd","wr","ended","isStream","streamx","pipelinePromise","isEnded","isFinished","isDisturbed","getStreamError","PassThrough","assign","obj","props","errCode","code","_","ErrClass","alphabet","encodeLookup","decodeLookup","arr2hex","string","hex2arr","sizeof","chars","lookup","arr2text","enc","encoder","TextEncoder","text2arr","encode","bin2hex","res","hex2bin","hex","points","fromCharCode","subarray","crypto","msCrypto","subtle","webkitSubtle","randomBytes","size","view","getRandomValues","Debug","MAX_BUFFERED_AMOUNT","filterTrickle","sdp","Peer","_pc","allowHalfOpen","__objectMode","objectMode","_id","_debug","channelName","initiator","channelConfig","channelNegotiated","negotiated","config","offerOptions","answerOptions","sdpTransform","trickle","allowHalfTrickle","iceCompleteTimeout","_destroying","_connected","remoteAddress","remoteFamily","remotePort","localAddress","localFamily","localPort","_pcReady","_channelReady","_iceComplete","_iceCompleteTimer","_channel","_pendingCandidates","_isNegotiating","_firstNegotiation","_batchedNegotiation","_queuedNegotiation","_sendersAwaitingStable","_closingInterval","_remoteTracks","_remoteStreams","_chunk","_cb","_interval","__destroy","_isReactNativeWebrtc","_peerConnectionId","oniceconnectionstatechange","_onIceStateChange","onicegatheringstatechange","onconnectionstatechange","_onConnectionStateChange","onsignalingstatechange","_onSignalingStateChange","onicecandidate","event","_onIceCandidate","peerIdentity","_setupData","channel","createDataChannel","ondatachannel","_needsNegotiation","_onFinishBound","_onFinish","bufferSize","bufferedAmount","connected","readyState","address","port","family","parse","renegotiate","transceiverRequest","addTransceiver","kind","candidate","remoteDescription","_addIceCandidate","setRemoteDescription","_createAnswer","iceCandidateObj","addIceCandidate","endsWith","send","negotiate","_createOffer","_senderMap","clearInterval","close","onmessage","onopen","ontrack","binaryType","bufferedAmountLowThreshold","label","_onChannelMessage","onbufferedamountlow","_onChannelBufferedAmountLow","_onChannelOpen","_onChannelClose","filename","lineno","colno","isClosing","setInterval","destroySoon","_startIceCompleteTimeout","createOffer","offer","sendOffer","localDescription","setLocalDescription","createAnswer","answer","sendAnswer","_requestMissingTransceivers","connectionState","iceConnectionState","iceGatheringState","_maybeReady","flattenValues","report","toString","values","getStats","reports","stat","id","_connecting","findCandidatePair","items","remoteCandidates","localCandidates","candidatePairs","foundSelectedCandidatePair","item","setSelectedCandidatePair","selectedCandidatePair","local","localCandidateId","ip","ipAddress","portNumber","googLocalAddress","includes","remote","remoteCandidateId","googRemoteAddress","selectedCandidatePairId","googActiveConnection","selected","_onInterval","unref","signalingState","sender","removeTrack","sdpMLineIndex","sdpMid","ArrayBuffer","WEBRTC_SUPPORT","iceServers","urls","sdpSemantics","UDPTracker","DEFAULT_ANNOUNCE_PEERS","MAX_ANNOUNCE_PEERS","parseUrl","URL","defineProperties","href","protocol","origin","_WebSocket","WebSocket","Socket","socket","_ws","OPEN","_handleOpen","_handleMessage","_handleClose","_handleError","_handleFinishBound","_handleFinish","onClose","CLOSED","WEBSOCKET_SUPPORT","Tracker","client","announceUrl","interval","intervalMs","DEFAULT_ANNOUNCE_INTERVAL","announce","_defaultAnnounceOpts","socketPool","WebSocketTracker","peers","reconnecting","retries","reconnectTimer","expectingResponse","_openSocket","params","action","info_hash","_infoHashBinary","peer_id","_peerIdBinary","_trackerId","trackerid","_send","numwant","_generateOffers","offers","scrape","infoHash","peerId","peer","trackerTimeout","_onSocketConnectBound","_onSocketDataBound","_onSocketCloseBound","_onSocketErrorBound","consumers","destroyCleanup","DESTROY_TIMEOUT","_onSocketConnect","_onSocketError","_onSocketData","_onSocketClose","parsedUrl","agent","_proxyOpts","httpsAgent","httpAgent","socksProxy","_onAnnounceResponse","_onScrapeResponse","failure","trackerId","complete","_createPeer","to_peer_id","offer_id","offerId","files","_startReconnectTimer","floor","random","pow","generateOffer","checkDone","_rtcConfig","wrtc","_wrtc","onError","onConnect","_socketPool","Client","_peerIdBuffer","_infoHashBuffer","_port","_getAnnounceOpts","getAnnounceOpts","rtcConfig","_userAgent","proxyOpts","isView","substring","Set","webrtcSupport","nextTickWarn","_trackers","HTTPTracker","location","_announce","tracker","parallel","uploaded","downloaded","clientOpts","FF","a","b","GG","HH","II","byteToHex","byte","substr","bs","wordToBytes","word","utf8toBytes","utf8","unescape","encodeURIComponent","md5Module","utf8toMD5","toHex","bytesToMD5","fromBytes","bytes","words","bytes_count","bits_count","Uint32Array","AA","BB","CC","DD","hash_bytes","fromUtf8","b64","to64","u","charAt","b64_map","gen_salt","salt","crypt","setting","md","kl","TRACKER_CLIENT_VERSION_PREFIX","versionString","splittedVersion","padStart","HASH_SYMBOLS","getStreamString","getSegmentString","externalId","joinChunks","chunks","reduce","sum","offset","utf8ToUintArray","utf8String","encodeInto","arrayBackwards","isObject","deepCopy","element","overrideConfig","updates","defaults","keyStr","updateValue","defaultValue","mergeAndFilterConfig","defaultConfig","baseConfig","specificStreamConfig","mergedConfig","keysOfT","filteredConfig","PeerCommandType","SerializedItem","intToBytes","num","isNegative","bytesAmountNumber","binaryString","necessaryBits","ceil","bytesAmount","BigInt","bytesToInt","getNumberPart","number","serializeInt","numBytes","numberMetadata","deserializeInt","metadata","numberBytesLength","deserializeSimilarIntArray","codeByte","commonPartArraysAmount","originalIntArr","commonPartWithLength","arrayLength","commonPart","diffPart","numbers","deserializeString","lengthByte","stringBytes","ResizableUint8Array","_length","addBytes","bytesToAdd","getBuffer","commandFrameStart","stringToUtf8CodesBuffer","commandFrameEnd","commandDivFrameStart","commandDivFrameEnd","startFrames","endFrames","commandFramesLength","isCommandChunk","bufferEndingToCompare","some","frame","areBuffersEqual","BinaryCommandJoiningError","BinaryCommandChunksJoiner","onComplete","Serialization.ResizableUint8Array","isFirstChunk","unframeCommandChunk","BinaryCommandCreator","commandType","maxChunkLength","resultBuffers","Serialization.serializeInt","commonPartNumbersMap","Map","diffByte","binaryArray","getBytesChunks","unframedBuffer","frameBuffer","chunksCount","chunkLength","getResultBuffers","deserializeCommand","commandCode","deserializedCommand","getDataTypeFromByte","Serialization.SerializedItem","Int","Serialization.deserializeInt","SimilarIntArray","Serialization.deserializeSimilarIntArray","Serialization.deserializeString","typeCode","Min","Max","frameStart","frameEnd","buffer1","buffer2","serializePeerCommand","command","maxChunkSize","CancelSegmentRequest","SegmentAbsent","SegmentDataSendingCompleted","creator","addInteger","SegmentRequest","SegmentsAnnouncement","p","loadingByHttp","l","loaded","addSimilarIntArr","SegmentData","PeerProtocol","connection","peerConfig","eventHandlers","onChunkUploaded","onDataReceived","commandChunks","uploadingContext","Command.isCommandChunk","receivingCommandBytes","onSegmentChunkReceived","idUtf8","binaryCommandBuffers","Command.serializePeerCommand","webRtcMaxMessageSize","stopUploadingSegmentData","stopUploading","getUploadingRequestId","requestId","bytesLeft","bytesToSend","rej","Utils.getControlledPromise","isUploadingSegmentData","sendChunk","drained","Command.BinaryCommandChunksJoiner","commandBuffer","Command.deserializeCommand","onCommandReceived","addCommandChunk","Command.BinaryCommandJoiningError","Command","streamType","onPeerClosed","getPeerIdFromConnection","peerProtocol","onConnectionError","onPeerConnectionClosed","downloadingContext","loadedSegments","httpLoadingSegments","downloadingErrors","logger","downloadingSegment","has","onSegmentsAnnouncement","onSegmentRequested","isSegmentDataCommandReceived","controls","sendCancelSegmentRequestCommand","cancelSegmentDownloading","isValid","validateP2PSegment","delete","segmentRequest","p2pNotReceivingBytesTimeoutMs","p2pErrorRetries","sendCommand","splitSegmentDataToChunksAndUploadAsync","sendSegmentDataSendingCompletedCommand","loadedSegmentsIds","httpLoadingSegmentsIds","segmentExternalId","hexString","isSafariOrWkWebview","isSafari","test","isWkWebview","P2PTrackerClient","streamSwarmId","streamHash","streamId","binary15BytesHashString","md5","btoa","streamShortId","LoggerUtils.getStreamString","PEER_ID_BY_INFO_HASH","trackerClientVersionPrefix","trackerClientId","randomCharsCount","TrackerClient","announceTrackers","onReceivePeerConnection","onTrackerClientWarning","onTrackerClientError","static","_peers","potentialConnections","peerConnection","itemId","peerItem","add","onPeerConnected","clearPeerIdCache","getStreamSwarmId","swarmId","getSegmentFromStreamsMap","segmentRuntimeId","segments","getSegmentPlaybackStatuses","playback","timeWindowsConfig","currentP2PLoader","availableMemoryPercent","highDemandTimeWindow","httpDownloadTimeWindow","p2pDownloadTimeWindow","availableMemoryInPercent","isHighDemand","isSegmentInTimeWindow","isHttpDownloadable","isP2PDownloadable","isSegmentLoadingOrLoadedBySomeone","timeWindowLength","startTime","endTime","rate","P2PLoader","streamManifestUrl","requests","segmentStorage","onSegmentAnnouncement","StreamUtils.getStreamSwarmId","trackerClient","broadcastAnnouncement","setSegmentChangeCallback","dispatchEvent","isAnnounceMicrotaskCreated","peersWithSegment","getSegmentStatus","getOrCreateRequest","downloadSegment","connectedPeerCount","iterator","getSegmentsAnnouncement","getStoredSegmentIds","httpLoading","httpRequests","runtimeId","isP2PUploadDisabled","sendSegmentsAnnouncementCommand","sendEmptyAnnouncement","sendSegmentsAnnouncement","byteFrom","sendSegmentAbsentCommand","segmentData","getSegmentData","uploadSegmentData","P2PLoadersContainer","_currentLoaderItem","findOrCreateLoaderForStream","loaders","loader","loggerInfo","loaderItem","destroyTimeoutId","createLoader","setLoaderDestroyTimeout","destroyAndRemoveLoader","p2pInactiveLoaderDestroyTimeoutMs","currentLoader","mapSegmentWithStreamToSegment","Request$1","requestProcessQueueCallback","bandwidthCalculators","playbackConfig","onSegmentError","onSegmentAbort","onSegmentStart","onSegmentLoaded","_totalBytes","notReceivingBytesTimeout","Timeout","abortOnTimeout","_logger","currentAttempt","_failedAttempts","FailedRequestAttempts","finalData","_loadedBytes","_status","progress","_abortRequestCallback","_isHandledByProcessQueue","Utils.joinChunks","isHandledByProcessQueue","markHandledByProcessQueue","requestData","setStatus","startFromByte","startTimestamp","manageBandwidthCalculatorsState","throwErrorIfNotLoadingStatus","segmentUrl","bytesLength","restart","allBC","http","httpBC","lastLoadedChunkTimestamp","method","attempts","attempt","lastAttempt","timeoutId","RequestsContainer","executingHttpCount","executingP2PCount","p2pRequests","abortFromProcessQueue","EngineRequest","engineCallbacks","_shouldBeStartedImmediately","shouldBeStartedImmediately","bandwidth","onSuccess","markAsShouldBeStartedImmediately","generateQueue","lastRequestedSegment","availablePercentMemory","requestedSegment","queueSegments","first","firstStatuses","isNotActualStatuses","second","secondStatuses","statuses","HybridLoader","streamDetails","activeStream","segmentAvgDuration","sumDuration","requestProcessQueueMicrotask","p2pLoaders","setIntervalLoading","engineRequest","storageCleanUpIntervalId","levelChangedTimestamp","lastQueueProcessingTimeStamp","randomHttpDownloadInterval","isProcessQueueMicrotaskCreated","peersCount","randomTimeout","loadRandomThroughHttp","callbacks","LoggerUtils.getSegmentString","changeCurrentLoader","isLive","hasSegment","queueDownloadRatio","getBandwidth","force","processQueue","queueSegmentIds","httpErrorRetries","remove","storeSegment","failedAttempts","httpAttemptsCount","processRequests","simultaneousHttpDownloads","simultaneousP2PDownloads","loadThroughHttp","isP2PLoadingRequest","abortLastHttpLoadingInQueueAfterItem","loadThroughP2P","abortLastP2PLoadingInQueueAfterItem","isSegmentLoadedBySomeone","availableStorageCapacityPercent","getAvailableStorageCapacityPercent","p2pLoader","segmentsToLoad","QueueUtils.generateQueue","safeRandomSegmentsCount","randomIndices","probability","randomIndex","itemSegment","Utils.arrayBackwards","totalCapacity","usedCapacity","getUsage","maxPossibleLength","alreadyLoadedCount","activeLevelBitrate","getBandwidthLoadingOnly","max","httpRealBandwidth","notifyLevelChanged","sendEmptySegmentsAnnouncement","isRateChanged","isPositionChanged","isPositionSignificantlyChanged","onPlaybackUpdated","BandwidthCalculator","clearThresholdMs","loadingsCount","loadingOnlyTimestamps","timestamps","noLoadingsTime","loadingsStoppedAt","clearStale","seconds","ignoreThresholdTimestamp","NEGATIVE_INFINITY","milliseconds","lastItemTimestamp","lastCountedTimestamp","threshold","samplesToRemove","getStorageItemId","segmentId","BYTES_PER_MiB","SegmentMemoryStorage","segmentMemoryStorageLimit","currentStorageUsage","cache","coreConfig","mainStreamConfig","secondaryStreamConfig","currentPlayback","segmentChangeCallback","constructor","setMemoryStorageLimit","isLiveStream","_swarmId","storageId","increaseStorageUsage","segmentStorageId","dataItem","playbackPosition","calculatedUsedCapacity","externalIds","streamCacheId","newSegmentSize","isMemoryLimitReached","affectedStreams","sortedCache","sort","shouldRemoveSegment","decreaseStorageUsage","sendUpdatesToAffectedStreams","segmentByteLength","callback","currentPlaybackPosition","getStreamTimeWindow","configKey","EventTarget","eventName","definedListeners","indexOf","Core","customSegmentStorageFactory","isP2PDisabled","manifestResponseUrl","commonCoreConfig","mainStreamLoader","secondaryStreamLoader","DEFAULT_COMMON_CORE_CONFIG","DEFAULT_STREAM_CONFIG","mainStream","secondaryStream","dynamicConfig","mainStreamConfigCopy","secondaryStreamConfigCopy","overrideAllConfigs","processSpecificDynamicConfigParams","prevConfig","updatedConfig","getUpdatedStreamProperty","destroyStreamLoader","sendBroadcastAnnouncement","propertyName","StreamUtils.getSegmentFromStreamsMap","streamRuntimeId","addSegments","removeSegmentIds","updateStream","initializeSegmentStorage","identifySegment","getStreamHybridLoader","loadSegment","abortSegmentRequest","updatePlayback","bitrate","createCustomStorage","initialize","createNewHybridLoader","streamConfig"],"mappings":"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","x_google_ignoreList":[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,24,25,26,27,28,29]}