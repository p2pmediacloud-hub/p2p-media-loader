import { CoreRequestError as I, debug as k, Core as x } from "p2p-media-loader-core";
function M(o, t) {
  return t ? `${o}|${t.start}-${t.end}` : o;
}
function C(o, t) {
  if (o !== void 0 && t !== void 0 && o <= t) return { start: o, end: t };
}
class T {
  context;
  config;
  stats;
  #t;
  #a;
  #e;
  #i;
  #s;
  #n;
  constructor(t, e) {
    this.#i = e, this.#a = () => new t.loader(t), this.stats = { aborted: !1, chunkCount: 0, loading: { start: 0, first: 0, end: 0 }, buffering: { start: 0, first: 0, end: 0 }, parsing: { start: 0, end: 0 }, total: 1, loaded: 1, bwEstimate: 0, retry: 0 };
  }
  load(t, e, s) {
    this.context = t, this.config = e, this.#t = s;
    const { stats: a } = this, { rangeStart: d, rangeEnd: i } = t, n = C(d, i !== void 0 ? i - 1 : void 0);
    this.#n = M(t.url, n);
    const r = this.#i.isSegmentLoadable(this.#n);
    if (!this.#i.hasSegment(this.#n) || !r) return this.#e = this.#a(), this.#e.stats = this.stats, void this.#e.load(t, e, s);
    this.#i.loadSegment(this.#n, { onSuccess: (c) => {
      this.#s = c;
      const l = this.#s.data.byteLength;
      a.loading = (function(f, m, g) {
        const v = 8e3 * m / f, p = g - v;
        return { start: p - 10, first: p, end: g };
      })(this.#s.bandwidth, l, performance.now()), a.total = l, a.loaded = l, s.onProgress && s.onProgress(this.stats, t, this.#s.data, void 0), s.onSuccess({ data: this.#s.data, url: t.url }, this.stats, t, void 0);
    }, onError: (c) => {
      c instanceof I && c.type === "aborted" && this.stats.aborted || this.#o(c);
    } });
  }
  #o(t) {
    const e = { code: 0, text: "" };
    (t instanceof I && t.type === "failed" || t instanceof Error) && (e.text = t.message), this.#t?.onError(e, this.context, null, this.stats);
  }
  #r() {
    !this.#s && this.#n && (this.stats.aborted = !0, this.#i.abortSegmentLoading(this.#n));
  }
  abort() {
    this.#e ? this.#e.abort() : (this.#r(), this.#t?.onAbort?.(this.stats, this.context, {}));
  }
  destroy() {
    this.#e ? this.#e.destroy() : (this.stats.aborted || this.#r(), this.#t = null, this.config = null);
  }
}
class P {
  #t;
  context;
  stats;
  constructor(t) {
    this.#t = new t.loader(t), this.stats = this.#t.stats, this.context = this.#t.context;
  }
  load(t, e, s) {
    this.#t.load(t, e, s);
  }
  abort() {
    this.#t.abort();
  }
  destroy() {
    this.#t.destroy();
  }
}
class R {
  core;
  constructor(t) {
    this.core = t;
  }
  processMainManifest(t) {
    const { levels: e, audioTracks: s } = t;
    for (const [a, d] of e.entries()) {
      const { url: i } = d;
      this.core.addStreamIfNoneExists({ runtimeId: Array.isArray(i) ? i[0] : i, type: "main", index: a });
    }
    for (const [a, d] of s.entries()) {
      const { url: i } = d;
      this.core.addStreamIfNoneExists({ runtimeId: Array.isArray(i) ? i[0] : i, type: "secondary", index: a });
    }
  }
  updatePlaylist(t) {
    const { details: { url: e, fragments: s, live: a } } = t, d = this.core.getStream(e);
    if (!d) return;
    const i = new Set(d.segments.keys()), n = [];
    s.forEach((r, c) => {
      const { url: l, byteRange: f, sn: m, start: g, end: v } = r, [p, y] = f, S = C(p, y !== void 0 ? y - 1 : void 0), w = M(l, S);
      i.delete(w), d.segments.has(w) || n.push({ runtimeId: w, url: l, externalId: a ? m : c, byteRange: S, startTime: g, endTime: v });
    }), (n.length || i.size) && this.core.updateStream(e, n, i.values());
  }
}
const H = "dXNlckNvZGVz", h = "d3NzOi8v", b = "czEu", u = "Y2RudHJhY2tlcnMuY29t", E = "bjEu", L = "dDEu", U = ["X1", "Y2", "Z3"];
function A() {
  switch ((function() {
    const o = -(/* @__PURE__ */ new Date()).getTimezoneOffset() / 60, t = document.cookie.split("; ").find((a) => a.startsWith(atob(H) + "=")), e = t ? t.split("=")[1] : null;
    if (e && U.includes(e)) return e;
    const s = o >= -11 && o <= -2 ? "X1" : o >= -1 && o <= 3 ? "Y2" : "Z3";
    return document.cookie = atob(H) + `=${s};path=/;max-age=86400`, s;
  })()) {
    case "X1":
      return { p1: [h + L + u].map(atob) };
    case "Y2":
    default:
      return { p1: [h + E + u].map(atob) };
    case "Z3":
      return { p1: [h + b + u].map(atob) };
  }
}
class D {
  core;
  segmentManager;
  hlsInstanceGetter;
  currentHlsInstance;
  debug = k("p2pml-hlsjs:engine");
  downloaded = 0;
  downloaded_total = 0;
  clientId;
  lastLogTime = 0;
  lastSource = null;
  startTime = Date.now();
  static injectMixin(t) {
    return e = t, class extends e {
      #t;
      get p2pEngine() {
        return this.#t;
      }
      constructor(...s) {
        const a = s[0], { p2p: d, ...i } = a ?? {}, n = new D(d);
        super({ ...i, ...n.getConfigForHlsJs() }), n.bindHls(this), this.#t = n, d?.onHlsJsCreated?.(this);
      }
    };
    var e;
  }
  constructor(t) {
    if (!t?.surl) throw new Error("p2p.surl (base64 domain) is required in configuration!");
    this.clientId = localStorage.getItem("clientId") || `client-${Math.random().toString(36).substr(2, 10)}-${Date.now()}`, localStorage.setItem("clientId", this.clientId);
    let e = (t?.core?.mode === "fast" ? { p1: [h + b + u, h + E + u, h + L + u].map(atob) } : A()).p1;
    if (t?.core?.nSpeed !== void 0) e = (function(n, r = 2) {
      return n.slice(0, r);
    })(e, t.core.nSpeed);
    else if (t?.core?.randomEndpoint) e = [(s = e)[Math.floor(Math.random() * s.length)]];
    else if (t?.core?.xSpeed !== void 0) e = (function(n, r = 0) {
      return r >= 0 && r < n.length ? [n[r]] : n;
    })(e, t.core.xSpeed);
    else if (t?.core?.vSpeed) switch (t.core.vSpeed) {
      case "s1":
        e = [atob(h + b + u)];
        break;
      case "n1":
        e = [atob(h + E + u)];
        break;
      case "t1":
        e = [atob(h + L + u)];
    }
    var s;
    const a = { ...t?.core || {}, announceTrackers: e };
    this.core = new x(a), this.segmentManager = new R(this.core);
    const d = (function(n) {
      if (!n) throw new Error("Stats URL domain (surl) is required in p2p config!");
      return atob("aHR0cHM6Ly8=") + atob(n) + atob("L3N0YXRz");
    })(t.surl), i = async () => {
      const n = t?.core?.swarmId || "unknown", r = t?.stop !== void 0 ? 1e3 * t.stop : 48e5;
      if (!(Date.now() - this.startTime >= r || this.downloaded + this.downloaded_total === 0 && Date.now() - this.startTime > 6e4)) try {
        const c = await fetch(d, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ swarmId: n, clientId: this.clientId, p2pBytes: this.downloaded, cdnBytes: this.downloaded_total, timestamp: Date.now() }), keepalive: !0 });
        if (c.ok) {
          const l = await c.json();
          l.success && typeof l.liveViewers == "number" && (window.liveViewers = l.liveViewers);
        }
      } catch {
      }
    };
    this.core.addEventListener("onChunkDownloaded", (n, r, c) => {
      r === "p2p" ? this.downloaded += n : r === "http" && (this.downloaded_total += n);
      const l = Date.now();
      (l - this.lastLogTime >= 5e3 || r !== this.lastSource) && (this.lastLogTime = l, this.lastSource = r, this.debug(`Downloaded ${n} bytes from ${r}${c ? ` (peer: ${c})` : ""}`));
    }), setInterval(i, 3e4), setTimeout(i, 1e4), window.addEventListener("beforeunload", i), window.clientStats = { getClientId: () => this.clientId, getStats: () => ({ p2pBytes: this.downloaded, cdnBytes: this.downloaded_total, total: this.downloaded + this.downloaded_total }), sendImmediate: i };
  }
  addEventListener(t, e) {
    this.core.addEventListener(t, e);
  }
  removeEventListener(t, e) {
    this.core.removeEventListener(t, e);
  }
  getConfigForHlsJs() {
    return { fLoader: this.createFragmentLoaderClass(), pLoader: this.createPlaylistLoaderClass() };
  }
  getConfig() {
    return { core: this.core.getConfig() };
  }
  applyDynamicConfig(t) {
    t.core && this.core.applyDynamicConfig(t.core);
  }
  bindHls(t) {
    this.hlsInstanceGetter = typeof t == "function" ? t : () => t;
  }
  initHlsEvents() {
    const t = this.hlsInstanceGetter?.();
    this.currentHlsInstance !== t && (this.currentHlsInstance && this.destroy(), this.currentHlsInstance = t, this.updateHlsEventsHandlers("register"), this.updateMediaElementEventHandlers("register"));
  }
  updateHlsEventsHandlers(t) {
    const e = this.currentHlsInstance;
    if (!e) return;
    const s = t === "register" ? "on" : "off";
    e[s]("hlsManifestLoaded", this.handleManifestLoaded), e[s]("hlsLevelSwitching", this.handleLevelSwitching), e[s]("hlsLevelUpdated", this.handleLevelUpdated), e[s]("hlsAudioTrackLoaded", this.handleLevelUpdated), e[s]("hlsDestroying", this.destroy), e[s]("hlsMediaAttaching", this.destroyCore), e[s]("hlsManifestLoading", this.destroyCore), e[s]("hlsMediaDetached", this.handleMediaDetached), e[s]("hlsMediaAttached", this.handleMediaAttached);
  }
  updateMediaElementEventHandlers = (t) => {
    const e = this.currentHlsInstance?.media;
    if (!e) return;
    const s = t === "register" ? "addEventListener" : "removeEventListener";
    e[s]("timeupdate", this.handlePlaybackUpdate), e[s]("seeking", this.handlePlaybackUpdate), e[s]("ratechange", this.handlePlaybackUpdate);
  };
  handleManifestLoaded = (t, e) => {
    const s = e.networkDetails;
    s instanceof XMLHttpRequest ? this.core.setManifestResponseUrl(s.responseURL) : s instanceof Response && this.core.setManifestResponseUrl(s.url), this.segmentManager.processMainManifest(e);
  };
  handleLevelSwitching = (t, e) => {
    e.bitrate && this.core.setActiveLevelBitrate(e.bitrate);
  };
  handleLevelUpdated = (t, e) => {
    this.currentHlsInstance && e.details.live && e.details.fragments[0].type === "main" && !this.currentHlsInstance.userConfig.liveSyncDuration && !this.currentHlsInstance.userConfig.liveSyncDurationCount && e.details.fragments.length > 4 && this.updateLiveSyncDurationCount(e), this.core.setIsLive(e.details.live), this.segmentManager.updatePlaylist(e);
  };
  updateLiveSyncDurationCount(t) {
    const e = t.details.targetduration, s = Math.floor(120 / e), a = Math.min(t.details.fragments.length - 1, s);
    this.currentHlsInstance && this.currentHlsInstance.config.liveSyncDurationCount !== a && (this.debug(`Setting liveSyncDurationCount to ${a}`), this.currentHlsInstance.config.liveSyncDurationCount = a);
  }
  handleMediaAttached = () => {
    this.updateMediaElementEventHandlers("register");
  };
  handleMediaDetached = () => {
    this.updateMediaElementEventHandlers("unregister");
  };
  handlePlaybackUpdate = (t) => {
    const e = t.target;
    this.core.updatePlayback(e.currentTime, e.playbackRate);
  };
  destroyCore = () => this.core.destroy();
  destroy = () => {
    this.destroyCore(), this.updateHlsEventsHandlers("unregister"), this.updateMediaElementEventHandlers("unregister"), this.currentHlsInstance = void 0;
  };
  createFragmentLoaderClass() {
    const { core: t } = this, e = this;
    return class extends T {
      constructor(s) {
        super(s, t);
      }
      static getEngine() {
        return e;
      }
    };
  }
  createPlaylistLoaderClass() {
    const t = this;
    return class extends P {
      constructor(e) {
        super(e), t.initHlsEvents();
      }
    };
  }
}
export {
  D as HlsJsP2PEngine
};
//# sourceMappingURL=p2p-media-loader-hlsjs.es.min.js.map
