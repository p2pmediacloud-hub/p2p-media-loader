{"version":3,"file":"p2p-media-loader-core.es.js","sources":["../src/types.ts","../src/http-loader.ts","../../../node_modules/.pnpm/vite-plugin-node-polyfills@0.24.0_rollup@4.53.2_vite@7.2.2_@types+node@24.10.1_terser@5.44.1_yaml@2.8.1_/node_modules/vite-plugin-node-polyfills/shims/process/dist/index.js","../../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js","../../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/common.js","../../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/browser.js","../../../node_modules/.pnpm/events@3.3.0/node_modules/events/events.js","../../../node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js","../../../node_modules/.pnpm/once@1.4.0/node_modules/once/once.js","../../../node_modules/.pnpm/queue-microtask@1.2.3/node_modules/queue-microtask/index.js","../../../node_modules/.pnpm/run-parallel@1.2.0/node_modules/run-parallel/index.js","../../../node_modules/.pnpm/webrtc-polyfill@1.1.10/node_modules/webrtc-polyfill/browser.js","../../../node_modules/.pnpm/events-universal@1.0.1/node_modules/events-universal/default.js","../../../node_modules/.pnpm/fast-fifo@1.3.2/node_modules/fast-fifo/fixed-size.js","../../../node_modules/.pnpm/fast-fifo@1.3.2/node_modules/fast-fifo/index.js","../../../node_modules/.pnpm/text-decoder@1.2.3/node_modules/text-decoder/lib/browser-decoder.js","../../../node_modules/.pnpm/text-decoder@1.2.3/node_modules/text-decoder/index.js","../../../node_modules/.pnpm/streamx@2.23.0/node_modules/streamx/index.js","../../../node_modules/.pnpm/err-code@3.0.1/node_modules/err-code/index.js","../../../node_modules/.pnpm/uint8-util@2.2.5/node_modules/uint8-util/util.js","../../../node_modules/.pnpm/base64-arraybuffer@1.0.2/node_modules/base64-arraybuffer/dist/base64-arraybuffer.es5.js","../../../node_modules/.pnpm/uint8-util@2.2.5/node_modules/uint8-util/browser.js","../../../node_modules/.pnpm/@thaunknown+simple-peer@10.0.12/node_modules/@thaunknown/simple-peer/lite.js","../__vite-browser-external","../../../node_modules/.pnpm/bittorrent-tracker@11.2.2/node_modules/bittorrent-tracker/lib/common.js","../../../node_modules/.pnpm/@thaunknown+simple-websocket@9.1.3_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@thaunknown/simple-websocket/index.js","../../../node_modules/.pnpm/bittorrent-tracker@11.2.2/node_modules/bittorrent-tracker/lib/client/tracker.js","../../../node_modules/.pnpm/bittorrent-tracker@11.2.2/node_modules/bittorrent-tracker/lib/client/websocket-tracker.js","../../../node_modules/.pnpm/bittorrent-tracker@11.2.2/node_modules/bittorrent-tracker/client.js","../../../node_modules/.pnpm/nano-md5@1.0.5/node_modules/nano-md5/md5.js","../src/utils/version.ts","../src/utils/peer.ts","../src/utils/logger.ts","../src/utils/utils.ts","../src/p2p/commands/types.ts","../src/p2p/commands/binary-serialization.ts","../src/p2p/commands/binary-command-creator.ts","../src/p2p/commands/commands.ts","../src/p2p/peer-protocol.ts","../src/p2p/peer.ts","../src/p2p/tracker-client.ts","../src/utils/stream.ts","../src/p2p/loader.ts","../src/p2p/loaders-container.ts","../src/requests/request.ts","../src/requests/request-container.ts","../src/requests/engine-request.ts","../src/utils/queue.ts","../src/hybrid-loader.ts","../src/bandwidth-calculator.ts","../src/segment-storage/utils.ts","../src/segment-storage/segment-memory-storage.ts","../src/utils/event-target.ts","../src/core.ts"],"sourcesContent":["import { SegmentStorage } from \"./segment-storage/index.js\";\n\n/** Represents the types of streams available, either primary (main) or secondary. */\nexport type StreamType = \"main\" | \"secondary\";\n\n/** Represents a range of bytes, used for specifying a segment of data to download. */\nexport type ByteRange = {\n  /** The starting byte index of the range. */\n  start: number;\n  /** The ending byte index of the range. */\n  end: number;\n};\n\n/** Describes a media segment with its unique identifiers, location, and timing information. */\nexport type Segment = {\n  /** A runtime identifier for the segment that includes URL and byte range from its manifest. */\n  readonly runtimeId: string;\n\n  /** An unique identifier of the segment in its stream used for P2P communications: sequence number for HLS or playtime for MPEG-DASH. */\n  readonly externalId: number;\n\n  /** The URL from which the segment can be downloaded. */\n  readonly url: string;\n\n  /** An optional property specifying the range of bytes that represent the segment. */\n  readonly byteRange?: ByteRange;\n\n  /** The start time of the segment in seconds, relative to the beginning of the stream. */\n  readonly startTime: number;\n\n  /** The end time of the segment in seconds, relative to the beginning of the stream. */\n  readonly endTime: number;\n};\n\n/** Extends a Segment with a reference to its associated stream. */\nexport type SegmentWithStream<TStream extends Stream = Stream> = Segment & {\n  readonly stream: StreamWithSegments<TStream>;\n};\n\n/**\n * Represents a stream that includes multiple segments, each associated with the stream.\n * @template TStream Type of the underlying stream data structure.\n */\nexport type StreamWithSegments<TStream extends Stream = Stream> = TStream & {\n  readonly segments: Map<string, SegmentWithStream<TStream>>;\n};\n\n/** Represents a media stream with various defining characteristics. */\nexport type Stream = {\n  /** Runtime identifier of the stream from an engine. */\n  readonly runtimeId: string;\n\n  /** Stream type. */\n  readonly type: StreamType;\n\n  /** Stream index in the manifest. */\n  readonly index: number;\n};\n\n/** Represents a defined Core configuration with specific settings for the main and secondary streams. */\nexport type DefinedCoreConfig = CommonCoreConfig & {\n  /** Configuration for the main stream. */\n  mainStream: StreamConfig;\n  /** Configuration for the secondary stream. */\n  secondaryStream: StreamConfig;\n};\n\n/** Represents a set of properties that can be dynamically modified at runtime. */\nexport type DynamicStreamProperties =\n  | \"highDemandTimeWindow\"\n  | \"httpDownloadTimeWindow\"\n  | \"p2pDownloadTimeWindow\"\n  | \"simultaneousHttpDownloads\"\n  | \"simultaneousP2PDownloads\"\n  | \"webRtcMaxMessageSize\"\n  | \"p2pNotReceivingBytesTimeoutMs\"\n  | \"p2pInactiveLoaderDestroyTimeoutMs\"\n  | \"httpNotReceivingBytesTimeoutMs\"\n  | \"httpErrorRetries\"\n  | \"p2pErrorRetries\"\n  | \"validateP2PSegment\"\n  | \"httpRequestSetup\"\n  | \"isP2PDisabled\"\n  | \"isP2PUploadDisabled\";\n\n/**\n * Represents a dynamically modifiable configuration, allowing updates to selected CoreConfig properties at runtime.\n *\n * @example\n * ```typescript\n * const dynamicConfig: DynamicCoreConfig = {\n *   core: {\n *     cachedSegmentsCount: 200,\n *   },\n *   mainStream: {\n *     swarmId: \"custom swarm ID for video stream\",\n *     p2pDownloadTimeWindow: 6000,\n *   },\n *   secondaryStream: {\n *     swarmId: \"custom swarm ID for audio stream\",\n *     p2pDownloadTimeWindow: 3000,\n *   }\n * };\n * ```\n */\nexport type DynamicCoreConfig = Partial<\n  Pick<CoreConfig, DynamicStreamProperties>\n> &\n  Partial<CommonCoreConfig> & {\n    /** Optional dynamic configuration for the main stream. */\n    mainStream?: DynamicStreamConfig;\n    /** Optional dynamic configuration for the secondary stream. */\n    secondaryStream?: DynamicStreamConfig;\n  };\n\n/** Represents a partial configuration for a stream with dynamic properties. */\nexport type DynamicStreamConfig = Partial<\n  Pick<StreamConfig, DynamicStreamProperties>\n>;\n\n/** Represents the configuration for the Core functionality that is common to all streams. */\nexport type CommonCoreConfig = {\n  /**\n   * Defines the memory storage limit for media segments, in MiB.\n   *\n   * @default\n   * ```typescript\n   * segmentMemoryStorageLimit: undefined\n   * ```\n   *\n   * - When `undefined`, the default limit is determined based on the device type and browser:\n   *    - Desktop: 4096 MiB\n   *    - Android: 2048 MiB\n   *    - iOS: 1024 MiB\n   *    - Android WebView: 1024 MiB\n   *    - iOS WebView: 1024 MiB\n   *\n   */\n  segmentMemoryStorageLimit: number | undefined;\n\n  /**\n   * Optional custom storage factory for the segments storage.\n   *\n   * @default\n   * ```typescript\n   * customSegmentStorageFactory: undefined\n   * ```\n   */\n  customSegmentStorageFactory?: (isLive: boolean) => SegmentStorage;\n};\n\n/**\n * Represents a set of configuration parameters that can be used to override or extend the\n * default configuration settings for a specific stream (main or secondary).\n *\n * @example Configuration for basic video stream\n *\n * ```typescript\n * const config: CoreConfig = {\n *  highDemandTimeWindow: 15,\n *  httpDownloadTimeWindow: 3000,\n *  p2pDownloadTimeWindow: 6000,\n *  swarmId: \"custom swarm ID for video stream\",\n * }\n * ```\n *\n * @example Configuration for advanced video stream\n *\n * ```typescript\n * const config: CoreConfig = {\n *  // Configuration for both streams\n *  highDemandTimeWindow: 20,\n *  httpDownloadTimeWindow: 3000,\n *  p2pDownloadTimeWindow: 6000,\n *  mainStream: {\n *   // Optional configuration for the main stream\n *   swarmId: \"custom swarm ID for video stream\",\n *  },\n *  secondaryStream: {\n *   // Optional configuration for the secondary stream\n *   swarmId: \"custom swarm ID for audio stream\",\n *  },\n *  ```\n */\nexport type CoreConfig = Partial<StreamConfig> &\n  Partial<CommonCoreConfig> & {\n    /** Optional configuration for the main stream. */\n    mainStream?: Partial<StreamConfig>;\n    /** Optional configuration for the secondary stream. */\n    secondaryStream?: Partial<StreamConfig>;\n  };\n\n/** Configuration options for the Core functionality, including network and processing parameters. */\nexport type StreamConfig = {\n  /**\n   * Controls if peer-to-peer upload is disabled for the stream.\n   * If `true`, the stream only downloads segments without uploading to peers.\n   *\n   * @default\n   * ```typescript\n   * isP2PUploadDisabled: false\n   * ```\n   */\n  isP2PUploadDisabled: boolean;\n  /**\n   * Controls whether peer-to-peer functionality is disabled for the stream.\n   *\n   * @default\n   * ```typescript\n   * isP2PDisabled: false\n   * ```\n   */\n  isP2PDisabled: boolean;\n  /**\n   * Defines the duration of the time window, in seconds, during which segments are pre-loaded to ensure smooth playback.\n   * This window helps prioritize the fetching of media segments that are imminent to playback.\n   *\n   * @default\n   * ```typescript\n   * highDemandTimeWindow: 15\n   * ```\n   */\n  highDemandTimeWindow: number;\n\n  /**\n   * Defines the time window, in seconds, for HTTP segment downloads. This property specifies the duration\n   * over which media segments are pre-fetched using HTTP requests.\n   *\n   * For a better P2P ratio, it is recommended to set this `httpDownloadTimeWindow` to be lower than `p2pDownloadTimeWindow`.\n   *\n   * NOTE: This setting only takes effect if there is at least one peer connection and the connected peer\n   * does not have the requested segments available to share via P2P.\n   *\n   * @default\n   * ```typescript\n   * httpDownloadTimeWindow: 3000\n   * ```\n   */\n  httpDownloadTimeWindow: number;\n\n  /**\n   * Defines the time window, in seconds, dedicated to pre-fetching media segments via Peer-to-Peer (P2P) downloads.\n   * This duration determines how much content is downloaded in advance using P2P connections to ensure smooth playback and reduce reliance on HTTP downloads.\n   *\n   * For a better P2P ratio, it is recommended to set this time window to be greater than `httpDownloadTimeWindow` to maximize P2P usage.\n   *\n   * @default\n   * ```typescript\n   * p2pDownloadTimeWindow: 6000\n   * ```\n   */\n  p2pDownloadTimeWindow: number;\n\n  /**\n   * Maximum number of simultaneous HTTP downloads allowed.\n   *\n   * @default\n   * ```typescript\n   * simultaneousHttpDownloads: 2\n   * ```\n   */\n  simultaneousHttpDownloads: number;\n\n  /**\n   * Maximum number of simultaneous P2P downloads allowed.\n   *\n   * @default\n   * ```typescript\n   * simultaneousP2PDownloads: 3\n   * ```\n   */\n  simultaneousP2PDownloads: number;\n\n  /**\n   * Maximum message size for WebRTC communications, in bytes.\n   *\n   * @default\n   * ```typescript\n   * webRtcMaxMessageSize: 64 * 1024 - 1\n   * ```\n   */\n  webRtcMaxMessageSize: number;\n\n  /**\n   * Timeout for not receiving bytes from P2P, in milliseconds.\n   *\n   * @default\n   * ```typescript\n   * p2pNotReceivingBytesTimeoutMs: 2000\n   * ```\n   */\n  p2pNotReceivingBytesTimeoutMs: number;\n\n  /**\n   * Timeout for destroying the P2P loader if inactive, in milliseconds.\n   *\n   * @default\n   * ```typescript\n   * p2pInactiveLoaderDestroyTimeoutMs: 30 * 1000\n   * ```\n   */\n  p2pInactiveLoaderDestroyTimeoutMs: number;\n\n  /**\n   * Timeout for not receiving bytes from HTTP downloads, in milliseconds.\n   *\n   * @default\n   * ```typescript\n   * httpNotReceivingBytesTimeoutMs: 3000\n   * ```\n   */\n  httpNotReceivingBytesTimeoutMs: number;\n\n  /**\n   * Number of retries allowed after an HTTP error.\n   *\n   * @default\n   * ```typescript\n   * httpErrorRetries: 3\n   * ```\n   */\n  httpErrorRetries: number;\n\n  /**\n   * Number of retries allowed after a P2P error.\n   *\n   * @default\n   * ```typescript\n   * p2pErrorRetries: 3\n   * ```\n   */\n  p2pErrorRetries: number;\n\n  /**\n   * List of URLs to the WebTorrent trackers used for announcing and discovering peers (i.e. WebRTC signaling).\n   *\n   * WARNING: In the Safari browser, only the first tracker will be used. Safari has issues with multiple trackers,\n   * leading to problems with sending SDP messages for WebRTC signaling.\n   *\n   * @default\n   * The default trackers used are:\n   * ```typescript\n   * [\n   *   \"wss://tracker.novage.com.ua\",\n   *   \"wss://tracker.webtorrent.dev\",\n   *   \"wss://tracker.openwebtorrent.com\",\n   * ]\n   * ```\n   */\n  announceTrackers: string[];\n\n  /**\n   * Configuration for the RTC layer, used in WebRTC communication.\n   * This configuration specifies the STUN/TURN servers used by WebRTC to establish connections through NATs and firewalls.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/RTCConfiguration\n   *\n   * @default\n   * ```json\n   * {\n   *   \"rtcConfig\": {\n   *     \"iceServers\": [\n   *       { \"urls\": \"stun:stun.l.google.com:19302\" },\n   *       { \"urls\": \"stun:global.stun.twilio.com:3478\" }\n   *     ]\n   *   }\n   * }\n   * ```\n   */\n  rtcConfig: RTCConfiguration;\n\n  /**\n   * Prefix to use for the WebTorrent client version in tracker communications.\n   * If undefined, the default version prefix is used, which is calculated based on the package version.\n   *\n   * @default\n   * ```typescript\n   * trackerClientVersionPrefix: undefined\n   * ```\n   */\n  trackerClientVersionPrefix: string;\n\n  /**\n   * Optional unique identifier for the swarm, used to isolate peer pools by media stream.\n   * If undefined, the URL of the manifest is used as the swarm ID.\n   * @default\n   * ```typescript\n   * swarmId: undefined\n   * ```\n   */\n  swarmId?: string;\n\n  /**\n   * Optional function to validate a P2P segment before fully integrating it into the playback buffer.\n   * @param url URL of the segment to validate.\n   * @param byteRange Optional byte range of the segment.\n   * @param data Downloaded segment data.\n   * @returns A promise that resolves with a boolean indicating if the segment is valid.\n   *\n   * @default\n   * ```typescript\n   * validateP2PSegment: undefined\n   * ```\n   */\n  validateP2PSegment?: (\n    url: string,\n    byteRange: ByteRange | undefined,\n    data: ArrayBuffer,\n  ) => Promise<boolean>;\n\n  /**\n   * Optional function to validate a HTTP segment before fully integrating it into the playback buffer.\n   * @param url URL of the segment to validate.\n   * @param byteRange Optional byte range of the segment.\n   * @param data Downloaded segment data.\n   * @returns A promise that resolves with a boolean indicating if the segment is valid.\n   *\n   * @default\n   * ```typescript\n   * validateHTTPSegment: undefined\n   * ```\n   */\n  validateHTTPSegment?: (\n    url: string,\n    byteRange: ByteRange | undefined,\n    data: ArrayBuffer,\n  ) => Promise<boolean>;\n\n  /**\n   * Optional function to customize the setup of HTTP requests for segment downloads.\n   * @param segmentUrl URL of the segment.\n   * @param segmentByteRange The range of bytes requested for the segment.\n   * @param requestAbortSignal An abort signal to cancel the request if needed.\n   * @param requestByteRange Additional byte range for partial requests, if required.\n   * @returns A promise that resolves with the configured request, or undefined if no customization should be made.\n   *\n   * @default\n   * ```typescript\n   * httpRequestSetup: undefined\n   * ```\n   */\n  httpRequestSetup?: (\n    segmentUrl: string,\n    segmentByteRange: ByteRange | undefined,\n    requestAbortSignal: AbortSignal,\n    requestByteRange: { start: number; end?: number } | undefined,\n  ) => Promise<Request | undefined | null>;\n};\n\n/**\n * Specifies the source of a download within a media streaming context.\n *\n * \"http\" - Indicates that the segment was downloaded using the HTTP protocol.\n *\n * \"p2p\"- Indicates that the segment was downloaded through a peer-to-peer network.\n */\nexport type DownloadSource = \"http\" | \"p2p\";\n\n/** Represents details about a segment event. */\nexport type SegmentStartDetails = {\n  /** The segment that the event is about. */\n  segment: Segment;\n\n  /** The origin of the segment download. */\n  downloadSource: DownloadSource;\n\n  /** The peer ID, if the segment is downloaded from a peer. */\n  peerId: string | undefined;\n};\n\n/** Represents details about a segment error event. */\nexport type SegmentErrorDetails = {\n  /** The error that occurred during the segment download. */\n  error: RequestError;\n\n  /** The segment that the event is about. */\n  segment: Segment;\n\n  /** The source of the download. */\n  downloadSource: DownloadSource;\n\n  /** The peer ID, if the segment was downloaded from a peer. */\n  peerId: string | undefined;\n\n  /** The type of stream that the segment is associated with. */\n  streamType: StreamType;\n};\n\n/** Represents details about a segment abort event. */\nexport type SegmentAbortDetails = {\n  /** The segment that the event is about. */\n  segment: Segment;\n\n  /** The source of the download. */\n  downloadSource: DownloadSource | undefined;\n\n  /** The peer ID, if the segment was downloaded from a peer. */\n  peerId: string | undefined;\n\n  /** The type of stream that the segment is associated with. */\n  streamType: StreamType;\n};\n\n/** Represents the details about a loaded segment. */\nexport type SegmentLoadDetails = {\n  /** The URL of the loaded segment */\n  segmentUrl: string;\n\n  /** The length of the segment in bytes. */\n  bytesLength: number;\n\n  /** The source of the download. */\n  downloadSource: DownloadSource;\n\n  /** The peer ID, if the segment was downloaded from a peer. */\n  peerId: string | undefined;\n\n  /** The segment that the event is about. */\n  streamType: StreamType;\n};\n\n/** Represents the details of a peer in a peer-to-peer network. */\nexport type PeerDetails = {\n  /** The unique identifier for a peer in the network. */\n  peerId: string;\n  /** The type of stream that the peer is connected to. */\n  streamType: StreamType;\n};\n\n/** Represents the details of a peer error event. */\nexport type PeerErrorDetails = {\n  /** The unique identifier for a peer in the network. */\n  peerId: string;\n  /** The type of stream that the peer is connected to. */\n  streamType: StreamType;\n  /** The error that occurred during the peer-to-peer connection. */\n  error: Error;\n};\n\n/** Represents the details of a tracker error event. */\nexport type TrackerErrorDetails = {\n  /** The type of stream that the tracker is for. */\n  streamType: StreamType;\n  /** The error that occurred during the tracker request. */\n  error: unknown;\n};\n\nexport type TrackerWarningDetails = {\n  /** The type of stream that the tracker is for. */\n  streamType: StreamType;\n  /** The warning that occurred during the tracker request. */\n  warning: unknown;\n};\n\n/**\n * The CoreEventMap defines a comprehensive suite of event handlers crucial for monitoring and controlling the lifecycle\n * of segment downloading and uploading processes.\n */\nexport type CoreEventMap = {\n  /**\n   * Invoked when a segment is fully downloaded and available for use.\n   *\n   * @param params - Contains information about the loaded segment.\n   */\n  onSegmentLoaded: (params: SegmentLoadDetails) => void;\n\n  /**\n   * Triggered when an error occurs during the download of a segment.\n   *\n   * @param params - Contains information about the errored segment.\n   */\n  onSegmentError: (params: SegmentErrorDetails) => void;\n\n  /**\n   * Called if the download of a segment is aborted before completion.\n   *\n   * @param params - Contains information about the aborted segment.\n   */\n  onSegmentAbort: (params: SegmentAbortDetails) => void;\n\n  /**\n   * Fired at the beginning of a segment download process.\n   *\n   * @param params - Provides details about the segment being downloaded.\n   */\n  onSegmentStart: (params: SegmentStartDetails) => void;\n\n  /**\n   * Occurs when a new peer-to-peer connection is established.\n   *\n   * @param params - Contains details about the peer that the event is about.\n   */\n  onPeerConnect: (params: PeerDetails) => void;\n\n  /**\n   * Triggered when an existing peer-to-peer connection is closed.\n   *\n   * @param params - Contains details about the peer that the event is about.\n   */\n  onPeerClose: (params: PeerDetails) => void;\n\n  /**\n   * Triggered when an error occurs during a peer-to-peer connection.\n   *\n   * @param params - Contains details about the error and the peer that the event is about.\n   */\n  onPeerError: (params: PeerErrorDetails) => void;\n\n  /**\n   * Invoked after a chunk of data from a segment has been successfully downloaded.\n   *\n   * @param bytesLength - The size of the downloaded chunk in bytes.\n   * @param downloadSource - The source of the download.\n   * @param peerId - The peer ID of the peer that the event is about, if applicable.\n   */\n  onChunkDownloaded: (\n    bytesLength: number,\n    downloadSource: DownloadSource,\n    peerId?: string,\n  ) => void;\n\n  /**\n   * Called when a chunk of data has been successfully uploaded to a peer.\n   *\n   * @param bytesLength - The length of the segment in bytes.\n   * @param peerId - The peer ID, if the segment was downloaded from a peer\n   */\n  onChunkUploaded: (bytesLength: number, peerId: string) => void;\n\n  /**\n   * Called when an error occurs during the tracker request process.\n   *\n   * @param params - Contains information about the tracker error.\n   */\n  onTrackerError: (params: TrackerErrorDetails) => void;\n\n  /**\n   * Called when a warning occurs during the tracker request process.\n   *\n   * @param params - Contains information about the tracker warning.\n   */\n  onTrackerWarning: (params: TrackerWarningDetails) => void;\n};\n\n/** Defines the types of errors that can occur during a request abortion process. */\nexport type RequestAbortErrorType = \"abort\" | \"bytes-receiving-timeout\";\n\n/** Defines the types of errors specific to HTTP requests. */\nexport type HttpRequestErrorType =\n  | \"http-error\"\n  | \"http-bytes-mismatch\"\n  | \"http-unexpected-status-code\"\n  | \"http-segment-validation-failed\";\n\n/** Defines the types of errors specific to peer-to-peer requests. */\nexport type PeerRequestErrorType =\n  | \"peer-response-bytes-length-mismatch\"\n  | \"peer-protocol-violation\"\n  | \"peer-segment-absent\"\n  | \"peer-closed\"\n  | \"p2p-segment-validation-failed\";\n\n/** Enumerates all possible request error types, including HTTP and peer-related errors. */\nexport type RequestErrorType =\n  | RequestAbortErrorType\n  | PeerRequestErrorType\n  | HttpRequestErrorType;\n\n/**\n * Represents an error that can occur during the request process, with a timestamp for when the error occurred.\n * @template T - The specific type of request error.\n */\nexport class RequestError<\n  T extends RequestErrorType = RequestErrorType,\n> extends Error {\n  /** Error timestamp. */\n  readonly timestamp: number;\n\n  /**\n   * Constructs a new RequestError.\n   * @param type - The specific error type.\n   * @param message - Optional message describing the error.\n   */\n  constructor(\n    readonly type: T,\n    message?: string,\n  ) {\n    super(message);\n    this.timestamp = performance.now();\n  }\n}\n\n/** Represents the response from a segment request, including the data and measured bandwidth. */\nexport type SegmentResponse = {\n  /** Segment data as an ArrayBuffer. */\n  data: ArrayBuffer;\n\n  /** Measured bandwidth for the segment download, in bytes per second. */\n  bandwidth: number;\n};\n\n/** Custom error class for errors that occur during core network requests. */\nexport class CoreRequestError extends Error {\n  /**\n   * Constructs a new CoreRequestError.\n   * @param type - The type of the error, either 'failed' or 'aborted'.\n   */\n  constructor(readonly type: \"failed\" | \"aborted\") {\n    super();\n  }\n}\n\n/** Callbacks for handling the success or failure of an engine operation. */\nexport type EngineCallbacks = {\n  /**\n   * Called when the operation is successful.\n   * @param response - The response from the successful operation.\n   */\n  onSuccess: (response: SegmentResponse) => void;\n\n  /**\n   * Called when the operation encounters an error.\n   * @param reason - The error encountered during the operation.\n   */\n  onError: (reason: CoreRequestError) => void;\n};\n","import {\n  CoreConfig,\n  CoreEventMap,\n  RequestError,\n  HttpRequestErrorType,\n} from \"./types.js\";\nimport {\n  Request as SegmentRequest,\n  RequestControls,\n} from \"./requests/request.js\";\nimport { EventTarget } from \"./utils/event-target.js\";\n\ntype HttpConfig = Pick<\n  CoreConfig,\n  \"httpNotReceivingBytesTimeoutMs\" | \"httpRequestSetup\" | \"validateHTTPSegment\"\n>;\n\nexport class HttpRequestExecutor {\n  private readonly requestControls: RequestControls;\n  private readonly abortController = new AbortController();\n  private readonly expectedBytesLength?: number;\n  private readonly requestByteRange?: { start: number; end?: number };\n  private readonly onChunkDownloaded: CoreEventMap[\"onChunkDownloaded\"];\n\n  constructor(\n    private readonly request: SegmentRequest,\n    private readonly httpConfig: HttpConfig,\n    eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    this.onChunkDownloaded =\n      eventTarget.getEventDispatcher(\"onChunkDownloaded\");\n\n    const { byteRange } = this.request.segment;\n    if (byteRange) this.requestByteRange = { ...byteRange };\n\n    if (request.loadedBytes !== 0) {\n      this.requestByteRange = this.requestByteRange ?? { start: 0 };\n      this.requestByteRange.start =\n        this.requestByteRange.start + request.loadedBytes;\n    }\n    if (this.request.totalBytes) {\n      this.expectedBytesLength =\n        this.request.totalBytes - this.request.loadedBytes;\n    }\n\n    this.requestControls = this.request.start(\n      { downloadSource: \"http\" },\n      {\n        abort: () => this.abortController.abort(\"abort\"),\n        notReceivingBytesTimeoutMs:\n          this.httpConfig.httpNotReceivingBytesTimeoutMs,\n      },\n    );\n    void this.fetch();\n  }\n\n  private async fetch() {\n    const { segment } = this.request;\n    try {\n      let request = await this.httpConfig.httpRequestSetup?.(\n        segment.url,\n        segment.byteRange,\n        this.abortController.signal,\n        this.requestByteRange,\n      );\n\n      if (!request) {\n        const headers = new Headers(\n          this.requestByteRange\n            ? {\n                Range: `bytes=${this.requestByteRange.start}-${\n                  this.requestByteRange.end ?? \"\"\n                }`,\n              }\n            : undefined,\n        );\n\n        request = new Request(segment.url, {\n          headers,\n          signal: this.abortController.signal,\n        });\n      }\n\n      if (this.abortController.signal.aborted) {\n        throw new DOMException(\n          \"Request aborted before request fetch\",\n          \"AbortError\",\n        );\n      }\n\n      const response = await window.fetch(request);\n\n      this.handleResponseHeaders(response);\n\n      if (!response.body) return;\n      const { requestControls } = this;\n      requestControls.firstBytesReceived();\n\n      const reader = response.body.getReader();\n      for await (const chunk of readStream(reader)) {\n        this.requestControls.addLoadedChunk(chunk);\n        this.onChunkDownloaded(chunk.byteLength, \"http\");\n      }\n\n      const isValid =\n        (await this.httpConfig.validateHTTPSegment?.(\n          segment.url,\n          segment.byteRange,\n          this.request.data,\n        )) ?? true;\n\n      if (!isValid) {\n        this.request.clearLoadedBytes();\n        throw new RequestError<\"http-segment-validation-failed\">(\n          \"http-segment-validation-failed\",\n        );\n      }\n\n      requestControls.completeOnSuccess();\n    } catch (error) {\n      this.handleError(error);\n    }\n  }\n\n  private handleResponseHeaders(response: Response) {\n    if (!response.ok) {\n      if (response.status === 406) {\n        this.request.clearLoadedBytes();\n        throw new RequestError<\"http-bytes-mismatch\">(\n          \"http-bytes-mismatch\",\n          response.statusText,\n        );\n      } else {\n        throw new RequestError<\"http-error\">(\"http-error\", response.statusText);\n      }\n    }\n\n    const { requestByteRange } = this;\n    if (requestByteRange) {\n      if (response.status === 200) {\n        if (this.request.segment.byteRange) {\n          throw new RequestError(\"http-unexpected-status-code\");\n        } else {\n          this.request.clearLoadedBytes();\n        }\n      } else {\n        if (response.status !== 206) {\n          throw new RequestError(\n            \"http-unexpected-status-code\",\n            response.statusText,\n          );\n        }\n        const contentLengthHeader = response.headers.get(\"Content-Length\");\n        if (\n          contentLengthHeader &&\n          this.expectedBytesLength !== undefined &&\n          this.expectedBytesLength !== +contentLengthHeader\n        ) {\n          this.request.clearLoadedBytes();\n          throw new RequestError(\"http-bytes-mismatch\", response.statusText);\n        }\n\n        const contentRangeHeader = response.headers.get(\"Content-Range\");\n        const contentRange = contentRangeHeader\n          ? parseContentRangeHeader(contentRangeHeader)\n          : undefined;\n        if (contentRange) {\n          const { from, to } = contentRange;\n          const responseExpectedBytesLength =\n            to !== undefined && from !== undefined ? to - from + 1 : undefined;\n\n          if (\n            (responseExpectedBytesLength !== undefined &&\n              this.expectedBytesLength !== responseExpectedBytesLength) ||\n            (from !== undefined && requestByteRange.start !== from) ||\n            (to !== undefined &&\n              requestByteRange.end !== undefined &&\n              requestByteRange.end !== to)\n          ) {\n            this.request.clearLoadedBytes();\n            throw new RequestError(\"http-bytes-mismatch\", response.statusText);\n          }\n        }\n      }\n    }\n\n    if (response.status === 200 && this.request.totalBytes === undefined) {\n      const contentLengthHeader = response.headers.get(\"Content-Length\");\n      if (contentLengthHeader) this.request.setTotalBytes(+contentLengthHeader);\n    }\n  }\n\n  private handleError(error: unknown) {\n    if (error instanceof Error) {\n      if (error.name !== \"abort\") return;\n\n      const httpLoaderError =\n        error instanceof RequestError\n          ? (error as RequestError<HttpRequestErrorType>)\n          : new RequestError(\"http-error\", error.message);\n\n      this.requestControls.abortOnError(httpLoaderError);\n    }\n  }\n}\n\nasync function* readStream(\n  reader: ReadableStreamDefaultReader<Uint8Array>,\n): AsyncGenerator<Uint8Array> {\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) break;\n    yield value;\n  }\n}\n\nconst rangeHeaderRegex = /^bytes (?:(?:(\\d+)|)-(?:(\\d+)|)|\\*)\\/(?:(\\d+)|\\*)$/;\n\nfunction parseContentRangeHeader(headerValue: string) {\n  const match = rangeHeaderRegex.exec(headerValue.trim());\n  if (!match) return;\n\n  const [, from, to, total] = match;\n  return {\n    from: from ? parseInt(from) : undefined,\n    to: to ? parseInt(to) : undefined,\n    total: total ? parseInt(total) : undefined,\n  };\n}\n","function getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar browser = {exports: {}};\n\n// shim for using process in browser\nvar process = browser.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ());\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] };\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\nvar browserExports = browser.exports;\nconst process$1 = /*@__PURE__*/getDefaultExportFromCjs(browserExports);\n\nexport { process$1 as default, process$1 as process };\n//# sourceMappingURL=index.js.map\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '')\n\t\t\t.trim()\n\t\t\t.replace(/\\s+/g, ',')\n\t\t\t.split(',')\n\t\t\t.filter(Boolean);\n\n\t\tfor (const ns of split) {\n\t\t\tif (ns[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(ns.slice(1));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(ns);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the given string matches a namespace template, honoring\n\t * asterisks as wildcards.\n\t *\n\t * @param {String} search\n\t * @param {String} template\n\t * @return {Boolean}\n\t */\n\tfunction matchesTemplate(search, template) {\n\t\tlet searchIndex = 0;\n\t\tlet templateIndex = 0;\n\t\tlet starIndex = -1;\n\t\tlet matchIndex = 0;\n\n\t\twhile (searchIndex < search.length) {\n\t\t\tif (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {\n\t\t\t\t// Match character or proceed with wildcard\n\t\t\t\tif (template[templateIndex] === '*') {\n\t\t\t\t\tstarIndex = templateIndex;\n\t\t\t\t\tmatchIndex = searchIndex;\n\t\t\t\t\ttemplateIndex++; // Skip the '*'\n\t\t\t\t} else {\n\t\t\t\t\tsearchIndex++;\n\t\t\t\t\ttemplateIndex++;\n\t\t\t\t}\n\t\t\t} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition\n\t\t\t\t// Backtrack to the last '*' and try to match more characters\n\t\t\t\ttemplateIndex = starIndex + 1;\n\t\t\t\tmatchIndex++;\n\t\t\t\tsearchIndex = matchIndex;\n\t\t\t} else {\n\t\t\t\treturn false; // No match\n\t\t\t}\n\t\t}\n\n\t\t// Handle trailing '*' in template\n\t\twhile (templateIndex < template.length && template[templateIndex] === '*') {\n\t\t\ttemplateIndex++;\n\t\t}\n\n\t\treturn templateIndex === template.length;\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names,\n\t\t\t...createDebug.skips.map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tfor (const skip of createDebug.skips) {\n\t\t\tif (matchesTemplate(name, skip)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (const ns of createDebug.names) {\n\t\t\tif (matchesTemplate(name, ns)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\tlet m;\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\t// eslint-disable-next-line no-return-assign\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug') || exports.storage.getItem('DEBUG') ;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n","var wrappy = require('wrappy')\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n","/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nlet promise\n\nmodule.exports = typeof queueMicrotask === 'function'\n  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : global)\n  // reuse resolved promise, and allocate it lazily\n  : cb => (promise || (promise = Promise.resolve()))\n    .then(cb)\n    .catch(err => setTimeout(() => { throw err }, 0))\n","/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nmodule.exports = runParallel\n\nconst queueMicrotask = require('queue-microtask')\n\nfunction runParallel (tasks, cb) {\n  let results, pending, keys\n  let isSync = true\n\n  if (Array.isArray(tasks)) {\n    results = []\n    pending = tasks.length\n  } else {\n    keys = Object.keys(tasks)\n    results = {}\n    pending = keys.length\n  }\n\n  function done (err) {\n    function end () {\n      if (cb) cb(err, results)\n      cb = null\n    }\n    if (isSync) queueMicrotask(end)\n    else end()\n  }\n\n  function each (i, err, result) {\n    results[i] = result\n    if (--pending === 0 || err) {\n      done(err)\n    }\n  }\n\n  if (!pending) {\n    // empty\n    done(null)\n  } else if (keys) {\n    // object\n    keys.forEach(function (key) {\n      tasks[key](function (err, result) { each(key, err, result) })\n    })\n  } else {\n    // array\n    tasks.forEach(function (task, i) {\n      task(function (err, result) { each(i, err, result) })\n    })\n  }\n\n  isSync = false\n}\n","const scope = typeof window !== 'undefined' ? window : self\r\n\r\n// @ts-ignore\r\nexport const RTCPeerConnection = scope.RTCPeerConnection || scope.mozRTCPeerConnection || scope.webkitRTCPeerConnection\r\n// @ts-ignore\r\nexport const RTCSessionDescription = scope.RTCSessionDescription || scope.mozRTCSessionDescription || scope.webkitRTCSessionDescription\r\n// @ts-ignore\r\nexport const RTCIceCandidate = scope.RTCIceCandidate || scope.mozRTCIceCandidate || scope.webkitRTCIceCandidate\r\nexport const RTCIceTransport = scope.RTCIceTransport\r\nexport const RTCDataChannel = scope.RTCDataChannel\r\nexport const RTCSctpTransport = scope.RTCSctpTransport\r\nexport const RTCDtlsTransport = scope.RTCDtlsTransport\r\nexport const RTCCertificate = scope.RTCCertificate\r\nexport const MediaStream = scope.MediaStream\r\nexport const MediaStreamTrack = scope.MediaStreamTrack\r\nexport const MediaStreamTrackEvent = scope.MediaStreamTrackEvent\r\nexport const RTCPeerConnectionIceEvent = scope.RTCPeerConnectionIceEvent\r\nexport const RTCDataChannelEvent = scope.RTCDataChannelEvent\r\nexport const RTCTrackEvent = scope.RTCTrackEvent\r\nexport const RTCError = scope.RTCError\r\nexport const RTCErrorEvent = scope.RTCErrorEvent\r\nexport const RTCRtpTransceiver = scope.RTCRtpTransceiver\r\nexport const RTCRtpReceiver = scope.RTCRtpReceiver\r\nexport const RTCRtpSender = scope.RTCRtpSender\r\n\r\nexport * as default from './browser.js'\r\n","module.exports = require('events')\n","module.exports = class FixedFIFO {\n  constructor (hwm) {\n    if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) throw new Error('Max size for a FixedFIFO should be a power of two')\n    this.buffer = new Array(hwm)\n    this.mask = hwm - 1\n    this.top = 0\n    this.btm = 0\n    this.next = null\n  }\n\n  clear () {\n    this.top = this.btm = 0\n    this.next = null\n    this.buffer.fill(undefined)\n  }\n\n  push (data) {\n    if (this.buffer[this.top] !== undefined) return false\n    this.buffer[this.top] = data\n    this.top = (this.top + 1) & this.mask\n    return true\n  }\n\n  shift () {\n    const last = this.buffer[this.btm]\n    if (last === undefined) return undefined\n    this.buffer[this.btm] = undefined\n    this.btm = (this.btm + 1) & this.mask\n    return last\n  }\n\n  peek () {\n    return this.buffer[this.btm]\n  }\n\n  isEmpty () {\n    return this.buffer[this.btm] === undefined\n  }\n}\n","const FixedFIFO = require('./fixed-size')\n\nmodule.exports = class FastFIFO {\n  constructor (hwm) {\n    this.hwm = hwm || 16\n    this.head = new FixedFIFO(this.hwm)\n    this.tail = this.head\n    this.length = 0\n  }\n\n  clear () {\n    this.head = this.tail\n    this.head.clear()\n    this.length = 0\n  }\n\n  push (val) {\n    this.length++\n    if (!this.head.push(val)) {\n      const prev = this.head\n      this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length)\n      this.head.push(val)\n    }\n  }\n\n  shift () {\n    if (this.length !== 0) this.length--\n    const val = this.tail.shift()\n    if (val === undefined && this.tail.next) {\n      const next = this.tail.next\n      this.tail.next = null\n      this.tail = next\n      return this.tail.shift()\n    }\n\n    return val\n  }\n\n  peek () {\n    const val = this.tail.peek()\n    if (val === undefined && this.tail.next) return this.tail.next.peek()\n    return val\n  }\n\n  isEmpty () {\n    return this.length === 0\n  }\n}\n","module.exports = class BrowserDecoder {\n  constructor (encoding) {\n    this.decoder = new TextDecoder(encoding === 'utf16le' ? 'utf16-le' : encoding)\n  }\n\n  get remaining () {\n    return -1\n  }\n\n  decode (data) {\n    return this.decoder.decode(data, { stream: true })\n  }\n\n  flush () {\n    return this.decoder.decode(new Uint8Array(0))\n  }\n}\n","const PassThroughDecoder = require('./lib/pass-through-decoder')\nconst UTF8Decoder = require('./lib/utf8-decoder')\n\nmodule.exports = class TextDecoder {\n  constructor (encoding = 'utf8') {\n    this.encoding = normalizeEncoding(encoding)\n\n    switch (this.encoding) {\n      case 'utf8':\n        this.decoder = new UTF8Decoder()\n        break\n      case 'utf16le':\n      case 'base64':\n        throw new Error('Unsupported encoding: ' + this.encoding)\n      default:\n        this.decoder = new PassThroughDecoder(this.encoding)\n    }\n  }\n\n  get remaining () {\n    return this.decoder.remaining\n  }\n\n  push (data) {\n    if (typeof data === 'string') return data\n    return this.decoder.decode(data)\n  }\n\n  // For Node.js compatibility\n  write (data) {\n    return this.push(data)\n  }\n\n  end (data) {\n    let result = ''\n    if (data) result = this.push(data)\n    result += this.decoder.flush()\n    return result\n  }\n}\n\nfunction normalizeEncoding (encoding) {\n  encoding = encoding.toLowerCase()\n\n  switch (encoding) {\n    case 'utf8':\n    case 'utf-8':\n      return 'utf8'\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return 'utf16le'\n    case 'latin1':\n    case 'binary':\n      return 'latin1'\n    case 'base64':\n    case 'ascii':\n    case 'hex':\n      return encoding\n    default:\n      throw new Error('Unknown encoding: ' + encoding)\n  }\n};\n","const { EventEmitter } = require('events-universal')\nconst STREAM_DESTROYED = new Error('Stream was destroyed')\nconst PREMATURE_CLOSE = new Error('Premature close')\n\nconst FIFO = require('fast-fifo')\nconst TextDecoder = require('text-decoder')\n\n// if we do a future major, expect queue microtask to be there always, for now a bit defensive\nconst qmt = typeof queueMicrotask === 'undefined' ? fn => global.process.nextTick(fn) : queueMicrotask\n\n/* eslint-disable no-multi-spaces */\n\n// 29 bits used total (4 from shared, 14 from read, and 11 from write)\nconst MAX = ((1 << 29) - 1)\n\n// Shared state\nconst OPENING       = 0b0001\nconst PREDESTROYING = 0b0010\nconst DESTROYING    = 0b0100\nconst DESTROYED     = 0b1000\n\nconst NOT_OPENING = MAX ^ OPENING\nconst NOT_PREDESTROYING = MAX ^ PREDESTROYING\n\n// Read state (4 bit offset from shared state)\nconst READ_ACTIVE           = 0b00000000000001 << 4\nconst READ_UPDATING         = 0b00000000000010 << 4\nconst READ_PRIMARY          = 0b00000000000100 << 4\nconst READ_QUEUED           = 0b00000000001000 << 4\nconst READ_RESUMED          = 0b00000000010000 << 4\nconst READ_PIPE_DRAINED     = 0b00000000100000 << 4\nconst READ_ENDING           = 0b00000001000000 << 4\nconst READ_EMIT_DATA        = 0b00000010000000 << 4\nconst READ_EMIT_READABLE    = 0b00000100000000 << 4\nconst READ_EMITTED_READABLE = 0b00001000000000 << 4\nconst READ_DONE             = 0b00010000000000 << 4\nconst READ_NEXT_TICK        = 0b00100000000000 << 4\nconst READ_NEEDS_PUSH       = 0b01000000000000 << 4\nconst READ_READ_AHEAD       = 0b10000000000000 << 4\n\n// Combined read state\nconst READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED\nconst READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH\nconst READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE\nconst READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED\nconst READ_RESUMED_READ_AHEAD = READ_RESUMED | READ_READ_AHEAD\n\nconst READ_NOT_ACTIVE             = MAX ^ READ_ACTIVE\nconst READ_NON_PRIMARY            = MAX ^ READ_PRIMARY\nconst READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH)\nconst READ_PUSHED                 = MAX ^ READ_NEEDS_PUSH\nconst READ_PAUSED                 = MAX ^ READ_RESUMED\nconst READ_NOT_QUEUED             = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE)\nconst READ_NOT_ENDING             = MAX ^ READ_ENDING\nconst READ_PIPE_NOT_DRAINED       = MAX ^ READ_FLOWING\nconst READ_NOT_NEXT_TICK          = MAX ^ READ_NEXT_TICK\nconst READ_NOT_UPDATING           = MAX ^ READ_UPDATING\nconst READ_NO_READ_AHEAD          = MAX ^ READ_READ_AHEAD\nconst READ_PAUSED_NO_READ_AHEAD   = MAX ^ READ_RESUMED_READ_AHEAD\n\n// Write state (18 bit offset, 4 bit offset from shared state and 14 from read state)\nconst WRITE_ACTIVE     = 0b00000000001 << 18\nconst WRITE_UPDATING   = 0b00000000010 << 18\nconst WRITE_PRIMARY    = 0b00000000100 << 18\nconst WRITE_QUEUED     = 0b00000001000 << 18\nconst WRITE_UNDRAINED  = 0b00000010000 << 18\nconst WRITE_DONE       = 0b00000100000 << 18\nconst WRITE_EMIT_DRAIN = 0b00001000000 << 18\nconst WRITE_NEXT_TICK  = 0b00010000000 << 18\nconst WRITE_WRITING    = 0b00100000000 << 18\nconst WRITE_FINISHING  = 0b01000000000 << 18\nconst WRITE_CORKED     = 0b10000000000 << 18\n\nconst WRITE_NOT_ACTIVE    = MAX ^ (WRITE_ACTIVE | WRITE_WRITING)\nconst WRITE_NON_PRIMARY   = MAX ^ WRITE_PRIMARY\nconst WRITE_NOT_FINISHING = MAX ^ (WRITE_ACTIVE | WRITE_FINISHING)\nconst WRITE_DRAINED       = MAX ^ WRITE_UNDRAINED\nconst WRITE_NOT_QUEUED    = MAX ^ WRITE_QUEUED\nconst WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK\nconst WRITE_NOT_UPDATING  = MAX ^ WRITE_UPDATING\nconst WRITE_NOT_CORKED    = MAX ^ WRITE_CORKED\n\n// Combined shared state\nconst ACTIVE = READ_ACTIVE | WRITE_ACTIVE\nconst NOT_ACTIVE = MAX ^ ACTIVE\nconst DONE = READ_DONE | WRITE_DONE\nconst DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING\nconst OPEN_STATUS = DESTROY_STATUS | OPENING\nconst AUTO_DESTROY = DESTROY_STATUS | DONE\nconst NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY\nconst ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK\nconst TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE\nconst IS_OPENING = OPEN_STATUS | TICKING\n\n// Combined shared state and read state\nconst READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE\nconst READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED\nconst READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED\nconst READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE\nconst SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH | READ_READ_AHEAD\nconst READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE\nconst READ_UPDATE_SYNC_STATUS = READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY\nconst READ_NEXT_TICK_OR_OPENING = READ_NEXT_TICK | OPENING\n\n// Combined write state\nconst WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED\nconst WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE\nconst WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE\nconst WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED | WRITE_CORKED\nconst WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE\nconst WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING\nconst WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE\nconst WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_UPDATE_SYNC_STATUS = WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY\nconst WRITE_DROP_DATA = WRITE_FINISHING | WRITE_DONE | DESTROY_STATUS\n\nconst asyncIterator = Symbol.asyncIterator || Symbol('asyncIterator')\n\nclass WritableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapWritable, byteLength, byteLengthWritable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark\n    this.buffered = 0\n    this.error = null\n    this.pipeline = null\n    this.drains = null // if we add more seldomly used helpers we might them into a subobject so its a single ptr\n    this.byteLength = byteLengthWritable || byteLength || defaultByteLength\n    this.map = mapWritable || map\n    this.afterWrite = afterWrite.bind(this)\n    this.afterUpdateNextTick = updateWriteNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & WRITE_DONE) !== 0\n  }\n\n  push (data) {\n    if ((this.stream._duplexState & WRITE_DROP_DATA) !== 0) return false\n    if (this.map !== null) data = this.map(data)\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    if (this.buffered < this.highWaterMark) {\n      this.stream._duplexState |= WRITE_QUEUED\n      return true\n    }\n\n    this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED\n    return false\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= WRITE_NOT_QUEUED\n\n    return data\n  }\n\n  end (data) {\n    if (typeof data === 'function') this.stream.once('finish', data)\n    else if (data !== undefined && data !== null) this.push(data)\n    this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY\n  }\n\n  autoBatch (data, cb) {\n    const buffer = []\n    const stream = this.stream\n\n    buffer.push(data)\n    while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {\n      buffer.push(stream._writableState.shift())\n    }\n\n    if ((stream._duplexState & OPEN_STATUS) !== 0) return cb(null)\n    stream._writev(buffer, cb)\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= WRITE_UPDATING\n\n    do {\n      while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {\n        const data = this.shift()\n        stream._duplexState |= WRITE_ACTIVE_AND_WRITING\n        stream._write(data, this.afterWrite)\n      }\n\n      if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= WRITE_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {\n      stream._duplexState = stream._duplexState | WRITE_ACTIVE\n      stream._final(afterFinal.bind(this))\n      return\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= WRITE_NEXT_TICK\n    if ((this.stream._duplexState & WRITE_UPDATING) === 0) qmt(this.afterUpdateNextTick)\n  }\n}\n\nclass ReadableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapReadable, byteLength, byteLengthReadable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark\n    this.buffered = 0\n    this.readAhead = highWaterMark > 0\n    this.error = null\n    this.pipeline = null\n    this.byteLength = byteLengthReadable || byteLength || defaultByteLength\n    this.map = mapReadable || map\n    this.pipeTo = null\n    this.afterRead = afterRead.bind(this)\n    this.afterUpdateNextTick = updateReadNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & READ_DONE) !== 0\n  }\n\n  pipe (pipeTo, cb) {\n    if (this.pipeTo !== null) throw new Error('Can only pipe to one destination')\n    if (typeof cb !== 'function') cb = null\n\n    this.stream._duplexState |= READ_PIPE_DRAINED\n    this.pipeTo = pipeTo\n    this.pipeline = new Pipeline(this.stream, pipeTo, cb)\n\n    if (cb) this.stream.on('error', noop) // We already error handle this so supress crashes\n\n    if (isStreamx(pipeTo)) {\n      pipeTo._writableState.pipeline = this.pipeline\n      if (cb) pipeTo.on('error', noop) // We already error handle this so supress crashes\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline)) // TODO: just call finished from pipeTo itself\n    } else {\n      const onerror = this.pipeline.done.bind(this.pipeline, pipeTo)\n      const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null) // onclose has a weird bool arg\n      pipeTo.on('error', onerror)\n      pipeTo.on('close', onclose)\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline))\n    }\n\n    pipeTo.on('drain', afterDrain.bind(this))\n    this.stream.emit('piping', pipeTo)\n    pipeTo.emit('pipe', this.stream)\n  }\n\n  push (data) {\n    const stream = this.stream\n\n    if (data === null) {\n      this.highWaterMark = 0\n      stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED\n      return false\n    }\n\n    if (this.map !== null) {\n      data = this.map(data)\n      if (data === null) {\n        stream._duplexState &= READ_PUSHED\n        return this.buffered < this.highWaterMark\n      }\n    }\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED\n\n    return this.buffered < this.highWaterMark\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= READ_NOT_QUEUED\n    return data\n  }\n\n  unshift (data) {\n    const pending = [this.map !== null ? this.map(data) : data]\n    while (this.buffered > 0) pending.push(this.shift())\n\n    for (let i = 0; i < pending.length - 1; i++) {\n      const data = pending[i]\n      this.buffered += this.byteLength(data)\n      this.queue.push(data)\n    }\n\n    this.push(pending[pending.length - 1])\n  }\n\n  read () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n      return data\n    }\n\n    if (this.readAhead === false) {\n      stream._duplexState |= READ_READ_AHEAD\n      this.updateNextTick()\n    }\n\n    return null\n  }\n\n  drain () {\n    const stream = this.stream\n\n    while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n    }\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= READ_UPDATING\n\n    do {\n      this.drain()\n\n      while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === READ_READ_AHEAD) {\n        stream._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH\n        stream._read(this.afterRead)\n        this.drain()\n      }\n\n      if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {\n        stream._duplexState |= READ_EMITTED_READABLE\n        stream.emit('readable')\n      }\n\n      if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= READ_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {\n      stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING\n      stream.emit('end')\n      if ((stream._duplexState & AUTO_DESTROY) === DONE) stream._duplexState |= DESTROYING\n      if (this.pipeTo !== null) this.pipeTo.end()\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTickIfOpen () {\n    if ((this.stream._duplexState & READ_NEXT_TICK_OR_OPENING) !== 0) return\n    this.stream._duplexState |= READ_NEXT_TICK\n    if ((this.stream._duplexState & READ_UPDATING) === 0) qmt(this.afterUpdateNextTick)\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= READ_NEXT_TICK\n    if ((this.stream._duplexState & READ_UPDATING) === 0) qmt(this.afterUpdateNextTick)\n  }\n}\n\nclass TransformState {\n  constructor (stream) {\n    this.data = null\n    this.afterTransform = afterTransform.bind(stream)\n    this.afterFinal = null\n  }\n}\n\nclass Pipeline {\n  constructor (src, dst, cb) {\n    this.from = src\n    this.to = dst\n    this.afterPipe = cb\n    this.error = null\n    this.pipeToFinished = false\n  }\n\n  finished () {\n    this.pipeToFinished = true\n  }\n\n  done (stream, err) {\n    if (err) this.error = err\n\n    if (stream === this.to) {\n      this.to = null\n\n      if (this.from !== null) {\n        if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {\n          this.from.destroy(this.error || new Error('Writable stream closed prematurely'))\n        }\n        return\n      }\n    }\n\n    if (stream === this.from) {\n      this.from = null\n\n      if (this.to !== null) {\n        if ((stream._duplexState & READ_DONE) === 0) {\n          this.to.destroy(this.error || new Error('Readable stream closed before ending'))\n        }\n        return\n      }\n    }\n\n    if (this.afterPipe !== null) this.afterPipe(this.error)\n    this.to = this.from = this.afterPipe = null\n  }\n}\n\nfunction afterDrain () {\n  this.stream._duplexState |= READ_PIPE_DRAINED\n  this.updateCallback()\n}\n\nfunction afterFinal (err) {\n  const stream = this.stream\n  if (err) stream.destroy(err)\n  if ((stream._duplexState & DESTROY_STATUS) === 0) {\n    stream._duplexState |= WRITE_DONE\n    stream.emit('finish')\n  }\n  if ((stream._duplexState & AUTO_DESTROY) === DONE) {\n    stream._duplexState |= DESTROYING\n  }\n\n  stream._duplexState &= WRITE_NOT_FINISHING\n\n  // no need to wait the extra tick here, so we short circuit that\n  if ((stream._duplexState & WRITE_UPDATING) === 0) this.update()\n  else this.updateNextTick()\n}\n\nfunction afterDestroy (err) {\n  const stream = this.stream\n\n  if (!err && this.error !== STREAM_DESTROYED) err = this.error\n  if (err) stream.emit('error', err)\n  stream._duplexState |= DESTROYED\n  stream.emit('close')\n\n  const rs = stream._readableState\n  const ws = stream._writableState\n\n  if (rs !== null && rs.pipeline !== null) rs.pipeline.done(stream, err)\n\n  if (ws !== null) {\n    while (ws.drains !== null && ws.drains.length > 0) ws.drains.shift().resolve(false)\n    if (ws.pipeline !== null) ws.pipeline.done(stream, err)\n  }\n}\n\nfunction afterWrite (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n  stream._duplexState &= WRITE_NOT_ACTIVE\n\n  if (this.drains !== null) tickDrains(this.drains)\n\n  if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {\n    stream._duplexState &= WRITE_DRAINED\n    if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {\n      stream.emit('drain')\n    }\n  }\n\n  this.updateCallback()\n}\n\nfunction afterRead (err) {\n  if (err) this.stream.destroy(err)\n  this.stream._duplexState &= READ_NOT_ACTIVE\n  if (this.readAhead === false && (this.stream._duplexState & READ_RESUMED) === 0) this.stream._duplexState &= READ_NO_READ_AHEAD\n  this.updateCallback()\n}\n\nfunction updateReadNT () {\n  if ((this.stream._duplexState & READ_UPDATING) === 0) {\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction updateWriteNT () {\n  if ((this.stream._duplexState & WRITE_UPDATING) === 0) {\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction tickDrains (drains) {\n  for (let i = 0; i < drains.length; i++) {\n    // drains.writes are monotonic, so if one is 0 its always the first one\n    if (--drains[i].writes === 0) {\n      drains.shift().resolve(true)\n      i--\n    }\n  }\n}\n\nfunction afterOpen (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n\n  if ((stream._duplexState & DESTROYING) === 0) {\n    if ((stream._duplexState & READ_PRIMARY_STATUS) === 0) stream._duplexState |= READ_PRIMARY\n    if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0) stream._duplexState |= WRITE_PRIMARY\n    stream.emit('open')\n  }\n\n  stream._duplexState &= NOT_ACTIVE\n\n  if (stream._writableState !== null) {\n    stream._writableState.updateCallback()\n  }\n\n  if (stream._readableState !== null) {\n    stream._readableState.updateCallback()\n  }\n}\n\nfunction afterTransform (err, data) {\n  if (data !== undefined && data !== null) this.push(data)\n  this._writableState.afterWrite(err)\n}\n\nfunction newListener (name) {\n  if (this._readableState !== null) {\n    if (name === 'data') {\n      this._duplexState |= (READ_EMIT_DATA | READ_RESUMED_READ_AHEAD)\n      this._readableState.updateNextTick()\n    }\n    if (name === 'readable') {\n      this._duplexState |= READ_EMIT_READABLE\n      this._readableState.updateNextTick()\n    }\n  }\n\n  if (this._writableState !== null) {\n    if (name === 'drain') {\n      this._duplexState |= WRITE_EMIT_DRAIN\n      this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Stream extends EventEmitter {\n  constructor (opts) {\n    super()\n\n    this._duplexState = 0\n    this._readableState = null\n    this._writableState = null\n\n    if (opts) {\n      if (opts.open) this._open = opts.open\n      if (opts.destroy) this._destroy = opts.destroy\n      if (opts.predestroy) this._predestroy = opts.predestroy\n      if (opts.signal) {\n        opts.signal.addEventListener('abort', abort.bind(this))\n      }\n    }\n\n    this.on('newListener', newListener)\n  }\n\n  _open (cb) {\n    cb(null)\n  }\n\n  _destroy (cb) {\n    cb(null)\n  }\n\n  _predestroy () {\n    // does nothing\n  }\n\n  get readable () {\n    return this._readableState !== null ? true : undefined\n  }\n\n  get writable () {\n    return this._writableState !== null ? true : undefined\n  }\n\n  get destroyed () {\n    return (this._duplexState & DESTROYED) !== 0\n  }\n\n  get destroying () {\n    return (this._duplexState & DESTROY_STATUS) !== 0\n  }\n\n  destroy (err) {\n    if ((this._duplexState & DESTROY_STATUS) === 0) {\n      if (!err) err = STREAM_DESTROYED\n      this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY\n\n      if (this._readableState !== null) {\n        this._readableState.highWaterMark = 0\n        this._readableState.error = err\n      }\n      if (this._writableState !== null) {\n        this._writableState.highWaterMark = 0\n        this._writableState.error = err\n      }\n\n      this._duplexState |= PREDESTROYING\n      this._predestroy()\n      this._duplexState &= NOT_PREDESTROYING\n\n      if (this._readableState !== null) this._readableState.updateNextTick()\n      if (this._writableState !== null) this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Readable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | WRITE_DONE | READ_READ_AHEAD\n    this._readableState = new ReadableState(this, opts)\n\n    if (opts) {\n      if (this._readableState.readAhead === false) this._duplexState &= READ_NO_READ_AHEAD\n      if (opts.read) this._read = opts.read\n      if (opts.eagerOpen) this._readableState.updateNextTick()\n      if (opts.encoding) this.setEncoding(opts.encoding)\n    }\n  }\n\n  setEncoding (encoding) {\n    const dec = new TextDecoder(encoding)\n    const map = this._readableState.map || echo\n    this._readableState.map = mapOrSkip\n    return this\n\n    function mapOrSkip (data) {\n      const next = dec.push(data)\n      return next === '' && (data.byteLength !== 0 || dec.remaining > 0) ? null : map(next)\n    }\n  }\n\n  _read (cb) {\n    cb(null)\n  }\n\n  pipe (dest, cb) {\n    this._readableState.updateNextTick()\n    this._readableState.pipe(dest, cb)\n    return dest\n  }\n\n  read () {\n    this._readableState.updateNextTick()\n    return this._readableState.read()\n  }\n\n  push (data) {\n    this._readableState.updateNextTickIfOpen()\n    return this._readableState.push(data)\n  }\n\n  unshift (data) {\n    this._readableState.updateNextTickIfOpen()\n    return this._readableState.unshift(data)\n  }\n\n  resume () {\n    this._duplexState |= READ_RESUMED_READ_AHEAD\n    this._readableState.updateNextTick()\n    return this\n  }\n\n  pause () {\n    this._duplexState &= (this._readableState.readAhead === false ? READ_PAUSED_NO_READ_AHEAD : READ_PAUSED)\n    return this\n  }\n\n  static _fromAsyncIterator (ite, opts) {\n    let destroy\n\n    const rs = new Readable({\n      ...opts,\n      read (cb) {\n        ite.next().then(push).then(cb.bind(null, null)).catch(cb)\n      },\n      predestroy () {\n        destroy = ite.return()\n      },\n      destroy (cb) {\n        if (!destroy) return cb(null)\n        destroy.then(cb.bind(null, null)).catch(cb)\n      }\n    })\n\n    return rs\n\n    function push (data) {\n      if (data.done) rs.push(null)\n      else rs.push(data.value)\n    }\n  }\n\n  static from (data, opts) {\n    if (isReadStreamx(data)) return data\n    if (data[asyncIterator]) return this._fromAsyncIterator(data[asyncIterator](), opts)\n    if (!Array.isArray(data)) data = data === undefined ? [] : [data]\n\n    let i = 0\n    return new Readable({\n      ...opts,\n      read (cb) {\n        this.push(i === data.length ? null : data[i++])\n        cb(null)\n      }\n    })\n  }\n\n  static isBackpressured (rs) {\n    return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark\n  }\n\n  static isPaused (rs) {\n    return (rs._duplexState & READ_RESUMED) === 0\n  }\n\n  [asyncIterator] () {\n    const stream = this\n\n    let error = null\n    let promiseResolve = null\n    let promiseReject = null\n\n    this.on('error', (err) => { error = err })\n    this.on('readable', onreadable)\n    this.on('close', onclose)\n\n    return {\n      [asyncIterator] () {\n        return this\n      },\n      next () {\n        return new Promise(function (resolve, reject) {\n          promiseResolve = resolve\n          promiseReject = reject\n          const data = stream.read()\n          if (data !== null) ondata(data)\n          else if ((stream._duplexState & DESTROYED) !== 0) ondata(null)\n        })\n      },\n      return () {\n        return destroy(null)\n      },\n      throw (err) {\n        return destroy(err)\n      }\n    }\n\n    function onreadable () {\n      if (promiseResolve !== null) ondata(stream.read())\n    }\n\n    function onclose () {\n      if (promiseResolve !== null) ondata(null)\n    }\n\n    function ondata (data) {\n      if (promiseReject === null) return\n      if (error) promiseReject(error)\n      else if (data === null && (stream._duplexState & READ_DONE) === 0) promiseReject(STREAM_DESTROYED)\n      else promiseResolve({ value: data, done: data === null })\n      promiseReject = promiseResolve = null\n    }\n\n    function destroy (err) {\n      stream.destroy(err)\n      return new Promise((resolve, reject) => {\n        if (stream._duplexState & DESTROYED) return resolve({ value: undefined, done: true })\n        stream.once('close', function () {\n          if (err) reject(err)\n          else resolve({ value: undefined, done: true })\n        })\n      })\n    }\n  }\n}\n\nclass Writable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | READ_DONE\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n      if (opts.eagerOpen) this._writableState.updateNextTick()\n    }\n  }\n\n  cork () {\n    this._duplexState |= WRITE_CORKED\n  }\n\n  uncork () {\n    this._duplexState &= WRITE_NOT_CORKED\n    this._writableState.updateNextTick()\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  static isBackpressured (ws) {\n    return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0\n  }\n\n  static drained (ws) {\n    if (ws.destroyed) return Promise.resolve(false)\n    const state = ws._writableState\n    const pending = (isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length)\n    const writes = pending + ((ws._duplexState & WRITE_WRITING) ? 1 : 0)\n    if (writes === 0) return Promise.resolve(true)\n    if (state.drains === null) state.drains = []\n    return new Promise((resolve) => {\n      state.drains.push({ writes, resolve })\n    })\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Duplex extends Readable { // and Writable\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState = OPENING | (this._duplexState & READ_READ_AHEAD)\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n    }\n  }\n\n  cork () {\n    this._duplexState |= WRITE_CORKED\n  }\n\n  uncork () {\n    this._duplexState &= WRITE_NOT_CORKED\n    this._writableState.updateNextTick()\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Transform extends Duplex {\n  constructor (opts) {\n    super(opts)\n    this._transformState = new TransformState(this)\n\n    if (opts) {\n      if (opts.transform) this._transform = opts.transform\n      if (opts.flush) this._flush = opts.flush\n    }\n  }\n\n  _write (data, cb) {\n    if (this._readableState.buffered >= this._readableState.highWaterMark) {\n      this._transformState.data = data\n    } else {\n      this._transform(data, this._transformState.afterTransform)\n    }\n  }\n\n  _read (cb) {\n    if (this._transformState.data !== null) {\n      const data = this._transformState.data\n      this._transformState.data = null\n      cb(null)\n      this._transform(data, this._transformState.afterTransform)\n    } else {\n      cb(null)\n    }\n  }\n\n  destroy (err) {\n    super.destroy(err)\n    if (this._transformState.data !== null) {\n      this._transformState.data = null\n      this._transformState.afterTransform()\n    }\n  }\n\n  _transform (data, cb) {\n    cb(null, data)\n  }\n\n  _flush (cb) {\n    cb(null)\n  }\n\n  _final (cb) {\n    this._transformState.afterFinal = cb\n    this._flush(transformAfterFlush.bind(this))\n  }\n}\n\nclass PassThrough extends Transform {}\n\nfunction transformAfterFlush (err, data) {\n  const cb = this._transformState.afterFinal\n  if (err) return cb(err)\n  if (data !== null && data !== undefined) this.push(data)\n  this.push(null)\n  cb(null)\n}\n\nfunction pipelinePromise (...streams) {\n  return new Promise((resolve, reject) => {\n    return pipeline(...streams, (err) => {\n      if (err) return reject(err)\n      resolve()\n    })\n  })\n}\n\nfunction pipeline (stream, ...streams) {\n  const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams]\n  const done = (all.length && typeof all[all.length - 1] === 'function') ? all.pop() : null\n\n  if (all.length < 2) throw new Error('Pipeline requires at least 2 streams')\n\n  let src = all[0]\n  let dest = null\n  let error = null\n\n  for (let i = 1; i < all.length; i++) {\n    dest = all[i]\n\n    if (isStreamx(src)) {\n      src.pipe(dest, onerror)\n    } else {\n      errorHandle(src, true, i > 1, onerror)\n      src.pipe(dest)\n    }\n\n    src = dest\n  }\n\n  if (done) {\n    let fin = false\n\n    const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy)\n\n    dest.on('error', (err) => {\n      if (error === null) error = err\n    })\n\n    dest.on('finish', () => {\n      fin = true\n      if (!autoDestroy) done(error)\n    })\n\n    if (autoDestroy) {\n      dest.on('close', () => done(error || (fin ? null : PREMATURE_CLOSE)))\n    }\n  }\n\n  return dest\n\n  function errorHandle (s, rd, wr, onerror) {\n    s.on('error', onerror)\n    s.on('close', onclose)\n\n    function onclose () {\n      if (rd && s._readableState && !s._readableState.ended) return onerror(PREMATURE_CLOSE)\n      if (wr && s._writableState && !s._writableState.ended) return onerror(PREMATURE_CLOSE)\n    }\n  }\n\n  function onerror (err) {\n    if (!err || error) return\n    error = err\n\n    for (const s of all) {\n      s.destroy(err)\n    }\n  }\n}\n\nfunction echo (s) {\n  return s\n}\n\nfunction isStream (stream) {\n  return !!stream._readableState || !!stream._writableState\n}\n\nfunction isStreamx (stream) {\n  return typeof stream._duplexState === 'number' && isStream(stream)\n}\n\nfunction isEnded (stream) {\n  return !!stream._readableState && stream._readableState.ended\n}\n\nfunction isFinished (stream) {\n  return !!stream._writableState && stream._writableState.ended\n}\n\nfunction getStreamError (stream, opts = {}) {\n  const err = (stream._readableState && stream._readableState.error) || (stream._writableState && stream._writableState.error)\n\n  // avoid implicit errors by default\n  return (!opts.all && err === STREAM_DESTROYED) ? null : err\n}\n\nfunction isReadStreamx (stream) {\n  return isStreamx(stream) && stream.readable\n}\n\nfunction isDisturbed (stream) {\n  return (stream._duplexState & OPENING) !== OPENING || (stream._duplexState & ACTIVE_OR_TICKING) !== 0\n}\n\nfunction isTypedArray (data) {\n  return typeof data === 'object' && data !== null && typeof data.byteLength === 'number'\n}\n\nfunction defaultByteLength (data) {\n  return isTypedArray(data) ? data.byteLength : 1024\n}\n\nfunction noop () {}\n\nfunction abort () {\n  this.destroy(new Error('Stream aborted.'))\n}\n\nfunction isWritev (s) {\n  return s._writev !== Writable.prototype._writev && s._writev !== Duplex.prototype._writev\n}\n\nmodule.exports = {\n  pipeline,\n  pipelinePromise,\n  isStream,\n  isStreamx,\n  isEnded,\n  isFinished,\n  isDisturbed,\n  getStreamError,\n  Stream,\n  Writable,\n  Readable,\n  Duplex,\n  Transform,\n  // Export PassThrough for compatibility with Node.js core's stream module\n  PassThrough\n}\n","'use strict';\n\n/**\n * @typedef {{ [key: string]: any }} Extensions\n * @typedef {Error} Err\n * @property {string} message\n */\n\n/**\n *\n * @param {Error} obj\n * @param {Extensions} props\n * @returns {Error & Extensions}\n */\nfunction assign(obj, props) {\n    for (const key in props) {\n        Object.defineProperty(obj, key, {\n            value: props[key],\n            enumerable: true,\n            configurable: true,\n        });\n    }\n\n    return obj;\n}\n\n/**\n *\n * @param {any} err - An Error\n * @param {string|Extensions} code - A string code or props to set on the error\n * @param {Extensions} [props] - Props to set on the error\n * @returns {Error & Extensions}\n */\nfunction createError(err, code, props) {\n    if (!err || typeof err === 'string') {\n        throw new TypeError('Please pass an Error to err-code');\n    }\n\n    if (!props) {\n        props = {};\n    }\n\n    if (typeof code === 'object') {\n        props = code;\n        code = '';\n    }\n\n    if (code) {\n        props.code = code;\n    }\n\n    try {\n        return assign(err, props);\n    } catch (_) {\n        props.message = err.message;\n        props.stack = err.stack;\n\n        const ErrClass = function () {};\n\n        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));\n\n        // @ts-ignore\n        const output = assign(new ErrClass(), props);\n\n        return output;\n    }\n}\n\nmodule.exports = createError;\n","/* Common package for dealing with hex/string/uint8 conversions (and sha1 hashing)\r\n*\r\n* @author   Jimmy Wrting <jimmy@warting.se> (https://jimmy.warting.se/opensource)\r\n* @license  MIT\r\n*/\r\nexport const alphabet = '0123456789abcdef'\r\nconst encodeLookup = []\r\nconst decodeLookup = []\r\n\r\nfor (let i = 0; i < 256; i++) {\r\n  encodeLookup[i] = alphabet[i >> 4 & 0xf] + alphabet[i & 0xf]\r\n  if (i < 16) {\r\n    if (i < 10) {\r\n      decodeLookup[0x30 + i] = i\r\n    } else {\r\n      decodeLookup[0x61 - 10 + i] = i\r\n    }\r\n  }\r\n}\r\n\r\nexport const arr2hex = data => {\r\n  const length = data.length\r\n  let string = ''\r\n  let i = 0\r\n  while (i < length) {\r\n    string += encodeLookup[data[i++]]\r\n  }\r\n  return string\r\n}\r\n\r\nexport const hex2arr = str => {\r\n  const sizeof = str.length >> 1\r\n  const length = sizeof << 1\r\n  const array = new Uint8Array(sizeof)\r\n  let n = 0\r\n  let i = 0\r\n  while (i < length) {\r\n    array[n++] = decodeLookup[str.charCodeAt(i++)] << 4 | decodeLookup[str.charCodeAt(i++)]\r\n  }\r\n  return array\r\n}\r\n\r\nexport const concat = (chunks, size = 0) => {\r\n  const length = chunks.length || 0\r\n  if (!size) {\r\n    let i = length\r\n    while (i--) size += chunks[i].length\r\n  }\r\n  const b = new Uint8Array(size)\r\n  let offset = size\r\n  let i = length\r\n  while (i--) {\r\n    offset -= chunks[i].length\r\n    b.set(chunks[i], offset)\r\n  }\r\n\r\n  return b\r\n}\r\n\r\nexport const equal = (a, b) => {\r\n  if (a.length !== b.length) return false\r\n  for (let i = a.length; i > -1; i -= 1) {\r\n    if ((a[i] !== b[i])) return false\r\n  }\r\n  return true\r\n}\r\n","/*\n * base64-arraybuffer 1.0.2 <https://github.com/niklasvh/base64-arraybuffer>\n * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>\n * Released under MIT License\n */\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n// Use a lookup table to find the index.\nvar lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\nfor (var i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n}\nvar encode = function (arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';\n    for (i = 0; i < len; i += 3) {\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64 += chars[bytes[i + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + '=';\n    }\n    else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + '==';\n    }\n    return base64;\n};\nvar decode = function (base64) {\n    var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n    if (base64[base64.length - 1] === '=') {\n        bufferLength--;\n        if (base64[base64.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n    var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n    for (i = 0; i < len; i += 4) {\n        encoded1 = lookup[base64.charCodeAt(i)];\n        encoded2 = lookup[base64.charCodeAt(i + 1)];\n        encoded3 = lookup[base64.charCodeAt(i + 2)];\n        encoded4 = lookup[base64.charCodeAt(i + 3)];\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n    return arraybuffer;\n};\n\nexport { decode, encode };\n//# sourceMappingURL=base64-arraybuffer.es5.js.map\n","import { arr2hex, hex2arr, alphabet } from './util.js'\r\nimport { decode, encode } from 'base64-arraybuffer'\r\n\r\nconst decoder = new TextDecoder()\r\n// 50% slower at < 48 chars, but little impact at 4M OPS/s vs 8M OPS/s\r\nexport const arr2text = (data, enc) => {\r\n  if (!enc) return decoder.decode(data)\r\n  const dec = new TextDecoder(enc)\r\n  return dec.decode(data)\r\n}\r\n\r\n// sacrifice ~20% speed for bundle size\r\nconst encoder = new TextEncoder()\r\nexport const text2arr = str => encoder.encode(str)\r\n\r\nexport const arr2base = data => encode(data)\r\n\r\nexport const base2arr = str => new Uint8Array(decode(str))\r\n\r\nexport const bin2hex = str => {\r\n  let res = ''\r\n  let c\r\n  let i = 0\r\n  const len = str.length\r\n\r\n  while (i < len) {\r\n    c = str.charCodeAt(i++)\r\n    res += alphabet[c >> 4] + alphabet[c & 0xF]\r\n  }\r\n\r\n  return res\r\n}\r\n\r\nconst MAX_ARGUMENTS_LENGTH = 0x10000\r\nexport const hex2bin = hex => {\r\n  const points = hex2arr(hex)\r\n  if (points.length <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode(...points)\r\n\r\n  let res = ''\r\n  let i = 0\r\n  while (i < points.length) {\r\n    res += String.fromCharCode(...points.subarray(i, i += MAX_ARGUMENTS_LENGTH))\r\n  }\r\n  return res\r\n}\r\n\r\nconst scope = typeof window !== 'undefined' ? window : self\r\nconst crypto = scope.crypto || scope.msCrypto || {}\r\nconst subtle = crypto.subtle || crypto.webkitSubtle\r\n\r\nconst formatMap = {\r\n  hex: arr2hex,\r\n  base64: arr2base\r\n}\r\n\r\nexport const hash = async (data, format, algo = 'sha-1') => {\r\n  if (!subtle) throw new Error('no web crypto support')\r\n  if (typeof data === 'string') data = text2arr(data)\r\n  const out = new Uint8Array(await subtle.digest(algo, data))\r\n  return format ? formatMap[format](out) : out\r\n}\r\n\r\nexport const randomBytes = size => {\r\n  const view = new Uint8Array(size)\r\n  return crypto.getRandomValues(view)\r\n}\r\n\r\nexport * from './util.js'\r\n","/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\r\nimport debug from 'debug'\r\nimport { RTCPeerConnection, RTCSessionDescription, RTCIceCandidate } from 'webrtc-polyfill'\r\nimport { Duplex } from 'streamx'\r\nimport errCode from 'err-code'\r\nimport { randomBytes, arr2hex, text2arr } from 'uint8-util'\r\n\r\nconst Debug = debug('simple-peer')\r\n\r\nconst MAX_BUFFERED_AMOUNT = 64 * 1024\r\nconst ICECOMPLETE_TIMEOUT = 5 * 1000\r\nconst CHANNEL_CLOSING_TIMEOUT = 5 * 1000\r\n\r\n// HACK: Filter trickle lines when trickle is disabled #354\r\nfunction filterTrickle (sdp) {\r\n  return sdp.replace(/a=ice-options:trickle\\s\\n/g, '')\r\n}\r\n\r\nfunction warn (message) {\r\n  console.warn(message)\r\n}\r\n\r\n/**\r\n * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.\r\n * Duplex stream.\r\n * @param {Object} opts\r\n */\r\nclass Peer extends Duplex {\r\n  /** @type {RTCPeerConnection} */\r\n  _pc\r\n  constructor (opts) {\r\n    opts = Object.assign({\r\n      allowHalfOpen: false\r\n    }, opts)\r\n\r\n    super(opts)\r\n\r\n    this.__objectMode = !!opts.objectMode // streamx is objectMode by default, so implement readable's fuctionality\r\n\r\n    this._id = arr2hex(randomBytes(4)).slice(0, 7)\r\n    this._debug('new peer %o', opts)\r\n\r\n    this.channelName = opts.initiator\r\n      ? opts.channelName || arr2hex(randomBytes(20))\r\n      : null\r\n\r\n    this.initiator = opts.initiator || false\r\n    this.channelConfig = opts.channelConfig || Peer.channelConfig\r\n    this.channelNegotiated = this.channelConfig.negotiated\r\n    this.config = Object.assign({}, Peer.config, opts.config)\r\n    this.offerOptions = opts.offerOptions || {}\r\n    this.answerOptions = opts.answerOptions || {}\r\n    this.sdpTransform = opts.sdpTransform || (sdp => sdp)\r\n    this.trickle = opts.trickle !== undefined ? opts.trickle : true\r\n    this.allowHalfTrickle = opts.allowHalfTrickle !== undefined ? opts.allowHalfTrickle : false\r\n    this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT\r\n\r\n    this._destroying = false\r\n    this._connected = false\r\n\r\n    this.remoteAddress = undefined\r\n    this.remoteFamily = undefined\r\n    this.remotePort = undefined\r\n    this.localAddress = undefined\r\n    this.localFamily = undefined\r\n    this.localPort = undefined\r\n\r\n    if (!RTCPeerConnection) {\r\n      if (typeof window === 'undefined') {\r\n        throw errCode(new Error('No WebRTC support: Specify `opts.wrtc` option in this environment'), 'ERR_WEBRTC_SUPPORT')\r\n      } else {\r\n        throw errCode(new Error('No WebRTC support: Not a supported browser'), 'ERR_WEBRTC_SUPPORT')\r\n      }\r\n    }\r\n\r\n    this._pcReady = false\r\n    this._channelReady = false\r\n    this._iceComplete = false // ice candidate trickle done (got null candidate)\r\n    this._iceCompleteTimer = null // send an offer/answer anyway after some timeout\r\n    this._channel = null\r\n    this._pendingCandidates = []\r\n\r\n    this._isNegotiating = false // is this peer waiting for negotiation to complete?\r\n    this._firstNegotiation = true\r\n    this._batchedNegotiation = false // batch synchronous negotiations\r\n    this._queuedNegotiation = false // is there a queued negotiation request?\r\n    this._sendersAwaitingStable = []\r\n    this._closingInterval = null\r\n\r\n    this._remoteTracks = []\r\n    this._remoteStreams = []\r\n\r\n    this._chunk = null\r\n    this._cb = null\r\n    this._interval = null\r\n\r\n    try {\r\n      this._pc = new RTCPeerConnection(this.config)\r\n    } catch (err) {\r\n      this.__destroy(errCode(err, 'ERR_PC_CONSTRUCTOR'))\r\n      return\r\n    }\r\n\r\n    // We prefer feature detection whenever possible, but sometimes that's not\r\n    // possible for certain implementations.\r\n    this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === 'number'\r\n\r\n    this._pc.oniceconnectionstatechange = () => {\r\n      this._onIceStateChange()\r\n    }\r\n    this._pc.onicegatheringstatechange = () => {\r\n      this._onIceStateChange()\r\n    }\r\n    this._pc.onconnectionstatechange = () => {\r\n      this._onConnectionStateChange()\r\n    }\r\n    this._pc.onsignalingstatechange = () => {\r\n      this._onSignalingStateChange()\r\n    }\r\n    this._pc.onicecandidate = event => {\r\n      this._onIceCandidate(event)\r\n    }\r\n\r\n    // HACK: Fix for odd Firefox behavior, see: https://github.com/feross/simple-peer/pull/783\r\n    if (typeof this._pc.peerIdentity === 'object') {\r\n      this._pc.peerIdentity.catch(err => {\r\n        this.__destroy(errCode(err, 'ERR_PC_PEER_IDENTITY'))\r\n      })\r\n    }\r\n\r\n    // Other spec events, unused by this implementation:\r\n    // - onconnectionstatechange\r\n    // - onicecandidateerror\r\n    // - onfingerprintfailure\r\n    // - onnegotiationneeded\r\n\r\n    if (this.initiator || this.channelNegotiated) {\r\n      this._setupData({\r\n        channel: this._pc.createDataChannel(this.channelName, this.channelConfig)\r\n      })\r\n    } else {\r\n      this._pc.ondatachannel = event => {\r\n        this._setupData(event)\r\n      }\r\n    }\r\n\r\n    this._debug('initial negotiation')\r\n    this._needsNegotiation()\r\n\r\n    this._onFinishBound = () => {\r\n      this._onFinish()\r\n    }\r\n    this.once('finish', this._onFinishBound)\r\n  }\r\n\r\n  get bufferSize () {\r\n    return (this._channel && this._channel.bufferedAmount) || 0\r\n  }\r\n\r\n  // HACK: it's possible channel.readyState is \"closing\" before peer.destroy() fires\r\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\r\n  get connected () {\r\n    return (this._connected && this._channel.readyState === 'open')\r\n  }\r\n\r\n  address () {\r\n    return { port: this.localPort, family: this.localFamily, address: this.localAddress }\r\n  }\r\n\r\n  signal (data) {\r\n    if (this._destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot signal after peer is destroyed'), 'ERR_DESTROYED')\r\n    if (typeof data === 'string') {\r\n      try {\r\n        data = JSON.parse(data)\r\n      } catch (err) {\r\n        data = {}\r\n      }\r\n    }\r\n    this._debug('signal()')\r\n\r\n    if (data.renegotiate && this.initiator) {\r\n      this._debug('got request to renegotiate')\r\n      this._needsNegotiation()\r\n    }\r\n    if (data.transceiverRequest && this.initiator) {\r\n      this._debug('got request for transceiver')\r\n      this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init)\r\n    }\r\n    if (data.candidate) {\r\n      if (this._pc.remoteDescription && this._pc.remoteDescription.type) {\r\n        this._addIceCandidate(data.candidate)\r\n      } else {\r\n        this._pendingCandidates.push(data.candidate)\r\n      }\r\n    }\r\n    if (data.sdp) {\r\n      this._pc.setRemoteDescription(new RTCSessionDescription(data))\r\n        .then(() => {\r\n          if (this.destroyed) return\r\n\r\n          this._pendingCandidates.forEach(candidate => {\r\n            this._addIceCandidate(candidate)\r\n          })\r\n          this._pendingCandidates = []\r\n\r\n          if (this._pc.remoteDescription.type === 'offer') this._createAnswer()\r\n        })\r\n        .catch(err => {\r\n          this.__destroy(errCode(err, 'ERR_SET_REMOTE_DESCRIPTION'))\r\n        })\r\n    }\r\n    if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {\r\n      this.__destroy(errCode(new Error('signal() called with invalid signal data'), 'ERR_SIGNALING'))\r\n    }\r\n  }\r\n\r\n  _addIceCandidate (candidate) {\r\n    const iceCandidateObj = new RTCIceCandidate(candidate)\r\n    this._pc.addIceCandidate(iceCandidateObj)\r\n      .catch(err => {\r\n        if (!iceCandidateObj.address || iceCandidateObj.address.endsWith('.local')) {\r\n          warn('Ignoring unsupported ICE candidate.')\r\n        } else {\r\n          this.__destroy(errCode(err, 'ERR_ADD_ICE_CANDIDATE'))\r\n        }\r\n      })\r\n  }\r\n\r\n  /**\r\n   * Send text/binary data to the remote peer.\r\n   * @param {ArrayBufferView|ArrayBuffer|Uint8Array|string|Blob} chunk\r\n   */\r\n  send (chunk) {\r\n    if (this._destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot send after peer is destroyed'), 'ERR_DESTROYED')\r\n    this._channel.send(chunk)\r\n  }\r\n\r\n  _needsNegotiation () {\r\n    this._debug('_needsNegotiation')\r\n    if (this._batchedNegotiation) return // batch synchronous renegotiations\r\n    this._batchedNegotiation = true\r\n    queueMicrotask(() => {\r\n      this._batchedNegotiation = false\r\n      if (this.initiator || !this._firstNegotiation) {\r\n        this._debug('starting batched negotiation')\r\n        this.negotiate()\r\n      } else {\r\n        this._debug('non-initiator initial negotiation request discarded')\r\n      }\r\n      this._firstNegotiation = false\r\n    })\r\n  }\r\n\r\n  negotiate () {\r\n    if (this._destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot negotiate after peer is destroyed'), 'ERR_DESTROYED')\r\n\r\n    if (this.initiator) {\r\n      if (this._isNegotiating) {\r\n        this._queuedNegotiation = true\r\n        this._debug('already negotiating, queueing')\r\n      } else {\r\n        this._debug('start negotiation')\r\n        setTimeout(() => { // HACK: Chrome crashes if we immediately call createOffer\r\n          this._createOffer()\r\n        }, 0)\r\n      }\r\n    } else {\r\n      if (this._isNegotiating) {\r\n        this._queuedNegotiation = true\r\n        this._debug('already negotiating, queueing')\r\n      } else {\r\n        this._debug('requesting negotiation from initiator')\r\n        this.emit('signal', { // request initiator to renegotiate\r\n          type: 'renegotiate',\r\n          renegotiate: true\r\n        })\r\n      }\r\n    }\r\n    this._isNegotiating = true\r\n  }\r\n\r\n  _final (cb) {\r\n    if (!this._readableState.ended) this.push(null)\r\n    cb(null)\r\n  }\r\n\r\n  __destroy (err) {\r\n    this.end()\r\n    this._destroy(() => {}, err)\r\n  }\r\n\r\n  _destroy (cb, err) {\r\n    if (this.destroyed || this._destroying) return\r\n    this._destroying = true\r\n\r\n    this._debug('destroying (error: %s)', err && (err.message || err))\r\n\r\n    setTimeout(() => { // allow events concurrent with the call to _destroy() to fire (see #692)\r\n      if (this._connected) this.emit('disconnect')\r\n      this._connected = false\r\n      this._pcReady = false\r\n      this._channelReady = false\r\n      this._remoteTracks = null\r\n      this._remoteStreams = null\r\n      this._senderMap = null\r\n\r\n      clearInterval(this._closingInterval)\r\n      this._closingInterval = null\r\n\r\n      clearInterval(this._interval)\r\n      this._interval = null\r\n      this._chunk = null\r\n      this._cb = null\r\n\r\n      if (this._onFinishBound) this.removeListener('finish', this._onFinishBound)\r\n      this._onFinishBound = null\r\n\r\n      if (this._channel) {\r\n        try {\r\n          this._channel.close()\r\n        } catch (err) {}\r\n\r\n        // allow events concurrent with destruction to be handled\r\n        this._channel.onmessage = null\r\n        this._channel.onopen = null\r\n        this._channel.onclose = null\r\n        this._channel.onerror = null\r\n      }\r\n      if (this._pc) {\r\n        try {\r\n          this._pc.close()\r\n        } catch (err) {}\r\n\r\n        // allow events concurrent with destruction to be handled\r\n        this._pc.oniceconnectionstatechange = null\r\n        this._pc.onicegatheringstatechange = null\r\n        this._pc.onsignalingstatechange = null\r\n        this._pc.onicecandidate = null\r\n        this._pc.ontrack = null\r\n        this._pc.ondatachannel = null\r\n      }\r\n      this._pc = null\r\n      this._channel = null\r\n      if (err) this.emit('error', err)\r\n      cb()\r\n    }, 0)\r\n  }\r\n\r\n  _setupData (event) {\r\n    if (!event.channel) {\r\n      // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),\r\n      // which is invalid behavior. Handle it gracefully.\r\n      // See: https://github.com/feross/simple-peer/issues/163\r\n      return this.__destroy(errCode(new Error('Data channel event is missing `channel` property'), 'ERR_DATA_CHANNEL'))\r\n    }\r\n\r\n    this._channel = event.channel\r\n    this._channel.binaryType = 'arraybuffer'\r\n\r\n    if (typeof this._channel.bufferedAmountLowThreshold === 'number') {\r\n      this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT\r\n    }\r\n\r\n    this.channelName = this._channel.label\r\n\r\n    this._channel.onmessage = event => {\r\n      this._onChannelMessage(event)\r\n    }\r\n    this._channel.onbufferedamountlow = () => {\r\n      this._onChannelBufferedAmountLow()\r\n    }\r\n    this._channel.onopen = () => {\r\n      this._onChannelOpen()\r\n    }\r\n    this._channel.onclose = () => {\r\n      this._onChannelClose()\r\n    }\r\n    this._channel.onerror = event => {\r\n      const err = event.error instanceof Error\r\n        ? event.error\r\n        : new Error(`Datachannel error: ${event.message} ${event.filename}:${event.lineno}:${event.colno}`)\r\n      this.__destroy(errCode(err, 'ERR_DATA_CHANNEL'))\r\n    }\r\n\r\n    // HACK: Chrome will sometimes get stuck in readyState \"closing\", let's check for this condition\r\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\r\n    let isClosing = false\r\n    this._closingInterval = setInterval(() => { // No \"onclosing\" event\r\n      if (this._channel && this._channel.readyState === 'closing') {\r\n        if (isClosing) this._onChannelClose() // closing timed out: equivalent to onclose firing\r\n        isClosing = true\r\n      } else {\r\n        isClosing = false\r\n      }\r\n    }, CHANNEL_CLOSING_TIMEOUT)\r\n  }\r\n\r\n  _write (chunk, cb) {\r\n    if (this.destroyed) return cb(errCode(new Error('cannot write after peer is destroyed'), 'ERR_DATA_CHANNEL'))\r\n\r\n    if (this._connected) {\r\n      try {\r\n        this.send(chunk)\r\n      } catch (err) {\r\n        return this.__destroy(errCode(err, 'ERR_DATA_CHANNEL'))\r\n      }\r\n      if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n        this._debug('start backpressure: bufferedAmount %d', this._channel.bufferedAmount)\r\n        this._cb = cb\r\n      } else {\r\n        cb(null)\r\n      }\r\n    } else {\r\n      this._debug('write before connect')\r\n      this._chunk = chunk\r\n      this._cb = cb\r\n    }\r\n  }\r\n\r\n  // When stream finishes writing, close socket. Half open connections are not\r\n  // supported.\r\n  _onFinish () {\r\n    if (this.destroyed) return\r\n\r\n    // Wait a bit before destroying so the socket flushes.\r\n    // TODO: is there a more reliable way to accomplish this?\r\n    const destroySoon = () => {\r\n      setTimeout(() => this.__destroy(), 1000)\r\n    }\r\n\r\n    if (this._connected) {\r\n      destroySoon()\r\n    } else {\r\n      this.once('connect', destroySoon)\r\n    }\r\n  }\r\n\r\n  _startIceCompleteTimeout () {\r\n    if (this.destroyed) return\r\n    if (this._iceCompleteTimer) return\r\n    this._debug('started iceComplete timeout')\r\n    this._iceCompleteTimer = setTimeout(() => {\r\n      if (!this._iceComplete) {\r\n        this._iceComplete = true\r\n        this._debug('iceComplete timeout completed')\r\n        this.emit('iceTimeout')\r\n        this.emit('_iceComplete')\r\n      }\r\n    }, this.iceCompleteTimeout)\r\n  }\r\n\r\n  _createOffer () {\r\n    if (this.destroyed) return\r\n\r\n    this._pc.createOffer(this.offerOptions)\r\n      .then(offer => {\r\n        if (this.destroyed) return\r\n        if (!this.trickle && !this.allowHalfTrickle) offer.sdp = filterTrickle(offer.sdp)\r\n        offer.sdp = this.sdpTransform(offer.sdp)\r\n\r\n        const sendOffer = () => {\r\n          if (this.destroyed) return\r\n          const signal = this._pc.localDescription || offer\r\n          this._debug('signal')\r\n          this.emit('signal', {\r\n            type: signal.type,\r\n            sdp: signal.sdp\r\n          })\r\n        }\r\n\r\n        const onSuccess = () => {\r\n          this._debug('createOffer success')\r\n          if (this.destroyed) return\r\n          if (this.trickle || this._iceComplete) sendOffer()\r\n          else this.once('_iceComplete', sendOffer) // wait for candidates\r\n        }\r\n\r\n        const onError = err => {\r\n          this.__destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))\r\n        }\r\n\r\n        this._pc.setLocalDescription(offer)\r\n          .then(onSuccess)\r\n          .catch(onError)\r\n      })\r\n      .catch(err => {\r\n        this.__destroy(errCode(err, 'ERR_CREATE_OFFER'))\r\n      })\r\n  }\r\n\r\n  _createAnswer () {\r\n    if (this.destroyed) return\r\n\r\n    this._pc.createAnswer(this.answerOptions)\r\n      .then(answer => {\r\n        if (this.destroyed) return\r\n        if (!this.trickle && !this.allowHalfTrickle) answer.sdp = filterTrickle(answer.sdp)\r\n        answer.sdp = this.sdpTransform(answer.sdp)\r\n\r\n        const sendAnswer = () => {\r\n          if (this.destroyed) return\r\n          const signal = this._pc.localDescription || answer\r\n          this._debug('signal')\r\n          this.emit('signal', {\r\n            type: signal.type,\r\n            sdp: signal.sdp\r\n          })\r\n          if (!this.initiator) this._requestMissingTransceivers?.()\r\n        }\r\n\r\n        const onSuccess = () => {\r\n          if (this.destroyed) return\r\n          if (this.trickle || this._iceComplete) sendAnswer()\r\n          else this.once('_iceComplete', sendAnswer)\r\n        }\r\n\r\n        const onError = err => {\r\n          this.__destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))\r\n        }\r\n\r\n        this._pc.setLocalDescription(answer)\r\n          .then(onSuccess)\r\n          .catch(onError)\r\n      })\r\n      .catch(err => {\r\n        this.__destroy(errCode(err, 'ERR_CREATE_ANSWER'))\r\n      })\r\n  }\r\n\r\n  _onConnectionStateChange () {\r\n    if (this.destroyed || this._destroying) return\r\n    if (this._pc.connectionState === 'failed') {\r\n      this.__destroy(errCode(new Error('Connection failed.'), 'ERR_CONNECTION_FAILURE'))\r\n    }\r\n  }\r\n\r\n  _onIceStateChange () {\r\n    if (this.destroyed) return\r\n    const iceConnectionState = this._pc.iceConnectionState\r\n    const iceGatheringState = this._pc.iceGatheringState\r\n\r\n    this._debug(\r\n      'iceStateChange (connection: %s) (gathering: %s)',\r\n      iceConnectionState,\r\n      iceGatheringState\r\n    )\r\n    this.emit('iceStateChange', iceConnectionState, iceGatheringState)\r\n\r\n    if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {\r\n      this._pcReady = true\r\n      this._maybeReady()\r\n    }\r\n    if (iceConnectionState === 'failed') {\r\n      this.__destroy(errCode(new Error('Ice connection failed.'), 'ERR_ICE_CONNECTION_FAILURE'))\r\n    }\r\n    if (iceConnectionState === 'closed') {\r\n      this.__destroy(errCode(new Error('Ice connection closed.'), 'ERR_ICE_CONNECTION_CLOSED'))\r\n    }\r\n  }\r\n\r\n  getStats (cb) {\r\n    // statreports can come with a value array instead of properties\r\n    const flattenValues = report => {\r\n      if (Object.prototype.toString.call(report.values) === '[object Array]') {\r\n        report.values.forEach(value => {\r\n          Object.assign(report, value)\r\n        })\r\n      }\r\n      return report\r\n    }\r\n\r\n    // Promise-based getStats() (standard)\r\n    if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {\r\n      this._pc.getStats()\r\n        .then(res => {\r\n          const reports = []\r\n          res.forEach(report => {\r\n            reports.push(flattenValues(report))\r\n          })\r\n          cb(null, reports)\r\n        }, err => cb(err))\r\n\r\n    // Single-parameter callback-based getStats() (non-standard)\r\n    } else if (this._pc.getStats.length > 0) {\r\n      this._pc.getStats(res => {\r\n        // If we destroy connection in `connect` callback this code might happen to run when actual connection is already closed\r\n        if (this.destroyed) return\r\n\r\n        const reports = []\r\n        res.result().forEach(result => {\r\n          const report = {}\r\n          result.names().forEach(name => {\r\n            report[name] = result.stat(name)\r\n          })\r\n          report.id = result.id\r\n          report.type = result.type\r\n          report.timestamp = result.timestamp\r\n          reports.push(flattenValues(report))\r\n        })\r\n        cb(null, reports)\r\n      }, err => cb(err))\r\n\r\n    // Unknown browser, skip getStats() since it's anyone's guess which style of\r\n    // getStats() they implement.\r\n    } else {\r\n      cb(null, [])\r\n    }\r\n  }\r\n\r\n  _maybeReady () {\r\n    this._debug('maybeReady pc %s channel %s', this._pcReady, this._channelReady)\r\n    if (this._connected || this._connecting || !this._pcReady || !this._channelReady) return\r\n\r\n    this._connecting = true\r\n\r\n    // HACK: We can't rely on order here, for details see https://github.com/js-platform/node-webrtc/issues/339\r\n    const findCandidatePair = () => {\r\n      if (this.destroyed || this._destroying) return\r\n\r\n      this.getStats((err, items) => {\r\n        if (this.destroyed || this._destroying) return\r\n\r\n        // Treat getStats error as non-fatal. It's not essential.\r\n        if (err) items = []\r\n\r\n        const remoteCandidates = {}\r\n        const localCandidates = {}\r\n        const candidatePairs = {}\r\n        let foundSelectedCandidatePair = false\r\n\r\n        items.forEach(item => {\r\n          // TODO: Once all browsers support the hyphenated stats report types, remove\r\n          // the non-hypenated ones\r\n          if (item.type === 'remotecandidate' || item.type === 'remote-candidate') {\r\n            remoteCandidates[item.id] = item\r\n          }\r\n          if (item.type === 'localcandidate' || item.type === 'local-candidate') {\r\n            localCandidates[item.id] = item\r\n          }\r\n          if (item.type === 'candidatepair' || item.type === 'candidate-pair') {\r\n            candidatePairs[item.id] = item\r\n          }\r\n        })\r\n\r\n        const setSelectedCandidatePair = selectedCandidatePair => {\r\n          foundSelectedCandidatePair = true\r\n\r\n          let local = localCandidates[selectedCandidatePair.localCandidateId]\r\n\r\n          if (local && (local.ip || local.address)) {\r\n            // Spec\r\n            this.localAddress = local.ip || local.address\r\n            this.localPort = Number(local.port)\r\n          } else if (local && local.ipAddress) {\r\n            // Firefox\r\n            this.localAddress = local.ipAddress\r\n            this.localPort = Number(local.portNumber)\r\n          } else if (typeof selectedCandidatePair.googLocalAddress === 'string') {\r\n            // TODO: remove this once Chrome 58 is released\r\n            local = selectedCandidatePair.googLocalAddress.split(':')\r\n            this.localAddress = local[0]\r\n            this.localPort = Number(local[1])\r\n          }\r\n          if (this.localAddress) {\r\n            this.localFamily = this.localAddress.includes(':') ? 'IPv6' : 'IPv4'\r\n          }\r\n\r\n          let remote = remoteCandidates[selectedCandidatePair.remoteCandidateId]\r\n\r\n          if (remote && (remote.ip || remote.address)) {\r\n            // Spec\r\n            this.remoteAddress = remote.ip || remote.address\r\n            this.remotePort = Number(remote.port)\r\n          } else if (remote && remote.ipAddress) {\r\n            // Firefox\r\n            this.remoteAddress = remote.ipAddress\r\n            this.remotePort = Number(remote.portNumber)\r\n          } else if (typeof selectedCandidatePair.googRemoteAddress === 'string') {\r\n            // TODO: remove this once Chrome 58 is released\r\n            remote = selectedCandidatePair.googRemoteAddress.split(':')\r\n            this.remoteAddress = remote[0]\r\n            this.remotePort = Number(remote[1])\r\n          }\r\n          if (this.remoteAddress) {\r\n            this.remoteFamily = this.remoteAddress.includes(':') ? 'IPv6' : 'IPv4'\r\n          }\r\n\r\n          this._debug(\r\n            'connect local: %s:%s remote: %s:%s',\r\n            this.localAddress,\r\n            this.localPort,\r\n            this.remoteAddress,\r\n            this.remotePort\r\n          )\r\n        }\r\n\r\n        items.forEach(item => {\r\n          // Spec-compliant\r\n          if (item.type === 'transport' && item.selectedCandidatePairId) {\r\n            setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId])\r\n          }\r\n\r\n          // Old implementations\r\n          if (\r\n            (item.type === 'googCandidatePair' && item.googActiveConnection === 'true') ||\r\n            ((item.type === 'candidatepair' || item.type === 'candidate-pair') && item.selected)\r\n          ) {\r\n            setSelectedCandidatePair(item)\r\n          }\r\n        })\r\n\r\n        // Ignore candidate pair selection in browsers like Safari 11 that do not have any local or remote candidates\r\n        // But wait until at least 1 candidate pair is available\r\n        if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {\r\n          setTimeout(findCandidatePair, 100)\r\n          return\r\n        } else {\r\n          this._connecting = false\r\n          this._connected = true\r\n          this.emit('connect')\r\n        }\r\n\r\n        if (this._chunk) {\r\n          try {\r\n            this.send(this._chunk)\r\n          } catch (err) {\r\n            return this.__destroy(errCode(err, 'ERR_DATA_CHANNEL'))\r\n          }\r\n          this._chunk = null\r\n          this._debug('sent chunk from \"write before connect\"')\r\n\r\n          const cb = this._cb\r\n          this._cb = null\r\n          cb(null)\r\n        }\r\n\r\n        // If `bufferedAmountLowThreshold` and 'onbufferedamountlow' are unsupported,\r\n        // fallback to using setInterval to implement backpressure.\r\n        if (typeof this._channel.bufferedAmountLowThreshold !== 'number') {\r\n          this._interval = setInterval(() => this._onInterval(), 150)\r\n          if (this._interval.unref) this._interval.unref()\r\n        }\r\n\r\n        this._debug('connect')\r\n        this.emit('connect')\r\n      })\r\n    }\r\n    findCandidatePair()\r\n  }\r\n\r\n  _onInterval () {\r\n    if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n      return\r\n    }\r\n    this._onChannelBufferedAmountLow()\r\n  }\r\n\r\n  _onSignalingStateChange () {\r\n    if (this.destroyed) return\r\n\r\n    if (this._pc.signalingState === 'stable') {\r\n      this._isNegotiating = false\r\n\r\n      // HACK: Firefox doesn't yet support removing tracks when signalingState !== 'stable'\r\n      this._debug('flushing sender queue', this._sendersAwaitingStable)\r\n      this._sendersAwaitingStable.forEach(sender => {\r\n        this._pc.removeTrack(sender)\r\n        this._queuedNegotiation = true\r\n      })\r\n      this._sendersAwaitingStable = []\r\n\r\n      if (this._queuedNegotiation) {\r\n        this._debug('flushing negotiation queue')\r\n        this._queuedNegotiation = false\r\n        this._needsNegotiation() // negotiate again\r\n      } else {\r\n        this._debug('negotiated')\r\n        this.emit('negotiated')\r\n      }\r\n    }\r\n\r\n    this._debug('signalingStateChange %s', this._pc.signalingState)\r\n    this.emit('signalingStateChange', this._pc.signalingState)\r\n  }\r\n\r\n  _onIceCandidate (event) {\r\n    if (this.destroyed) return\r\n    if (event.candidate && this.trickle) {\r\n      this.emit('signal', {\r\n        type: 'candidate',\r\n        candidate: {\r\n          candidate: event.candidate.candidate,\r\n          sdpMLineIndex: event.candidate.sdpMLineIndex,\r\n          sdpMid: event.candidate.sdpMid\r\n        }\r\n      })\r\n    } else if (!event.candidate && !this._iceComplete) {\r\n      this._iceComplete = true\r\n      this.emit('_iceComplete')\r\n    }\r\n    // as soon as we've received one valid candidate start timeout\r\n    if (event.candidate) {\r\n      this._startIceCompleteTimeout()\r\n    }\r\n  }\r\n\r\n  _onChannelMessage (event) {\r\n    if (this.destroyed) return\r\n    let data = event.data\r\n    if (data instanceof ArrayBuffer) {\r\n      data = new Uint8Array(data)\r\n    } else if (this.__objectMode === false) {\r\n      data = text2arr(data)\r\n    }\r\n    this.push(data)\r\n  }\r\n\r\n  _onChannelBufferedAmountLow () {\r\n    if (this.destroyed || !this._cb) return\r\n    this._debug('ending backpressure: bufferedAmount %d', this._channel.bufferedAmount)\r\n    const cb = this._cb\r\n    this._cb = null\r\n    cb(null)\r\n  }\r\n\r\n  _onChannelOpen () {\r\n    if (this._connected || this.destroyed) return\r\n    this._debug('on channel open')\r\n    this._channelReady = true\r\n    this._maybeReady()\r\n  }\r\n\r\n  _onChannelClose () {\r\n    if (this.destroyed) return\r\n    this._debug('on channel close')\r\n    this.__destroy()\r\n  }\r\n\r\n  _debug () {\r\n    const args = [].slice.call(arguments)\r\n    args[0] = '[' + this._id + '] ' + args[0]\r\n    Debug.apply(null, args)\r\n  }\r\n}\r\n\r\nPeer.WEBRTC_SUPPORT = !!RTCPeerConnection\r\n\r\n/**\r\n * Expose peer and data channel config for overriding all Peer\r\n * instances. Otherwise, just set opts.config or opts.channelConfig\r\n * when constructing a Peer.\r\n */\r\nPeer.config = {\r\n  iceServers: [\r\n    {\r\n      urls: [\r\n        'stun:stun.l.google.com:19302',\r\n        'stun:global.stun.twilio.com:3478'\r\n      ]\r\n    }\r\n  ],\r\n  sdpSemantics: 'unified-plan'\r\n}\r\n\r\nPeer.channelConfig = {}\r\n\r\nexport default Peer\r\n","export default {}","/**\n * Functions/constants needed by both the client and server.\n */\nimport * as common from './common-node.js'\nexport * from './common-node.js'\n\nexport const DEFAULT_ANNOUNCE_PEERS = 50\nexport const MAX_ANNOUNCE_PEERS = 82\n\n// HACK: Fix for WHATWG URL object not parsing non-standard URL schemes like\n// 'udp:'. Just replace it with 'http:' since we only need a few properties.\n//\n// Note: Only affects Chrome and Firefox. Works fine in Node.js, Safari, and\n// Edge.\n//\n// Note: UDP trackers aren't used in the normal browser build, but they are\n// used in a Chrome App build (i.e. by Brave Browser).\n//\n// Bug reports:\n// - Chrome: https://bugs.chromium.org/p/chromium/issues/detail?id=734880\n// - Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1374505\nexport const parseUrl = str => {\n  const url = new URL(str.replace(/^udp:/, 'http:'))\n\n  if (str.match(/^udp:/)) {\n    Object.defineProperties(url, {\n      href: { value: url.href.replace(/^http/, 'udp') },\n      protocol: { value: url.protocol.replace(/^http/, 'udp') },\n      origin: { value: url.origin.replace(/^http/, 'udp') }\n    })\n  }\n\n  return url\n}\n\nexport default {\n  DEFAULT_ANNOUNCE_PEERS,\n  MAX_ANNOUNCE_PEERS,\n  parseUrl,\n  ...common\n}\n","/*! simple-websocket. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\r\n/* global WebSocket */\r\n\r\nimport Debug from 'debug'\r\nimport queueMicrotask from 'queue-microtask' // TODO: remove when Node 10 is not supported\r\nimport ws from 'ws' // websockets in node - will be empty object in browser\r\nimport { Duplex } from 'streamx'\r\nimport { text2arr, randomBytes, arr2hex } from 'uint8-util'\r\n\r\nconst debug = Debug('simple-websocket')\r\n\r\nconst _WebSocket = typeof ws !== 'function' ? WebSocket : ws\r\n\r\nconst MAX_BUFFERED_AMOUNT = 64 * 1024\r\n\r\n/**\r\n * WebSocket. Same API as node core `net.Socket`. Duplex stream.\r\n * @param {Object} opts\r\n * @param {string=} opts.url websocket server url\r\n * @param {string=} opts.socket raw websocket instance to wrap\r\n */\r\nexport default class Socket extends Duplex {\r\n  constructor (opts = {}) {\r\n    // Support simple usage: `new Socket(url)`\r\n    if (typeof opts === 'string') {\r\n      opts = { url: opts }\r\n    }\r\n\r\n    opts = Object.assign({\r\n      allowHalfOpen: false\r\n    }, opts)\r\n\r\n    super(opts)\r\n\r\n    this.__objectMode = !!opts.objectMode // streamx is objectMode by default, so implement readable's fuctionality\r\n    if (opts.objectMode != null) delete opts.objectMode // causes error with ws...\r\n\r\n    if (opts.url == null && opts.socket == null) {\r\n      throw new Error('Missing required `url` or `socket` option')\r\n    }\r\n    if (opts.url != null && opts.socket != null) {\r\n      throw new Error('Must specify either `url` or `socket` option, not both')\r\n    }\r\n\r\n    this._id = arr2hex(randomBytes(4)).slice(0, 7)\r\n    this._debug('new websocket: %o', opts)\r\n\r\n    this.connected = false\r\n\r\n    this._chunk = null\r\n    this._cb = null\r\n    this._interval = null\r\n\r\n    if (opts.socket) {\r\n      this.url = opts.socket.url\r\n      this._ws = opts.socket\r\n      this.connected = opts.socket.readyState === _WebSocket.OPEN\r\n    } else {\r\n      this.url = opts.url\r\n      try {\r\n        if (typeof ws === 'function') {\r\n          // `ws` package accepts options\r\n          this._ws = new _WebSocket(opts.url, {\r\n            ...opts,\r\n            encoding: undefined // encoding option breaks ws internals\r\n          })\r\n        } else {\r\n          this._ws = new _WebSocket(opts.url)\r\n        }\r\n      } catch (err) {\r\n        queueMicrotask(() => this.destroy(err))\r\n        return\r\n      }\r\n    }\r\n\r\n    this._ws.binaryType = 'arraybuffer'\r\n\r\n    if (opts.socket && this.connected) {\r\n      queueMicrotask(() => this._handleOpen())\r\n    } else {\r\n      this._ws.onopen = () => this._handleOpen()\r\n    }\r\n\r\n    this._ws.onmessage = event => this._handleMessage(event)\r\n    this._ws.onclose = () => this._handleClose()\r\n    this._ws.onerror = err => this._handleError(err)\r\n\r\n    this._handleFinishBound = () => this._handleFinish()\r\n    this.once('finish', this._handleFinishBound)\r\n  }\r\n\r\n  /**\r\n   * Send text/binary data to the WebSocket server.\r\n   * @param {TypedArrayView|ArrayBuffer|Uint8Array|string|Blob|Object} chunk\r\n   */\r\n  send (chunk) {\r\n    this._ws.send(chunk)\r\n  }\r\n\r\n  _final (cb) {\r\n    if (!this._readableState.ended) this.push(null)\r\n    cb(null)\r\n  }\r\n\r\n  _destroy (cb) {\r\n    if (this.destroyed) return\r\n    if (!this._writableState.ended) this.end()\r\n\r\n    this.connected = false\r\n\r\n    clearInterval(this._interval)\r\n    this._interval = null\r\n    this._chunk = null\r\n    this._cb = null\r\n\r\n    if (this._handleFinishBound) {\r\n      this.removeListener('finish', this._handleFinishBound)\r\n    }\r\n    this._handleFinishBound = null\r\n\r\n    if (this._ws) {\r\n      const ws = this._ws\r\n      const onClose = () => {\r\n        ws.onclose = null\r\n      }\r\n      if (ws.readyState === _WebSocket.CLOSED) {\r\n        onClose()\r\n      } else {\r\n        try {\r\n          ws.onclose = onClose\r\n          ws.close()\r\n        } catch (err) {\r\n          onClose()\r\n        }\r\n      }\r\n\r\n      ws.onopen = null\r\n      ws.onmessage = null\r\n      ws.onerror = () => {}\r\n    }\r\n    this._ws = null\r\n\r\n    cb()\r\n  }\r\n\r\n  _write (chunk, cb) {\r\n    if (this.destroyed) return cb(new Error('cannot write after socket is destroyed'))\r\n\r\n    if (this.connected) {\r\n      try {\r\n        this.send(chunk)\r\n      } catch (err) {\r\n        return this.destroy(err)\r\n      }\r\n      if (typeof ws !== 'function' && this._ws.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n        this._debug('start backpressure: bufferedAmount %d', this._ws.bufferedAmount)\r\n        this._cb = cb\r\n      } else {\r\n        cb(null)\r\n      }\r\n    } else {\r\n      this._debug('write before connect')\r\n      this._chunk = chunk\r\n      this._cb = cb\r\n    }\r\n  }\r\n\r\n  _handleOpen () {\r\n    if (this.connected || this.destroyed) return\r\n    this.connected = true\r\n\r\n    if (this._chunk) {\r\n      try {\r\n        this.send(this._chunk)\r\n      } catch (err) {\r\n        return this.destroy(err)\r\n      }\r\n      this._chunk = null\r\n      this._debug('sent chunk from \"write before connect\"')\r\n\r\n      const cb = this._cb\r\n      this._cb = null\r\n      cb(null)\r\n    }\r\n\r\n    // Backpressure is not implemented in Node.js. The `ws` module has a buggy\r\n    // `bufferedAmount` property. See: https://github.com/websockets/ws/issues/492\r\n    if (typeof ws !== 'function') {\r\n      this._interval = setInterval(() => this._onInterval(), 150)\r\n      if (this._interval.unref) this._interval.unref()\r\n    }\r\n\r\n    this._debug('connect')\r\n    this.emit('connect')\r\n  }\r\n\r\n  _handleMessage (event) {\r\n    if (this.destroyed) return\r\n    let data = event.data\r\n    if (data instanceof ArrayBuffer) data = new Uint8Array(data)\r\n    if (this.__objectMode === false) data = text2arr(data)\r\n    this.push(data)\r\n  }\r\n\r\n  _handleClose () {\r\n    if (this.destroyed) return\r\n    this._debug('on close')\r\n    this.destroy()\r\n  }\r\n\r\n  _handleError (_) {\r\n    this.destroy(new Error(`Error connecting to ${this.url}`))\r\n  }\r\n\r\n  // When stream finishes writing, close socket. Half open connections are not\r\n  // supported.\r\n  _handleFinish () {\r\n    if (this.destroyed) return\r\n\r\n    // Wait a bit before destroying so the socket flushes.\r\n    // TODO: is there a more reliable way to accomplish this?\r\n    const destroySoon = () => {\r\n      setTimeout(() => this.destroy(), 1000)\r\n    }\r\n\r\n    if (this.connected) {\r\n      destroySoon()\r\n    } else {\r\n      this.once('connect', destroySoon)\r\n    }\r\n  }\r\n\r\n  _onInterval () {\r\n    if (!this._cb || !this._ws || this._ws.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n      return\r\n    }\r\n    this._debug('ending backpressure: bufferedAmount %d', this._ws.bufferedAmount)\r\n    const cb = this._cb\r\n    this._cb = null\r\n    cb(null)\r\n  }\r\n\r\n  _debug () {\r\n    const args = [].slice.call(arguments)\r\n    args[0] = '[' + this._id + '] ' + args[0]\r\n    debug.apply(null, args)\r\n  }\r\n}\r\n\r\nSocket.WEBSOCKET_SUPPORT = !!_WebSocket\r\n","import EventEmitter from 'events'\n\nclass Tracker extends EventEmitter {\n  constructor (client, announceUrl) {\n    super()\n\n    this.client = client\n    this.announceUrl = announceUrl\n\n    this.interval = null\n    this.destroyed = false\n  }\n\n  setInterval (intervalMs) {\n    if (intervalMs == null) intervalMs = this.DEFAULT_ANNOUNCE_INTERVAL\n\n    clearInterval(this.interval)\n\n    if (intervalMs) {\n      this.interval = setInterval(() => {\n        this.announce(this.client._defaultAnnounceOpts())\n      }, intervalMs)\n      if (this.interval.unref) this.interval.unref()\n    }\n  }\n}\n\nexport default Tracker\n","import Debug from 'debug'\nimport Peer from '@thaunknown/simple-peer/lite.js'\nimport Socket from '@thaunknown/simple-websocket'\nimport { arr2text, arr2hex, hex2bin, bin2hex, randomBytes } from 'uint8-util'\n\nimport common from '../common.js'\nimport Tracker from './tracker.js'\n\nconst debug = Debug('bittorrent-tracker:websocket-tracker')\n\n// Use a socket pool, so tracker clients share WebSocket objects for the same server.\n// In practice, WebSockets are pretty slow to establish, so this gives a nice performance\n// boost, and saves browser resources.\nconst socketPool = {}\n\nconst RECONNECT_MINIMUM = 10 * 1000\nconst RECONNECT_MAXIMUM = 60 * 60 * 1000\nconst RECONNECT_VARIANCE = 5 * 60 * 1000\nconst OFFER_TIMEOUT = 50 * 1000\n\nclass WebSocketTracker extends Tracker {\n  constructor (client, announceUrl) {\n    super(client, announceUrl)\n    debug('new websocket tracker %s', announceUrl)\n\n    this.peers = {} // peers (offer id -> peer)\n    this.socket = null\n\n    this.reconnecting = false\n    this.retries = 0\n    this.reconnectTimer = null\n\n    // Simple boolean flag to track whether the socket has received data from\n    // the websocket server since the last time socket.send() was called.\n    this.expectingResponse = false\n\n    this._openSocket()\n  }\n\n  announce (opts) {\n    if (this.destroyed || this.reconnecting) return\n    if (!this.socket.connected) {\n      this.socket.once('connect', () => {\n        this.announce(opts)\n      })\n      return\n    }\n\n    const params = Object.assign({}, opts, {\n      action: 'announce',\n      info_hash: this.client._infoHashBinary,\n      peer_id: this.client._peerIdBinary\n    })\n    if (this._trackerId) params.trackerid = this._trackerId\n\n    if (opts.event === 'stopped' || opts.event === 'completed') {\n      // Don't include offers with 'stopped' or 'completed' event\n      this._send(params)\n    } else {\n      // Limit the number of offers that are generated, since it can be slow\n      const numwant = Math.min(opts.numwant, 10)\n\n      this._generateOffers(numwant, offers => {\n        params.numwant = numwant\n        params.offers = offers\n        this._send(params)\n      })\n    }\n  }\n\n  scrape (opts) {\n    if (this.destroyed || this.reconnecting) return\n    if (!this.socket.connected) {\n      this.socket.once('connect', () => {\n        this.scrape(opts)\n      })\n      return\n    }\n\n    const infoHashes = (Array.isArray(opts.infoHash) && opts.infoHash.length > 0)\n      ? opts.infoHash.map(infoHash => hex2bin(infoHash))\n      : (opts.infoHash && hex2bin(opts.infoHash)) || this.client._infoHashBinary\n    const params = {\n      action: 'scrape',\n      info_hash: infoHashes\n    }\n\n    this._send(params)\n  }\n\n  destroy (cb = noop) {\n    if (this.destroyed) return cb(null)\n\n    this.destroyed = true\n\n    clearInterval(this.interval)\n    clearTimeout(this.reconnectTimer)\n\n    // Destroy peers\n    for (const peerId in this.peers) {\n      const peer = this.peers[peerId]\n      clearTimeout(peer.trackerTimeout)\n      peer.destroy()\n    }\n    this.peers = null\n\n    if (this.socket) {\n      this.socket.removeListener('connect', this._onSocketConnectBound)\n      this.socket.removeListener('data', this._onSocketDataBound)\n      this.socket.removeListener('close', this._onSocketCloseBound)\n      this.socket.removeListener('error', this._onSocketErrorBound)\n      this.socket = null\n    }\n\n    this._onSocketConnectBound = null\n    this._onSocketErrorBound = null\n    this._onSocketDataBound = null\n    this._onSocketCloseBound = null\n\n    if (socketPool[this.announceUrl]) {\n      socketPool[this.announceUrl].consumers -= 1\n    }\n\n    // Other instances are using the socket, so there's nothing left to do here\n    if (socketPool[this.announceUrl].consumers > 0) return cb()\n\n    let socket = socketPool[this.announceUrl]\n    delete socketPool[this.announceUrl]\n    socket.on('error', noop) // ignore all future errors\n    socket.once('close', cb)\n\n    let timeout\n\n    // If there is no data response expected, destroy immediately.\n    if (!this.expectingResponse) return destroyCleanup()\n\n    // Otherwise, wait a short time for potential responses to come in from the\n    // server, then force close the socket.\n    timeout = setTimeout(destroyCleanup, common.DESTROY_TIMEOUT)\n\n    // But, if a response comes from the server before the timeout fires, do cleanup\n    // right away.\n    socket.once('data', destroyCleanup)\n\n    function destroyCleanup () {\n      if (timeout) {\n        clearTimeout(timeout)\n        timeout = null\n      }\n      socket.removeListener('data', destroyCleanup)\n      socket.destroy()\n      socket = null\n    }\n  }\n\n  _openSocket () {\n    this.destroyed = false\n\n    if (!this.peers) this.peers = {}\n\n    this._onSocketConnectBound = () => {\n      this._onSocketConnect()\n    }\n    this._onSocketErrorBound = err => {\n      this._onSocketError(err)\n    }\n    this._onSocketDataBound = data => {\n      this._onSocketData(data)\n    }\n    this._onSocketCloseBound = () => {\n      this._onSocketClose()\n    }\n\n    this.socket = socketPool[this.announceUrl]\n    if (this.socket) {\n      socketPool[this.announceUrl].consumers += 1\n      if (this.socket.connected) {\n        this._onSocketConnectBound()\n      }\n    } else {\n      const parsedUrl = new URL(this.announceUrl)\n      let agent\n      if (this.client._proxyOpts) {\n        agent = parsedUrl.protocol === 'wss:' ? this.client._proxyOpts.httpsAgent : this.client._proxyOpts.httpAgent\n        if (!agent && this.client._proxyOpts.socksProxy) {\n          agent = this.client._proxyOpts.socksProxy\n        }\n      }\n      this.socket = socketPool[this.announceUrl] = new Socket({ url: this.announceUrl, agent })\n      this.socket.consumers = 1\n      this.socket.once('connect', this._onSocketConnectBound)\n    }\n\n    this.socket.on('data', this._onSocketDataBound)\n    this.socket.once('close', this._onSocketCloseBound)\n    this.socket.once('error', this._onSocketErrorBound)\n  }\n\n  _onSocketConnect () {\n    if (this.destroyed) return\n\n    if (this.reconnecting) {\n      this.reconnecting = false\n      this.retries = 0\n      this.announce(this.client._defaultAnnounceOpts())\n    }\n  }\n\n  _onSocketData (data) {\n    if (this.destroyed) return\n\n    this.expectingResponse = false\n\n    try {\n      data = JSON.parse(arr2text(data))\n    } catch (err) {\n      this.client.emit('warning', new Error('Invalid tracker response'))\n      return\n    }\n\n    if (data.action === 'announce') {\n      this._onAnnounceResponse(data)\n    } else if (data.action === 'scrape') {\n      this._onScrapeResponse(data)\n    } else {\n      this._onSocketError(new Error(`invalid action in WS response: ${data.action}`))\n    }\n  }\n\n  _onAnnounceResponse (data) {\n    if (data.info_hash !== this.client._infoHashBinary) {\n      debug(\n        'ignoring websocket data from %s for %s (looking for %s: reused socket)',\n        this.announceUrl, bin2hex(data.info_hash), this.client.infoHash\n      )\n      return\n    }\n\n    if (data.peer_id && data.peer_id === this.client._peerIdBinary) {\n      // ignore offers/answers from this client\n      return\n    }\n\n    debug(\n      'received %s from %s for %s',\n      JSON.stringify(data), this.announceUrl, this.client.infoHash\n    )\n\n    const failure = data['failure reason']\n    if (failure) return this.client.emit('warning', new Error(failure))\n\n    const warning = data['warning message']\n    if (warning) this.client.emit('warning', new Error(warning))\n\n    const interval = data.interval || data['min interval']\n    if (interval) this.setInterval(interval * 1000)\n\n    const trackerId = data['tracker id']\n    if (trackerId) {\n      // If absent, do not discard previous trackerId value\n      this._trackerId = trackerId\n    }\n\n    if (data.complete != null) {\n      const response = Object.assign({}, data, {\n        announce: this.announceUrl,\n        infoHash: bin2hex(data.info_hash)\n      })\n      this.client.emit('update', response)\n    }\n\n    let peer\n    if (data.offer && data.peer_id) {\n      debug('creating peer (from remote offer)')\n      peer = this._createPeer()\n      peer.id = bin2hex(data.peer_id)\n      peer.once('signal', answer => {\n        const params = {\n          action: 'announce',\n          info_hash: this.client._infoHashBinary,\n          peer_id: this.client._peerIdBinary,\n          to_peer_id: data.peer_id,\n          answer,\n          offer_id: data.offer_id\n        }\n        if (this._trackerId) params.trackerid = this._trackerId\n        this._send(params)\n      })\n      this.client.emit('peer', peer)\n      peer.signal(data.offer)\n    }\n\n    if (data.answer && data.peer_id) {\n      const offerId = bin2hex(data.offer_id)\n      peer = this.peers[offerId]\n      if (peer) {\n        peer.id = bin2hex(data.peer_id)\n        this.client.emit('peer', peer)\n        peer.signal(data.answer)\n\n        clearTimeout(peer.trackerTimeout)\n        peer.trackerTimeout = null\n        delete this.peers[offerId]\n      } else {\n        debug(`got unexpected answer: ${JSON.stringify(data.answer)}`)\n      }\n    }\n  }\n\n  _onScrapeResponse (data) {\n    data = data.files || {}\n\n    const keys = Object.keys(data)\n    if (keys.length === 0) {\n      this.client.emit('warning', new Error('invalid scrape response'))\n      return\n    }\n\n    keys.forEach(infoHash => {\n      // TODO: optionally handle data.flags.min_request_interval\n      // (separate from announce interval)\n      const response = Object.assign(data[infoHash], {\n        announce: this.announceUrl,\n        infoHash: bin2hex(infoHash)\n      })\n      this.client.emit('scrape', response)\n    })\n  }\n\n  _onSocketClose () {\n    if (this.destroyed) return\n    this.destroy()\n    this._startReconnectTimer()\n  }\n\n  _onSocketError (err) {\n    if (this.destroyed) return\n    this.destroy()\n    // errors will often happen if a tracker is offline, so don't treat it as fatal\n    this.client.emit('warning', err)\n    this._startReconnectTimer()\n  }\n\n  _startReconnectTimer () {\n    const ms = Math.floor(Math.random() * RECONNECT_VARIANCE) + Math.min(Math.pow(2, this.retries) * RECONNECT_MINIMUM, RECONNECT_MAXIMUM)\n\n    this.reconnecting = true\n    clearTimeout(this.reconnectTimer)\n    this.reconnectTimer = setTimeout(() => {\n      this.retries++\n      this._openSocket()\n    }, ms)\n    if (this.reconnectTimer.unref) this.reconnectTimer.unref()\n\n    debug('reconnecting socket in %s ms', ms)\n  }\n\n  _send (params) {\n    if (this.destroyed) return\n    this.expectingResponse = true\n    const message = JSON.stringify(params)\n    debug('send %s', message)\n    this.socket.send(message)\n  }\n\n  _generateOffers (numwant, cb) {\n    const self = this\n    const offers = []\n    debug('generating %s offers', numwant)\n\n    for (let i = 0; i < numwant; ++i) {\n      generateOffer()\n    }\n    checkDone()\n\n    function generateOffer () {\n      const offerId = arr2hex(randomBytes(20))\n      debug('creating peer (from _generateOffers)')\n      const peer = self.peers[offerId] = self._createPeer({ initiator: true })\n      peer.once('signal', offer => {\n        offers.push({\n          offer,\n          offer_id: hex2bin(offerId)\n        })\n        checkDone()\n      })\n      peer.trackerTimeout = setTimeout(() => {\n        debug('tracker timeout: destroying peer')\n        peer.trackerTimeout = null\n        delete self.peers[offerId]\n        peer.destroy()\n      }, OFFER_TIMEOUT)\n      if (peer.trackerTimeout.unref) peer.trackerTimeout.unref()\n    }\n\n    function checkDone () {\n      if (offers.length === numwant) {\n        debug('generated %s offers', numwant)\n        cb(offers)\n      }\n    }\n  }\n\n  _createPeer (opts) {\n    const self = this\n\n    opts = Object.assign({\n      trickle: false,\n      config: self.client._rtcConfig,\n      wrtc: self.client._wrtc\n    }, opts)\n\n    const peer = new Peer(opts)\n\n    peer.once('error', onError)\n    peer.once('connect', onConnect)\n\n    return peer\n\n    // Handle peer 'error' events that are fired *before* the peer is emitted in\n    // a 'peer' event.\n    function onError (err) {\n      self.client.emit('warning', new Error(`Connection error: ${err.message}`))\n      peer.destroy()\n    }\n\n    // Once the peer is emitted in a 'peer' event, then it's the consumer's\n    // responsibility to listen for errors, so the listeners are removed here.\n    function onConnect () {\n      peer.removeListener('error', onError)\n      peer.removeListener('connect', onConnect)\n    }\n  }\n}\n\nWebSocketTracker.prototype.DEFAULT_ANNOUNCE_INTERVAL = 10 * 1000 // 30 seconds\n// Normally this shouldn't be accessed but is occasionally useful\nWebSocketTracker._socketPool = socketPool\n\nfunction noop () {}\n\nexport default WebSocketTracker\n","import Debug from 'debug'\nimport EventEmitter from 'events'\nimport once from 'once'\nimport parallel from 'run-parallel'\nimport Peer from '@thaunknown/simple-peer/lite.js'\nimport queueMicrotask from 'queue-microtask'\nimport { hex2arr, hex2bin, text2arr, arr2hex, arr2text } from 'uint8-util'\n\nimport common from './lib/common.js'\nimport HTTPTracker from './lib/client/http-tracker.js' // empty object in browser\nimport UDPTracker from './lib/client/udp-tracker.js' // empty object in browser\nimport WebSocketTracker from './lib/client/websocket-tracker.js'\n\nconst debug = Debug('bittorrent-tracker:client')\n\n/**\n * BitTorrent tracker client.\n *\n * Find torrent peers, to help a torrent client participate in a torrent swarm.\n *\n * @param {Object} opts                          options object\n * @param {string|Uint8Array} opts.infoHash          torrent info hash\n * @param {string|Uint8Array} opts.peerId            peer id\n * @param {string|Array.<string>} opts.announce  announce\n * @param {number} opts.port                     torrent client listening port\n * @param {function} opts.getAnnounceOpts        callback to provide data to tracker\n * @param {number} opts.rtcConfig                RTCPeerConnection configuration object\n * @param {number} opts.userAgent                User-Agent header for http requests\n * @param {number} opts.wrtc                     custom webrtc impl (useful in node.js)\n * @param {object} opts.proxyOpts                proxy options (useful in node.js)\n */\nclass Client extends EventEmitter {\n  constructor (opts = {}) {\n    super()\n\n    if (!opts.peerId) throw new Error('Option `peerId` is required')\n    if (!opts.infoHash) throw new Error('Option `infoHash` is required')\n    if (!opts.announce) throw new Error('Option `announce` is required')\n    if (!process.browser && !opts.port) throw new Error('Option `port` is required')\n\n    this.peerId = typeof opts.peerId === 'string'\n      ? opts.peerId\n      : arr2hex(opts.peerId)\n    this._peerIdBuffer = hex2arr(this.peerId)\n    this._peerIdBinary = hex2bin(this.peerId)\n\n    this.infoHash = typeof opts.infoHash === 'string'\n      ? opts.infoHash.toLowerCase()\n      : arr2hex(opts.infoHash)\n    this._infoHashBuffer = hex2arr(this.infoHash)\n    this._infoHashBinary = hex2bin(this.infoHash)\n\n    debug('new client %s', this.infoHash)\n\n    this.destroyed = false\n\n    this._port = opts.port\n    this._getAnnounceOpts = opts.getAnnounceOpts\n    this._rtcConfig = opts.rtcConfig\n    this._userAgent = opts.userAgent\n    this._proxyOpts = opts.proxyOpts\n\n    // Support lazy 'wrtc' module initialization\n    // See: https://github.com/webtorrent/webtorrent-hybrid/issues/46\n    this._wrtc = typeof opts.wrtc === 'function' ? opts.wrtc() : opts.wrtc\n\n    let announce = typeof opts.announce === 'string'\n      ? [opts.announce]\n      : opts.announce == null ? [] : opts.announce\n\n    // Remove trailing slash from trackers to catch duplicates\n    announce = announce.map(announceUrl => {\n      if (ArrayBuffer.isView(announceUrl)) announceUrl = arr2text(announceUrl)\n      if (announceUrl[announceUrl.length - 1] === '/') {\n        announceUrl = announceUrl.substring(0, announceUrl.length - 1)\n      }\n      return announceUrl\n    })\n    // remove duplicates by converting to Set and back\n    announce = Array.from(new Set(announce))\n\n    const webrtcSupport = this._wrtc !== false && (!!this._wrtc || Peer.WEBRTC_SUPPORT)\n\n    const nextTickWarn = err => {\n      queueMicrotask(() => {\n        this.emit('warning', err)\n      })\n    }\n\n    this._trackers = announce\n      .map(announceUrl => {\n        let parsedUrl\n        try {\n          parsedUrl = common.parseUrl(announceUrl)\n        } catch (err) {\n          nextTickWarn(new Error(`Invalid tracker URL: ${announceUrl}`))\n          return null\n        }\n\n        const port = parsedUrl.port\n        if (port < 0 || port > 65535) {\n          nextTickWarn(new Error(`Invalid tracker port: ${announceUrl}`))\n          return null\n        }\n\n        const protocol = parsedUrl.protocol\n        if ((protocol === 'http:' || protocol === 'https:') &&\n            typeof HTTPTracker === 'function') {\n          return new HTTPTracker(this, announceUrl)\n        } else if (protocol === 'udp:' && typeof UDPTracker === 'function') {\n          return new UDPTracker(this, announceUrl)\n        } else if ((protocol === 'ws:' || protocol === 'wss:') && webrtcSupport) {\n          // Skip ws:// trackers on https:// sites because they throw SecurityError\n          if (protocol === 'ws:' && typeof window !== 'undefined' &&\n              window.location.protocol === 'https:') {\n            nextTickWarn(new Error(`Unsupported tracker protocol: ${announceUrl}`))\n            return null\n          }\n          return new WebSocketTracker(this, announceUrl)\n        } else {\n          nextTickWarn(new Error(`Unsupported tracker protocol: ${announceUrl}`))\n          return null\n        }\n      })\n      .filter(Boolean)\n  }\n\n  /**\n   * Send a `start` announce to the trackers.\n   * @param {Object} opts\n   * @param {number=} opts.uploaded\n   * @param {number=} opts.downloaded\n   * @param {number=} opts.left (if not set, calculated automatically)\n   */\n  start (opts) {\n    opts = this._defaultAnnounceOpts(opts)\n    opts.event = 'started'\n    debug('send `start` %o', opts)\n    this._announce(opts)\n\n    // start announcing on intervals\n    this._trackers.forEach(tracker => {\n      tracker.setInterval()\n    })\n  }\n\n  /**\n   * Send a `stop` announce to the trackers.\n   * @param {Object} opts\n   * @param {number=} opts.uploaded\n   * @param {number=} opts.downloaded\n   * @param {number=} opts.numwant\n   * @param {number=} opts.left (if not set, calculated automatically)\n   */\n  stop (opts) {\n    opts = this._defaultAnnounceOpts(opts)\n    opts.event = 'stopped'\n    debug('send `stop` %o', opts)\n    this._announce(opts)\n  }\n\n  /**\n   * Send a `complete` announce to the trackers.\n   * @param {Object} opts\n   * @param {number=} opts.uploaded\n   * @param {number=} opts.downloaded\n   * @param {number=} opts.numwant\n   * @param {number=} opts.left (if not set, calculated automatically)\n   */\n  complete (opts) {\n    if (!opts) opts = {}\n    opts = this._defaultAnnounceOpts(opts)\n    opts.event = 'completed'\n    debug('send `complete` %o', opts)\n    this._announce(opts)\n  }\n\n  /**\n   * Send a `update` announce to the trackers.\n   * @param {Object} opts\n   * @param {number=} opts.uploaded\n   * @param {number=} opts.downloaded\n   * @param {number=} opts.numwant\n   * @param {number=} opts.left (if not set, calculated automatically)\n   */\n  update (opts) {\n    opts = this._defaultAnnounceOpts(opts)\n    if (opts.event) delete opts.event\n    debug('send `update` %o', opts)\n    this._announce(opts)\n  }\n\n  _announce (opts) {\n    this._trackers.forEach(tracker => {\n      // tracker should not modify `opts` object, it's passed to all trackers\n      tracker.announce(opts)\n    })\n  }\n\n  /**\n   * Send a scrape request to the trackers.\n   * @param {Object} opts\n   */\n  scrape (opts) {\n    debug('send `scrape`')\n    if (!opts) opts = {}\n    this._trackers.forEach(tracker => {\n      // tracker should not modify `opts` object, it's passed to all trackers\n      tracker.scrape(opts)\n    })\n  }\n\n  setInterval (intervalMs) {\n    debug('setInterval %d', intervalMs)\n    this._trackers.forEach(tracker => {\n      tracker.setInterval(intervalMs)\n    })\n  }\n\n  destroy (cb) {\n    if (this.destroyed) return\n    this.destroyed = true\n    debug('destroy')\n\n    const tasks = this._trackers.map(tracker => cb => {\n      tracker.destroy(cb)\n    })\n\n    parallel(tasks, cb)\n\n    this._trackers = []\n    this._getAnnounceOpts = null\n  }\n\n  _defaultAnnounceOpts (opts = {}) {\n    if (opts.numwant == null) opts.numwant = common.DEFAULT_ANNOUNCE_PEERS\n\n    if (opts.uploaded == null) opts.uploaded = 0\n    if (opts.downloaded == null) opts.downloaded = 0\n\n    if (this._getAnnounceOpts) opts = Object.assign({}, opts, this._getAnnounceOpts())\n\n    return opts\n  }\n}\n\n/**\n * Simple convenience function to scrape a tracker for an info hash without needing to\n * create a Client, pass it a parsed torrent, etc. Support scraping a tracker for multiple\n * torrents at the same time.\n * @params {Object} opts\n * @param  {string|Array.<string>} opts.infoHash\n * @param  {string} opts.announce\n * @param  {function} cb\n */\nClient.scrape = (opts, cb) => {\n  cb = once(cb)\n\n  if (!opts.infoHash) throw new Error('Option `infoHash` is required')\n  if (!opts.announce) throw new Error('Option `announce` is required')\n\n  const clientOpts = Object.assign({}, opts, {\n    infoHash: Array.isArray(opts.infoHash) ? opts.infoHash[0] : opts.infoHash,\n    peerId: text2arr('01234567890123456789'), // dummy value\n    port: 6881 // dummy value\n  })\n\n  const client = new Client(clientOpts)\n  client.once('error', cb)\n  client.once('warning', cb)\n\n  let len = Array.isArray(opts.infoHash) ? opts.infoHash.length : 1\n  const results = {}\n  client.on('scrape', data => {\n    len -= 1\n    results[data.infoHash] = data\n    if (len === 0) {\n      client.destroy()\n      const keys = Object.keys(results)\n      if (keys.length === 1) {\n        cb(null, results[keys[0]])\n      } else {\n        cb(null, results)\n      }\n    }\n  })\n\n  client.scrape({ infoHash: opts.infoHash })\n  return client\n}\n\nexport default Client\n","function FF(a, b, c, d, m, s, k) {\n\tvar n = a + (b & c | ~b & d) + (m >>> 0) + k;\n\treturn ((n << s) | (n >>> (32 - s))) + b;\n}\n\nfunction GG(a, b, c, d, m, s, k) {\n\tvar n = a + (b & d | c & ~d) + (m >>> 0) + k;\n\treturn ((n << s) | (n >>> (32 - s))) + b;\n}\n\nfunction HH(a, b, c, d, m, s, k) {\n\tvar n = a + (b ^ c ^ d) + (m >>> 0) + k;\n\treturn ((n << s) | (n >>> (32 - s))) + b;\n}\n\nfunction II(a, b, c, d, m, s, k) {\n\tvar n = a + (c ^ (b | ~d)) + (m >>> 0) + k;\n\treturn ((n << s) | (n >>> (32 - s))) + b;\n}\n\n\nfunction byteToHex(byte) {\n\treturn (256+(byte&255)).toString(16).substr(-2);\n}\n\n\nfunction bs(byte) {\n\treturn String.fromCharCode(byte & 255);\n}\n\nfunction wordToBytes(word) {\n\treturn bs(word) + bs(word >>> 8) + bs(word >>> 16) + bs(word >>> 24);\n}\n\n\n// converts utf8 string to bytes string\nvar utf8toBytes = function (utf8) {\n\treturn unescape(encodeURIComponent(utf8));\n};\n\n\n// converts bytes string to 32-bits words array padded with \"1\" and zeros and bits_length for MD5 message buffer\nfunction bytesToWords(bytes) {\n\tvar bytes_count = bytes.length,\n\t    bits_count = bytes_count << 3,\n\t    words = new Uint32Array((bytes_count + 72) >>> 6 << 4);\n\tfor (var i = 0, n = bytes.length; i < n; ++i)\n\t\twords[i >>> 2] |= bytes.charCodeAt(i) << ((i & 3) << 3);\n\twords[bytes_count >> 2] |= 0x80 << (bits_count & 31); // append \"1\" bit to message\n\twords[words.length - 2] = bits_count;\n\treturn words;\n}\n\n\nvar exports = module.exports = function md5(utf8) {\n\treturn utf8toMD5(utf8).toHex();\n};\n\nvar bytesToMD5 = exports.fromBytes = function (bytes) {\n\tvar words = bytesToWords(bytes),\n\t    a = 0x67452301,\n\t    b = 0xEFCDAB89,\n\t    c = 0x98BADCFE,\n\t    d = 0x10325476,\n\t    S11 = 7, S12 = 12, S13 = 17, S14 = 22,\n\t    S21 = 5, S22 = 9 , S23 = 14, S24 = 20,\n\t    S31 = 4, S32 = 11, S33 = 16, S34 = 23,\n\t    S41 = 6, S42 = 10, S43 = 15, S44 = 21;\n\n\tfor (var i = 0, ws = words.length; i < ws; i += 16) {\n\t\tvar AA = a, BB = b, CC = c, DD = d;\n\t\ta = FF(a, b, c, d, words[i+0], S11, 0xD76AA478);\n\t\td = FF(d, a, b, c, words[i+1], S12, 0xE8C7B756);\n\t\tc = FF(c, d, a, b, words[i+2], S13, 0x242070DB);\n\t\tb = FF(b, c, d, a, words[i+3], S14, 0xC1BDCEEE);\n\t\ta = FF(a, b, c, d, words[i+4], S11, 0xF57C0FAF);\n\t\td = FF(d, a, b, c, words[i+5], S12, 0x4787C62A);\n\t\tc = FF(c, d, a, b, words[i+6], S13, 0xA8304613);\n\t\tb = FF(b, c, d, a, words[i+7], S14, 0xFD469501);\n\t\ta = FF(a, b, c, d, words[i+8], S11, 0x698098D8);\n\t\td = FF(d, a, b, c, words[i+9], S12, 0x8B44F7AF);\n\t\tc = FF(c, d, a, b, words[i+10],S13, 0xFFFF5BB1);\n\t\tb = FF(b, c, d, a, words[i+11],S14, 0x895CD7BE);\n\t\ta = FF(a, b, c, d, words[i+12],S11, 0x6B901122);\n\t\td = FF(d, a, b, c, words[i+13],S12, 0xFD987193);\n\t\tc = FF(c, d, a, b, words[i+14],S13, 0xA679438E);\n\t\tb = FF(b, c, d, a, words[i+15],S14, 0x49B40821);\n\t\ta = GG(a, b, c, d, words[i+1], S21, 0xF61E2562);\n\t\td = GG(d, a, b, c, words[i+6], S22, 0xC040B340);\n\t\tc = GG(c, d, a, b, words[i+11],S23, 0x265E5A51);\n\t\tb = GG(b, c, d, a, words[i+0], S24, 0xE9B6C7AA);\n\t\ta = GG(a, b, c, d, words[i+5], S21, 0xD62F105D);\n\t\td = GG(d, a, b, c, words[i+10],S22, 0x2441453);\n\t\tc = GG(c, d, a, b, words[i+15],S23, 0xD8A1E681);\n\t\tb = GG(b, c, d, a, words[i+4], S24, 0xE7D3FBC8);\n\t\ta = GG(a, b, c, d, words[i+9], S21, 0x21E1CDE6);\n\t\td = GG(d, a, b, c, words[i+14],S22, 0xC33707D6);\n\t\tc = GG(c, d, a, b, words[i+3], S23, 0xF4D50D87);\n\t\tb = GG(b, c, d, a, words[i+8], S24, 0x455A14ED);\n\t\ta = GG(a, b, c, d, words[i+13],S21, 0xA9E3E905);\n\t\td = GG(d, a, b, c, words[i+2], S22, 0xFCEFA3F8);\n\t\tc = GG(c, d, a, b, words[i+7], S23, 0x676F02D9);\n\t\tb = GG(b, c, d, a, words[i+12],S24, 0x8D2A4C8A);\n\t\ta = HH(a, b, c, d, words[i+5], S31, 0xFFFA3942);\n\t\td = HH(d, a, b, c, words[i+8], S32, 0x8771F681);\n\t\tc = HH(c, d, a, b, words[i+11],S33, 0x6D9D6122);\n\t\tb = HH(b, c, d, a, words[i+14],S34, 0xFDE5380C);\n\t\ta = HH(a, b, c, d, words[i+1], S31, 0xA4BEEA44);\n\t\td = HH(d, a, b, c, words[i+4], S32, 0x4BDECFA9);\n\t\tc = HH(c, d, a, b, words[i+7], S33, 0xF6BB4B60);\n\t\tb = HH(b, c, d, a, words[i+10],S34, 0xBEBFBC70);\n\t\ta = HH(a, b, c, d, words[i+13],S31, 0x289B7EC6);\n\t\td = HH(d, a, b, c, words[i+0], S32, 0xEAA127FA);\n\t\tc = HH(c, d, a, b, words[i+3], S33, 0xD4EF3085);\n\t\tb = HH(b, c, d, a, words[i+6], S34, 0x4881D05);\n\t\ta = HH(a, b, c, d, words[i+9], S31, 0xD9D4D039);\n\t\td = HH(d, a, b, c, words[i+12],S32, 0xE6DB99E5);\n\t\tc = HH(c, d, a, b, words[i+15],S33, 0x1FA27CF8);\n\t\tb = HH(b, c, d, a, words[i+2], S34, 0xC4AC5665);\n\t\ta = II(a, b, c, d, words[i+0], S41, 0xF4292244);\n\t\td = II(d, a, b, c, words[i+7], S42, 0x432AFF97);\n\t\tc = II(c, d, a, b, words[i+14],S43, 0xAB9423A7);\n\t\tb = II(b, c, d, a, words[i+5], S44, 0xFC93A039);\n\t\ta = II(a, b, c, d, words[i+12],S41, 0x655B59C3);\n\t\td = II(d, a, b, c, words[i+3], S42, 0x8F0CCC92);\n\t\tc = II(c, d, a, b, words[i+10],S43, 0xFFEFF47D);\n\t\tb = II(b, c, d, a, words[i+1], S44, 0x85845DD1);\n\t\ta = II(a, b, c, d, words[i+8], S41, 0x6FA87E4F);\n\t\td = II(d, a, b, c, words[i+15],S42, 0xFE2CE6E0);\n\t\tc = II(c, d, a, b, words[i+6], S43, 0xA3014314);\n\t\tb = II(b, c, d, a, words[i+13],S44, 0x4E0811A1);\n\t\ta = II(a, b, c, d, words[i+4], S41, 0xF7537E82);\n\t\td = II(d, a, b, c, words[i+11],S42, 0xBD3AF235);\n\t\tc = II(c, d, a, b, words[i+2], S43, 0x2AD7D2BB);\n\t\tb = II(b, c, d, a, words[i+9], S44, 0xEB86D391);\n\t\ta = (a + AA) >>> 0;\n\t\tb = (b + BB) >>> 0;\n\t\tc = (c + CC) >>> 0;\n\t\td = (d + DD) >>> 0;\n\t}\n\n\tvar hash_bytes = new String(wordToBytes(a) + wordToBytes(b) + wordToBytes(c) + wordToBytes(d));\n\thash_bytes.toHex = function () {\n\t\tvar hex = '';\n\t\tfor (var i = 0, n = hash_bytes.length; i < n; ++i)\n\t\t\thex += byteToHex(hash_bytes.charCodeAt(i));\n\t\treturn hex;\n\t};\n\treturn hash_bytes;\n};\n\n\nvar utf8toMD5 = exports.fromUtf8 = function (utf8) {\n\treturn bytesToMD5(utf8toBytes(utf8));\n};\n\n\n\nvar b64 = './0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';\n\nfunction to64(u, n) {\n\tfor (var s = ''; --n >= 0; u >>>= 6)\n\t\ts += b64.charAt(u & 63);\n\treturn s;\n}\n\n\nvar MAX_KEY_LENGTH = 64,\n    b64_map = [ 0,6,12, 1,7,13, 2,8,14, 3,9,15, 4,10,5, 11 ];\n\n\nvar gen_salt = exports.salt = function (n) {\n\tvar s = '';\n\tif (!n)\n\t\tn = 8;\n\tdo {\n\t\ts += b64.charAt( 64*Math.random() >>> 0 );\n\t} while (--n);\n\treturn s;\n};\n\n\nexports.crypt = function (key, setting) {\n\n\tif (key.length > MAX_KEY_LENGTH)\n\t\tthrow Error(\"too long key\");\n\n\tif (!setting)\n\t\tsetting = '$1$'+gen_salt();\n\n\tkey = utf8toBytes(key);\n\n\tvar salt = utf8toBytes(setting.replace(/^\\$1\\$([^$]+)(?:\\$.*)?$/, '$1')),\n\t    md = bytesToMD5(key + salt + key),\n\t    s = key + '$1$' + salt;\n\n\tfor (var kl = key.length; kl > 16; kl -= 16)\n\t\ts += md;\n\n\ts += md.slice(0, kl);\n\n\tfor (var kl = key.length; kl; kl >>= 1)\n\t\ts += kl & 1 ? \"\\0\" : key.charAt(0);\n\n\tmd = bytesToMD5(s);\n\n\tfor (var i = 0; i < 1000; ++i)\n\t\tmd = bytesToMD5((i & 1 ? key : md) + (i % 3 ? salt : '') + (i % 7 ? key : '') + (i & 1 ? md : key));\n\n\tvar h = '$1$'+salt+'$';\n\n\tfor (var i = 0; i < 15; i += 3)\n\t\th += to64(\n\t\t\tmd.charCodeAt(b64_map[i+0]) << 16 |\n\t\t\tmd.charCodeAt(b64_map[i+1]) << 8 |\n\t\t\tmd.charCodeAt(b64_map[i+2]), 4);\n\n\treturn h + to64(md.charCodeAt(b64_map[15]), 2);\n};\n","export const PACKAGE_VERSION = \"2.2.2\";\n","import md5 from \"nano-md5\";\nimport { PACKAGE_VERSION } from \"./version.js\";\n\nexport const TRACKER_CLIENT_VERSION_PREFIX = `-PM${formatVersion(PACKAGE_VERSION)}-`;\n\nconst HASH_SYMBOLS =\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\nconst PEER_ID_LENGTH = 20;\n\nexport function getStreamHash(streamId: string): string {\n  // slice one byte to have 15 bytes binary string\n  const binary15BytesHashString = md5.fromUtf8(streamId).slice(1);\n  const base64Hash20CharsString = btoa(binary15BytesHashString);\n  return base64Hash20CharsString;\n}\n\nexport function generatePeerId(trackerClientVersionPrefix: string): string {\n  const trackerClientId = [trackerClientVersionPrefix];\n  const randomCharsCount = PEER_ID_LENGTH - trackerClientVersionPrefix.length;\n\n  for (let i = 0; i < randomCharsCount; i++) {\n    trackerClientId.push(\n      HASH_SYMBOLS[Math.floor(Math.random() * HASH_SYMBOLS.length)],\n    );\n  }\n\n  return trackerClientId.join(\"\");\n}\n\nfunction formatVersion(versionString: string) {\n  const splittedVersion = versionString.split(\".\");\n\n  return `${splittedVersion[0].padStart(2, \"0\")}${splittedVersion[1].padStart(2, \"0\")}`;\n}\n","import { SegmentWithStream, Stream } from \"../types.js\";\nimport { SegmentPlaybackStatuses } from \"./stream.js\";\n\nexport function getStreamString(stream: Stream) {\n  return `${stream.type}-${stream.index}`;\n}\n\nexport function getSegmentString(segment: SegmentWithStream) {\n  const { externalId } = segment;\n  return `(${getStreamString(segment.stream)} | ${externalId})`;\n}\n\nexport function getSegmentPlaybackStatusesString(\n  statuses: SegmentPlaybackStatuses,\n): string {\n  const { isHighDemand, isHttpDownloadable, isP2PDownloadable } = statuses;\n  if (isHighDemand) return \"high-demand\";\n  if (isHttpDownloadable && isP2PDownloadable) return \"http-p2p-window\";\n  if (isHttpDownloadable) return \"http-window\";\n  if (isP2PDownloadable) return \"p2p-window\";\n  return \"-\";\n}\n","import { CommonCoreConfig, CoreConfig, StreamConfig } from \"../types.js\";\n\nexport function getControlledPromise<T = void>() {\n  let resolve: (value: T) => void;\n  let reject: (reason?: unknown) => void;\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return {\n    promise,\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    resolve: resolve!,\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    reject: reject!,\n  };\n}\n\nexport function joinChunks(chunks: Uint8Array[], totalBytes?: number) {\n  totalBytes ??= chunks.reduce((sum, chunk) => sum + chunk.byteLength, 0);\n\n  const buffer = new Uint8Array(totalBytes);\n  let offset = 0;\n  for (const chunk of chunks) {\n    buffer.set(chunk, offset);\n    offset += chunk.byteLength;\n  }\n\n  return buffer;\n}\n\nexport function getPercent(numerator: number, denominator: number): number {\n  return (numerator / denominator) * 100;\n}\n\nexport function getRandomItem<T>(items: T[]): T {\n  return items[Math.floor(Math.random() * items.length)];\n}\n\nexport function utf8ToUintArray(utf8String: string): Uint8Array {\n  const encoder = new TextEncoder();\n  const bytes = new Uint8Array(utf8String.length);\n  encoder.encodeInto(utf8String, bytes);\n  return bytes;\n}\n\nexport function hexToUtf8(hexString: string) {\n  const bytes = new Uint8Array(hexString.length / 2);\n\n  for (let i = 0; i < hexString.length; i += 2) {\n    bytes[i / 2] = parseInt(hexString.slice(i, i + 2), 16);\n  }\n  const decoder = new TextDecoder();\n  return decoder.decode(bytes);\n}\n\nexport function* arrayBackwards<T>(arr: T[]) {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    yield arr[i];\n  }\n}\n\nfunction isObject(item: unknown): item is Record<string, unknown> {\n  return !!item && typeof item === \"object\" && !Array.isArray(item);\n}\n\nfunction isArray(item: unknown): item is unknown[] {\n  return Array.isArray(item);\n}\n\nexport function filterUndefinedProps<T extends object>(obj: T): Partial<T> {\n  function filter(obj: unknown): unknown {\n    if (isObject(obj)) {\n      const result: Record<string, unknown> = {};\n      Object.keys(obj).forEach((key) => {\n        if (obj[key] !== undefined) {\n          const value = filter(obj[key]);\n          if (value !== undefined) {\n            result[key] = value;\n          }\n        }\n      });\n      return result;\n    } else {\n      return obj;\n    }\n  }\n\n  return filter(obj) as Partial<T>;\n}\n\nexport function deepCopy<T>(item: T): T {\n  if (isArray(item)) {\n    return item.map((element) => deepCopy(element)) as T;\n  } else if (isObject(item)) {\n    const copy = {} as Record<string, unknown>;\n    for (const key of Object.keys(item)) {\n      copy[key] = deepCopy(item[key]);\n    }\n    return copy as T;\n  } else {\n    return item;\n  }\n}\n\nexport function shuffleArray<T>(array: T[]): T[] {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n  return array;\n}\n\ntype RecursivePartial<T> = {\n  [P in keyof T]?: T[P] extends object ? RecursivePartial<T[P]> : T[P];\n};\n\nexport function overrideConfig<T>(\n  target: T,\n  updates: RecursivePartial<T> | null,\n  defaults: RecursivePartial<T> = {} as RecursivePartial<T>,\n): T {\n  if (\n    typeof target !== \"object\" ||\n    target === null ||\n    typeof updates !== \"object\" ||\n    updates === null\n  ) {\n    return target;\n  }\n\n  (Object.keys(updates) as (keyof T)[]).forEach((key) => {\n    const keyStr = typeof key === \"symbol\" ? key.toString() : String(key);\n    if (key === \"__proto__\" || key === \"constructor\" || key === \"prototype\") {\n      throw new Error(`Attempt to modify restricted property '${keyStr}'`);\n    }\n\n    const updateValue = updates[key];\n    const defaultValue = defaults[key];\n\n    if (key in target) {\n      if (updateValue === undefined) {\n        target[key] =\n          defaultValue === undefined\n            ? (undefined as (T & object)[keyof T])\n            : (defaultValue as (T & object)[keyof T]);\n      } else {\n        target[key] = updateValue as (T & object)[keyof T];\n      }\n    }\n  });\n\n  return target;\n}\n\ntype MergeConfigsToTypeOptions = {\n  defaultConfig: StreamConfig | CommonCoreConfig | CoreConfig;\n  baseConfig?: Partial<CoreConfig>;\n  specificStreamConfig?: Partial<StreamConfig>;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-unnecessary-type-parameters\nexport function mergeAndFilterConfig<T>(options: MergeConfigsToTypeOptions) {\n  const { defaultConfig, baseConfig = {}, specificStreamConfig = {} } = options;\n\n  const mergedConfig = deepCopy({\n    ...defaultConfig,\n    ...baseConfig,\n    ...specificStreamConfig,\n  });\n\n  const keysOfT = Object.keys(defaultConfig) as (keyof T)[];\n  const filteredConfig: Partial<T> = {};\n\n  keysOfT.forEach((key) => {\n    if (key in mergedConfig) {\n      filteredConfig[key] = mergedConfig[\n        key as keyof typeof mergedConfig\n      ] as T[keyof T];\n    }\n  });\n\n  return filteredConfig as T;\n}\n","type BasePeerCommand<T extends PeerCommandType = PeerCommandType> = {\n  c: T;\n};\n\nexport const enum PeerCommandType {\n  SegmentsAnnouncement,\n  SegmentRequest,\n  SegmentData,\n  SegmentDataSendingCompleted,\n  SegmentAbsent,\n  CancelSegmentRequest,\n}\n\nexport type PeerSegmentCommand = BasePeerCommand<\n  | PeerCommandType.SegmentAbsent\n  | PeerCommandType.CancelSegmentRequest\n  | PeerCommandType.SegmentDataSendingCompleted\n> & {\n  i: number; // segment id\n  r: number; // request id\n};\n\nexport type PeerRequestSegmentCommand =\n  BasePeerCommand<PeerCommandType.SegmentRequest> & {\n    i: number; // segment id\n    r: number; // request id\n    b?: number; // byte from\n  };\n\nexport type PeerSegmentAnnouncementCommand =\n  BasePeerCommand<PeerCommandType.SegmentsAnnouncement> & {\n    l?: number[]; // loaded segments\n    p?: number[]; // segments loading by http\n  };\n\nexport type PeerSendSegmentCommand =\n  BasePeerCommand<PeerCommandType.SegmentData> & {\n    i: number; // segment id\n    r: number; // request id\n    s: number; // size in bytes\n  };\n\nexport type PeerCommand =\n  | PeerSegmentCommand\n  | PeerRequestSegmentCommand\n  | PeerSegmentAnnouncementCommand\n  | PeerSendSegmentCommand;\n","import { joinChunks } from \"../../utils/utils.js\";\n\n// restricted up to 16 item types (4 bits to type definition)\nexport const enum SerializedItem {\n  Min = -1,\n  Int,\n  SimilarIntArray,\n  String,\n  Max,\n}\n\nfunction abs(num: bigint): bigint {\n  return num < 0 ? -num : num;\n}\n\nfunction getRequiredBytesForInt(num: bigint): number {\n  const binaryString = num.toString(2);\n  const necessaryBits = num < 0 ? binaryString.length : binaryString.length + 1;\n  return Math.ceil(necessaryBits / 8);\n}\n\nfunction intToBytes(num: bigint): Uint8Array {\n  const isNegative = num < 0;\n  const bytesAmountNumber = getRequiredBytesForInt(num);\n  const bytes = new Uint8Array(bytesAmountNumber);\n  const bytesAmount = BigInt(bytesAmountNumber);\n\n  num = abs(num);\n  for (let i = 0; i < bytesAmountNumber; i++) {\n    const shift = 8n * (bytesAmount - 1n - BigInt(i));\n    const byte = (num >> shift) & 0xffn;\n    bytes[i] = Number(byte);\n  }\n\n  if (isNegative) bytes[0] = bytes[0] | 0b10000000;\n  return bytes;\n}\n\nfunction bytesToInt(bytes: Uint8Array): bigint {\n  const byteLength = BigInt(bytes.length);\n  const getNumberPart = (byte: number, i: number): bigint => {\n    const shift = 8n * (byteLength - 1n - BigInt(i));\n    return BigInt(byte) << shift;\n  };\n\n  // ignore first bit of first byte as it is sign bit\n  let number = getNumberPart(bytes[0] & 0b01111111, 0);\n  for (let i = 1; i < byteLength; i++) {\n    number = getNumberPart(bytes[i], i) | number;\n  }\n  if ((bytes[0] & 0b10000000) >> 7 !== 0) number = -number;\n\n  return number;\n}\n\nexport function serializeInt(num: bigint): Uint8Array {\n  const numBytes = intToBytes(num);\n  const numberMetadata = (SerializedItem.Int << 4) | numBytes.length;\n  return new Uint8Array([numberMetadata, ...numBytes]);\n}\n\nexport function deserializeInt(bytes: Uint8Array) {\n  const metadata = bytes[0];\n  const code: SerializedItem = metadata >> 4;\n  if (code !== SerializedItem.Int) {\n    throw new Error(\n      \"Trying to deserialize integer with invalid serialized item code\",\n    );\n  }\n  const numberBytesLength = metadata & 0b1111;\n  const start = 1;\n  const end = start + numberBytesLength;\n  return {\n    number: bytesToInt(bytes.slice(start, end)),\n    byteLength: numberBytesLength + 1,\n  };\n}\n\nexport function serializeSimilarIntArray(numbers: bigint[]) {\n  const commonPartNumbersMap = new Map<bigint, ResizableUint8Array>();\n\n  for (const number of numbers) {\n    const common = number & ~0xffn;\n    const diffByte = number & 0xffn;\n    const bytes = commonPartNumbersMap.get(common) ?? new ResizableUint8Array();\n    if (!bytes.length) commonPartNumbersMap.set(common, bytes);\n    bytes.push(Number(diffByte));\n  }\n\n  const result = new ResizableUint8Array();\n  result.push([SerializedItem.SimilarIntArray << 4, commonPartNumbersMap.size]);\n\n  for (const [commonPart, binaryArray] of commonPartNumbersMap) {\n    const { length } = binaryArray.getBytesChunks();\n    const commonPartWithLength = commonPart | (BigInt(length) & 0xffn);\n    binaryArray.unshift(serializeInt(commonPartWithLength));\n    result.push(binaryArray.getBuffer());\n  }\n\n  return result.getBuffer();\n}\n\nexport function deserializeSimilarIntArray(bytes: Uint8Array) {\n  const [codeByte, commonPartArraysAmount] = bytes;\n  const code: SerializedItem = codeByte >> 4;\n  if (code !== SerializedItem.SimilarIntArray) {\n    throw new Error(\n      \"Trying to deserialize similar int array with invalid serialized item code\",\n    );\n  }\n\n  let offset = 2;\n  const originalIntArr: bigint[] = [];\n  for (let i = 0; i < commonPartArraysAmount; i++) {\n    const { number: commonPartWithLength, byteLength } = deserializeInt(\n      bytes.slice(offset),\n    );\n    offset += byteLength;\n    const arrayLength = commonPartWithLength & 0xffn;\n    const commonPart = commonPartWithLength & ~0xffn;\n\n    for (let j = 0; j < arrayLength; j++) {\n      const diffPart = BigInt(bytes[offset]);\n      originalIntArr.push(commonPart | diffPart);\n      offset++;\n    }\n  }\n\n  return { numbers: originalIntArr, byteLength: offset };\n}\n\nexport function serializeString(string: string) {\n  const { length } = string;\n  const bytes = new ResizableUint8Array();\n  bytes.push([\n    (SerializedItem.String << 4) | ((length >> 8) & 0x0f),\n    length & 0xff,\n  ]);\n  bytes.push(new TextEncoder().encode(string));\n  return bytes.getBuffer();\n}\n\nexport function deserializeString(bytes: Uint8Array) {\n  const [codeByte, lengthByte] = bytes;\n  const code: SerializedItem = codeByte >> 4;\n  if (code !== SerializedItem.String) {\n    throw new Error(\n      \"Trying to deserialize bytes (sting) with invalid serialized item code.\",\n    );\n  }\n  const length = ((codeByte & 0x0f) << 8) | lengthByte;\n  const stringBytes = bytes.slice(2, length + 2);\n  const string = new TextDecoder(\"utf8\").decode(stringBytes);\n  return { string, byteLength: length + 2 };\n}\n\nexport class ResizableUint8Array {\n  private bytes: Uint8Array[] = [];\n  private _length = 0;\n\n  push(bytes: Uint8Array | number | number[]) {\n    this.addBytes(bytes, \"end\");\n  }\n\n  unshift(bytes: Uint8Array | number | number[]) {\n    this.addBytes(bytes, \"start\");\n  }\n\n  private addBytes(\n    bytes: Uint8Array | number | number[],\n    position: \"start\" | \"end\",\n  ) {\n    let bytesToAdd: Uint8Array;\n    if (bytes instanceof Uint8Array) {\n      bytesToAdd = bytes;\n    } else if (Array.isArray(bytes)) {\n      bytesToAdd = new Uint8Array(bytes);\n    } else {\n      bytesToAdd = new Uint8Array([bytes]);\n    }\n    this._length += bytesToAdd.length;\n    this.bytes[position === \"start\" ? \"unshift\" : \"push\"](bytesToAdd);\n  }\n\n  getBytesChunks(): readonly Uint8Array[] {\n    return this.bytes;\n  }\n\n  getBuffer(): Uint8Array {\n    return joinChunks(this.bytes, this._length);\n  }\n\n  get length() {\n    return this._length;\n  }\n}\n","import * as Serialization from \"./binary-serialization.js\";\nimport { PeerCommandType, PeerCommand } from \"./types.js\";\n\nconst FRAME_PART_LENGTH = 4;\nconst commandFrameStart = stringToUtf8CodesBuffer(\"cstr\", FRAME_PART_LENGTH);\nconst commandFrameEnd = stringToUtf8CodesBuffer(\"cend\", FRAME_PART_LENGTH);\nconst commandDivFrameStart = stringToUtf8CodesBuffer(\"dstr\", FRAME_PART_LENGTH);\nconst commandDivFrameEnd = stringToUtf8CodesBuffer(\"dend\", FRAME_PART_LENGTH);\nconst startFrames = [commandFrameStart, commandDivFrameStart];\nconst endFrames = [commandFrameEnd, commandDivFrameEnd];\nconst commandFramesLength = commandFrameStart.length + commandFrameEnd.length;\n\nexport function isCommandChunk(buffer: Uint8Array) {\n  const { length } = commandFrameStart;\n  const bufferEndingToCompare = buffer.slice(-length);\n  return (\n    startFrames.some((frame) =>\n      areBuffersEqual(buffer, frame, FRAME_PART_LENGTH),\n    ) &&\n    endFrames.some((frame) =>\n      areBuffersEqual(bufferEndingToCompare, frame, FRAME_PART_LENGTH),\n    )\n  );\n}\n\nfunction isFirstCommandChunk(buffer: Uint8Array) {\n  return areBuffersEqual(buffer, commandFrameStart, FRAME_PART_LENGTH);\n}\n\nfunction isLastCommandChunk(buffer: Uint8Array) {\n  return areBuffersEqual(\n    buffer.slice(-FRAME_PART_LENGTH),\n    commandFrameEnd,\n    FRAME_PART_LENGTH,\n  );\n}\n\nexport class BinaryCommandJoiningError extends Error {\n  constructor(readonly type: \"incomplete-joining\" | \"no-first-chunk\") {\n    super();\n  }\n}\n\nexport class BinaryCommandChunksJoiner {\n  private readonly chunks = new Serialization.ResizableUint8Array();\n  private status: \"joining\" | \"completed\" = \"joining\";\n\n  constructor(\n    private readonly onComplete: (commandBuffer: Uint8Array) => void,\n  ) {}\n\n  addCommandChunk(chunk: Uint8Array) {\n    if (this.status === \"completed\") return;\n\n    const isFirstChunk = isFirstCommandChunk(chunk);\n    if (!this.chunks.length && !isFirstChunk) {\n      throw new BinaryCommandJoiningError(\"no-first-chunk\");\n    }\n    if (this.chunks.length && isFirstChunk) {\n      throw new BinaryCommandJoiningError(\"incomplete-joining\");\n    }\n    this.chunks.push(this.unframeCommandChunk(chunk));\n\n    if (!isLastCommandChunk(chunk)) return;\n    this.status = \"completed\";\n    this.onComplete(this.chunks.getBuffer());\n  }\n\n  private unframeCommandChunk(chunk: Uint8Array) {\n    return chunk.slice(FRAME_PART_LENGTH, chunk.length - FRAME_PART_LENGTH);\n  }\n}\n\nexport class BinaryCommandCreator {\n  private readonly bytes = new Serialization.ResizableUint8Array();\n  private resultBuffers: Uint8Array[] = [];\n  private status: \"creating\" | \"completed\" = \"creating\";\n\n  constructor(\n    commandType: PeerCommandType,\n    private readonly maxChunkLength: number,\n  ) {\n    this.bytes.push(commandType);\n  }\n\n  addInteger(name: string, value: number) {\n    this.bytes.push(name.charCodeAt(0));\n    const bytes = Serialization.serializeInt(BigInt(value));\n    this.bytes.push(bytes);\n  }\n\n  addSimilarIntArr(name: string, arr: number[]) {\n    this.bytes.push(name.charCodeAt(0));\n    const bytes = Serialization.serializeSimilarIntArray(\n      arr.map((num) => BigInt(num)),\n    );\n    this.bytes.push(bytes);\n  }\n\n  addString(name: string, string: string) {\n    this.bytes.push(name.charCodeAt(0));\n    const bytes = Serialization.serializeString(string);\n    this.bytes.push(bytes);\n  }\n\n  complete() {\n    if (!this.bytes.length) throw new Error(\"Buffer is empty\");\n    if (this.status === \"completed\") return;\n    this.status = \"completed\";\n\n    const unframedBuffer = this.bytes.getBuffer();\n    if (unframedBuffer.length + commandFramesLength <= this.maxChunkLength) {\n      this.resultBuffers.push(\n        frameBuffer(unframedBuffer, commandFrameStart, commandFrameEnd),\n      );\n      return;\n    }\n\n    let chunksCount = Math.ceil(unframedBuffer.length / this.maxChunkLength);\n    if (\n      Math.ceil(unframedBuffer.length / chunksCount) + commandFramesLength >\n      this.maxChunkLength\n    ) {\n      chunksCount++;\n    }\n\n    for (const [i, chunk] of splitBufferToEqualChunks(\n      unframedBuffer,\n      chunksCount,\n    )) {\n      if (i === 0) {\n        this.resultBuffers.push(\n          frameBuffer(chunk, commandFrameStart, commandDivFrameEnd),\n        );\n      } else if (i === chunksCount - 1) {\n        this.resultBuffers.push(\n          frameBuffer(chunk, commandDivFrameStart, commandFrameEnd),\n        );\n      } else {\n        this.resultBuffers.push(\n          frameBuffer(chunk, commandDivFrameStart, commandDivFrameEnd),\n        );\n      }\n    }\n  }\n\n  getResultBuffers(): Uint8Array[] {\n    if (this.status === \"creating\" || !this.resultBuffers.length) {\n      throw new Error(\"Command is not complete.\");\n    }\n    return this.resultBuffers;\n  }\n}\n\nexport function deserializeCommand(bytes: Uint8Array): PeerCommand {\n  const [commandCode] = bytes;\n  const deserializedCommand: Record<string, unknown> = {\n    c: commandCode,\n  };\n\n  let offset = 1;\n  while (offset < bytes.length) {\n    const name = String.fromCharCode(bytes[offset]);\n    offset++;\n    const dataType = getDataTypeFromByte(bytes[offset]);\n\n    switch (dataType) {\n      case Serialization.SerializedItem.Int:\n        {\n          const { number, byteLength } = Serialization.deserializeInt(\n            bytes.slice(offset),\n          );\n          deserializedCommand[name] = Number(number);\n          offset += byteLength;\n        }\n        break;\n      case Serialization.SerializedItem.SimilarIntArray:\n        {\n          const { numbers, byteLength } =\n            Serialization.deserializeSimilarIntArray(bytes.slice(offset));\n          deserializedCommand[name] = numbers.map((n) => Number(n));\n          offset += byteLength;\n        }\n        break;\n      case Serialization.SerializedItem.String:\n        {\n          const { string, byteLength } = Serialization.deserializeString(\n            bytes.slice(offset),\n          );\n          deserializedCommand[name] = string;\n          offset += byteLength;\n        }\n        break;\n    }\n  }\n  return deserializedCommand as unknown as PeerCommand;\n}\n\nfunction getDataTypeFromByte(byte: number): Serialization.SerializedItem {\n  const typeCode: Serialization.SerializedItem = byte >> 4;\n  if (\n    typeCode <= Serialization.SerializedItem.Min ||\n    typeCode >= Serialization.SerializedItem.Max\n  ) {\n    throw new Error(\"Not existing type\");\n  }\n\n  return typeCode;\n}\n\nfunction stringToUtf8CodesBuffer(string: string, length?: number): Uint8Array {\n  if (length && string.length !== length) {\n    throw new Error(\"Wrong string length\");\n  }\n  const buffer = new Uint8Array(length ?? string.length);\n  for (let i = 0; i < string.length; i++) buffer[i] = string.charCodeAt(i);\n  return buffer;\n}\n\nfunction* splitBufferToEqualChunks(\n  buffer: Uint8Array,\n  chunksCount: number,\n): Generator<[number, Uint8Array], void> {\n  const chunkLength = Math.ceil(buffer.length / chunksCount);\n  for (let i = 0; i < chunksCount; i++) {\n    yield [i, buffer.slice(i * chunkLength, (i + 1) * chunkLength)];\n  }\n}\n\nfunction frameBuffer(\n  buffer: Uint8Array,\n  frameStart: Uint8Array,\n  frameEnd: Uint8Array,\n) {\n  const result = new Uint8Array(\n    buffer.length + frameStart.length + frameEnd.length,\n  );\n  result.set(frameStart);\n  result.set(buffer, frameStart.length);\n  result.set(frameEnd, frameStart.length + buffer.length);\n\n  return result;\n}\n\nfunction areBuffersEqual(\n  buffer1: Uint8Array,\n  buffer2: Uint8Array,\n  length: number,\n) {\n  for (let i = 0; i < length; i++) {\n    if (buffer1[i] !== buffer2[i]) return false;\n  }\n  return true;\n}\n","import { BinaryCommandCreator } from \"./binary-command-creator.js\";\nimport {\n  PeerSegmentCommand,\n  PeerSendSegmentCommand,\n  PeerSegmentAnnouncementCommand,\n  PeerRequestSegmentCommand,\n  PeerCommand,\n  PeerCommandType,\n} from \"./types.js\";\n\nfunction serializeSegmentAnnouncementCommand(\n  command: PeerSegmentAnnouncementCommand,\n  maxChunkSize: number,\n) {\n  const { c: commandCode, p: loadingByHttp, l: loaded } = command;\n  const creator = new BinaryCommandCreator(commandCode, maxChunkSize);\n  if (loaded?.length) creator.addSimilarIntArr(\"l\", loaded);\n  if (loadingByHttp?.length) {\n    creator.addSimilarIntArr(\"p\", loadingByHttp);\n  }\n  creator.complete();\n  return creator.getResultBuffers();\n}\n\nfunction serializePeerSegmentCommand(\n  command: PeerSegmentCommand,\n  maxChunkSize: number,\n) {\n  const creator = new BinaryCommandCreator(command.c, maxChunkSize);\n  creator.addInteger(\"i\", command.i);\n  creator.addInteger(\"r\", command.r);\n  creator.complete();\n  return creator.getResultBuffers();\n}\n\nfunction serializePeerSendSegmentCommand(\n  command: PeerSendSegmentCommand,\n  maxChunkSize: number,\n) {\n  const creator = new BinaryCommandCreator(command.c, maxChunkSize);\n  creator.addInteger(\"i\", command.i);\n  creator.addInteger(\"s\", command.s);\n  creator.addInteger(\"r\", command.r);\n  creator.complete();\n  return creator.getResultBuffers();\n}\n\nfunction serializePeerSegmentRequestCommand(\n  command: PeerRequestSegmentCommand,\n  maxChunkSize: number,\n) {\n  const creator = new BinaryCommandCreator(command.c, maxChunkSize);\n  creator.addInteger(\"i\", command.i);\n  creator.addInteger(\"r\", command.r);\n  if (command.b) creator.addInteger(\"b\", command.b);\n  creator.complete();\n  return creator.getResultBuffers();\n}\n\nexport function serializePeerCommand(\n  command: PeerCommand,\n  maxChunkSize: number,\n) {\n  switch (command.c) {\n    case PeerCommandType.CancelSegmentRequest:\n    case PeerCommandType.SegmentAbsent:\n    case PeerCommandType.SegmentDataSendingCompleted:\n      return serializePeerSegmentCommand(command, maxChunkSize);\n    case PeerCommandType.SegmentRequest:\n      return serializePeerSegmentRequestCommand(command, maxChunkSize);\n    case PeerCommandType.SegmentsAnnouncement:\n      return serializeSegmentAnnouncementCommand(command, maxChunkSize);\n    case PeerCommandType.SegmentData:\n      return serializePeerSendSegmentCommand(command, maxChunkSize);\n  }\n}\n","import { PeerConnection } from \"bittorrent-tracker\";\nimport { CoreEventMap, StreamConfig } from \"../types.js\";\nimport * as Utils from \"../utils/utils.js\";\nimport * as Command from \"./commands/index.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\n\nexport type PeerConfig = Pick<\n  StreamConfig,\n  | \"p2pNotReceivingBytesTimeoutMs\"\n  | \"webRtcMaxMessageSize\"\n  | \"p2pErrorRetries\"\n  | \"validateP2PSegment\"\n>;\n\nexport class PeerProtocol {\n  private commandChunks?: Command.BinaryCommandChunksJoiner;\n  private uploadingContext?: { stopUploading: () => void; requestId: number };\n  private readonly onChunkDownloaded: CoreEventMap[\"onChunkDownloaded\"];\n  private readonly onChunkUploaded: CoreEventMap[\"onChunkUploaded\"];\n\n  constructor(\n    private readonly connection: PeerConnection,\n    private readonly peerConfig: PeerConfig,\n    private readonly eventHandlers: {\n      onCommandReceived: (command: Command.PeerCommand) => void;\n      onSegmentChunkReceived: (data: Uint8Array) => void;\n    },\n    eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    this.onChunkDownloaded =\n      eventTarget.getEventDispatcher(\"onChunkDownloaded\");\n    this.onChunkUploaded = eventTarget.getEventDispatcher(\"onChunkUploaded\");\n    connection.on(\"data\", this.onDataReceived);\n  }\n\n  private onDataReceived = (data: Uint8Array) => {\n    if (Command.isCommandChunk(data)) {\n      this.receivingCommandBytes(data);\n    } else {\n      this.eventHandlers.onSegmentChunkReceived(data);\n\n      this.onChunkDownloaded(data.byteLength, \"p2p\", this.connection.idUtf8);\n    }\n  };\n\n  sendCommand(command: Command.PeerCommand) {\n    const binaryCommandBuffers = Command.serializePeerCommand(\n      command,\n      this.peerConfig.webRtcMaxMessageSize,\n    );\n    for (const buffer of binaryCommandBuffers) {\n      this.connection.write(buffer);\n    }\n  }\n\n  stopUploadingSegmentData() {\n    this.uploadingContext?.stopUploading();\n    this.uploadingContext = undefined;\n  }\n\n  getUploadingRequestId() {\n    return this.uploadingContext?.requestId;\n  }\n\n  async splitSegmentDataToChunksAndUploadAsync(\n    data: ArrayBuffer,\n    requestId: number,\n  ) {\n    if (this.uploadingContext) {\n      throw new Error(`Some segment data is already uploading.`);\n    }\n    const chunks = getBufferChunks(data, this.peerConfig.webRtcMaxMessageSize);\n    const { promise, resolve, reject } = Utils.getControlledPromise();\n\n    let isUploadingSegmentData = false;\n\n    const uploadingContext = {\n      stopUploading: () => {\n        isUploadingSegmentData = false;\n      },\n      requestId,\n    };\n\n    this.uploadingContext = uploadingContext;\n\n    const sendChunk = () => {\n      if (!isUploadingSegmentData) {\n        reject();\n        return;\n      }\n\n      while (true) {\n        const chunk = chunks.next().value;\n\n        if (!chunk) {\n          resolve();\n          break;\n        }\n\n        const drained = this.connection.write(chunk);\n        this.onChunkUploaded(chunk.byteLength, this.connection.idUtf8);\n        if (!drained) break;\n      }\n    };\n\n    try {\n      this.connection.on(\"drain\", sendChunk);\n      isUploadingSegmentData = true;\n      sendChunk();\n      await promise;\n    } finally {\n      this.connection.off(\"drain\", sendChunk);\n\n      if (this.uploadingContext === uploadingContext) {\n        this.uploadingContext = undefined;\n      }\n    }\n  }\n\n  private receivingCommandBytes(buffer: Uint8Array) {\n    this.commandChunks ??= new Command.BinaryCommandChunksJoiner(\n      (commandBuffer) => {\n        this.commandChunks = undefined;\n        const command = Command.deserializeCommand(commandBuffer);\n        this.eventHandlers.onCommandReceived(command);\n      },\n    );\n    try {\n      this.commandChunks.addCommandChunk(buffer);\n    } catch (err) {\n      if (!(err instanceof Command.BinaryCommandJoiningError)) return;\n      this.commandChunks = undefined;\n    }\n  }\n}\n\nfunction* getBufferChunks(\n  data: ArrayBuffer,\n  maxChunkSize: number,\n): Generator<ArrayBuffer, void> {\n  let bytesLeft = data.byteLength;\n  while (bytesLeft > 0) {\n    const bytesToSend = bytesLeft >= maxChunkSize ? maxChunkSize : bytesLeft;\n    const from = data.byteLength - bytesLeft;\n    const buffer = data.slice(from, from + bytesToSend);\n    bytesLeft -= bytesToSend;\n    yield buffer;\n  }\n}\n","import { PeerConnection } from \"bittorrent-tracker\";\nimport debug from \"debug\";\nimport { Request, RequestControls } from \"../requests/request.js\";\nimport {\n  CoreEventMap,\n  PeerRequestErrorType,\n  RequestError,\n  RequestAbortErrorType,\n  SegmentWithStream,\n  StreamType,\n} from \"../types.js\";\nimport * as Utils from \"../utils/utils.js\";\nimport * as Command from \"./commands/index.js\";\nimport { PeerProtocol, PeerConfig } from \"./peer-protocol.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\n\nconst { PeerCommandType } = Command;\ntype PeerEventHandlers = {\n  onPeerClosed: (peer: Peer) => void;\n  onSegmentRequested: (\n    peer: Peer,\n    segmentId: number,\n    requestId: number,\n    byteFrom?: number,\n  ) => void;\n  onSegmentsAnnouncement: () => void;\n};\n\nexport class Peer {\n  readonly id: string;\n  private readonly peerProtocol;\n  private downloadingContext?: {\n    request: Request;\n    controls: RequestControls;\n    isSegmentDataCommandReceived: boolean;\n    requestId: number;\n  };\n  private loadedSegments = new Set<number>();\n  private httpLoadingSegments = new Set<number>();\n  private downloadingErrors: RequestError<\n    PeerRequestErrorType | RequestAbortErrorType\n  >[] = [];\n  private logger = debug(\"p2pml-core:peer\");\n  private readonly onPeerClosed: CoreEventMap[\"onPeerClose\"];\n\n  constructor(\n    private readonly connection: PeerConnection,\n    private readonly eventHandlers: PeerEventHandlers,\n    private readonly peerConfig: PeerConfig,\n    private readonly streamType: StreamType,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    this.onPeerClosed = eventTarget.getEventDispatcher(\"onPeerClose\");\n\n    this.id = Peer.getPeerIdFromConnection(connection);\n    this.peerProtocol = new PeerProtocol(\n      connection,\n      peerConfig,\n      {\n        onSegmentChunkReceived: this.onSegmentChunkReceived,\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        onCommandReceived: this.onCommandReceived,\n      },\n      eventTarget,\n    );\n    eventTarget.getEventDispatcher(\"onPeerConnect\")({\n      peerId: this.id,\n      streamType,\n    });\n\n    connection.on(\"error\", this.onConnectionError);\n    connection.on(\"close\", this.onPeerConnectionClosed);\n    connection.on(\"end\", this.onPeerConnectionClosed);\n    connection.on(\"finish\", this.onPeerConnectionClosed);\n  }\n\n  get downloadingSegment(): SegmentWithStream | undefined {\n    return this.downloadingContext?.request.segment;\n  }\n\n  getSegmentStatus(\n    segment: SegmentWithStream,\n  ): \"loaded\" | \"http-loading\" | undefined {\n    const { externalId } = segment;\n    if (this.loadedSegments.has(externalId)) return \"loaded\";\n    if (this.httpLoadingSegments.has(externalId)) return \"http-loading\";\n  }\n\n  private onCommandReceived = async (command: Command.PeerCommand) => {\n    switch (command.c) {\n      case PeerCommandType.SegmentsAnnouncement:\n        this.loadedSegments = new Set(command.l);\n        this.httpLoadingSegments = new Set(command.p);\n        this.eventHandlers.onSegmentsAnnouncement();\n        break;\n\n      case PeerCommandType.SegmentRequest:\n        this.peerProtocol.stopUploadingSegmentData();\n        this.eventHandlers.onSegmentRequested(\n          this,\n          command.i,\n          command.r,\n          command.b,\n        );\n        break;\n\n      case PeerCommandType.SegmentData:\n        {\n          if (!this.downloadingContext) break;\n          if (this.downloadingContext.isSegmentDataCommandReceived) break;\n\n          const { request, controls, requestId } = this.downloadingContext;\n          if (\n            request.segment.externalId !== command.i ||\n            requestId !== command.r\n          ) {\n            break;\n          }\n\n          this.downloadingContext.isSegmentDataCommandReceived = true;\n          controls.firstBytesReceived();\n\n          if (request.totalBytes === undefined) {\n            request.setTotalBytes(command.s);\n          } else if (request.totalBytes - request.loadedBytes !== command.s) {\n            request.clearLoadedBytes();\n            this.sendCancelSegmentRequestCommand(request.segment, requestId);\n            this.cancelSegmentDownloading(\n              \"peer-response-bytes-length-mismatch\",\n            );\n            this.destroy();\n          }\n        }\n        break;\n\n      case PeerCommandType.SegmentDataSendingCompleted: {\n        const { downloadingContext } = this;\n\n        if (!downloadingContext?.isSegmentDataCommandReceived) return;\n\n        const { request, controls } = downloadingContext;\n\n        const isWrongSegment =\n          downloadingContext.request.segment.externalId !== command.i ||\n          downloadingContext.requestId !== command.r;\n\n        if (isWrongSegment) {\n          request.clearLoadedBytes();\n          this.cancelSegmentDownloading(\"peer-protocol-violation\");\n          this.destroy();\n          return;\n        }\n\n        const isWrongBytes = request.loadedBytes !== request.totalBytes;\n\n        if (isWrongBytes) {\n          request.clearLoadedBytes();\n          this.cancelSegmentDownloading(\"peer-response-bytes-length-mismatch\");\n          this.destroy();\n          return;\n        }\n\n        const isValid =\n          (await this.peerConfig.validateP2PSegment?.(\n            request.segment.url,\n            request.segment.byteRange,\n            request.data,\n          )) ?? true;\n\n        if (this.downloadingContext !== downloadingContext) return;\n\n        if (!isValid) {\n          request.clearLoadedBytes();\n          this.cancelSegmentDownloading(\"p2p-segment-validation-failed\");\n          this.destroy();\n          return;\n        }\n\n        this.downloadingErrors = [];\n        controls.completeOnSuccess();\n        this.downloadingContext = undefined;\n        break;\n      }\n\n      case PeerCommandType.SegmentAbsent:\n        if (\n          this.downloadingContext?.request.segment.externalId === command.i &&\n          this.downloadingContext.requestId === command.r\n        ) {\n          this.cancelSegmentDownloading(\"peer-segment-absent\");\n          this.loadedSegments.delete(command.i);\n        }\n        break;\n\n      case PeerCommandType.CancelSegmentRequest: {\n        const uploadingRequestId = this.peerProtocol.getUploadingRequestId();\n\n        if (uploadingRequestId !== command.r) break;\n\n        this.peerProtocol.stopUploadingSegmentData();\n        break;\n      }\n    }\n  };\n\n  protected onSegmentChunkReceived = (chunk: Uint8Array) => {\n    if (!this.downloadingContext?.isSegmentDataCommandReceived) return;\n\n    const { request, controls } = this.downloadingContext;\n\n    const isOverflow =\n      request.totalBytes !== undefined &&\n      request.loadedBytes + chunk.byteLength > request.totalBytes;\n\n    if (isOverflow) {\n      request.clearLoadedBytes();\n      this.cancelSegmentDownloading(\"peer-response-bytes-length-mismatch\");\n      this.destroy();\n      return;\n    }\n\n    controls.addLoadedChunk(chunk);\n  };\n\n  downloadSegment(segmentRequest: Request) {\n    if (this.downloadingContext) {\n      throw new Error(\"Some segment already is downloading\");\n    }\n    this.downloadingContext = {\n      request: segmentRequest,\n      requestId: Math.floor(Math.random() * 1000),\n      isSegmentDataCommandReceived: false,\n      controls: segmentRequest.start(\n        { downloadSource: \"p2p\", peerId: this.id },\n        {\n          notReceivingBytesTimeoutMs:\n            this.peerConfig.p2pNotReceivingBytesTimeoutMs,\n          abort: (error) => {\n            if (!this.downloadingContext) return;\n            const { request, requestId } = this.downloadingContext;\n            this.sendCancelSegmentRequestCommand(request.segment, requestId);\n            this.downloadingErrors.push(error);\n            this.downloadingContext = undefined;\n\n            const timeoutErrors = this.downloadingErrors.filter(\n              (error) => error.type === \"bytes-receiving-timeout\",\n            );\n\n            if (timeoutErrors.length >= this.peerConfig.p2pErrorRetries) {\n              this.destroy();\n            }\n          },\n        },\n      ),\n    };\n    const command: Command.PeerRequestSegmentCommand = {\n      c: PeerCommandType.SegmentRequest,\n      r: this.downloadingContext.requestId,\n      i: segmentRequest.segment.externalId,\n    };\n    if (segmentRequest.loadedBytes) command.b = segmentRequest.loadedBytes;\n    this.peerProtocol.sendCommand(command);\n  }\n\n  async uploadSegmentData(\n    segment: SegmentWithStream,\n    requestId: number,\n    data: ArrayBuffer,\n  ) {\n    const { externalId } = segment;\n    this.logger(`send segment ${segment.externalId} to ${this.id}`);\n    const command: Command.PeerSendSegmentCommand = {\n      c: PeerCommandType.SegmentData,\n      i: externalId,\n      r: requestId,\n      s: data.byteLength,\n    };\n    this.peerProtocol.sendCommand(command);\n    try {\n      await this.peerProtocol.splitSegmentDataToChunksAndUploadAsync(\n        data,\n        requestId,\n      );\n      this.sendSegmentDataSendingCompletedCommand(segment, requestId);\n      this.logger(`segment ${externalId} has been sent to ${this.id}`);\n    } catch {\n      this.logger(`cancel segment uploading ${externalId}`);\n    }\n  }\n\n  private cancelSegmentDownloading(type: PeerRequestErrorType) {\n    if (!this.downloadingContext) return;\n    const { request, controls } = this.downloadingContext;\n    const { segment } = request;\n    this.logger(`cancel segment request ${segment.externalId} (${type})`);\n    const error = new RequestError(type);\n    controls.abortOnError(error);\n    this.downloadingContext = undefined;\n    this.downloadingErrors.push(error);\n  }\n\n  sendSegmentsAnnouncementCommand(\n    loadedSegmentsIds: number[],\n    httpLoadingSegmentsIds: number[],\n  ) {\n    const command: Command.PeerSegmentAnnouncementCommand = {\n      c: PeerCommandType.SegmentsAnnouncement,\n      p: httpLoadingSegmentsIds,\n      l: loadedSegmentsIds,\n    };\n    this.peerProtocol.sendCommand(command);\n  }\n\n  sendSegmentAbsentCommand(segmentExternalId: number, requestId: number) {\n    this.peerProtocol.sendCommand({\n      c: PeerCommandType.SegmentAbsent,\n      i: segmentExternalId,\n      r: requestId,\n    });\n  }\n\n  private sendCancelSegmentRequestCommand(\n    segment: SegmentWithStream,\n    requestId: number,\n  ) {\n    this.peerProtocol.sendCommand({\n      c: PeerCommandType.CancelSegmentRequest,\n      i: segment.externalId,\n      r: requestId,\n    });\n  }\n\n  private sendSegmentDataSendingCompletedCommand(\n    segment: SegmentWithStream,\n    requestId: number,\n  ) {\n    this.peerProtocol.sendCommand({\n      c: PeerCommandType.SegmentDataSendingCompleted,\n      r: requestId,\n      i: segment.externalId,\n    });\n  }\n\n  private onPeerConnectionClosed = () => {\n    this.destroy();\n  };\n\n  private onConnectionError = (error: Error) => {\n    this.logger(`peer connection error ${this.id} %O`, error);\n    this.eventTarget.getEventDispatcher(\"onPeerError\")({\n      peerId: this.id,\n      streamType: this.streamType,\n      error,\n    });\n\n    const { code } = error as { code?: string };\n\n    if (code === \"ERR_DATA_CHANNEL\") {\n      this.destroy();\n    } else if (code === \"ERR_CONNECTION_FAILURE\") {\n      this.destroy();\n    }\n  };\n\n  destroy = () => {\n    this.cancelSegmentDownloading(\"peer-closed\");\n    this.connection.destroy();\n    this.eventHandlers.onPeerClosed(this);\n    this.onPeerClosed({\n      peerId: this.id,\n      streamType: this.streamType,\n    });\n    this.logger(`peer closed ${this.id}`);\n  };\n\n  static getPeerIdFromConnection(connection: PeerConnection) {\n    return Utils.hexToUtf8(connection.id);\n  }\n}\n","import TrackerClient, {\n  PeerConnection,\n  TrackerClientEvents,\n} from \"bittorrent-tracker\";\nimport { CoreEventMap, StreamConfig, StreamWithSegments } from \"../types.js\";\nimport debug from \"debug\";\nimport * as PeerUtil from \"../utils/peer.js\";\nimport * as LoggerUtils from \"../utils/logger.js\";\nimport { Peer } from \"./peer.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\nimport { utf8ToUintArray } from \"../utils/utils.js\";\n\ntype PeerItem = {\n  peer?: Peer;\n  potentialConnections: Set<PeerConnection>;\n};\n\ntype P2PTrackerClientEventHandlers = {\n  onPeerConnected: (peer: Peer) => void;\n  onSegmentRequested: (\n    peer: Peer,\n    segmentExternalId: number,\n    requestId: number,\n    bytesFrom?: number,\n  ) => void;\n  onSegmentsAnnouncement: () => void;\n};\n\nfunction isSafariOrWkWebview() {\n  const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n  const isWkWebview =\n    /\\b(iPad|iPhone|Macintosh).*AppleWebKit(?!.*Safari)/i.test(\n      navigator.userAgent,\n    );\n\n  return isSafari || isWkWebview;\n}\n\nexport class P2PTrackerClient {\n  private static readonly PEER_ID_BY_INFO_HASH = new Map<string, string>();\n\n  private readonly streamShortId: string;\n  private readonly client: TrackerClient;\n  private readonly _peers = new Map<string, PeerItem>();\n  private readonly logger = debug(\"p2pml-core:p2p-tracker-client\");\n\n  constructor(\n    streamSwarmId: string,\n    private readonly stream: StreamWithSegments,\n    private readonly eventHandlers: P2PTrackerClientEventHandlers,\n    private readonly config: StreamConfig,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    const streamHash = PeerUtil.getStreamHash(streamSwarmId);\n    this.streamShortId = LoggerUtils.getStreamString(stream);\n\n    let peerId = P2PTrackerClient.PEER_ID_BY_INFO_HASH.get(streamHash);\n    if (!peerId) {\n      peerId = PeerUtil.generatePeerId(config.trackerClientVersionPrefix);\n      P2PTrackerClient.PEER_ID_BY_INFO_HASH.set(streamHash, peerId);\n    }\n\n    this.client = new TrackerClient({\n      infoHash: utf8ToUintArray(streamHash),\n      peerId: utf8ToUintArray(peerId),\n      announce: isSafariOrWkWebview()\n        ? config.announceTrackers.slice(0, 1) // Safari has issues with multiple trackers\n        : config.announceTrackers,\n      rtcConfig: this.config.rtcConfig,\n    });\n    this.client.on(\"peer\", this.onReceivePeerConnection);\n    this.client.on(\"warning\", this.onTrackerClientWarning);\n    this.client.on(\"error\", this.onTrackerClientError);\n    this.logger(\n      `create new client; \\nstream: ${this.streamShortId}; hash: ${streamHash}\\npeerId: ${peerId}`,\n    );\n  }\n\n  start() {\n    this.client.start();\n  }\n\n  destroy() {\n    this.client.destroy();\n\n    for (const { peer, potentialConnections } of this._peers.values()) {\n      peer?.destroy();\n      for (const connection of potentialConnections) {\n        connection.destroy();\n      }\n    }\n\n    this._peers.clear();\n    this.logger(\"destroy client; stream:\", this.streamShortId);\n  }\n\n  private onReceivePeerConnection: TrackerClientEvents[\"peer\"] = (\n    peerConnection,\n  ) => {\n    const itemId = Peer.getPeerIdFromConnection(peerConnection);\n    let peerItem = this._peers.get(itemId);\n\n    if (peerItem?.peer) {\n      peerConnection.destroy();\n      return;\n    }\n\n    if (!peerItem) {\n      peerItem = { potentialConnections: new Set() };\n      peerConnection.idUtf8 = itemId;\n      this._peers.set(itemId, peerItem);\n    }\n\n    peerItem.potentialConnections.add(peerConnection);\n\n    peerConnection.on(\"connect\", () => {\n      if (peerItem.peer) return;\n\n      for (const connection of peerItem.potentialConnections) {\n        if (connection !== peerConnection) connection.destroy();\n      }\n\n      peerItem.potentialConnections.clear();\n\n      peerItem.peer = new Peer(\n        peerConnection,\n        {\n          onPeerClosed: this.onPeerClosed,\n          onSegmentRequested: this.eventHandlers.onSegmentRequested,\n          onSegmentsAnnouncement: this.eventHandlers.onSegmentsAnnouncement,\n        },\n        this.config,\n        this.stream.type,\n        this.eventTarget,\n      );\n      this.logger(\n        `connected with peer: ${peerItem.peer.id} ${this.streamShortId}`,\n      );\n      this.eventHandlers.onPeerConnected(peerItem.peer);\n    });\n  };\n\n  private onTrackerClientWarning: TrackerClientEvents[\"warning\"] = (\n    warning,\n  ) => {\n    this.logger(\"tracker warning %s:\", this.streamShortId, warning);\n    this.eventTarget.getEventDispatcher(\"onTrackerWarning\")({\n      streamType: this.stream.type,\n      warning,\n    });\n  };\n\n  private onTrackerClientError: TrackerClientEvents[\"error\"] = (error) => {\n    this.logger(\"tracker error in stream %s:\", this.streamShortId, error);\n    this.eventTarget.getEventDispatcher(\"onTrackerError\")({\n      streamType: this.stream.type,\n      error,\n    });\n  };\n\n  *peers() {\n    for (const peerItem of this._peers.values()) {\n      if (peerItem.peer) yield peerItem.peer;\n    }\n  }\n\n  private onPeerClosed = (peer: Peer) => {\n    this.logger(`peer closed: ${peer.id}`);\n    this._peers.delete(peer.id);\n  };\n\n  static clearPeerIdCache() {\n    P2PTrackerClient.PEER_ID_BY_INFO_HASH.clear();\n  }\n}\n","import {\n  SegmentWithStream,\n  Stream,\n  StreamConfig,\n  StreamWithSegments,\n} from \"../types.js\";\nimport { Playback } from \"../internal-types.js\";\nimport { P2PLoader } from \"../p2p/loader.js\";\n\nexport type SegmentPlaybackStatuses = {\n  isHighDemand: boolean;\n  isHttpDownloadable: boolean;\n  isP2PDownloadable: boolean;\n};\n\nexport type PlaybackTimeWindowsConfig = Pick<\n  StreamConfig,\n  \"highDemandTimeWindow\" | \"httpDownloadTimeWindow\" | \"p2pDownloadTimeWindow\"\n>;\n\nconst PEER_PROTOCOL_VERSION = \"v2\";\n\nexport function getStreamSwarmId(\n  swarmId: string,\n  stream: Readonly<Stream>,\n): string {\n  return `${PEER_PROTOCOL_VERSION}-${swarmId}-${getStreamId(stream)}`;\n}\n\nexport function getSegmentFromStreamsMap(\n  streams: Map<string, StreamWithSegments>,\n  segmentRuntimeId: string,\n): SegmentWithStream | undefined {\n  for (const stream of streams.values()) {\n    const segment = stream.segments.get(segmentRuntimeId);\n    if (segment) return segment;\n  }\n}\n\nexport function getSegmentFromStreamByExternalId(\n  stream: StreamWithSegments,\n  segmentExternalId: number,\n): SegmentWithStream | undefined {\n  for (const segment of stream.segments.values()) {\n    if (segment.externalId === segmentExternalId) return segment;\n  }\n}\n\nexport function getStreamId(stream: Stream) {\n  return `${stream.type}-${stream.index}`;\n}\n\nexport function getSegmentAvgDuration(stream: StreamWithSegments) {\n  const { segments } = stream;\n  let sumDuration = 0;\n  const { size } = segments;\n  for (const segment of segments.values()) {\n    const duration = segment.endTime - segment.startTime;\n    sumDuration += duration;\n  }\n\n  return sumDuration / size;\n}\n\nfunction calculateTimeWindows(\n  timeWindowsConfig: PlaybackTimeWindowsConfig,\n  availableMemoryInPercent: number,\n) {\n  const {\n    highDemandTimeWindow,\n    httpDownloadTimeWindow,\n    p2pDownloadTimeWindow,\n  } = timeWindowsConfig;\n\n  const result = {\n    highDemandTimeWindow,\n    httpDownloadTimeWindow,\n    p2pDownloadTimeWindow,\n  };\n\n  if (availableMemoryInPercent <= 5) {\n    result.httpDownloadTimeWindow = 0;\n    result.p2pDownloadTimeWindow = 0;\n  } else if (availableMemoryInPercent <= 10) {\n    result.p2pDownloadTimeWindow = result.httpDownloadTimeWindow;\n  }\n\n  return result;\n}\n\nexport function getSegmentPlaybackStatuses(\n  segment: SegmentWithStream,\n  playback: Playback,\n  timeWindowsConfig: PlaybackTimeWindowsConfig,\n  currentP2PLoader: P2PLoader,\n  availableMemoryPercent: number,\n): SegmentPlaybackStatuses {\n  const {\n    highDemandTimeWindow,\n    httpDownloadTimeWindow,\n    p2pDownloadTimeWindow,\n  } = calculateTimeWindows(timeWindowsConfig, availableMemoryPercent);\n\n  return {\n    isHighDemand: isSegmentInTimeWindow(\n      segment,\n      playback,\n      highDemandTimeWindow,\n    ),\n    isHttpDownloadable: isSegmentInTimeWindow(\n      segment,\n      playback,\n      httpDownloadTimeWindow,\n    ),\n    isP2PDownloadable:\n      isSegmentInTimeWindow(segment, playback, p2pDownloadTimeWindow) &&\n      currentP2PLoader.isSegmentLoadingOrLoadedBySomeone(segment),\n  };\n}\n\nfunction isSegmentInTimeWindow(\n  segment: SegmentWithStream,\n  playback: Playback,\n  timeWindowLength: number,\n) {\n  const { startTime, endTime } = segment;\n  const { position, rate } = playback;\n  const rightMargin = position + timeWindowLength * rate;\n  return !(rightMargin < startTime || position > endTime);\n}\n","import { Peer } from \"./peer.js\";\nimport {\n  CoreEventMap,\n  SegmentWithStream,\n  StreamConfig,\n  StreamWithSegments,\n} from \"../types.js\";\nimport { RequestsContainer } from \"../requests/request-container.js\";\nimport { P2PTrackerClient } from \"./tracker-client.js\";\nimport * as StreamUtils from \"../utils/stream.js\";\nimport * as Utils from \"../utils/utils.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\nimport { SegmentStorage } from \"../segment-storage/index.js\";\n\nexport type EventTargetMap = Record<`onStorageUpdated-${string}`, () => void> &\n  CoreEventMap;\n\nexport class P2PLoader {\n  private readonly trackerClient: P2PTrackerClient;\n  private isAnnounceMicrotaskCreated = false;\n\n  constructor(\n    private streamManifestUrl: string,\n    private readonly stream: StreamWithSegments,\n    private readonly requests: RequestsContainer,\n    private readonly segmentStorage: SegmentStorage,\n    private readonly config: StreamConfig,\n    private readonly eventTarget: EventTarget<EventTargetMap>,\n    private readonly onSegmentAnnouncement: () => void,\n  ) {\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, this.stream);\n\n    this.trackerClient = new P2PTrackerClient(\n      streamSwarmId,\n      this.stream,\n      {\n        onPeerConnected: this.onPeerConnected,\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        onSegmentRequested: this.onSegmentRequested,\n        onSegmentsAnnouncement: this.onSegmentAnnouncement,\n      },\n      this.config,\n      this.eventTarget,\n    );\n\n    this.eventTarget.addEventListener(\n      `onStorageUpdated-${streamSwarmId}`,\n      this.broadcastAnnouncement,\n    );\n    this.segmentStorage.setSegmentChangeCallback((streamId: string) => {\n      this.eventTarget.dispatchEvent(`onStorageUpdated-${streamId}`);\n    });\n\n    this.trackerClient.start();\n  }\n\n  downloadSegment(segment: SegmentWithStream) {\n    const peersWithSegment: Peer[] = [];\n    for (const peer of this.trackerClient.peers()) {\n      if (\n        !peer.downloadingSegment &&\n        peer.getSegmentStatus(segment) === \"loaded\"\n      ) {\n        peersWithSegment.push(peer);\n      }\n    }\n\n    if (peersWithSegment.length === 0) return;\n    const peer = Utils.getRandomItem(peersWithSegment);\n\n    const request = this.requests.getOrCreateRequest(segment);\n    peer.downloadSegment(request);\n  }\n\n  isSegmentLoadingOrLoadedBySomeone(segment: SegmentWithStream): boolean {\n    for (const peer of this.trackerClient.peers()) {\n      if (peer.getSegmentStatus(segment)) return true;\n    }\n    return false;\n  }\n\n  isSegmentLoadedBySomeone(segment: SegmentWithStream): boolean {\n    for (const peer of this.trackerClient.peers()) {\n      if (peer.getSegmentStatus(segment) === \"loaded\") return true;\n    }\n    return false;\n  }\n\n  get connectedPeerCount() {\n    let count = 0;\n    const iterator = this.trackerClient.peers();\n    while (!iterator.next().done) count++;\n    return count;\n  }\n\n  private getSegmentsAnnouncement() {\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, this.stream);\n\n    const loaded: number[] = this.segmentStorage.getStoredSegmentIds(\n      swarmId,\n      streamSwarmId,\n    );\n    const httpLoading: number[] = [];\n\n    for (const request of this.requests.httpRequests()) {\n      const segment = this.stream.segments.get(request.segment.runtimeId);\n      if (!segment) continue;\n\n      httpLoading.push(segment.externalId);\n    }\n    return { loaded, httpLoading };\n  }\n\n  private onPeerConnected = (peer: Peer) => {\n    if (this.config.isP2PUploadDisabled) return;\n\n    const { httpLoading, loaded } = this.getSegmentsAnnouncement();\n    peer.sendSegmentsAnnouncementCommand(loaded, httpLoading);\n  };\n\n  broadcastAnnouncement = (sendEmptyAnnouncement = false) => {\n    if (sendEmptyAnnouncement) {\n      this.sendSegmentsAnnouncement([], []);\n      return;\n    }\n\n    if (this.isAnnounceMicrotaskCreated || this.config.isP2PUploadDisabled) {\n      return;\n    }\n\n    const { loaded, httpLoading } = this.getSegmentsAnnouncement();\n    this.sendSegmentsAnnouncement(loaded, httpLoading);\n  };\n\n  private sendSegmentsAnnouncement = (\n    loaded: number[],\n    httpLoading: number[],\n  ) => {\n    this.isAnnounceMicrotaskCreated = true;\n\n    queueMicrotask(() => {\n      for (const peer of this.trackerClient.peers()) {\n        peer.sendSegmentsAnnouncementCommand(loaded, httpLoading);\n      }\n      this.isAnnounceMicrotaskCreated = false;\n    });\n  };\n\n  private onSegmentRequested = async (\n    peer: Peer,\n    segmentExternalId: number,\n    requestId: number,\n    byteFrom?: number,\n  ) => {\n    const segment = StreamUtils.getSegmentFromStreamByExternalId(\n      this.stream,\n      segmentExternalId,\n    );\n    if (!segment) return;\n    if (this.config.isP2PUploadDisabled) {\n      peer.sendSegmentAbsentCommand(segmentExternalId, requestId);\n      return;\n    }\n\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, this.stream);\n\n    const segmentData = await this.segmentStorage.getSegmentData(\n      swarmId,\n      streamSwarmId,\n      segment.externalId,\n    );\n    if (!segmentData) {\n      peer.sendSegmentAbsentCommand(segmentExternalId, requestId);\n      return;\n    }\n    await peer.uploadSegmentData(\n      segment,\n      requestId,\n      byteFrom !== undefined ? segmentData.slice(byteFrom) : segmentData,\n    );\n  };\n\n  destroy() {\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, this.stream);\n\n    this.eventTarget.removeEventListener(\n      `onStorageUpdated-${streamSwarmId}`,\n      this.broadcastAnnouncement,\n    );\n    this.trackerClient.destroy();\n  }\n}\n","import { P2PLoader } from \"./loader.js\";\nimport debug from \"debug\";\nimport {\n  CoreEventMap,\n  Stream,\n  StreamConfig,\n  StreamWithSegments,\n  SegmentStorage,\n} from \"../index.js\";\nimport { RequestsContainer } from \"../requests/request-container.js\";\nimport * as LoggerUtils from \"../utils/logger.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\nimport * as StreamUtils from \"../utils/stream.js\";\n\ntype P2PLoaderContainerItem = {\n  stream: Stream;\n  loader: P2PLoader;\n  destroyTimeoutId?: number;\n  loggerInfo: string;\n};\n\nexport class P2PLoadersContainer {\n  private readonly loaders = new Map<string, P2PLoaderContainerItem>();\n  private _currentLoaderItem: P2PLoaderContainerItem;\n  private readonly logger = debug(\"p2pml-core:p2p-loaders-container\");\n\n  constructor(\n    private readonly streamManifestUrl: string,\n    stream: StreamWithSegments,\n    private readonly requests: RequestsContainer,\n    private readonly segmentStorage: SegmentStorage,\n    private readonly config: StreamConfig,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n    private onSegmentAnnouncement: () => void,\n  ) {\n    this._currentLoaderItem = this.findOrCreateLoaderForStream(stream);\n    this.logger(\n      `set current p2p loader: ${LoggerUtils.getStreamString(stream)}`,\n    );\n  }\n\n  private createLoader(stream: StreamWithSegments): P2PLoaderContainerItem {\n    if (this.loaders.has(stream.runtimeId)) {\n      throw new Error(\"Loader for this stream already exists\");\n    }\n    const loader = new P2PLoader(\n      this.streamManifestUrl,\n      stream,\n      this.requests,\n      this.segmentStorage,\n      this.config,\n      this.eventTarget,\n      () => {\n        if (this._currentLoaderItem.loader === loader) {\n          this.onSegmentAnnouncement();\n        }\n      },\n    );\n    const loggerInfo = LoggerUtils.getStreamString(stream);\n    this.logger(`created new loader: ${loggerInfo}`);\n    return {\n      loader,\n      stream,\n      loggerInfo: LoggerUtils.getStreamString(stream),\n    };\n  }\n\n  private findOrCreateLoaderForStream(stream: StreamWithSegments) {\n    const loaderItem = this.loaders.get(stream.runtimeId);\n    if (loaderItem) {\n      clearTimeout(loaderItem.destroyTimeoutId);\n      loaderItem.destroyTimeoutId = undefined;\n      return loaderItem;\n    } else {\n      const loader = this.createLoader(stream);\n      this.loaders.set(stream.runtimeId, loader);\n      return loader;\n    }\n  }\n\n  changeCurrentLoader(stream: StreamWithSegments) {\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(\n      swarmId,\n      this._currentLoaderItem.stream,\n    );\n    const ids = this.segmentStorage.getStoredSegmentIds(swarmId, streamSwarmId);\n    if (!ids.length) this.destroyAndRemoveLoader(this._currentLoaderItem);\n    else this.setLoaderDestroyTimeout(this._currentLoaderItem);\n\n    this._currentLoaderItem = this.findOrCreateLoaderForStream(stream);\n\n    this.logger(\n      `change current p2p loader: ${LoggerUtils.getStreamString(stream)}`,\n    );\n  }\n\n  private setLoaderDestroyTimeout(item: P2PLoaderContainerItem) {\n    item.destroyTimeoutId = window.setTimeout(\n      () => this.destroyAndRemoveLoader(item),\n      this.config.p2pInactiveLoaderDestroyTimeoutMs,\n    );\n  }\n\n  private destroyAndRemoveLoader(item: P2PLoaderContainerItem) {\n    item.loader.destroy();\n    this.loaders.delete(item.stream.runtimeId);\n    this.logger(`destroy p2p loader: `, item.loggerInfo);\n  }\n\n  get currentLoader() {\n    return this._currentLoaderItem.loader;\n  }\n\n  destroy() {\n    for (const { loader, destroyTimeoutId } of this.loaders.values()) {\n      loader.destroy();\n      clearTimeout(destroyTimeoutId);\n    }\n    this.loaders.clear();\n  }\n}\n","import debug from \"debug\";\nimport { BandwidthCalculators, Playback } from \"../internal-types.js\";\nimport {\n  CoreEventMap,\n  RequestError,\n  RequestAbortErrorType,\n  SegmentWithStream,\n  Segment,\n} from \"../types.js\";\nimport * as StreamUtils from \"../utils/stream.js\";\nimport * as Utils from \"../utils/utils.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\n\nexport type LoadProgress = {\n  startTimestamp: number;\n  lastLoadedChunkTimestamp?: number;\n  startFromByte?: number;\n  loadedBytes: number;\n};\n\ntype HttpRequestAttempt = {\n  downloadSource: \"http\";\n  error?: RequestError;\n};\n\ntype P2PRequestAttempt = {\n  downloadSource: \"p2p\";\n  peerId: string;\n  error?: RequestError;\n};\n\nexport type RequestAttempt = HttpRequestAttempt | P2PRequestAttempt;\n\nexport type RequestControls = Readonly<{\n  firstBytesReceived: Request[\"firstBytesReceived\"];\n  addLoadedChunk: Request[\"addLoadedChunk\"];\n  completeOnSuccess: Request[\"completeOnSuccess\"];\n  abortOnError: Request[\"abortOnError\"];\n}>;\n\ntype OmitEncapsulated<T extends RequestAttempt> = Omit<\n  T,\n  \"error\" | \"errorTimestamp\"\n>;\ntype StartRequestParameters =\n  | OmitEncapsulated<HttpRequestAttempt>\n  | OmitEncapsulated<P2PRequestAttempt>;\n\nexport type RequestStatus =\n  | \"not-started\"\n  | \"loading\"\n  | \"succeed\"\n  | \"failed\"\n  | \"aborted\";\n\nfunction mapSegmentWithStreamToSegment(segment: SegmentWithStream): Segment {\n  return {\n    runtimeId: segment.runtimeId,\n    externalId: segment.externalId,\n    url: segment.url,\n    byteRange: segment.byteRange,\n    startTime: segment.startTime,\n    endTime: segment.endTime,\n  };\n}\n\nexport class Request {\n  private currentAttempt?: RequestAttempt;\n  private _failedAttempts = new FailedRequestAttempts();\n  private finalData?: ArrayBuffer;\n  private bytes: Uint8Array[] = [];\n  private _loadedBytes = 0;\n  private _totalBytes?: number;\n  private _status: RequestStatus = \"not-started\";\n  private progress?: LoadProgress;\n  private notReceivingBytesTimeout: Timeout;\n  private _abortRequestCallback?: (\n    error: RequestError<RequestAbortErrorType>,\n  ) => void;\n  private readonly _logger: debug.Debugger;\n  private _isHandledByProcessQueue = false;\n  private readonly onSegmentError: CoreEventMap[\"onSegmentError\"];\n  private readonly onSegmentAbort: CoreEventMap[\"onSegmentAbort\"];\n  private readonly onSegmentStart: CoreEventMap[\"onSegmentStart\"];\n  private readonly onSegmentLoaded: CoreEventMap[\"onSegmentLoaded\"];\n\n  constructor(\n    readonly segment: SegmentWithStream,\n    private readonly requestProcessQueueCallback: () => void,\n    private readonly bandwidthCalculators: BandwidthCalculators,\n    private readonly playback: Playback,\n    private readonly playbackConfig: StreamUtils.PlaybackTimeWindowsConfig,\n    eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    this.onSegmentError = eventTarget.getEventDispatcher(\"onSegmentError\");\n    this.onSegmentAbort = eventTarget.getEventDispatcher(\"onSegmentAbort\");\n    this.onSegmentStart = eventTarget.getEventDispatcher(\"onSegmentStart\");\n    this.onSegmentLoaded = eventTarget.getEventDispatcher(\"onSegmentLoaded\");\n\n    const { byteRange } = this.segment;\n    if (byteRange) {\n      const { end, start } = byteRange;\n      this._totalBytes = end - start + 1;\n    }\n    this.notReceivingBytesTimeout = new Timeout(this.abortOnTimeout);\n\n    const { type } = this.segment.stream;\n    this._logger = debug(`p2pml-core:request-${type}`);\n  }\n\n  clearLoadedBytes() {\n    this._loadedBytes = 0;\n    this.bytes = [];\n    this._totalBytes = undefined;\n    this.finalData = undefined;\n  }\n\n  get status() {\n    return this._status;\n  }\n\n  private setStatus(status: RequestStatus) {\n    this._status = status;\n    this._isHandledByProcessQueue = false;\n  }\n\n  get downloadSource() {\n    return this.currentAttempt?.downloadSource;\n  }\n\n  get loadedBytes() {\n    return this._loadedBytes;\n  }\n\n  get totalBytes(): number | undefined {\n    return this._totalBytes;\n  }\n\n  get data(): ArrayBuffer {\n    this.finalData ??= Utils.joinChunks(this.bytes).buffer;\n    return this.finalData;\n  }\n\n  get failedAttempts() {\n    return this._failedAttempts;\n  }\n\n  get isHandledByProcessQueue() {\n    return this._isHandledByProcessQueue;\n  }\n\n  markHandledByProcessQueue() {\n    this._isHandledByProcessQueue = true;\n  }\n\n  setTotalBytes(value: number) {\n    if (this._totalBytes !== undefined) {\n      throw new Error(\"Request total bytes value is already set\");\n    }\n    this._totalBytes = value;\n  }\n\n  start(\n    requestData: StartRequestParameters,\n    controls: {\n      notReceivingBytesTimeoutMs?: number;\n      abort: (errorType: RequestError<RequestAbortErrorType>) => void;\n    },\n  ): RequestControls {\n    if (this._status === \"succeed\") {\n      throw new Error(\n        `Request ${this.segment.externalId} has been already succeed.`,\n      );\n    }\n    if (this._status === \"loading\") {\n      throw new Error(\n        `Request ${this.segment.externalId} has been already started.`,\n      );\n    }\n\n    this.setStatus(\"loading\");\n    this.currentAttempt = { ...requestData };\n    this.progress = {\n      startFromByte: this._loadedBytes,\n      loadedBytes: 0,\n      startTimestamp: performance.now(),\n    };\n    this.manageBandwidthCalculatorsState(\"start\");\n\n    const { notReceivingBytesTimeoutMs, abort } = controls;\n    this._abortRequestCallback = abort;\n\n    if (notReceivingBytesTimeoutMs !== undefined) {\n      this.notReceivingBytesTimeout.start(notReceivingBytesTimeoutMs);\n    }\n\n    this.logger(\n      `${requestData.downloadSource} ${this.segment.externalId} started`,\n    );\n\n    this.onSegmentStart({\n      segment: mapSegmentWithStreamToSegment(this.segment),\n      downloadSource: requestData.downloadSource,\n      peerId:\n        requestData.downloadSource === \"p2p\" ? requestData.peerId : undefined,\n    });\n\n    return {\n      firstBytesReceived: this.firstBytesReceived,\n      addLoadedChunk: this.addLoadedChunk,\n      completeOnSuccess: this.completeOnSuccess,\n      abortOnError: this.abortOnError,\n    };\n  }\n\n  abortFromProcessQueue() {\n    this.throwErrorIfNotLoadingStatus();\n    this.setStatus(\"aborted\");\n    this.logger(\n      `${this.currentAttempt?.downloadSource} ${this.segment.externalId} aborted`,\n    );\n    this._abortRequestCallback?.(new RequestError(\"abort\"));\n    this.onSegmentAbort({\n      segment: mapSegmentWithStreamToSegment(this.segment),\n      downloadSource: this.currentAttempt?.downloadSource,\n      peerId:\n        this.currentAttempt?.downloadSource === \"p2p\"\n          ? this.currentAttempt.peerId\n          : undefined,\n      streamType: this.segment.stream.type,\n    });\n    this._abortRequestCallback = undefined;\n    this.manageBandwidthCalculatorsState(\"stop\");\n    this.notReceivingBytesTimeout.clear();\n  }\n\n  private abortOnTimeout = () => {\n    this.throwErrorIfNotLoadingStatus();\n    if (!this.currentAttempt) return;\n\n    this.setStatus(\"failed\");\n    const error = new RequestError(\"bytes-receiving-timeout\");\n    this._abortRequestCallback?.(error);\n    this.logger(\n      `${this.downloadSource} ${this.segment.externalId} failed ${error.type}`,\n    );\n    this._failedAttempts.add({\n      ...this.currentAttempt,\n      error,\n    });\n    this.onSegmentError({\n      segment: mapSegmentWithStreamToSegment(this.segment),\n      error,\n      downloadSource: this.currentAttempt.downloadSource,\n      peerId:\n        this.currentAttempt.downloadSource === \"p2p\"\n          ? this.currentAttempt.peerId\n          : undefined,\n      streamType: this.segment.stream.type,\n    });\n    this.notReceivingBytesTimeout.clear();\n    this.manageBandwidthCalculatorsState(\"stop\");\n    this.requestProcessQueueCallback();\n  };\n\n  private abortOnError = (error: RequestError) => {\n    this.throwErrorIfNotLoadingStatus();\n    if (!this.currentAttempt) return;\n\n    this.setStatus(\"failed\");\n    this.logger(\n      `${this.downloadSource} ${this.segment.externalId} failed ${error.type}`,\n    );\n    this._failedAttempts.add({\n      ...this.currentAttempt,\n      error,\n    });\n    this.onSegmentError({\n      segment: mapSegmentWithStreamToSegment(this.segment),\n      error,\n      downloadSource: this.currentAttempt.downloadSource,\n      peerId:\n        this.currentAttempt.downloadSource === \"p2p\"\n          ? this.currentAttempt.peerId\n          : undefined,\n      streamType: this.segment.stream.type,\n    });\n    this.notReceivingBytesTimeout.clear();\n    this.manageBandwidthCalculatorsState(\"stop\");\n    this.requestProcessQueueCallback();\n  };\n\n  private completeOnSuccess = () => {\n    this.throwErrorIfNotLoadingStatus();\n    if (!this.currentAttempt) return;\n\n    this.manageBandwidthCalculatorsState(\"stop\");\n    this.notReceivingBytesTimeout.clear();\n    this.setStatus(\"succeed\");\n    this._totalBytes = this._loadedBytes;\n    this.onSegmentLoaded({\n      segmentUrl: this.segment.url,\n      bytesLength: this.data.byteLength,\n      downloadSource: this.currentAttempt.downloadSource,\n      peerId:\n        this.currentAttempt.downloadSource === \"p2p\"\n          ? this.currentAttempt.peerId\n          : undefined,\n      streamType: this.segment.stream.type,\n    });\n\n    this.logger(\n      `${this.currentAttempt.downloadSource} ${this.segment.externalId} succeed`,\n    );\n    this.requestProcessQueueCallback();\n  };\n\n  private addLoadedChunk = (chunk: Uint8Array) => {\n    this.throwErrorIfNotLoadingStatus();\n    if (!this.currentAttempt || !this.progress) return;\n    this.notReceivingBytesTimeout.restart();\n\n    const { byteLength } = chunk;\n    const { all: allBC, http: httpBC } = this.bandwidthCalculators;\n    allBC.addBytes(byteLength);\n    if (this.currentAttempt.downloadSource === \"http\") {\n      httpBC.addBytes(byteLength);\n    }\n\n    this.bytes.push(chunk);\n    this.progress.lastLoadedChunkTimestamp = performance.now();\n    this.progress.loadedBytes += byteLength;\n    this._loadedBytes += byteLength;\n  };\n\n  private firstBytesReceived = () => {\n    this.throwErrorIfNotLoadingStatus();\n    this.notReceivingBytesTimeout.restart();\n  };\n\n  private throwErrorIfNotLoadingStatus() {\n    if (this._status !== \"loading\") {\n      throw new Error(`Request has been already ${this.status}.`);\n    }\n  }\n\n  private logger(message: string) {\n    this._logger.color =\n      this.currentAttempt?.downloadSource === \"http\" ? \"green\" : \"red\";\n    this._logger(message);\n    this._logger.color = \"\";\n  }\n\n  private manageBandwidthCalculatorsState(state: \"start\" | \"stop\") {\n    const { all, http } = this.bandwidthCalculators;\n    const method = state === \"start\" ? \"startLoading\" : \"stopLoading\";\n    if (this.currentAttempt?.downloadSource === \"http\") http[method]();\n    all[method]();\n  }\n}\n\nclass FailedRequestAttempts {\n  private attempts: Required<RequestAttempt>[] = [];\n\n  add(attempt: Required<RequestAttempt>) {\n    this.attempts.push(attempt);\n  }\n\n  get httpAttemptsCount() {\n    return this.attempts.reduce(\n      (sum, attempt) => (attempt.downloadSource === \"http\" ? sum + 1 : sum),\n      0,\n    );\n  }\n\n  get lastAttempt(): Readonly<Required<RequestAttempt>> | undefined {\n    return this.attempts[this.attempts.length - 1];\n  }\n\n  clear() {\n    this.attempts = [];\n  }\n}\n\nexport class Timeout {\n  private timeoutId?: number;\n  private ms?: number;\n\n  constructor(private readonly action: () => void) {}\n\n  start(ms: number) {\n    if (this.timeoutId) {\n      throw new Error(\"Timeout is already started.\");\n    }\n    this.ms = ms;\n    this.timeoutId = window.setTimeout(this.action, this.ms);\n  }\n\n  restart(ms?: number) {\n    if (this.timeoutId) clearTimeout(this.timeoutId);\n    if (ms) this.ms = ms;\n    if (!this.ms) return;\n    this.timeoutId = window.setTimeout(this.action, this.ms);\n  }\n\n  clear() {\n    clearTimeout(this.timeoutId);\n    this.timeoutId = undefined;\n  }\n}\n","import { Playback, BandwidthCalculators } from \"../internal-types.js\";\nimport { CoreEventMap, SegmentWithStream, StreamConfig } from \"../types.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\nimport { Request } from \"./request.js\";\n\nexport class RequestsContainer {\n  private readonly requests = new Map<SegmentWithStream, Request>();\n\n  constructor(\n    private readonly requestProcessQueueCallback: () => void,\n    private readonly bandwidthCalculators: BandwidthCalculators,\n    private readonly playback: Playback,\n    private readonly config: StreamConfig,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n  ) {}\n\n  get executingHttpCount() {\n    let count = 0;\n    for (const request of this.httpRequests()) {\n      if (request.status === \"loading\") count++;\n    }\n    return count;\n  }\n\n  get executingP2PCount() {\n    let count = 0;\n    for (const request of this.p2pRequests()) {\n      if (request.status === \"loading\") count++;\n    }\n    return count;\n  }\n\n  get(segment: SegmentWithStream) {\n    return this.requests.get(segment);\n  }\n\n  getOrCreateRequest(segment: SegmentWithStream) {\n    let request = this.requests.get(segment);\n    if (!request) {\n      request = new Request(\n        segment,\n        this.requestProcessQueueCallback,\n        this.bandwidthCalculators,\n        this.playback,\n        this.config,\n        this.eventTarget,\n      );\n      this.requests.set(segment, request);\n    }\n    return request;\n  }\n\n  remove(request: Request) {\n    this.requests.delete(request.segment);\n  }\n\n  items() {\n    return this.requests.values();\n  }\n\n  *httpRequests(): Generator<Request, void> {\n    for (const request of this.requests.values()) {\n      if (request.downloadSource === \"http\") yield request;\n    }\n  }\n\n  *p2pRequests(): Generator<Request, void> {\n    for (const request of this.requests.values()) {\n      if (request.downloadSource === \"p2p\") yield request;\n    }\n  }\n\n  destroy() {\n    for (const request of this.requests.values()) {\n      if (request.status !== \"loading\") continue;\n      request.abortFromProcessQueue();\n    }\n    this.requests.clear();\n  }\n}\n","import {\n  CoreRequestError,\n  EngineCallbacks,\n  SegmentWithStream,\n} from \"../types.js\";\n\nexport class EngineRequest {\n  private _status: \"pending\" | \"succeed\" | \"failed\" | \"aborted\" = \"pending\";\n  private _shouldBeStartedImmediately = false;\n\n  constructor(\n    readonly segment: SegmentWithStream,\n    readonly engineCallbacks: EngineCallbacks,\n  ) {}\n\n  get status() {\n    return this._status;\n  }\n\n  get shouldBeStartedImmediately() {\n    return this._shouldBeStartedImmediately;\n  }\n\n  resolve(data: ArrayBuffer, bandwidth: number) {\n    if (this._status !== \"pending\") return;\n    this._status = \"succeed\";\n    this.engineCallbacks.onSuccess({ data, bandwidth });\n  }\n\n  reject() {\n    if (this._status !== \"pending\") return;\n    this._status = \"failed\";\n    this.engineCallbacks.onError(new CoreRequestError(\"failed\"));\n  }\n\n  abort() {\n    if (this._status !== \"pending\") return;\n    this._status = \"aborted\";\n    this.engineCallbacks.onError(new CoreRequestError(\"aborted\"));\n  }\n\n  markAsShouldBeStartedImmediately() {\n    this._shouldBeStartedImmediately = true;\n  }\n}\n","import { Playback } from \"../internal-types.js\";\nimport { P2PLoader } from \"../p2p/loader.js\";\nimport { SegmentWithStream } from \"../types.js\";\nimport {\n  getSegmentPlaybackStatuses,\n  SegmentPlaybackStatuses,\n  PlaybackTimeWindowsConfig,\n} from \"./stream.js\";\n\nexport type QueueItem = {\n  segment: SegmentWithStream;\n  statuses: SegmentPlaybackStatuses;\n};\n\nexport function* generateQueue(\n  lastRequestedSegment: Readonly<SegmentWithStream>,\n  playback: Readonly<Playback>,\n  playbackConfig: PlaybackTimeWindowsConfig,\n  currentP2PLoader: P2PLoader,\n  availablePercentMemory: number,\n): Generator<QueueItem, void> {\n  const { runtimeId, stream } = lastRequestedSegment;\n\n  const requestedSegment = stream.segments.get(runtimeId);\n  if (!requestedSegment) return;\n\n  const queueSegments = stream.segments.values();\n\n  let first: SegmentWithStream;\n\n  do {\n    const next = queueSegments.next();\n    if (next.done) return; // should never happen\n    first = next.value;\n  } while (first !== requestedSegment);\n\n  const firstStatuses = getSegmentPlaybackStatuses(\n    first,\n    playback,\n    playbackConfig,\n    currentP2PLoader,\n    availablePercentMemory,\n  );\n  if (isNotActualStatuses(firstStatuses)) {\n    const next = queueSegments.next();\n\n    // for cases when engine requests segment that is a little bit\n    // earlier than current playhead position\n    // it could happen when playhead position is significantly changed by user\n    if (next.done) return;\n\n    const second = next.value;\n\n    const secondStatuses = getSegmentPlaybackStatuses(\n      second,\n      playback,\n      playbackConfig,\n      currentP2PLoader,\n      availablePercentMemory,\n    );\n\n    if (isNotActualStatuses(secondStatuses)) return;\n    firstStatuses.isHighDemand = true;\n    yield { segment: first, statuses: firstStatuses };\n    yield { segment: second, statuses: secondStatuses };\n  } else {\n    yield { segment: first, statuses: firstStatuses };\n  }\n\n  for (const segment of queueSegments) {\n    const statuses = getSegmentPlaybackStatuses(\n      segment,\n      playback,\n      playbackConfig,\n      currentP2PLoader,\n      availablePercentMemory,\n    );\n    if (isNotActualStatuses(statuses)) break;\n    yield { segment, statuses };\n  }\n}\n\nfunction isNotActualStatuses(statuses: SegmentPlaybackStatuses) {\n  const {\n    isHighDemand = false,\n    isHttpDownloadable = false,\n    isP2PDownloadable = false,\n  } = statuses;\n  return !isHighDemand && !isHttpDownloadable && !isP2PDownloadable;\n}\n","import { HttpRequestExecutor } from \"./http-loader.js\";\nimport {\n  CoreEventMap,\n  EngineCallbacks,\n  SegmentWithStream,\n  StreamConfig,\n  StreamWithSegments,\n} from \"./types.js\";\nimport {\n  Playback,\n  BandwidthCalculators,\n  StreamDetails,\n} from \"./internal-types.js\";\nimport { P2PLoadersContainer } from \"./p2p/loaders-container.js\";\nimport { RequestsContainer } from \"./requests/request-container.js\";\nimport { EngineRequest } from \"./requests/engine-request.js\";\nimport * as QueueUtils from \"./utils/queue.js\";\nimport * as LoggerUtils from \"./utils/logger.js\";\nimport * as StreamUtils from \"./utils/stream.js\";\nimport * as Utils from \"./utils/utils.js\";\nimport debug from \"debug\";\nimport { QueueItem } from \"./utils/queue.js\";\nimport { EventTarget } from \"./utils/event-target.js\";\nimport { SegmentStorage } from \"./segment-storage/index.js\";\n\nconst FAILED_ATTEMPTS_CLEAR_INTERVAL = 60000;\nconst PEER_UPDATE_LATENCY = 1000;\n\nexport class HybridLoader {\n  private readonly requests: RequestsContainer;\n  private engineRequest?: EngineRequest;\n  private readonly p2pLoaders: P2PLoadersContainer;\n  private readonly playback: Playback;\n  private readonly segmentAvgDuration: number;\n  private readonly logger: debug.Debugger;\n  private storageCleanUpIntervalId?: number;\n  private levelChangedTimestamp?: number;\n  private lastQueueProcessingTimeStamp?: number;\n  private randomHttpDownloadInterval?: number;\n  private isProcessQueueMicrotaskCreated = false;\n\n  constructor(\n    private streamManifestUrl: string,\n    private lastRequestedSegment: Readonly<SegmentWithStream>,\n    private readonly streamDetails: Required<Readonly<StreamDetails>>,\n    private readonly config: StreamConfig,\n    private readonly bandwidthCalculators: BandwidthCalculators,\n    private readonly segmentStorage: SegmentStorage,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    const activeStream = this.lastRequestedSegment.stream;\n    this.playback = { position: this.lastRequestedSegment.startTime, rate: 1 };\n    this.segmentAvgDuration = StreamUtils.getSegmentAvgDuration(activeStream);\n    this.requests = new RequestsContainer(\n      this.requestProcessQueueMicrotask,\n      this.bandwidthCalculators,\n      this.playback,\n      this.config,\n      this.eventTarget,\n    );\n\n    this.p2pLoaders = new P2PLoadersContainer(\n      this.streamManifestUrl,\n      this.lastRequestedSegment.stream,\n      this.requests,\n      this.segmentStorage,\n      this.config,\n      this.eventTarget,\n      this.requestProcessQueueMicrotask,\n    );\n\n    this.logger = debug(`p2pml-core:hybrid-loader-${activeStream.type}`);\n    this.logger.color = \"coral\";\n\n    this.setIntervalLoading();\n  }\n\n  private setIntervalLoading() {\n    const peersCount = this.p2pLoaders.currentLoader.connectedPeerCount;\n    const randomTimeout =\n      Math.random() * PEER_UPDATE_LATENCY * peersCount + PEER_UPDATE_LATENCY;\n    this.randomHttpDownloadInterval = window.setTimeout(() => {\n      this.loadRandomThroughHttp();\n      this.setIntervalLoading();\n    }, randomTimeout);\n  }\n\n  // api method for engines\n  async loadSegment(\n    segment: Readonly<SegmentWithStream>,\n    callbacks: EngineCallbacks,\n  ) {\n    this.logger(`requests: ${LoggerUtils.getSegmentString(segment)}`);\n    const { stream } = segment;\n    if (stream !== this.lastRequestedSegment.stream) {\n      this.logger(`stream changed to ${LoggerUtils.getStreamString(stream)}`);\n      this.p2pLoaders.changeCurrentLoader(stream);\n    }\n    this.lastRequestedSegment = segment;\n\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, stream);\n\n    this.segmentStorage.onSegmentRequested(\n      swarmId,\n      streamSwarmId,\n      segment.externalId,\n      segment.startTime,\n      segment.endTime,\n      stream.type,\n      this.streamDetails.isLive,\n    );\n    const engineRequest = new EngineRequest(segment, callbacks);\n\n    try {\n      const hasSegment = this.segmentStorage.hasSegment(\n        swarmId,\n        streamSwarmId,\n        segment.externalId,\n      );\n\n      if (hasSegment) {\n        const data = await this.segmentStorage.getSegmentData(\n          swarmId,\n          streamSwarmId,\n          segment.externalId,\n        );\n        if (data) {\n          const { queueDownloadRatio } = this.generateQueue();\n          engineRequest.resolve(data, this.getBandwidth(queueDownloadRatio));\n          return;\n        }\n      }\n\n      this.engineRequest?.abort();\n      this.engineRequest = engineRequest;\n    } catch {\n      engineRequest.reject();\n    } finally {\n      this.requestProcessQueueMicrotask();\n    }\n  }\n\n  private requestProcessQueueMicrotask = (force = true) => {\n    const now = performance.now();\n    if (\n      (!force &&\n        this.lastQueueProcessingTimeStamp !== undefined &&\n        now - this.lastQueueProcessingTimeStamp <= 1000) ||\n      this.isProcessQueueMicrotaskCreated\n    ) {\n      return;\n    }\n\n    this.isProcessQueueMicrotaskCreated = true;\n    queueMicrotask(() => {\n      try {\n        this.processQueue();\n        this.lastQueueProcessingTimeStamp = now;\n      } finally {\n        this.isProcessQueueMicrotaskCreated = false;\n      }\n    });\n  };\n\n  private processRequests(\n    queueSegmentIds: Set<string>,\n    queueDownloadRatio: number,\n  ) {\n    const { stream } = this.lastRequestedSegment;\n    const { httpErrorRetries } = this.config;\n    const now = performance.now();\n    for (const request of this.requests.items()) {\n      const {\n        downloadSource: type,\n        status,\n        segment,\n        isHandledByProcessQueue,\n      } = request;\n      const engineRequest =\n        this.engineRequest?.segment === segment\n          ? this.engineRequest\n          : undefined;\n\n      switch (status) {\n        case \"loading\":\n          if (!queueSegmentIds.has(segment.runtimeId) && !engineRequest) {\n            request.abortFromProcessQueue();\n            this.requests.remove(request);\n          }\n          break;\n\n        case \"succeed\": {\n          if (!type) break;\n          if (type === \"http\") {\n            this.p2pLoaders.currentLoader.broadcastAnnouncement();\n          }\n          if (engineRequest) {\n            engineRequest.resolve(\n              request.data,\n              this.getBandwidth(queueDownloadRatio),\n            );\n            this.engineRequest = undefined;\n          }\n          this.requests.remove(request);\n\n          const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n          const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, stream);\n\n          void this.segmentStorage.storeSegment(\n            swarmId,\n            streamSwarmId,\n            segment.externalId,\n            request.data,\n            segment.startTime,\n            segment.endTime,\n            segment.stream.type,\n            this.streamDetails.isLive,\n          );\n          break;\n        }\n\n        case \"failed\":\n          if (type === \"http\" && !isHandledByProcessQueue) {\n            this.p2pLoaders.currentLoader.broadcastAnnouncement();\n          }\n          if (\n            !engineRequest &&\n            !stream.segments.has(request.segment.runtimeId)\n          ) {\n            this.requests.remove(request);\n          }\n          if (\n            request.failedAttempts.httpAttemptsCount >= httpErrorRetries &&\n            engineRequest\n          ) {\n            this.engineRequest = undefined;\n            engineRequest.reject();\n          }\n          break;\n\n        case \"not-started\":\n          this.requests.remove(request);\n          break;\n\n        case \"aborted\":\n          this.requests.remove(request);\n          break;\n      }\n\n      request.markHandledByProcessQueue();\n      const { lastAttempt } = request.failedAttempts;\n      if (\n        lastAttempt &&\n        now - lastAttempt.error.timestamp > FAILED_ATTEMPTS_CLEAR_INTERVAL\n      ) {\n        request.failedAttempts.clear();\n      }\n    }\n  }\n\n  private processQueue() {\n    const { queue, queueSegmentIds, queueDownloadRatio } = this.generateQueue();\n    this.processRequests(queueSegmentIds, queueDownloadRatio);\n\n    const {\n      simultaneousHttpDownloads,\n      simultaneousP2PDownloads,\n      httpErrorRetries,\n    } = this.config;\n\n    if (\n      this.engineRequest?.shouldBeStartedImmediately &&\n      this.engineRequest.status === \"pending\" &&\n      this.requests.executingHttpCount < simultaneousHttpDownloads\n    ) {\n      const { segment } = this.engineRequest;\n      const request = this.requests.get(segment);\n      if (\n        !request ||\n        request.status === \"not-started\" ||\n        (request.status === \"failed\" &&\n          request.failedAttempts.httpAttemptsCount <\n            this.config.httpErrorRetries)\n      ) {\n        this.loadThroughHttp(segment);\n      }\n    }\n\n    for (const item of queue) {\n      const { statuses, segment } = item;\n      const request = this.requests.get(segment);\n\n      if (statuses.isHighDemand) {\n        if (\n          request?.downloadSource === \"http\" &&\n          request.status === \"loading\"\n        ) {\n          continue;\n        }\n\n        if (\n          request?.downloadSource === \"http\" &&\n          request.status === \"failed\" &&\n          request.failedAttempts.httpAttemptsCount >= httpErrorRetries\n        ) {\n          continue;\n        }\n\n        const isP2PLoadingRequest =\n          request?.status === \"loading\" && request.downloadSource === \"p2p\";\n\n        if (this.requests.executingHttpCount < simultaneousHttpDownloads) {\n          if (isP2PLoadingRequest) request.abortFromProcessQueue();\n          this.loadThroughHttp(segment);\n          continue;\n        }\n\n        if (\n          this.abortLastHttpLoadingInQueueAfterItem(queue, segment) &&\n          this.requests.executingHttpCount < simultaneousHttpDownloads\n        ) {\n          if (isP2PLoadingRequest) request.abortFromProcessQueue();\n          this.loadThroughHttp(segment);\n          continue;\n        }\n\n        if (isP2PLoadingRequest) continue;\n\n        if (this.requests.executingP2PCount < simultaneousP2PDownloads) {\n          this.loadThroughP2P(segment);\n          continue;\n        }\n\n        if (\n          this.abortLastP2PLoadingInQueueAfterItem(queue, segment) &&\n          this.requests.executingP2PCount < simultaneousP2PDownloads\n        ) {\n          this.loadThroughP2P(segment);\n          continue;\n        }\n      } else if (statuses.isP2PDownloadable) {\n        if (request?.status === \"loading\") continue;\n\n        if (this.requests.executingP2PCount < simultaneousP2PDownloads) {\n          this.loadThroughP2P(segment);\n        } else if (\n          this.p2pLoaders.currentLoader.isSegmentLoadedBySomeone(segment)\n        ) {\n          if (\n            this.abortLastP2PLoadingInQueueAfterItem(queue, segment) &&\n            this.requests.executingP2PCount < simultaneousP2PDownloads\n          ) {\n            this.loadThroughP2P(segment);\n          }\n        }\n      }\n    }\n  }\n\n  // api method for engines\n  abortSegmentRequest(segmentRuntimeId: string) {\n    if (this.engineRequest?.segment.runtimeId !== segmentRuntimeId) return;\n    this.engineRequest.abort();\n    this.logger(\n      \"abort: \",\n      LoggerUtils.getSegmentString(this.engineRequest.segment),\n    );\n    this.engineRequest = undefined;\n    this.requestProcessQueueMicrotask();\n  }\n\n  private loadThroughHttp(segment: SegmentWithStream) {\n    const request = this.requests.getOrCreateRequest(segment);\n    new HttpRequestExecutor(request, this.config, this.eventTarget);\n    this.p2pLoaders.currentLoader.broadcastAnnouncement();\n  }\n\n  private loadThroughP2P(segment: SegmentWithStream) {\n    this.p2pLoaders.currentLoader.downloadSegment(segment);\n  }\n\n  private loadRandomThroughHttp() {\n    const availableStorageCapacityPercent =\n      this.getAvailableStorageCapacityPercent();\n    if (availableStorageCapacityPercent <= 10) return;\n\n    const { simultaneousHttpDownloads, httpErrorRetries } = this.config;\n    const p2pLoader = this.p2pLoaders.currentLoader;\n\n    if (\n      this.requests.executingHttpCount >= simultaneousHttpDownloads ||\n      !p2pLoader.connectedPeerCount\n    ) {\n      return;\n    }\n\n    const segmentsToLoad: SegmentWithStream[] = [];\n    for (const { segment, statuses } of QueueUtils.generateQueue(\n      this.lastRequestedSegment,\n      this.playback,\n      this.config,\n      this.p2pLoaders.currentLoader,\n      availableStorageCapacityPercent,\n    )) {\n      const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n      const streamSwarmId = StreamUtils.getStreamSwarmId(\n        swarmId,\n        segment.stream,\n      );\n\n      if (\n        !statuses.isHttpDownloadable ||\n        statuses.isP2PDownloadable ||\n        this.segmentStorage.hasSegment(\n          swarmId,\n          streamSwarmId,\n          segment.externalId,\n        )\n      ) {\n        continue;\n      }\n      const request = this.requests.get(segment);\n      if (\n        request &&\n        (request.status === \"loading\" ||\n          request.status === \"succeed\" ||\n          request.failedAttempts.httpAttemptsCount >= httpErrorRetries)\n      ) {\n        continue;\n      }\n      segmentsToLoad.push(segment);\n    }\n\n    if (!segmentsToLoad.length) return;\n\n    const availableHttpDownloads =\n      simultaneousHttpDownloads - this.requests.executingHttpCount;\n\n    if (availableHttpDownloads === 0) return;\n\n    const peersCount = p2pLoader.connectedPeerCount + 1;\n    const safeRandomSegmentsCount = Math.min(\n      segmentsToLoad.length,\n      simultaneousHttpDownloads * peersCount,\n    );\n\n    const randomIndices = Utils.shuffleArray(\n      Array.from({ length: safeRandomSegmentsCount }, (_, i) => i),\n    );\n\n    let probability = safeRandomSegmentsCount / peersCount;\n\n    for (const randomIndex of randomIndices) {\n      if (this.requests.executingHttpCount >= simultaneousHttpDownloads) {\n        break;\n      }\n\n      if (probability >= 1 || Math.random() <= probability) {\n        const segment = segmentsToLoad[randomIndex];\n        this.loadThroughHttp(segment);\n      }\n\n      probability--;\n      if (probability <= 0) break;\n    }\n  }\n\n  private abortLastHttpLoadingInQueueAfterItem(\n    queue: QueueUtils.QueueItem[],\n    segment: SegmentWithStream,\n  ): boolean {\n    for (const { segment: itemSegment } of Utils.arrayBackwards(queue)) {\n      if (itemSegment === segment) break;\n      const request = this.requests.get(itemSegment);\n      if (request?.downloadSource === \"http\" && request.status === \"loading\") {\n        request.abortFromProcessQueue();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private abortLastP2PLoadingInQueueAfterItem(\n    queue: QueueUtils.QueueItem[],\n    segment: SegmentWithStream,\n  ): boolean {\n    for (const { segment: itemSegment } of Utils.arrayBackwards(queue)) {\n      if (itemSegment === segment) break;\n      const request = this.requests.get(itemSegment);\n      if (request?.downloadSource === \"p2p\" && request.status === \"loading\") {\n        request.abortFromProcessQueue();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private getAvailableStorageCapacityPercent(): number {\n    const { totalCapacity, usedCapacity } = this.segmentStorage.getUsage();\n    return 100 - (usedCapacity / totalCapacity) * 100;\n  }\n\n  private generateQueue() {\n    const queue: QueueItem[] = [];\n    const queueSegmentIds = new Set<string>();\n    let maxPossibleLength = 0;\n    let alreadyLoadedCount = 0;\n\n    const availableStorageCapacityPercent =\n      this.getAvailableStorageCapacityPercent();\n    for (const item of QueueUtils.generateQueue(\n      this.lastRequestedSegment,\n      this.playback,\n      this.config,\n      this.p2pLoaders.currentLoader,\n      availableStorageCapacityPercent,\n    )) {\n      maxPossibleLength++;\n      const { segment } = item;\n\n      const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n      const streamSwarmId = StreamUtils.getStreamSwarmId(\n        swarmId,\n        segment.stream,\n      );\n\n      if (\n        this.segmentStorage.hasSegment(\n          swarmId,\n          streamSwarmId,\n          segment.externalId,\n        ) ||\n        this.requests.get(segment)?.status === \"succeed\"\n      ) {\n        alreadyLoadedCount++;\n        continue;\n      }\n      queue.push(item);\n      queueSegmentIds.add(segment.runtimeId);\n    }\n\n    return {\n      queue,\n      queueSegmentIds,\n      maxPossibleLength,\n      alreadyLoadedCount,\n      queueDownloadRatio:\n        maxPossibleLength !== 0 ? alreadyLoadedCount / maxPossibleLength : 0,\n    };\n  }\n\n  private getBandwidth(queueDownloadRatio: number) {\n    const { http, all } = this.bandwidthCalculators;\n    const { activeLevelBitrate } = this.streamDetails;\n    if (this.streamDetails.activeLevelBitrate === 0) {\n      return all.getBandwidthLoadingOnly(3);\n    }\n\n    const bandwidth = Math.max(\n      all.getBandwidth(30, this.levelChangedTimestamp),\n      all.getBandwidth(60, this.levelChangedTimestamp),\n      all.getBandwidth(90, this.levelChangedTimestamp),\n    );\n\n    if (queueDownloadRatio >= 0.8 || bandwidth >= activeLevelBitrate * 0.9) {\n      return Math.max(\n        all.getBandwidthLoadingOnly(1),\n        all.getBandwidthLoadingOnly(3),\n        all.getBandwidthLoadingOnly(5),\n      );\n    }\n\n    const httpRealBandwidth = Math.max(\n      http.getBandwidthLoadingOnly(1),\n      http.getBandwidthLoadingOnly(3),\n      http.getBandwidthLoadingOnly(5),\n    );\n\n    return Math.max(bandwidth, httpRealBandwidth);\n  }\n\n  notifyLevelChanged() {\n    this.levelChangedTimestamp = performance.now();\n  }\n\n  sendBroadcastAnnouncement(sendEmptySegmentsAnnouncement = false) {\n    this.p2pLoaders.currentLoader.broadcastAnnouncement(\n      sendEmptySegmentsAnnouncement,\n    );\n  }\n\n  updatePlayback(position: number, rate: number) {\n    const isRateChanged = this.playback.rate !== rate;\n    const isPositionChanged = this.playback.position !== position;\n\n    if (!isRateChanged && !isPositionChanged) return;\n\n    const isPositionSignificantlyChanged =\n      Math.abs(position - this.playback.position) / this.segmentAvgDuration >\n      0.5;\n\n    if (isPositionChanged) this.playback.position = position;\n    if (isRateChanged && rate !== 0) this.playback.rate = rate;\n    if (isPositionSignificantlyChanged) {\n      this.logger(\"position significantly changed\");\n      this.engineRequest?.markAsShouldBeStartedImmediately();\n    }\n    this.segmentStorage.onPlaybackUpdated(position, rate);\n    this.requestProcessQueueMicrotask(isPositionSignificantlyChanged);\n  }\n\n  updateStream(stream: StreamWithSegments) {\n    if (stream !== this.lastRequestedSegment.stream) return;\n    this.logger(`update stream: ${LoggerUtils.getStreamString(stream)}`);\n    this.requestProcessQueueMicrotask();\n  }\n\n  destroy() {\n    clearInterval(this.storageCleanUpIntervalId);\n    clearInterval(this.randomHttpDownloadInterval);\n    this.storageCleanUpIntervalId = undefined;\n    this.engineRequest?.abort();\n    this.requests.destroy();\n    this.p2pLoaders.destroy();\n  }\n}\n","export class BandwidthCalculator {\n  private loadingsCount = 0;\n  private readonly bytes: number[] = [];\n  private readonly loadingOnlyTimestamps: number[] = [];\n  private readonly timestamps: number[] = [];\n  private noLoadingsTime = 0;\n  private loadingsStoppedAt = 0;\n\n  constructor(private readonly clearThresholdMs = 20000) {}\n\n  addBytes(bytesLength: number, now = performance.now()) {\n    this.bytes.push(bytesLength);\n    this.loadingOnlyTimestamps.push(now - this.noLoadingsTime);\n    this.timestamps.push(now);\n  }\n\n  startLoading(now = performance.now()) {\n    this.clearStale();\n    if (this.loadingsCount === 0 && this.loadingsStoppedAt !== 0) {\n      this.noLoadingsTime += now - this.loadingsStoppedAt;\n    }\n    this.loadingsCount++;\n  }\n\n  stopLoading(now = performance.now()) {\n    if (this.loadingsCount > 0) {\n      this.loadingsCount--;\n      if (this.loadingsCount === 0) this.loadingsStoppedAt = now;\n    }\n  }\n\n  getBandwidthLoadingOnly(\n    seconds: number,\n    ignoreThresholdTimestamp = Number.NEGATIVE_INFINITY,\n  ) {\n    if (!this.loadingOnlyTimestamps.length) return 0;\n    const milliseconds = seconds * 1000;\n    const lastItemTimestamp =\n      this.loadingOnlyTimestamps[this.loadingOnlyTimestamps.length - 1];\n    let lastCountedTimestamp = lastItemTimestamp;\n    const threshold = lastItemTimestamp - milliseconds;\n    let totalBytes = 0;\n\n    for (let i = this.bytes.length - 1; i >= 0; i--) {\n      const timestamp = this.loadingOnlyTimestamps[i];\n      if (\n        timestamp < threshold ||\n        this.timestamps[i] < ignoreThresholdTimestamp\n      ) {\n        break;\n      }\n      lastCountedTimestamp = timestamp;\n      totalBytes += this.bytes[i];\n    }\n\n    return (totalBytes * 8000) / (lastItemTimestamp - lastCountedTimestamp);\n  }\n\n  getBandwidth(\n    seconds: number,\n    ignoreThresholdTimestamp = Number.NEGATIVE_INFINITY,\n    now = performance.now(),\n  ) {\n    if (!this.timestamps.length) return 0;\n    const milliseconds = seconds * 1000;\n    const threshold = now - milliseconds;\n    let lastCountedTimestamp = now;\n    let totalBytes = 0;\n\n    for (let i = this.bytes.length - 1; i >= 0; i--) {\n      const timestamp = this.timestamps[i];\n      if (timestamp < threshold || timestamp < ignoreThresholdTimestamp) break;\n      lastCountedTimestamp = timestamp;\n      totalBytes += this.bytes[i];\n    }\n\n    return (totalBytes * 8000) / (now - lastCountedTimestamp);\n  }\n\n  clearStale() {\n    if (!this.loadingOnlyTimestamps.length) return;\n    const threshold =\n      this.loadingOnlyTimestamps[this.loadingOnlyTimestamps.length - 1] -\n      this.clearThresholdMs;\n\n    let samplesToRemove = 0;\n    for (const timestamp of this.loadingOnlyTimestamps) {\n      if (timestamp > threshold) break;\n      samplesToRemove++;\n    }\n\n    this.bytes.splice(0, samplesToRemove);\n    this.loadingOnlyTimestamps.splice(0, samplesToRemove);\n    this.timestamps.splice(0, samplesToRemove);\n  }\n}\n","export const getStorageItemId = (streamId: string, segmentId: number) =>\n  `${streamId}|${segmentId}`;\n\nexport const isAndroid = (userAgent: string) => /Android/i.test(userAgent);\n\nexport const isIPadOrIPhone = (userAgent: string) =>\n  /iPad|iPhone/i.test(userAgent);\n\nexport const isAndroidWebview = (userAgent: string) =>\n  /Android/i.test(userAgent) && !/Chrome|Firefox/i.test(userAgent);\n","import { CommonCoreConfig, StreamConfig, StreamType } from \"../types.js\";\nimport debug from \"debug\";\nimport { SegmentStorage } from \"./index.js\";\nimport {\n  isAndroid,\n  isIPadOrIPhone,\n  isAndroidWebview,\n  getStorageItemId,\n} from \"./utils.js\";\n\ntype SegmentDataItem = {\n  segmentId: number;\n  streamId: string;\n  data: ArrayBuffer;\n  startTime: number;\n  endTime: number;\n  streamType: StreamType;\n};\n\ntype Playback = {\n  position: number;\n  rate: number;\n};\n\ntype LastRequestedSegmentInfo = {\n  streamId: string;\n  segmentId: number;\n  startTime: number;\n  endTime: number;\n  swarmId: string;\n  streamType: StreamType;\n  isLiveStream: boolean;\n};\n\nconst BYTES_PER_MiB = 1048576;\n\nexport class SegmentMemoryStorage implements SegmentStorage {\n  private readonly userAgent = navigator.userAgent;\n  private segmentMemoryStorageLimit = 4 * 1024;\n  private currentStorageUsage = 0;\n\n  private cache = new Map<string, SegmentDataItem>();\n  private readonly logger: debug.Debugger;\n  private coreConfig?: CommonCoreConfig;\n  private mainStreamConfig?: StreamConfig;\n  private secondaryStreamConfig?: StreamConfig;\n  private currentPlayback?: Playback;\n  private lastRequestedSegment?: LastRequestedSegmentInfo;\n  private segmentChangeCallback?: (streamId: string) => void;\n\n  constructor() {\n    this.logger = debug(\"p2pml-core:segment-memory-storage\");\n    this.logger.color = \"RebeccaPurple\";\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async initialize(\n    coreConfig: CommonCoreConfig,\n    mainStreamConfig: StreamConfig,\n    secondaryStreamConfig: StreamConfig,\n  ) {\n    this.coreConfig = coreConfig;\n    this.mainStreamConfig = mainStreamConfig;\n    this.secondaryStreamConfig = secondaryStreamConfig;\n\n    this.setMemoryStorageLimit();\n    this.logger(\"initialized\");\n  }\n\n  onPlaybackUpdated(position: number, rate: number) {\n    this.currentPlayback = { position, rate };\n  }\n\n  onSegmentRequested(\n    swarmId: string,\n    streamId: string,\n    segmentId: number,\n    startTime: number,\n    endTime: number,\n    streamType: StreamType,\n    isLiveStream: boolean,\n  ): void {\n    this.lastRequestedSegment = {\n      streamId,\n      segmentId,\n      startTime,\n      endTime,\n      swarmId,\n      streamType,\n      isLiveStream,\n    };\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async storeSegment(\n    _swarmId: string,\n    streamId: string,\n    segmentId: number,\n    data: ArrayBuffer,\n    startTime: number,\n    endTime: number,\n    streamType: StreamType,\n    isLiveStream: boolean,\n  ) {\n    this.clear(isLiveStream, data.byteLength);\n\n    const storageId = getStorageItemId(streamId, segmentId);\n    this.cache.set(storageId, {\n      data,\n      segmentId,\n      streamId,\n      startTime,\n      endTime,\n      streamType,\n    });\n    this.increaseStorageUsage(data.byteLength);\n\n    this.logger(`add segment: ${segmentId} to ${streamId}`);\n\n    if (!this.segmentChangeCallback) {\n      throw new Error(\"dispatchStorageUpdatedEvent is not set\");\n    }\n\n    this.segmentChangeCallback(streamId);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async getSegmentData(_swarmId: string, streamId: string, segmentId: number) {\n    const segmentStorageId = getStorageItemId(streamId, segmentId);\n    const dataItem = this.cache.get(segmentStorageId);\n\n    if (dataItem === undefined) return undefined;\n\n    return dataItem.data;\n  }\n\n  getUsage() {\n    if (!this.lastRequestedSegment || !this.currentPlayback) {\n      return {\n        totalCapacity: this.segmentMemoryStorageLimit,\n        usedCapacity: this.currentStorageUsage,\n      };\n    }\n    const playbackPosition = this.currentPlayback.position;\n\n    let calculatedUsedCapacity = 0;\n    for (const { endTime, data } of this.cache.values()) {\n      if (playbackPosition > endTime) continue;\n\n      calculatedUsedCapacity += data.byteLength;\n    }\n\n    return {\n      totalCapacity: this.segmentMemoryStorageLimit,\n      usedCapacity: calculatedUsedCapacity / BYTES_PER_MiB,\n    };\n  }\n\n  hasSegment(_swarmId: string, streamId: string, externalId: number) {\n    const segmentStorageId = getStorageItemId(streamId, externalId);\n    const segment = this.cache.get(segmentStorageId);\n\n    return segment !== undefined;\n  }\n\n  getStoredSegmentIds(_swarmId: string, streamId: string) {\n    const externalIds: number[] = [];\n\n    for (const { segmentId, streamId: streamCacheId } of this.cache.values()) {\n      if (streamCacheId !== streamId) continue;\n      externalIds.push(segmentId);\n    }\n\n    return externalIds;\n  }\n\n  private clear(isLiveStream: boolean, newSegmentSize: number) {\n    if (\n      !this.currentPlayback ||\n      !this.mainStreamConfig ||\n      !this.secondaryStreamConfig ||\n      !this.coreConfig\n    ) {\n      return;\n    }\n\n    const isMemoryLimitReached = this.isMemoryLimitReached(newSegmentSize);\n\n    if (!isMemoryLimitReached && !isLiveStream) return;\n\n    const affectedStreams = new Set<string>();\n    const sortedCache = Array.from(this.cache.values()).sort(\n      (a, b) => a.startTime - b.startTime,\n    );\n\n    for (const segmentData of sortedCache) {\n      const { streamId, segmentId, data } = segmentData;\n      const storageId = getStorageItemId(streamId, segmentId);\n\n      const shouldRemove = this.shouldRemoveSegment(\n        segmentData,\n        isLiveStream,\n        this.currentPlayback.position,\n      );\n\n      if (!shouldRemove) continue;\n\n      this.cache.delete(storageId);\n      affectedStreams.add(streamId);\n      this.decreaseStorageUsage(data.byteLength);\n\n      this.logger(`Removed segment ${segmentId} from stream ${streamId}`);\n\n      if (!this.isMemoryLimitReached(newSegmentSize) && !isLiveStream) break;\n    }\n\n    this.sendUpdatesToAffectedStreams(affectedStreams);\n  }\n\n  private isMemoryLimitReached(segmentByteLength: number) {\n    return (\n      this.currentStorageUsage + segmentByteLength / BYTES_PER_MiB >\n      this.segmentMemoryStorageLimit\n    );\n  }\n\n  setSegmentChangeCallback(callback: (streamId: string) => void) {\n    this.segmentChangeCallback = callback;\n  }\n\n  private sendUpdatesToAffectedStreams(affectedStreams: Set<string>) {\n    if (affectedStreams.size === 0) return;\n\n    affectedStreams.forEach((stream) => {\n      if (!this.segmentChangeCallback) {\n        throw new Error(\"dispatchStorageUpdatedEvent is not set\");\n      }\n\n      this.segmentChangeCallback(stream);\n    });\n  }\n\n  private shouldRemoveSegment(\n    segmentData: SegmentDataItem,\n    isLiveStream: boolean,\n    currentPlaybackPosition: number,\n  ): boolean {\n    const { endTime, streamType } = segmentData;\n    const highDemandTimeWindow = this.getStreamTimeWindow(\n      streamType,\n      \"highDemandTimeWindow\",\n    );\n\n    if (currentPlaybackPosition <= endTime) return false;\n\n    if (isLiveStream) {\n      return currentPlaybackPosition > highDemandTimeWindow + endTime;\n    }\n\n    return true;\n  }\n\n  private increaseStorageUsage(segmentByteLength: number) {\n    this.currentStorageUsage += segmentByteLength / BYTES_PER_MiB;\n  }\n\n  private decreaseStorageUsage(segmentByteLength: number) {\n    this.currentStorageUsage -= segmentByteLength / BYTES_PER_MiB;\n  }\n\n  private setMemoryStorageLimit() {\n    if (this.coreConfig?.segmentMemoryStorageLimit) {\n      this.segmentMemoryStorageLimit =\n        this.coreConfig.segmentMemoryStorageLimit;\n      return;\n    }\n\n    if (isAndroidWebview(this.userAgent) || isIPadOrIPhone(this.userAgent)) {\n      this.segmentMemoryStorageLimit = 1024;\n    } else if (isAndroid(this.userAgent)) {\n      this.segmentMemoryStorageLimit = 2 * 1024;\n    }\n  }\n\n  private getStreamTimeWindow(\n    streamType: string,\n    configKey: \"highDemandTimeWindow\" | \"httpDownloadTimeWindow\",\n  ): number {\n    const config =\n      streamType === \"main\"\n        ? this.mainStreamConfig\n        : this.secondaryStreamConfig;\n\n    return config?.[configKey] ?? 0;\n  }\n\n  public destroy() {\n    this.cache.clear();\n  }\n}\n","export class EventTarget<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  EventTypesMap extends Record<string, (...args: any[]) => unknown>,\n> {\n  private events = new Map<\n    keyof EventTypesMap,\n    EventTypesMap[keyof EventTypesMap][]\n  >();\n\n  public dispatchEvent<K extends keyof EventTypesMap>(\n    eventName: K,\n    ...args: Parameters<EventTypesMap[K]>\n  ) {\n    const listeners = this.events.get(eventName);\n    if (!listeners) return;\n    for (const listener of listeners) {\n      listener(...args);\n    }\n  }\n\n  public getEventDispatcher<K extends keyof EventTypesMap>(eventName: K) {\n    let listeners = this.events.get(eventName);\n    if (!listeners) {\n      listeners = [];\n      this.events.set(eventName, listeners);\n    }\n\n    const definedListeners = listeners;\n\n    return (...args: Parameters<EventTypesMap[K]>) => {\n      for (const listener of definedListeners) {\n        listener(...args);\n      }\n    };\n  }\n\n  public addEventListener<K extends keyof EventTypesMap>(\n    eventName: K,\n    listener: EventTypesMap[K],\n  ) {\n    const listeners = this.events.get(eventName);\n    if (!listeners) {\n      this.events.set(eventName, [listener]);\n    } else {\n      listeners.push(listener);\n    }\n  }\n\n  public removeEventListener<K extends keyof EventTypesMap>(\n    eventName: K,\n    listener: EventTypesMap[K],\n  ) {\n    const listeners = this.events.get(eventName);\n    if (listeners) {\n      const index = listeners.indexOf(listener);\n      if (index !== -1) {\n        listeners.splice(index, 1);\n      }\n    }\n  }\n}\n","import { HybridLoader } from \"./hybrid-loader.js\";\nimport {\n  Stream,\n  CoreConfig,\n  Segment,\n  CoreEventMap,\n  DynamicCoreConfig,\n  EngineCallbacks,\n  StreamWithSegments,\n  SegmentWithStream,\n  CommonCoreConfig,\n  StreamConfig,\n  DefinedCoreConfig,\n  StreamType,\n  DynamicStreamConfig,\n} from \"./types.js\";\nimport { BandwidthCalculators, StreamDetails } from \"./internal-types.js\";\nimport * as StreamUtils from \"./utils/stream.js\";\nimport { BandwidthCalculator } from \"./bandwidth-calculator.js\";\nimport { SegmentMemoryStorage } from \"./segment-storage/segment-memory-storage.js\";\nimport { EventTarget } from \"./utils/event-target.js\";\nimport {\n  overrideConfig,\n  mergeAndFilterConfig,\n  deepCopy,\n  filterUndefinedProps,\n} from \"./utils/utils.js\";\nimport { TRACKER_CLIENT_VERSION_PREFIX } from \"./utils/peer.js\";\nimport { SegmentStorage } from \"./segment-storage/index.js\";\nimport { P2PTrackerClient } from \"./p2p/tracker-client.js\";\n\n/** Core class for managing media streams loading via P2P. */\nexport class Core<TStream extends Stream = Stream> {\n  /** Default configuration for common core settings. */\n  static readonly DEFAULT_COMMON_CORE_CONFIG: CommonCoreConfig = {\n    segmentMemoryStorageLimit: undefined,\n    customSegmentStorageFactory: undefined,\n  };\n\n  /** Default configuration for stream settings. */\n  static readonly DEFAULT_STREAM_CONFIG: StreamConfig = {\n    isP2PUploadDisabled: false,\n    isP2PDisabled: false,\n    simultaneousHttpDownloads: 2,\n    simultaneousP2PDownloads: 3,\n    highDemandTimeWindow: 15,\n    httpDownloadTimeWindow: 3000,\n    p2pDownloadTimeWindow: 6000,\n    webRtcMaxMessageSize: 64 * 1024 - 1,\n    p2pNotReceivingBytesTimeoutMs: 2000,\n    p2pInactiveLoaderDestroyTimeoutMs: 30 * 1000,\n    httpNotReceivingBytesTimeoutMs: 3000,\n    httpErrorRetries: 3,\n    p2pErrorRetries: 3,\n    trackerClientVersionPrefix: TRACKER_CLIENT_VERSION_PREFIX,\n    announceTrackers: [\n      \"wss://tracker.novage.com.ua\",\n      \"wss://tracker.webtorrent.dev\",\n      \"wss://tracker.openwebtorrent.com\",\n    ],\n    rtcConfig: {\n      iceServers: [\n        { urls: \"stun:stun.l.google.com:19302\" },\n        { urls: \"stun:global.stun.twilio.com:3478\" },\n      ],\n    },\n    validateP2PSegment: undefined,\n    validateHTTPSegment: undefined,\n    httpRequestSetup: undefined,\n    swarmId: undefined,\n  };\n\n  private readonly eventTarget = new EventTarget<CoreEventMap>();\n  private manifestResponseUrl?: string;\n  private readonly streams = new Map<string, StreamWithSegments<TStream>>();\n  private mainStreamConfig: StreamConfig;\n  private secondaryStreamConfig: StreamConfig;\n  private commonCoreConfig: CommonCoreConfig;\n  private readonly bandwidthCalculators: BandwidthCalculators = {\n    all: new BandwidthCalculator(),\n    http: new BandwidthCalculator(),\n  };\n  private segmentStorage?: SegmentStorage;\n  private mainStreamLoader?: HybridLoader;\n  private secondaryStreamLoader?: HybridLoader;\n  private streamDetails: StreamDetails = {\n    isLive: false,\n    activeLevelBitrate: 0,\n  };\n\n  /**\n   * Constructs a new Core instance with optional initial configuration.\n   *\n   * @param config - Optional partial configuration to override default settings.\n   *\n   * @example\n   * // Create a Core instance with custom configuration for HTTP and P2P downloads.\n   * const core = new Core({\n   *   simultaneousHttpDownloads: 5,\n   *   simultaneousP2PDownloads: 5,\n   *   httpErrorRetries: 5,\n   *   p2pErrorRetries: 5\n   * });\n   *\n   * @example\n   * // Create a Core instance using the default configuration.\n   * const core = new Core();\n   */\n  constructor(config?: Partial<CoreConfig>) {\n    const filteredConfig = filterUndefinedProps(config ?? {});\n\n    this.commonCoreConfig = mergeAndFilterConfig<CommonCoreConfig>({\n      defaultConfig: Core.DEFAULT_COMMON_CORE_CONFIG,\n      baseConfig: filteredConfig,\n    });\n\n    this.mainStreamConfig = mergeAndFilterConfig<StreamConfig>({\n      defaultConfig: Core.DEFAULT_STREAM_CONFIG,\n      baseConfig: filteredConfig,\n      specificStreamConfig: filteredConfig.mainStream,\n    });\n\n    this.secondaryStreamConfig = mergeAndFilterConfig<StreamConfig>({\n      defaultConfig: Core.DEFAULT_STREAM_CONFIG,\n      baseConfig: filteredConfig,\n      specificStreamConfig: filteredConfig.secondaryStream,\n    });\n  }\n\n  /**\n   * Retrieves the current configuration for the core instance, ensuring immutability.\n   *\n   * @returns A deep readonly version of the core configuration.\n   */\n  getConfig(): DefinedCoreConfig {\n    return {\n      ...deepCopy(this.commonCoreConfig),\n      mainStream: deepCopy(this.mainStreamConfig),\n      secondaryStream: deepCopy(this.secondaryStreamConfig),\n    };\n  }\n\n  /**\n   * Applies a set of dynamic configuration updates to the core, merging with the existing configuration.\n   *\n   * @param dynamicConfig - A set of configuration changes to apply.\n   *\n   * @example\n   * // Example of dynamically updating the download time windows and timeout settings.\n   * const dynamicConfig = {\n   *   httpDownloadTimeWindow: 60,  // Set HTTP download time window to 60 seconds\n   *   p2pDownloadTimeWindow: 60,   // Set P2P download time window to 60 seconds\n   *   httpNotReceivingBytesTimeoutMs: 1500,  // Set HTTP timeout to 1500 milliseconds\n   *   p2pNotReceivingBytesTimeoutMs: 1500    // Set P2P timeout to 1500 milliseconds\n   * };\n   * core.applyDynamicConfig(dynamicConfig);\n   */\n  applyDynamicConfig(dynamicConfig: DynamicCoreConfig) {\n    const { mainStream, secondaryStream } = dynamicConfig;\n\n    const mainStreamConfigCopy = deepCopy(this.mainStreamConfig);\n    const secondaryStreamConfigCopy = deepCopy(this.secondaryStreamConfig);\n\n    this.overrideAllConfigs(dynamicConfig, mainStream, secondaryStream);\n\n    this.processSpecificDynamicConfigParams(\n      mainStreamConfigCopy,\n      dynamicConfig,\n      \"main\",\n    );\n    this.processSpecificDynamicConfigParams(\n      secondaryStreamConfigCopy,\n      dynamicConfig,\n      \"secondary\",\n    );\n  }\n\n  private processSpecificDynamicConfigParams(\n    prevConfig: StreamConfig,\n    updatedConfig: DynamicCoreConfig,\n    streamType: StreamType,\n  ) {\n    const isP2PDisabled = this.getUpdatedStreamProperty(\n      \"isP2PDisabled\",\n      updatedConfig,\n      streamType,\n    );\n\n    if (isP2PDisabled && prevConfig.isP2PDisabled !== isP2PDisabled) {\n      this.destroyStreamLoader(streamType);\n    }\n\n    const isP2PUploadDisabled = this.getUpdatedStreamProperty(\n      \"isP2PUploadDisabled\",\n      updatedConfig,\n      streamType,\n    );\n\n    if (\n      isP2PUploadDisabled !== undefined &&\n      prevConfig.isP2PUploadDisabled !== isP2PUploadDisabled\n    ) {\n      const streamLoader =\n        streamType === \"main\"\n          ? this.mainStreamLoader\n          : this.secondaryStreamLoader;\n\n      streamLoader?.sendBroadcastAnnouncement(isP2PUploadDisabled);\n    }\n  }\n\n  private getUpdatedStreamProperty<K extends keyof DynamicStreamConfig>(\n    propertyName: K,\n    updatedConfig: DynamicCoreConfig,\n    streamType: StreamType,\n  ): DynamicStreamConfig[K] | undefined {\n    const updatedStreamConfig =\n      streamType === \"main\"\n        ? updatedConfig.mainStream\n        : updatedConfig.secondaryStream;\n\n    return updatedStreamConfig?.[propertyName] ?? updatedConfig[propertyName];\n  }\n\n  /**\n   * Adds an event listener for the specified event type on the core event target.\n   *\n   * @param eventName - The name of the event to listen for.\n   * @param listener - The callback function to invoke when the event is fired.\n   */\n  addEventListener<K extends keyof CoreEventMap>(\n    eventName: K,\n    listener: CoreEventMap[K],\n  ) {\n    this.eventTarget.addEventListener(eventName, listener);\n  }\n\n  /**\n   * Removes an event listener for the specified event type on the core event target.\n   *\n   * @param eventName - The name of the event to listen for.\n   * @param listener - The callback function to be removed.\n   */\n  removeEventListener<K extends keyof CoreEventMap>(\n    eventName: K,\n    listener: CoreEventMap[K],\n  ) {\n    this.eventTarget.removeEventListener(eventName, listener);\n  }\n\n  /**\n   * Sets the response URL for the manifest, stripping any query parameters.\n   *\n   * @param url - The full URL to the manifest response.\n   */\n  setManifestResponseUrl(url: string): void {\n    this.manifestResponseUrl = url.split(\"?\")[0];\n  }\n\n  /**\n   * Checks if a segment is already stored within the core.\n   *\n   * @param segmentRuntimeId - The runtime identifier of the segment to check.\n   * @returns `true` if the segment is present, otherwise `false`.\n   */\n  hasSegment(segmentRuntimeId: string): boolean {\n    return !!StreamUtils.getSegmentFromStreamsMap(\n      this.streams,\n      segmentRuntimeId,\n    );\n  }\n\n  /**\n   * Retrieves a specific stream by its runtime identifier, if it exists.\n   *\n   * @param streamRuntimeId - The runtime identifier of the stream to retrieve.\n   * @returns The stream with its segments, or `undefined` if not found.\n   */\n  getStream(streamRuntimeId: string): StreamWithSegments<TStream> | undefined {\n    return this.streams.get(streamRuntimeId);\n  }\n\n  /**\n   * Ensures a stream exists in the map; adds it if it does not.\n   *\n   * @param stream - The stream to potentially add to the map.\n   */\n  addStreamIfNoneExists(stream: TStream): void {\n    if (this.streams.has(stream.runtimeId)) return;\n\n    this.streams.set(stream.runtimeId, {\n      ...stream,\n      segments: new Map<string, SegmentWithStream<TStream>>(),\n    });\n  }\n\n  /**\n   * Updates the segments associated with a specific stream.\n   *\n   * @param streamRuntimeId - The runtime identifier of the stream to update.\n   * @param addSegments - Optional segments to add to the stream.\n   * @param removeSegmentIds - Optional segment IDs to remove from the stream.\n   */\n  updateStream(\n    streamRuntimeId: string,\n    addSegments?: Iterable<Segment>,\n    removeSegmentIds?: Iterable<string>,\n  ): void {\n    const stream = this.streams.get(streamRuntimeId);\n    if (!stream) return;\n\n    if (addSegments) {\n      for (const segment of addSegments) {\n        if (stream.segments.has(segment.runtimeId)) continue; // should not happen\n        stream.segments.set(segment.runtimeId, { ...segment, stream });\n      }\n    }\n\n    if (removeSegmentIds) {\n      for (const id of removeSegmentIds) {\n        stream.segments.delete(id);\n      }\n    }\n\n    this.mainStreamLoader?.updateStream(stream);\n    this.secondaryStreamLoader?.updateStream(stream);\n  }\n\n  /**\n   * Loads a segment given its runtime identifier and invokes the provided callbacks during the process.\n   * Initializes segment storage if it has not been initialized yet.\n   *\n   * @param segmentRuntimeId - The runtime identifier of the segment to load.\n   * @param callbacks - The callbacks to be invoked during segment loading.\n   * @throws {Error} - Throws if the manifest response URL is not defined.\n   */\n  async loadSegment(segmentRuntimeId: string, callbacks: EngineCallbacks) {\n    if (!this.manifestResponseUrl) {\n      throw new Error(\"Manifest response url is not defined\");\n    }\n\n    await this.initializeSegmentStorage();\n\n    const segment = this.identifySegment(segmentRuntimeId);\n\n    const loader = this.getStreamHybridLoader(segment);\n    void loader.loadSegment(segment, callbacks);\n  }\n\n  /**\n   * Aborts the loading of a segment specified by its runtime identifier.\n   *\n   * @param segmentRuntimeId - The runtime identifier of the segment whose loading is to be aborted.\n   */\n  abortSegmentLoading(segmentRuntimeId: string): void {\n    this.mainStreamLoader?.abortSegmentRequest(segmentRuntimeId);\n    this.secondaryStreamLoader?.abortSegmentRequest(segmentRuntimeId);\n  }\n\n  /**\n   * Updates the playback parameters while play head moves, specifically position and playback rate, for stream loaders.\n   *\n   * @param position - The new position in the stream, in seconds.\n   * @param rate - The new playback rate.\n   */\n  updatePlayback(position: number, rate: number): void {\n    this.mainStreamLoader?.updatePlayback(position, rate);\n    this.secondaryStreamLoader?.updatePlayback(position, rate);\n  }\n\n  /**\n   * Sets the active level bitrate, used for adjusting quality levels in adaptive streaming.\n   * Notifies the stream loaders if a change occurs.\n   *\n   * @param bitrate - The new bitrate to set as active.\n   */\n  setActiveLevelBitrate(bitrate: number) {\n    if (bitrate !== this.streamDetails.activeLevelBitrate) {\n      this.streamDetails.activeLevelBitrate = bitrate;\n      this.mainStreamLoader?.notifyLevelChanged();\n      this.secondaryStreamLoader?.notifyLevelChanged();\n    }\n  }\n\n  /**\n   * Updates the 'isLive' status of the stream\n   *\n   * @param isLive - Boolean indicating whether the stream is live.\n   */\n  setIsLive(isLive: boolean) {\n    this.streamDetails.isLive = isLive;\n  }\n\n  /**\n   * Identify if a segment is loadable by the P2P core based on the segment's stream type and configuration.\n   * @param segmentRuntimeId Segment runtime identifier to check.\n   * @returns `true` if the segment is loadable by the P2P core, otherwise `false`.\n   */\n  isSegmentLoadable(segmentRuntimeId: string): boolean {\n    try {\n      const segment = this.identifySegment(segmentRuntimeId);\n\n      if (\n        segment.stream.type === \"main\" &&\n        this.mainStreamConfig.isP2PDisabled\n      ) {\n        return false;\n      }\n\n      if (\n        segment.stream.type === \"secondary\" &&\n        this.secondaryStreamConfig.isP2PDisabled\n      ) {\n        return false;\n      }\n\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Cleans up resources used by the Core instance, including destroying any active stream loaders\n   * and clearing stored segments.\n   */\n  destroy(): void {\n    this.streams.clear();\n    this.mainStreamLoader?.destroy();\n    this.secondaryStreamLoader?.destroy();\n    this.segmentStorage?.destroy();\n    this.mainStreamLoader = undefined;\n    this.secondaryStreamLoader = undefined;\n    this.segmentStorage = undefined;\n    this.manifestResponseUrl = undefined;\n    this.streamDetails = { isLive: false, activeLevelBitrate: 0 };\n    P2PTrackerClient.clearPeerIdCache();\n  }\n\n  private async initializeSegmentStorage() {\n    if (this.segmentStorage) return;\n\n    const { isLive } = this.streamDetails;\n    const createCustomStorage =\n      this.commonCoreConfig.customSegmentStorageFactory;\n\n    if (createCustomStorage && typeof createCustomStorage !== \"function\") {\n      throw new Error(\"Storage configuration is invalid\");\n    }\n\n    const segmentStorage = createCustomStorage\n      ? createCustomStorage(isLive)\n      : new SegmentMemoryStorage();\n\n    await segmentStorage.initialize(\n      this.commonCoreConfig,\n      this.mainStreamConfig,\n      this.secondaryStreamConfig,\n    );\n\n    this.segmentStorage = segmentStorage;\n  }\n\n  private identifySegment(segmentRuntimeId: string): SegmentWithStream {\n    if (!this.manifestResponseUrl) {\n      throw new Error(\"Manifest response url is undefined\");\n    }\n\n    const segment = StreamUtils.getSegmentFromStreamsMap(\n      this.streams,\n      segmentRuntimeId,\n    );\n    if (!segment) {\n      throw new Error(`Not found segment with id: ${segmentRuntimeId}`);\n    }\n\n    return segment;\n  }\n\n  private overrideAllConfigs(\n    dynamicConfig: DynamicCoreConfig,\n    mainStream?: Partial<StreamConfig>,\n    secondaryStream?: Partial<StreamConfig>,\n  ) {\n    overrideConfig(this.commonCoreConfig, dynamicConfig);\n    overrideConfig(this.mainStreamConfig, dynamicConfig);\n    overrideConfig(this.secondaryStreamConfig, dynamicConfig);\n\n    if (mainStream) {\n      overrideConfig(this.mainStreamConfig, mainStream);\n    }\n\n    if (secondaryStream) {\n      overrideConfig(this.secondaryStreamConfig, secondaryStream);\n    }\n  }\n\n  private destroyStreamLoader(streamType: StreamType) {\n    if (streamType === \"main\") {\n      this.mainStreamLoader?.destroy();\n      this.mainStreamLoader = undefined;\n    } else {\n      this.secondaryStreamLoader?.destroy();\n      this.secondaryStreamLoader = undefined;\n    }\n  }\n\n  private getStreamHybridLoader(segment: SegmentWithStream) {\n    if (segment.stream.type === \"main\") {\n      this.mainStreamLoader ??= this.createNewHybridLoader(segment);\n      return this.mainStreamLoader;\n    } else {\n      this.secondaryStreamLoader ??= this.createNewHybridLoader(segment);\n      return this.secondaryStreamLoader;\n    }\n  }\n\n  private createNewHybridLoader(segment: SegmentWithStream) {\n    if (!this.manifestResponseUrl) {\n      throw new Error(\"Manifest response url is not defined\");\n    }\n\n    if (!this.segmentStorage) {\n      throw new Error(\"Segment storage is not initialized\");\n    }\n\n    const streamConfig =\n      segment.stream.type === \"main\"\n        ? this.mainStreamConfig\n        : this.secondaryStreamConfig;\n\n    return new HybridLoader(\n      this.manifestResponseUrl,\n      segment,\n      this.streamDetails,\n      streamConfig,\n      this.bandwidthCalculators,\n      this.segmentStorage,\n      this.eventTarget,\n    );\n  }\n}\n"],"names":["getDefaultExportFromCjs","browser","e","noop","browserExports","ms","require$$0","debug","self","common","exports","process","ReflectApply","ReflectOwnKeys","NumberIsNaN","EventEmitter","eventsModule","once","events","cb","onceModule","global","queueMicrotask","scope","require$$1","TextDecoder","require$$2","data","onerror","errCode","MAX_BUFFERED_AMOUNT","Duplex","err","event","Peer","Debug","ws","HTTPTracker","md5Module","md5","i","encoder","decoder","obj","PeerCommandType","SerializedItem","Serialization.ResizableUint8Array","Serialization.serializeInt","Serialization.serializeSimilarIntArray","Serialization.serializeString","Serialization.SerializedItem","Serialization.deserializeInt","Serialization.deserializeSimilarIntArray","Serialization.deserializeString","Command.isCommandChunk","Command.serializePeerCommand","Utils.getControlledPromise","Command.BinaryCommandChunksJoiner","Command.deserializeCommand","Command.BinaryCommandJoiningError","error","Utils.hexToUtf8","PeerUtil.getStreamHash","LoggerUtils.getStreamString","PeerUtil.generatePeerId","TrackerClient","StreamUtils.getStreamSwarmId","peer","Utils.getRandomItem","StreamUtils.getSegmentFromStreamByExternalId","Request","Utils.joinChunks","StreamUtils.getSegmentAvgDuration","LoggerUtils.getSegmentString","queue","QueueUtils.generateQueue","Utils.shuffleArray","Utils.arrayBackwards","StreamUtils.getSegmentFromStreamsMap"],"mappings":"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","x_google_ignoreList":[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,24,25,26,27,28,29]}