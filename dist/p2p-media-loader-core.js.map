{"version":3,"file":"p2p-media-loader-core.js","sources":["../src/types.ts","../src/http-loader.ts","../../../node_modules/.pnpm/vite-plugin-node-polyfills@0.24.0_rollup@4.53.2_vite@7.2.2_@types+node@24.10.1_terser@5.44.1_yaml@2.8.1_/node_modules/vite-plugin-node-polyfills/shims/process/dist/index.js","../../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js","../../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/common.js","../../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/browser.js","../../../node_modules/.pnpm/events@3.3.0/node_modules/events/events.js","../../../node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js","../../../node_modules/.pnpm/once@1.4.0/node_modules/once/once.js","../../../node_modules/.pnpm/queue-microtask@1.2.3/node_modules/queue-microtask/index.js","../../../node_modules/.pnpm/run-parallel@1.2.0/node_modules/run-parallel/index.js","../../../node_modules/.pnpm/webrtc-polyfill@1.1.10/node_modules/webrtc-polyfill/browser.js","../../../node_modules/.pnpm/events-universal@1.0.1/node_modules/events-universal/default.js","../../../node_modules/.pnpm/fast-fifo@1.3.2/node_modules/fast-fifo/fixed-size.js","../../../node_modules/.pnpm/fast-fifo@1.3.2/node_modules/fast-fifo/index.js","../../../node_modules/.pnpm/text-decoder@1.2.3/node_modules/text-decoder/lib/browser-decoder.js","../../../node_modules/.pnpm/text-decoder@1.2.3/node_modules/text-decoder/index.js","../../../node_modules/.pnpm/streamx@2.23.0/node_modules/streamx/index.js","../../../node_modules/.pnpm/err-code@3.0.1/node_modules/err-code/index.js","../../../node_modules/.pnpm/uint8-util@2.2.5/node_modules/uint8-util/util.js","../../../node_modules/.pnpm/base64-arraybuffer@1.0.2/node_modules/base64-arraybuffer/dist/base64-arraybuffer.es5.js","../../../node_modules/.pnpm/uint8-util@2.2.5/node_modules/uint8-util/browser.js","../../../node_modules/.pnpm/@thaunknown+simple-peer@10.0.12/node_modules/@thaunknown/simple-peer/lite.js","../__vite-browser-external","../../../node_modules/.pnpm/bittorrent-tracker@11.2.2/node_modules/bittorrent-tracker/lib/common.js","../../../node_modules/.pnpm/@thaunknown+simple-websocket@9.1.3_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@thaunknown/simple-websocket/index.js","../../../node_modules/.pnpm/bittorrent-tracker@11.2.2/node_modules/bittorrent-tracker/lib/client/tracker.js","../../../node_modules/.pnpm/bittorrent-tracker@11.2.2/node_modules/bittorrent-tracker/lib/client/websocket-tracker.js","../../../node_modules/.pnpm/bittorrent-tracker@11.2.2/node_modules/bittorrent-tracker/client.js","../../../node_modules/.pnpm/nano-md5@1.0.5/node_modules/nano-md5/md5.js","../src/utils/version.ts","../src/utils/peer.ts","../src/utils/logger.ts","../src/utils/utils.ts","../src/p2p/commands/types.ts","../src/p2p/commands/binary-serialization.ts","../src/p2p/commands/binary-command-creator.ts","../src/p2p/commands/commands.ts","../src/p2p/peer-protocol.ts","../src/p2p/peer.ts","../src/p2p/tracker-client.ts","../src/utils/stream.ts","../src/p2p/loader.ts","../src/p2p/loaders-container.ts","../src/requests/request.ts","../src/requests/request-container.ts","../src/requests/engine-request.ts","../src/utils/queue.ts","../src/hybrid-loader.ts","../src/bandwidth-calculator.ts","../src/segment-storage/utils.ts","../src/segment-storage/segment-memory-storage.ts","../src/utils/event-target.ts","../src/core.ts"],"sourcesContent":["import { SegmentStorage } from \"./segment-storage/index.js\";\n\n/** Represents the types of streams available, either primary (main) or secondary. */\nexport type StreamType = \"main\" | \"secondary\";\n\n/** Represents a range of bytes, used for specifying a segment of data to download. */\nexport type ByteRange = {\n  /** The starting byte index of the range. */\n  start: number;\n  /** The ending byte index of the range. */\n  end: number;\n};\n\n/** Describes a media segment with its unique identifiers, location, and timing information. */\nexport type Segment = {\n  /** A runtime identifier for the segment that includes URL and byte range from its manifest. */\n  readonly runtimeId: string;\n\n  /** An unique identifier of the segment in its stream used for P2P communications: sequence number for HLS or playtime for MPEG-DASH. */\n  readonly externalId: number;\n\n  /** The URL from which the segment can be downloaded. */\n  readonly url: string;\n\n  /** An optional property specifying the range of bytes that represent the segment. */\n  readonly byteRange?: ByteRange;\n\n  /** The start time of the segment in seconds, relative to the beginning of the stream. */\n  readonly startTime: number;\n\n  /** The end time of the segment in seconds, relative to the beginning of the stream. */\n  readonly endTime: number;\n};\n\n/** Extends a Segment with a reference to its associated stream. */\nexport type SegmentWithStream<TStream extends Stream = Stream> = Segment & {\n  readonly stream: StreamWithSegments<TStream>;\n};\n\n/**\n * Represents a stream that includes multiple segments, each associated with the stream.\n * @template TStream Type of the underlying stream data structure.\n */\nexport type StreamWithSegments<TStream extends Stream = Stream> = TStream & {\n  readonly segments: Map<string, SegmentWithStream<TStream>>;\n};\n\n/** Represents a media stream with various defining characteristics. */\nexport type Stream = {\n  /** Runtime identifier of the stream from an engine. */\n  readonly runtimeId: string;\n\n  /** Stream type. */\n  readonly type: StreamType;\n\n  /** Stream index in the manifest. */\n  readonly index: number;\n};\n\n/** Represents a defined Core configuration with specific settings for the main and secondary streams. */\nexport type DefinedCoreConfig = CommonCoreConfig & {\n  /** Configuration for the main stream. */\n  mainStream: StreamConfig;\n  /** Configuration for the secondary stream. */\n  secondaryStream: StreamConfig;\n};\n\n/** Represents a set of properties that can be dynamically modified at runtime. */\nexport type DynamicStreamProperties =\n  | \"highDemandTimeWindow\"\n  | \"httpDownloadTimeWindow\"\n  | \"p2pDownloadTimeWindow\"\n  | \"simultaneousHttpDownloads\"\n  | \"simultaneousP2PDownloads\"\n  | \"webRtcMaxMessageSize\"\n  | \"p2pNotReceivingBytesTimeoutMs\"\n  | \"p2pInactiveLoaderDestroyTimeoutMs\"\n  | \"httpNotReceivingBytesTimeoutMs\"\n  | \"httpErrorRetries\"\n  | \"p2pErrorRetries\"\n  | \"validateP2PSegment\"\n  | \"httpRequestSetup\"\n  | \"isP2PDisabled\"\n  | \"isP2PUploadDisabled\";\n\n/**\n * Represents a dynamically modifiable configuration, allowing updates to selected CoreConfig properties at runtime.\n *\n * @example\n * ```typescript\n * const dynamicConfig: DynamicCoreConfig = {\n *   core: {\n *     cachedSegmentsCount: 200,\n *   },\n *   mainStream: {\n *     swarmId: \"custom swarm ID for video stream\",\n *     p2pDownloadTimeWindow: 6000,\n *   },\n *   secondaryStream: {\n *     swarmId: \"custom swarm ID for audio stream\",\n *     p2pDownloadTimeWindow: 3000,\n *   }\n * };\n * ```\n */\nexport type DynamicCoreConfig = Partial<\n  Pick<CoreConfig, DynamicStreamProperties>\n> &\n  Partial<CommonCoreConfig> & {\n    /** Optional dynamic configuration for the main stream. */\n    mainStream?: DynamicStreamConfig;\n    /** Optional dynamic configuration for the secondary stream. */\n    secondaryStream?: DynamicStreamConfig;\n  };\n\n/** Represents a partial configuration for a stream with dynamic properties. */\nexport type DynamicStreamConfig = Partial<\n  Pick<StreamConfig, DynamicStreamProperties>\n>;\n\n/** Represents the configuration for the Core functionality that is common to all streams. */\nexport type CommonCoreConfig = {\n  /**\n   * Defines the memory storage limit for media segments, in MiB.\n   *\n   * @default\n   * ```typescript\n   * segmentMemoryStorageLimit: undefined\n   * ```\n   *\n   * - When `undefined`, the default limit is determined based on the device type and browser:\n   *    - Desktop: 4096 MiB\n   *    - Android: 2048 MiB\n   *    - iOS: 1024 MiB\n   *    - Android WebView: 1024 MiB\n   *    - iOS WebView: 1024 MiB\n   *\n   */\n  segmentMemoryStorageLimit: number | undefined;\n\n  /**\n   * Optional custom storage factory for the segments storage.\n   *\n   * @default\n   * ```typescript\n   * customSegmentStorageFactory: undefined\n   * ```\n   */\n  customSegmentStorageFactory?: (isLive: boolean) => SegmentStorage;\n};\n\n/**\n * Represents a set of configuration parameters that can be used to override or extend the\n * default configuration settings for a specific stream (main or secondary).\n *\n * @example Configuration for basic video stream\n *\n * ```typescript\n * const config: CoreConfig = {\n *  highDemandTimeWindow: 15,\n *  httpDownloadTimeWindow: 3000,\n *  p2pDownloadTimeWindow: 6000,\n *  swarmId: \"custom swarm ID for video stream\",\n * }\n * ```\n *\n * @example Configuration for advanced video stream\n *\n * ```typescript\n * const config: CoreConfig = {\n *  // Configuration for both streams\n *  highDemandTimeWindow: 20,\n *  httpDownloadTimeWindow: 3000,\n *  p2pDownloadTimeWindow: 6000,\n *  mainStream: {\n *   // Optional configuration for the main stream\n *   swarmId: \"custom swarm ID for video stream\",\n *  },\n *  secondaryStream: {\n *   // Optional configuration for the secondary stream\n *   swarmId: \"custom swarm ID for audio stream\",\n *  },\n *  ```\n */\nexport type CoreConfig = Partial<StreamConfig> &\n  Partial<CommonCoreConfig> & {\n    /** Optional configuration for the main stream. */\n    mainStream?: Partial<StreamConfig>;\n    /** Optional configuration for the secondary stream. */\n    secondaryStream?: Partial<StreamConfig>;\n  };\n\n/** Configuration options for the Core functionality, including network and processing parameters. */\nexport type StreamConfig = {\n  /**\n   * Controls if peer-to-peer upload is disabled for the stream.\n   * If `true`, the stream only downloads segments without uploading to peers.\n   *\n   * @default\n   * ```typescript\n   * isP2PUploadDisabled: false\n   * ```\n   */\n  isP2PUploadDisabled: boolean;\n  /**\n   * Controls whether peer-to-peer functionality is disabled for the stream.\n   *\n   * @default\n   * ```typescript\n   * isP2PDisabled: false\n   * ```\n   */\n  isP2PDisabled: boolean;\n  /**\n   * Defines the duration of the time window, in seconds, during which segments are pre-loaded to ensure smooth playback.\n   * This window helps prioritize the fetching of media segments that are imminent to playback.\n   *\n   * @default\n   * ```typescript\n   * highDemandTimeWindow: 15\n   * ```\n   */\n  highDemandTimeWindow: number;\n\n  /**\n   * Defines the time window, in seconds, for HTTP segment downloads. This property specifies the duration\n   * over which media segments are pre-fetched using HTTP requests.\n   *\n   * For a better P2P ratio, it is recommended to set this `httpDownloadTimeWindow` to be lower than `p2pDownloadTimeWindow`.\n   *\n   * NOTE: This setting only takes effect if there is at least one peer connection and the connected peer\n   * does not have the requested segments available to share via P2P.\n   *\n   * @default\n   * ```typescript\n   * httpDownloadTimeWindow: 3000\n   * ```\n   */\n  httpDownloadTimeWindow: number;\n\n  /**\n   * Defines the time window, in seconds, dedicated to pre-fetching media segments via Peer-to-Peer (P2P) downloads.\n   * This duration determines how much content is downloaded in advance using P2P connections to ensure smooth playback and reduce reliance on HTTP downloads.\n   *\n   * For a better P2P ratio, it is recommended to set this time window to be greater than `httpDownloadTimeWindow` to maximize P2P usage.\n   *\n   * @default\n   * ```typescript\n   * p2pDownloadTimeWindow: 6000\n   * ```\n   */\n  p2pDownloadTimeWindow: number;\n\n  /**\n   * Maximum number of simultaneous HTTP downloads allowed.\n   *\n   * @default\n   * ```typescript\n   * simultaneousHttpDownloads: 2\n   * ```\n   */\n  simultaneousHttpDownloads: number;\n\n  /**\n   * Maximum number of simultaneous P2P downloads allowed.\n   *\n   * @default\n   * ```typescript\n   * simultaneousP2PDownloads: 3\n   * ```\n   */\n  simultaneousP2PDownloads: number;\n\n  /**\n   * Maximum message size for WebRTC communications, in bytes.\n   *\n   * @default\n   * ```typescript\n   * webRtcMaxMessageSize: 64 * 1024 - 1\n   * ```\n   */\n  webRtcMaxMessageSize: number;\n\n  /**\n   * Timeout for not receiving bytes from P2P, in milliseconds.\n   *\n   * @default\n   * ```typescript\n   * p2pNotReceivingBytesTimeoutMs: 2000\n   * ```\n   */\n  p2pNotReceivingBytesTimeoutMs: number;\n\n  /**\n   * Timeout for destroying the P2P loader if inactive, in milliseconds.\n   *\n   * @default\n   * ```typescript\n   * p2pInactiveLoaderDestroyTimeoutMs: 30 * 1000\n   * ```\n   */\n  p2pInactiveLoaderDestroyTimeoutMs: number;\n\n  /**\n   * Timeout for not receiving bytes from HTTP downloads, in milliseconds.\n   *\n   * @default\n   * ```typescript\n   * httpNotReceivingBytesTimeoutMs: 3000\n   * ```\n   */\n  httpNotReceivingBytesTimeoutMs: number;\n\n  /**\n   * Number of retries allowed after an HTTP error.\n   *\n   * @default\n   * ```typescript\n   * httpErrorRetries: 3\n   * ```\n   */\n  httpErrorRetries: number;\n\n  /**\n   * Number of retries allowed after a P2P error.\n   *\n   * @default\n   * ```typescript\n   * p2pErrorRetries: 3\n   * ```\n   */\n  p2pErrorRetries: number;\n\n  /**\n   * List of URLs to the WebTorrent trackers used for announcing and discovering peers (i.e. WebRTC signaling).\n   *\n   * WARNING: In the Safari browser, only the first tracker will be used. Safari has issues with multiple trackers,\n   * leading to problems with sending SDP messages for WebRTC signaling.\n   *\n   * @default\n   * The default trackers used are:\n   * ```typescript\n   * [\n   *   \"wss://tracker.novage.com.ua\",\n   *   \"wss://tracker.webtorrent.dev\",\n   *   \"wss://tracker.openwebtorrent.com\",\n   * ]\n   * ```\n   */\n  announceTrackers: string[];\n\n  /**\n   * Configuration for the RTC layer, used in WebRTC communication.\n   * This configuration specifies the STUN/TURN servers used by WebRTC to establish connections through NATs and firewalls.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/RTCConfiguration\n   *\n   * @default\n   * ```json\n   * {\n   *   \"rtcConfig\": {\n   *     \"iceServers\": [\n   *       { \"urls\": \"stun:stun.l.google.com:19302\" },\n   *       { \"urls\": \"stun:global.stun.twilio.com:3478\" }\n   *     ]\n   *   }\n   * }\n   * ```\n   */\n  rtcConfig: RTCConfiguration;\n\n  /**\n   * Prefix to use for the WebTorrent client version in tracker communications.\n   * If undefined, the default version prefix is used, which is calculated based on the package version.\n   *\n   * @default\n   * ```typescript\n   * trackerClientVersionPrefix: undefined\n   * ```\n   */\n  trackerClientVersionPrefix: string;\n\n  /**\n   * Optional unique identifier for the swarm, used to isolate peer pools by media stream.\n   * If undefined, the URL of the manifest is used as the swarm ID.\n   * @default\n   * ```typescript\n   * swarmId: undefined\n   * ```\n   */\n  swarmId?: string;\n\n  /**\n   * Optional function to validate a P2P segment before fully integrating it into the playback buffer.\n   * @param url URL of the segment to validate.\n   * @param byteRange Optional byte range of the segment.\n   * @param data Downloaded segment data.\n   * @returns A promise that resolves with a boolean indicating if the segment is valid.\n   *\n   * @default\n   * ```typescript\n   * validateP2PSegment: undefined\n   * ```\n   */\n  validateP2PSegment?: (\n    url: string,\n    byteRange: ByteRange | undefined,\n    data: ArrayBuffer,\n  ) => Promise<boolean>;\n\n  /**\n   * Optional function to validate a HTTP segment before fully integrating it into the playback buffer.\n   * @param url URL of the segment to validate.\n   * @param byteRange Optional byte range of the segment.\n   * @param data Downloaded segment data.\n   * @returns A promise that resolves with a boolean indicating if the segment is valid.\n   *\n   * @default\n   * ```typescript\n   * validateHTTPSegment: undefined\n   * ```\n   */\n  validateHTTPSegment?: (\n    url: string,\n    byteRange: ByteRange | undefined,\n    data: ArrayBuffer,\n  ) => Promise<boolean>;\n\n  /**\n   * Optional function to customize the setup of HTTP requests for segment downloads.\n   * @param segmentUrl URL of the segment.\n   * @param segmentByteRange The range of bytes requested for the segment.\n   * @param requestAbortSignal An abort signal to cancel the request if needed.\n   * @param requestByteRange Additional byte range for partial requests, if required.\n   * @returns A promise that resolves with the configured request, or undefined if no customization should be made.\n   *\n   * @default\n   * ```typescript\n   * httpRequestSetup: undefined\n   * ```\n   */\n  httpRequestSetup?: (\n    segmentUrl: string,\n    segmentByteRange: ByteRange | undefined,\n    requestAbortSignal: AbortSignal,\n    requestByteRange: { start: number; end?: number } | undefined,\n  ) => Promise<Request | undefined | null>;\n};\n\n/**\n * Specifies the source of a download within a media streaming context.\n *\n * \"http\" - Indicates that the segment was downloaded using the HTTP protocol.\n *\n * \"p2p\"- Indicates that the segment was downloaded through a peer-to-peer network.\n */\nexport type DownloadSource = \"http\" | \"p2p\";\n\n/** Represents details about a segment event. */\nexport type SegmentStartDetails = {\n  /** The segment that the event is about. */\n  segment: Segment;\n\n  /** The origin of the segment download. */\n  downloadSource: DownloadSource;\n\n  /** The peer ID, if the segment is downloaded from a peer. */\n  peerId: string | undefined;\n};\n\n/** Represents details about a segment error event. */\nexport type SegmentErrorDetails = {\n  /** The error that occurred during the segment download. */\n  error: RequestError;\n\n  /** The segment that the event is about. */\n  segment: Segment;\n\n  /** The source of the download. */\n  downloadSource: DownloadSource;\n\n  /** The peer ID, if the segment was downloaded from a peer. */\n  peerId: string | undefined;\n\n  /** The type of stream that the segment is associated with. */\n  streamType: StreamType;\n};\n\n/** Represents details about a segment abort event. */\nexport type SegmentAbortDetails = {\n  /** The segment that the event is about. */\n  segment: Segment;\n\n  /** The source of the download. */\n  downloadSource: DownloadSource | undefined;\n\n  /** The peer ID, if the segment was downloaded from a peer. */\n  peerId: string | undefined;\n\n  /** The type of stream that the segment is associated with. */\n  streamType: StreamType;\n};\n\n/** Represents the details about a loaded segment. */\nexport type SegmentLoadDetails = {\n  /** The URL of the loaded segment */\n  segmentUrl: string;\n\n  /** The length of the segment in bytes. */\n  bytesLength: number;\n\n  /** The source of the download. */\n  downloadSource: DownloadSource;\n\n  /** The peer ID, if the segment was downloaded from a peer. */\n  peerId: string | undefined;\n\n  /** The segment that the event is about. */\n  streamType: StreamType;\n};\n\n/** Represents the details of a peer in a peer-to-peer network. */\nexport type PeerDetails = {\n  /** The unique identifier for a peer in the network. */\n  peerId: string;\n  /** The type of stream that the peer is connected to. */\n  streamType: StreamType;\n};\n\n/** Represents the details of a peer error event. */\nexport type PeerErrorDetails = {\n  /** The unique identifier for a peer in the network. */\n  peerId: string;\n  /** The type of stream that the peer is connected to. */\n  streamType: StreamType;\n  /** The error that occurred during the peer-to-peer connection. */\n  error: Error;\n};\n\n/** Represents the details of a tracker error event. */\nexport type TrackerErrorDetails = {\n  /** The type of stream that the tracker is for. */\n  streamType: StreamType;\n  /** The error that occurred during the tracker request. */\n  error: unknown;\n};\n\nexport type TrackerWarningDetails = {\n  /** The type of stream that the tracker is for. */\n  streamType: StreamType;\n  /** The warning that occurred during the tracker request. */\n  warning: unknown;\n};\n\n/**\n * The CoreEventMap defines a comprehensive suite of event handlers crucial for monitoring and controlling the lifecycle\n * of segment downloading and uploading processes.\n */\nexport type CoreEventMap = {\n  /**\n   * Invoked when a segment is fully downloaded and available for use.\n   *\n   * @param params - Contains information about the loaded segment.\n   */\n  onSegmentLoaded: (params: SegmentLoadDetails) => void;\n\n  /**\n   * Triggered when an error occurs during the download of a segment.\n   *\n   * @param params - Contains information about the errored segment.\n   */\n  onSegmentError: (params: SegmentErrorDetails) => void;\n\n  /**\n   * Called if the download of a segment is aborted before completion.\n   *\n   * @param params - Contains information about the aborted segment.\n   */\n  onSegmentAbort: (params: SegmentAbortDetails) => void;\n\n  /**\n   * Fired at the beginning of a segment download process.\n   *\n   * @param params - Provides details about the segment being downloaded.\n   */\n  onSegmentStart: (params: SegmentStartDetails) => void;\n\n  /**\n   * Occurs when a new peer-to-peer connection is established.\n   *\n   * @param params - Contains details about the peer that the event is about.\n   */\n  onPeerConnect: (params: PeerDetails) => void;\n\n  /**\n   * Triggered when an existing peer-to-peer connection is closed.\n   *\n   * @param params - Contains details about the peer that the event is about.\n   */\n  onPeerClose: (params: PeerDetails) => void;\n\n  /**\n   * Triggered when an error occurs during a peer-to-peer connection.\n   *\n   * @param params - Contains details about the error and the peer that the event is about.\n   */\n  onPeerError: (params: PeerErrorDetails) => void;\n\n  /**\n   * Invoked after a chunk of data from a segment has been successfully downloaded.\n   *\n   * @param bytesLength - The size of the downloaded chunk in bytes.\n   * @param downloadSource - The source of the download.\n   * @param peerId - The peer ID of the peer that the event is about, if applicable.\n   */\n  onChunkDownloaded: (\n    bytesLength: number,\n    downloadSource: DownloadSource,\n    peerId?: string,\n  ) => void;\n\n  /**\n   * Called when a chunk of data has been successfully uploaded to a peer.\n   *\n   * @param bytesLength - The length of the segment in bytes.\n   * @param peerId - The peer ID, if the segment was downloaded from a peer\n   */\n  onChunkUploaded: (bytesLength: number, peerId: string) => void;\n\n  /**\n   * Called when an error occurs during the tracker request process.\n   *\n   * @param params - Contains information about the tracker error.\n   */\n  onTrackerError: (params: TrackerErrorDetails) => void;\n\n  /**\n   * Called when a warning occurs during the tracker request process.\n   *\n   * @param params - Contains information about the tracker warning.\n   */\n  onTrackerWarning: (params: TrackerWarningDetails) => void;\n};\n\n/** Defines the types of errors that can occur during a request abortion process. */\nexport type RequestAbortErrorType = \"abort\" | \"bytes-receiving-timeout\";\n\n/** Defines the types of errors specific to HTTP requests. */\nexport type HttpRequestErrorType =\n  | \"http-error\"\n  | \"http-bytes-mismatch\"\n  | \"http-unexpected-status-code\"\n  | \"http-segment-validation-failed\";\n\n/** Defines the types of errors specific to peer-to-peer requests. */\nexport type PeerRequestErrorType =\n  | \"peer-response-bytes-length-mismatch\"\n  | \"peer-protocol-violation\"\n  | \"peer-segment-absent\"\n  | \"peer-closed\"\n  | \"p2p-segment-validation-failed\";\n\n/** Enumerates all possible request error types, including HTTP and peer-related errors. */\nexport type RequestErrorType =\n  | RequestAbortErrorType\n  | PeerRequestErrorType\n  | HttpRequestErrorType;\n\n/**\n * Represents an error that can occur during the request process, with a timestamp for when the error occurred.\n * @template T - The specific type of request error.\n */\nexport class RequestError<\n  T extends RequestErrorType = RequestErrorType,\n> extends Error {\n  /** Error timestamp. */\n  readonly timestamp: number;\n\n  /**\n   * Constructs a new RequestError.\n   * @param type - The specific error type.\n   * @param message - Optional message describing the error.\n   */\n  constructor(\n    readonly type: T,\n    message?: string,\n  ) {\n    super(message);\n    this.timestamp = performance.now();\n  }\n}\n\n/** Represents the response from a segment request, including the data and measured bandwidth. */\nexport type SegmentResponse = {\n  /** Segment data as an ArrayBuffer. */\n  data: ArrayBuffer;\n\n  /** Measured bandwidth for the segment download, in bytes per second. */\n  bandwidth: number;\n};\n\n/** Custom error class for errors that occur during core network requests. */\nexport class CoreRequestError extends Error {\n  /**\n   * Constructs a new CoreRequestError.\n   * @param type - The type of the error, either 'failed' or 'aborted'.\n   */\n  constructor(readonly type: \"failed\" | \"aborted\") {\n    super();\n  }\n}\n\n/** Callbacks for handling the success or failure of an engine operation. */\nexport type EngineCallbacks = {\n  /**\n   * Called when the operation is successful.\n   * @param response - The response from the successful operation.\n   */\n  onSuccess: (response: SegmentResponse) => void;\n\n  /**\n   * Called when the operation encounters an error.\n   * @param reason - The error encountered during the operation.\n   */\n  onError: (reason: CoreRequestError) => void;\n};\n","import {\n  CoreConfig,\n  CoreEventMap,\n  RequestError,\n  HttpRequestErrorType,\n} from \"./types.js\";\nimport {\n  Request as SegmentRequest,\n  RequestControls,\n} from \"./requests/request.js\";\nimport { EventTarget } from \"./utils/event-target.js\";\n\ntype HttpConfig = Pick<\n  CoreConfig,\n  \"httpNotReceivingBytesTimeoutMs\" | \"httpRequestSetup\" | \"validateHTTPSegment\"\n>;\n\nexport class HttpRequestExecutor {\n  private readonly requestControls: RequestControls;\n  private readonly abortController = new AbortController();\n  private readonly expectedBytesLength?: number;\n  private readonly requestByteRange?: { start: number; end?: number };\n  private readonly onChunkDownloaded: CoreEventMap[\"onChunkDownloaded\"];\n\n  constructor(\n    private readonly request: SegmentRequest,\n    private readonly httpConfig: HttpConfig,\n    eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    this.onChunkDownloaded =\n      eventTarget.getEventDispatcher(\"onChunkDownloaded\");\n\n    const { byteRange } = this.request.segment;\n    if (byteRange) this.requestByteRange = { ...byteRange };\n\n    if (request.loadedBytes !== 0) {\n      this.requestByteRange = this.requestByteRange ?? { start: 0 };\n      this.requestByteRange.start =\n        this.requestByteRange.start + request.loadedBytes;\n    }\n    if (this.request.totalBytes) {\n      this.expectedBytesLength =\n        this.request.totalBytes - this.request.loadedBytes;\n    }\n\n    this.requestControls = this.request.start(\n      { downloadSource: \"http\" },\n      {\n        abort: () => this.abortController.abort(\"abort\"),\n        notReceivingBytesTimeoutMs:\n          this.httpConfig.httpNotReceivingBytesTimeoutMs,\n      },\n    );\n    void this.fetch();\n  }\n\n  private async fetch() {\n    const { segment } = this.request;\n    try {\n      let request = await this.httpConfig.httpRequestSetup?.(\n        segment.url,\n        segment.byteRange,\n        this.abortController.signal,\n        this.requestByteRange,\n      );\n\n      if (!request) {\n        const headers = new Headers(\n          this.requestByteRange\n            ? {\n                Range: `bytes=${this.requestByteRange.start}-${\n                  this.requestByteRange.end ?? \"\"\n                }`,\n              }\n            : undefined,\n        );\n\n        request = new Request(segment.url, {\n          headers,\n          signal: this.abortController.signal,\n        });\n      }\n\n      if (this.abortController.signal.aborted) {\n        throw new DOMException(\n          \"Request aborted before request fetch\",\n          \"AbortError\",\n        );\n      }\n\n      const response = await window.fetch(request);\n\n      this.handleResponseHeaders(response);\n\n      if (!response.body) return;\n      const { requestControls } = this;\n      requestControls.firstBytesReceived();\n\n      const reader = response.body.getReader();\n      for await (const chunk of readStream(reader)) {\n        this.requestControls.addLoadedChunk(chunk);\n        this.onChunkDownloaded(chunk.byteLength, \"http\");\n      }\n\n      const isValid =\n        (await this.httpConfig.validateHTTPSegment?.(\n          segment.url,\n          segment.byteRange,\n          this.request.data,\n        )) ?? true;\n\n      if (!isValid) {\n        this.request.clearLoadedBytes();\n        throw new RequestError<\"http-segment-validation-failed\">(\n          \"http-segment-validation-failed\",\n        );\n      }\n\n      requestControls.completeOnSuccess();\n    } catch (error) {\n      this.handleError(error);\n    }\n  }\n\n  private handleResponseHeaders(response: Response) {\n    if (!response.ok) {\n      if (response.status === 406) {\n        this.request.clearLoadedBytes();\n        throw new RequestError<\"http-bytes-mismatch\">(\n          \"http-bytes-mismatch\",\n          response.statusText,\n        );\n      } else {\n        throw new RequestError<\"http-error\">(\"http-error\", response.statusText);\n      }\n    }\n\n    const { requestByteRange } = this;\n    if (requestByteRange) {\n      if (response.status === 200) {\n        if (this.request.segment.byteRange) {\n          throw new RequestError(\"http-unexpected-status-code\");\n        } else {\n          this.request.clearLoadedBytes();\n        }\n      } else {\n        if (response.status !== 206) {\n          throw new RequestError(\n            \"http-unexpected-status-code\",\n            response.statusText,\n          );\n        }\n        const contentLengthHeader = response.headers.get(\"Content-Length\");\n        if (\n          contentLengthHeader &&\n          this.expectedBytesLength !== undefined &&\n          this.expectedBytesLength !== +contentLengthHeader\n        ) {\n          this.request.clearLoadedBytes();\n          throw new RequestError(\"http-bytes-mismatch\", response.statusText);\n        }\n\n        const contentRangeHeader = response.headers.get(\"Content-Range\");\n        const contentRange = contentRangeHeader\n          ? parseContentRangeHeader(contentRangeHeader)\n          : undefined;\n        if (contentRange) {\n          const { from, to } = contentRange;\n          const responseExpectedBytesLength =\n            to !== undefined && from !== undefined ? to - from + 1 : undefined;\n\n          if (\n            (responseExpectedBytesLength !== undefined &&\n              this.expectedBytesLength !== responseExpectedBytesLength) ||\n            (from !== undefined && requestByteRange.start !== from) ||\n            (to !== undefined &&\n              requestByteRange.end !== undefined &&\n              requestByteRange.end !== to)\n          ) {\n            this.request.clearLoadedBytes();\n            throw new RequestError(\"http-bytes-mismatch\", response.statusText);\n          }\n        }\n      }\n    }\n\n    if (response.status === 200 && this.request.totalBytes === undefined) {\n      const contentLengthHeader = response.headers.get(\"Content-Length\");\n      if (contentLengthHeader) this.request.setTotalBytes(+contentLengthHeader);\n    }\n  }\n\n  private handleError(error: unknown) {\n    if (error instanceof Error) {\n      if (error.name !== \"abort\") return;\n\n      const httpLoaderError =\n        error instanceof RequestError\n          ? (error as RequestError<HttpRequestErrorType>)\n          : new RequestError(\"http-error\", error.message);\n\n      this.requestControls.abortOnError(httpLoaderError);\n    }\n  }\n}\n\nasync function* readStream(\n  reader: ReadableStreamDefaultReader<Uint8Array>,\n): AsyncGenerator<Uint8Array> {\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) break;\n    yield value;\n  }\n}\n\nconst rangeHeaderRegex = /^bytes (?:(?:(\\d+)|)-(?:(\\d+)|)|\\*)\\/(?:(\\d+)|\\*)$/;\n\nfunction parseContentRangeHeader(headerValue: string) {\n  const match = rangeHeaderRegex.exec(headerValue.trim());\n  if (!match) return;\n\n  const [, from, to, total] = match;\n  return {\n    from: from ? parseInt(from) : undefined,\n    to: to ? parseInt(to) : undefined,\n    total: total ? parseInt(total) : undefined,\n  };\n}\n","function getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar browser = {exports: {}};\n\n// shim for using process in browser\nvar process = browser.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ());\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] };\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\nvar browserExports = browser.exports;\nconst process$1 = /*@__PURE__*/getDefaultExportFromCjs(browserExports);\n\nexport { process$1 as default, process$1 as process };\n//# sourceMappingURL=index.js.map\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '')\n\t\t\t.trim()\n\t\t\t.replace(/\\s+/g, ',')\n\t\t\t.split(',')\n\t\t\t.filter(Boolean);\n\n\t\tfor (const ns of split) {\n\t\t\tif (ns[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(ns.slice(1));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(ns);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the given string matches a namespace template, honoring\n\t * asterisks as wildcards.\n\t *\n\t * @param {String} search\n\t * @param {String} template\n\t * @return {Boolean}\n\t */\n\tfunction matchesTemplate(search, template) {\n\t\tlet searchIndex = 0;\n\t\tlet templateIndex = 0;\n\t\tlet starIndex = -1;\n\t\tlet matchIndex = 0;\n\n\t\twhile (searchIndex < search.length) {\n\t\t\tif (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {\n\t\t\t\t// Match character or proceed with wildcard\n\t\t\t\tif (template[templateIndex] === '*') {\n\t\t\t\t\tstarIndex = templateIndex;\n\t\t\t\t\tmatchIndex = searchIndex;\n\t\t\t\t\ttemplateIndex++; // Skip the '*'\n\t\t\t\t} else {\n\t\t\t\t\tsearchIndex++;\n\t\t\t\t\ttemplateIndex++;\n\t\t\t\t}\n\t\t\t} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition\n\t\t\t\t// Backtrack to the last '*' and try to match more characters\n\t\t\t\ttemplateIndex = starIndex + 1;\n\t\t\t\tmatchIndex++;\n\t\t\t\tsearchIndex = matchIndex;\n\t\t\t} else {\n\t\t\t\treturn false; // No match\n\t\t\t}\n\t\t}\n\n\t\t// Handle trailing '*' in template\n\t\twhile (templateIndex < template.length && template[templateIndex] === '*') {\n\t\t\ttemplateIndex++;\n\t\t}\n\n\t\treturn templateIndex === template.length;\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names,\n\t\t\t...createDebug.skips.map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tfor (const skip of createDebug.skips) {\n\t\t\tif (matchesTemplate(name, skip)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (const ns of createDebug.names) {\n\t\t\tif (matchesTemplate(name, ns)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\tlet m;\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\t// eslint-disable-next-line no-return-assign\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug') || exports.storage.getItem('DEBUG') ;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n","var wrappy = require('wrappy')\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n","/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nlet promise\n\nmodule.exports = typeof queueMicrotask === 'function'\n  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : global)\n  // reuse resolved promise, and allocate it lazily\n  : cb => (promise || (promise = Promise.resolve()))\n    .then(cb)\n    .catch(err => setTimeout(() => { throw err }, 0))\n","/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nmodule.exports = runParallel\n\nconst queueMicrotask = require('queue-microtask')\n\nfunction runParallel (tasks, cb) {\n  let results, pending, keys\n  let isSync = true\n\n  if (Array.isArray(tasks)) {\n    results = []\n    pending = tasks.length\n  } else {\n    keys = Object.keys(tasks)\n    results = {}\n    pending = keys.length\n  }\n\n  function done (err) {\n    function end () {\n      if (cb) cb(err, results)\n      cb = null\n    }\n    if (isSync) queueMicrotask(end)\n    else end()\n  }\n\n  function each (i, err, result) {\n    results[i] = result\n    if (--pending === 0 || err) {\n      done(err)\n    }\n  }\n\n  if (!pending) {\n    // empty\n    done(null)\n  } else if (keys) {\n    // object\n    keys.forEach(function (key) {\n      tasks[key](function (err, result) { each(key, err, result) })\n    })\n  } else {\n    // array\n    tasks.forEach(function (task, i) {\n      task(function (err, result) { each(i, err, result) })\n    })\n  }\n\n  isSync = false\n}\n","const scope = typeof window !== 'undefined' ? window : self\r\n\r\n// @ts-ignore\r\nexport const RTCPeerConnection = scope.RTCPeerConnection || scope.mozRTCPeerConnection || scope.webkitRTCPeerConnection\r\n// @ts-ignore\r\nexport const RTCSessionDescription = scope.RTCSessionDescription || scope.mozRTCSessionDescription || scope.webkitRTCSessionDescription\r\n// @ts-ignore\r\nexport const RTCIceCandidate = scope.RTCIceCandidate || scope.mozRTCIceCandidate || scope.webkitRTCIceCandidate\r\nexport const RTCIceTransport = scope.RTCIceTransport\r\nexport const RTCDataChannel = scope.RTCDataChannel\r\nexport const RTCSctpTransport = scope.RTCSctpTransport\r\nexport const RTCDtlsTransport = scope.RTCDtlsTransport\r\nexport const RTCCertificate = scope.RTCCertificate\r\nexport const MediaStream = scope.MediaStream\r\nexport const MediaStreamTrack = scope.MediaStreamTrack\r\nexport const MediaStreamTrackEvent = scope.MediaStreamTrackEvent\r\nexport const RTCPeerConnectionIceEvent = scope.RTCPeerConnectionIceEvent\r\nexport const RTCDataChannelEvent = scope.RTCDataChannelEvent\r\nexport const RTCTrackEvent = scope.RTCTrackEvent\r\nexport const RTCError = scope.RTCError\r\nexport const RTCErrorEvent = scope.RTCErrorEvent\r\nexport const RTCRtpTransceiver = scope.RTCRtpTransceiver\r\nexport const RTCRtpReceiver = scope.RTCRtpReceiver\r\nexport const RTCRtpSender = scope.RTCRtpSender\r\n\r\nexport * as default from './browser.js'\r\n","module.exports = require('events')\n","module.exports = class FixedFIFO {\n  constructor (hwm) {\n    if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) throw new Error('Max size for a FixedFIFO should be a power of two')\n    this.buffer = new Array(hwm)\n    this.mask = hwm - 1\n    this.top = 0\n    this.btm = 0\n    this.next = null\n  }\n\n  clear () {\n    this.top = this.btm = 0\n    this.next = null\n    this.buffer.fill(undefined)\n  }\n\n  push (data) {\n    if (this.buffer[this.top] !== undefined) return false\n    this.buffer[this.top] = data\n    this.top = (this.top + 1) & this.mask\n    return true\n  }\n\n  shift () {\n    const last = this.buffer[this.btm]\n    if (last === undefined) return undefined\n    this.buffer[this.btm] = undefined\n    this.btm = (this.btm + 1) & this.mask\n    return last\n  }\n\n  peek () {\n    return this.buffer[this.btm]\n  }\n\n  isEmpty () {\n    return this.buffer[this.btm] === undefined\n  }\n}\n","const FixedFIFO = require('./fixed-size')\n\nmodule.exports = class FastFIFO {\n  constructor (hwm) {\n    this.hwm = hwm || 16\n    this.head = new FixedFIFO(this.hwm)\n    this.tail = this.head\n    this.length = 0\n  }\n\n  clear () {\n    this.head = this.tail\n    this.head.clear()\n    this.length = 0\n  }\n\n  push (val) {\n    this.length++\n    if (!this.head.push(val)) {\n      const prev = this.head\n      this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length)\n      this.head.push(val)\n    }\n  }\n\n  shift () {\n    if (this.length !== 0) this.length--\n    const val = this.tail.shift()\n    if (val === undefined && this.tail.next) {\n      const next = this.tail.next\n      this.tail.next = null\n      this.tail = next\n      return this.tail.shift()\n    }\n\n    return val\n  }\n\n  peek () {\n    const val = this.tail.peek()\n    if (val === undefined && this.tail.next) return this.tail.next.peek()\n    return val\n  }\n\n  isEmpty () {\n    return this.length === 0\n  }\n}\n","module.exports = class BrowserDecoder {\n  constructor (encoding) {\n    this.decoder = new TextDecoder(encoding === 'utf16le' ? 'utf16-le' : encoding)\n  }\n\n  get remaining () {\n    return -1\n  }\n\n  decode (data) {\n    return this.decoder.decode(data, { stream: true })\n  }\n\n  flush () {\n    return this.decoder.decode(new Uint8Array(0))\n  }\n}\n","const PassThroughDecoder = require('./lib/pass-through-decoder')\nconst UTF8Decoder = require('./lib/utf8-decoder')\n\nmodule.exports = class TextDecoder {\n  constructor (encoding = 'utf8') {\n    this.encoding = normalizeEncoding(encoding)\n\n    switch (this.encoding) {\n      case 'utf8':\n        this.decoder = new UTF8Decoder()\n        break\n      case 'utf16le':\n      case 'base64':\n        throw new Error('Unsupported encoding: ' + this.encoding)\n      default:\n        this.decoder = new PassThroughDecoder(this.encoding)\n    }\n  }\n\n  get remaining () {\n    return this.decoder.remaining\n  }\n\n  push (data) {\n    if (typeof data === 'string') return data\n    return this.decoder.decode(data)\n  }\n\n  // For Node.js compatibility\n  write (data) {\n    return this.push(data)\n  }\n\n  end (data) {\n    let result = ''\n    if (data) result = this.push(data)\n    result += this.decoder.flush()\n    return result\n  }\n}\n\nfunction normalizeEncoding (encoding) {\n  encoding = encoding.toLowerCase()\n\n  switch (encoding) {\n    case 'utf8':\n    case 'utf-8':\n      return 'utf8'\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return 'utf16le'\n    case 'latin1':\n    case 'binary':\n      return 'latin1'\n    case 'base64':\n    case 'ascii':\n    case 'hex':\n      return encoding\n    default:\n      throw new Error('Unknown encoding: ' + encoding)\n  }\n};\n","const { EventEmitter } = require('events-universal')\nconst STREAM_DESTROYED = new Error('Stream was destroyed')\nconst PREMATURE_CLOSE = new Error('Premature close')\n\nconst FIFO = require('fast-fifo')\nconst TextDecoder = require('text-decoder')\n\n// if we do a future major, expect queue microtask to be there always, for now a bit defensive\nconst qmt = typeof queueMicrotask === 'undefined' ? fn => global.process.nextTick(fn) : queueMicrotask\n\n/* eslint-disable no-multi-spaces */\n\n// 29 bits used total (4 from shared, 14 from read, and 11 from write)\nconst MAX = ((1 << 29) - 1)\n\n// Shared state\nconst OPENING       = 0b0001\nconst PREDESTROYING = 0b0010\nconst DESTROYING    = 0b0100\nconst DESTROYED     = 0b1000\n\nconst NOT_OPENING = MAX ^ OPENING\nconst NOT_PREDESTROYING = MAX ^ PREDESTROYING\n\n// Read state (4 bit offset from shared state)\nconst READ_ACTIVE           = 0b00000000000001 << 4\nconst READ_UPDATING         = 0b00000000000010 << 4\nconst READ_PRIMARY          = 0b00000000000100 << 4\nconst READ_QUEUED           = 0b00000000001000 << 4\nconst READ_RESUMED          = 0b00000000010000 << 4\nconst READ_PIPE_DRAINED     = 0b00000000100000 << 4\nconst READ_ENDING           = 0b00000001000000 << 4\nconst READ_EMIT_DATA        = 0b00000010000000 << 4\nconst READ_EMIT_READABLE    = 0b00000100000000 << 4\nconst READ_EMITTED_READABLE = 0b00001000000000 << 4\nconst READ_DONE             = 0b00010000000000 << 4\nconst READ_NEXT_TICK        = 0b00100000000000 << 4\nconst READ_NEEDS_PUSH       = 0b01000000000000 << 4\nconst READ_READ_AHEAD       = 0b10000000000000 << 4\n\n// Combined read state\nconst READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED\nconst READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH\nconst READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE\nconst READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED\nconst READ_RESUMED_READ_AHEAD = READ_RESUMED | READ_READ_AHEAD\n\nconst READ_NOT_ACTIVE             = MAX ^ READ_ACTIVE\nconst READ_NON_PRIMARY            = MAX ^ READ_PRIMARY\nconst READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH)\nconst READ_PUSHED                 = MAX ^ READ_NEEDS_PUSH\nconst READ_PAUSED                 = MAX ^ READ_RESUMED\nconst READ_NOT_QUEUED             = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE)\nconst READ_NOT_ENDING             = MAX ^ READ_ENDING\nconst READ_PIPE_NOT_DRAINED       = MAX ^ READ_FLOWING\nconst READ_NOT_NEXT_TICK          = MAX ^ READ_NEXT_TICK\nconst READ_NOT_UPDATING           = MAX ^ READ_UPDATING\nconst READ_NO_READ_AHEAD          = MAX ^ READ_READ_AHEAD\nconst READ_PAUSED_NO_READ_AHEAD   = MAX ^ READ_RESUMED_READ_AHEAD\n\n// Write state (18 bit offset, 4 bit offset from shared state and 14 from read state)\nconst WRITE_ACTIVE     = 0b00000000001 << 18\nconst WRITE_UPDATING   = 0b00000000010 << 18\nconst WRITE_PRIMARY    = 0b00000000100 << 18\nconst WRITE_QUEUED     = 0b00000001000 << 18\nconst WRITE_UNDRAINED  = 0b00000010000 << 18\nconst WRITE_DONE       = 0b00000100000 << 18\nconst WRITE_EMIT_DRAIN = 0b00001000000 << 18\nconst WRITE_NEXT_TICK  = 0b00010000000 << 18\nconst WRITE_WRITING    = 0b00100000000 << 18\nconst WRITE_FINISHING  = 0b01000000000 << 18\nconst WRITE_CORKED     = 0b10000000000 << 18\n\nconst WRITE_NOT_ACTIVE    = MAX ^ (WRITE_ACTIVE | WRITE_WRITING)\nconst WRITE_NON_PRIMARY   = MAX ^ WRITE_PRIMARY\nconst WRITE_NOT_FINISHING = MAX ^ (WRITE_ACTIVE | WRITE_FINISHING)\nconst WRITE_DRAINED       = MAX ^ WRITE_UNDRAINED\nconst WRITE_NOT_QUEUED    = MAX ^ WRITE_QUEUED\nconst WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK\nconst WRITE_NOT_UPDATING  = MAX ^ WRITE_UPDATING\nconst WRITE_NOT_CORKED    = MAX ^ WRITE_CORKED\n\n// Combined shared state\nconst ACTIVE = READ_ACTIVE | WRITE_ACTIVE\nconst NOT_ACTIVE = MAX ^ ACTIVE\nconst DONE = READ_DONE | WRITE_DONE\nconst DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING\nconst OPEN_STATUS = DESTROY_STATUS | OPENING\nconst AUTO_DESTROY = DESTROY_STATUS | DONE\nconst NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY\nconst ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK\nconst TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE\nconst IS_OPENING = OPEN_STATUS | TICKING\n\n// Combined shared state and read state\nconst READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE\nconst READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED\nconst READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED\nconst READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE\nconst SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH | READ_READ_AHEAD\nconst READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE\nconst READ_UPDATE_SYNC_STATUS = READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY\nconst READ_NEXT_TICK_OR_OPENING = READ_NEXT_TICK | OPENING\n\n// Combined write state\nconst WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED\nconst WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE\nconst WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE\nconst WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED | WRITE_CORKED\nconst WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE\nconst WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING\nconst WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE\nconst WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_UPDATE_SYNC_STATUS = WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY\nconst WRITE_DROP_DATA = WRITE_FINISHING | WRITE_DONE | DESTROY_STATUS\n\nconst asyncIterator = Symbol.asyncIterator || Symbol('asyncIterator')\n\nclass WritableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapWritable, byteLength, byteLengthWritable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark\n    this.buffered = 0\n    this.error = null\n    this.pipeline = null\n    this.drains = null // if we add more seldomly used helpers we might them into a subobject so its a single ptr\n    this.byteLength = byteLengthWritable || byteLength || defaultByteLength\n    this.map = mapWritable || map\n    this.afterWrite = afterWrite.bind(this)\n    this.afterUpdateNextTick = updateWriteNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & WRITE_DONE) !== 0\n  }\n\n  push (data) {\n    if ((this.stream._duplexState & WRITE_DROP_DATA) !== 0) return false\n    if (this.map !== null) data = this.map(data)\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    if (this.buffered < this.highWaterMark) {\n      this.stream._duplexState |= WRITE_QUEUED\n      return true\n    }\n\n    this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED\n    return false\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= WRITE_NOT_QUEUED\n\n    return data\n  }\n\n  end (data) {\n    if (typeof data === 'function') this.stream.once('finish', data)\n    else if (data !== undefined && data !== null) this.push(data)\n    this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY\n  }\n\n  autoBatch (data, cb) {\n    const buffer = []\n    const stream = this.stream\n\n    buffer.push(data)\n    while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {\n      buffer.push(stream._writableState.shift())\n    }\n\n    if ((stream._duplexState & OPEN_STATUS) !== 0) return cb(null)\n    stream._writev(buffer, cb)\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= WRITE_UPDATING\n\n    do {\n      while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {\n        const data = this.shift()\n        stream._duplexState |= WRITE_ACTIVE_AND_WRITING\n        stream._write(data, this.afterWrite)\n      }\n\n      if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= WRITE_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {\n      stream._duplexState = stream._duplexState | WRITE_ACTIVE\n      stream._final(afterFinal.bind(this))\n      return\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= WRITE_NEXT_TICK\n    if ((this.stream._duplexState & WRITE_UPDATING) === 0) qmt(this.afterUpdateNextTick)\n  }\n}\n\nclass ReadableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapReadable, byteLength, byteLengthReadable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark\n    this.buffered = 0\n    this.readAhead = highWaterMark > 0\n    this.error = null\n    this.pipeline = null\n    this.byteLength = byteLengthReadable || byteLength || defaultByteLength\n    this.map = mapReadable || map\n    this.pipeTo = null\n    this.afterRead = afterRead.bind(this)\n    this.afterUpdateNextTick = updateReadNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & READ_DONE) !== 0\n  }\n\n  pipe (pipeTo, cb) {\n    if (this.pipeTo !== null) throw new Error('Can only pipe to one destination')\n    if (typeof cb !== 'function') cb = null\n\n    this.stream._duplexState |= READ_PIPE_DRAINED\n    this.pipeTo = pipeTo\n    this.pipeline = new Pipeline(this.stream, pipeTo, cb)\n\n    if (cb) this.stream.on('error', noop) // We already error handle this so supress crashes\n\n    if (isStreamx(pipeTo)) {\n      pipeTo._writableState.pipeline = this.pipeline\n      if (cb) pipeTo.on('error', noop) // We already error handle this so supress crashes\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline)) // TODO: just call finished from pipeTo itself\n    } else {\n      const onerror = this.pipeline.done.bind(this.pipeline, pipeTo)\n      const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null) // onclose has a weird bool arg\n      pipeTo.on('error', onerror)\n      pipeTo.on('close', onclose)\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline))\n    }\n\n    pipeTo.on('drain', afterDrain.bind(this))\n    this.stream.emit('piping', pipeTo)\n    pipeTo.emit('pipe', this.stream)\n  }\n\n  push (data) {\n    const stream = this.stream\n\n    if (data === null) {\n      this.highWaterMark = 0\n      stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED\n      return false\n    }\n\n    if (this.map !== null) {\n      data = this.map(data)\n      if (data === null) {\n        stream._duplexState &= READ_PUSHED\n        return this.buffered < this.highWaterMark\n      }\n    }\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED\n\n    return this.buffered < this.highWaterMark\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= READ_NOT_QUEUED\n    return data\n  }\n\n  unshift (data) {\n    const pending = [this.map !== null ? this.map(data) : data]\n    while (this.buffered > 0) pending.push(this.shift())\n\n    for (let i = 0; i < pending.length - 1; i++) {\n      const data = pending[i]\n      this.buffered += this.byteLength(data)\n      this.queue.push(data)\n    }\n\n    this.push(pending[pending.length - 1])\n  }\n\n  read () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n      return data\n    }\n\n    if (this.readAhead === false) {\n      stream._duplexState |= READ_READ_AHEAD\n      this.updateNextTick()\n    }\n\n    return null\n  }\n\n  drain () {\n    const stream = this.stream\n\n    while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n    }\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= READ_UPDATING\n\n    do {\n      this.drain()\n\n      while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === READ_READ_AHEAD) {\n        stream._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH\n        stream._read(this.afterRead)\n        this.drain()\n      }\n\n      if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {\n        stream._duplexState |= READ_EMITTED_READABLE\n        stream.emit('readable')\n      }\n\n      if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= READ_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {\n      stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING\n      stream.emit('end')\n      if ((stream._duplexState & AUTO_DESTROY) === DONE) stream._duplexState |= DESTROYING\n      if (this.pipeTo !== null) this.pipeTo.end()\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTickIfOpen () {\n    if ((this.stream._duplexState & READ_NEXT_TICK_OR_OPENING) !== 0) return\n    this.stream._duplexState |= READ_NEXT_TICK\n    if ((this.stream._duplexState & READ_UPDATING) === 0) qmt(this.afterUpdateNextTick)\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= READ_NEXT_TICK\n    if ((this.stream._duplexState & READ_UPDATING) === 0) qmt(this.afterUpdateNextTick)\n  }\n}\n\nclass TransformState {\n  constructor (stream) {\n    this.data = null\n    this.afterTransform = afterTransform.bind(stream)\n    this.afterFinal = null\n  }\n}\n\nclass Pipeline {\n  constructor (src, dst, cb) {\n    this.from = src\n    this.to = dst\n    this.afterPipe = cb\n    this.error = null\n    this.pipeToFinished = false\n  }\n\n  finished () {\n    this.pipeToFinished = true\n  }\n\n  done (stream, err) {\n    if (err) this.error = err\n\n    if (stream === this.to) {\n      this.to = null\n\n      if (this.from !== null) {\n        if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {\n          this.from.destroy(this.error || new Error('Writable stream closed prematurely'))\n        }\n        return\n      }\n    }\n\n    if (stream === this.from) {\n      this.from = null\n\n      if (this.to !== null) {\n        if ((stream._duplexState & READ_DONE) === 0) {\n          this.to.destroy(this.error || new Error('Readable stream closed before ending'))\n        }\n        return\n      }\n    }\n\n    if (this.afterPipe !== null) this.afterPipe(this.error)\n    this.to = this.from = this.afterPipe = null\n  }\n}\n\nfunction afterDrain () {\n  this.stream._duplexState |= READ_PIPE_DRAINED\n  this.updateCallback()\n}\n\nfunction afterFinal (err) {\n  const stream = this.stream\n  if (err) stream.destroy(err)\n  if ((stream._duplexState & DESTROY_STATUS) === 0) {\n    stream._duplexState |= WRITE_DONE\n    stream.emit('finish')\n  }\n  if ((stream._duplexState & AUTO_DESTROY) === DONE) {\n    stream._duplexState |= DESTROYING\n  }\n\n  stream._duplexState &= WRITE_NOT_FINISHING\n\n  // no need to wait the extra tick here, so we short circuit that\n  if ((stream._duplexState & WRITE_UPDATING) === 0) this.update()\n  else this.updateNextTick()\n}\n\nfunction afterDestroy (err) {\n  const stream = this.stream\n\n  if (!err && this.error !== STREAM_DESTROYED) err = this.error\n  if (err) stream.emit('error', err)\n  stream._duplexState |= DESTROYED\n  stream.emit('close')\n\n  const rs = stream._readableState\n  const ws = stream._writableState\n\n  if (rs !== null && rs.pipeline !== null) rs.pipeline.done(stream, err)\n\n  if (ws !== null) {\n    while (ws.drains !== null && ws.drains.length > 0) ws.drains.shift().resolve(false)\n    if (ws.pipeline !== null) ws.pipeline.done(stream, err)\n  }\n}\n\nfunction afterWrite (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n  stream._duplexState &= WRITE_NOT_ACTIVE\n\n  if (this.drains !== null) tickDrains(this.drains)\n\n  if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {\n    stream._duplexState &= WRITE_DRAINED\n    if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {\n      stream.emit('drain')\n    }\n  }\n\n  this.updateCallback()\n}\n\nfunction afterRead (err) {\n  if (err) this.stream.destroy(err)\n  this.stream._duplexState &= READ_NOT_ACTIVE\n  if (this.readAhead === false && (this.stream._duplexState & READ_RESUMED) === 0) this.stream._duplexState &= READ_NO_READ_AHEAD\n  this.updateCallback()\n}\n\nfunction updateReadNT () {\n  if ((this.stream._duplexState & READ_UPDATING) === 0) {\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction updateWriteNT () {\n  if ((this.stream._duplexState & WRITE_UPDATING) === 0) {\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction tickDrains (drains) {\n  for (let i = 0; i < drains.length; i++) {\n    // drains.writes are monotonic, so if one is 0 its always the first one\n    if (--drains[i].writes === 0) {\n      drains.shift().resolve(true)\n      i--\n    }\n  }\n}\n\nfunction afterOpen (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n\n  if ((stream._duplexState & DESTROYING) === 0) {\n    if ((stream._duplexState & READ_PRIMARY_STATUS) === 0) stream._duplexState |= READ_PRIMARY\n    if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0) stream._duplexState |= WRITE_PRIMARY\n    stream.emit('open')\n  }\n\n  stream._duplexState &= NOT_ACTIVE\n\n  if (stream._writableState !== null) {\n    stream._writableState.updateCallback()\n  }\n\n  if (stream._readableState !== null) {\n    stream._readableState.updateCallback()\n  }\n}\n\nfunction afterTransform (err, data) {\n  if (data !== undefined && data !== null) this.push(data)\n  this._writableState.afterWrite(err)\n}\n\nfunction newListener (name) {\n  if (this._readableState !== null) {\n    if (name === 'data') {\n      this._duplexState |= (READ_EMIT_DATA | READ_RESUMED_READ_AHEAD)\n      this._readableState.updateNextTick()\n    }\n    if (name === 'readable') {\n      this._duplexState |= READ_EMIT_READABLE\n      this._readableState.updateNextTick()\n    }\n  }\n\n  if (this._writableState !== null) {\n    if (name === 'drain') {\n      this._duplexState |= WRITE_EMIT_DRAIN\n      this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Stream extends EventEmitter {\n  constructor (opts) {\n    super()\n\n    this._duplexState = 0\n    this._readableState = null\n    this._writableState = null\n\n    if (opts) {\n      if (opts.open) this._open = opts.open\n      if (opts.destroy) this._destroy = opts.destroy\n      if (opts.predestroy) this._predestroy = opts.predestroy\n      if (opts.signal) {\n        opts.signal.addEventListener('abort', abort.bind(this))\n      }\n    }\n\n    this.on('newListener', newListener)\n  }\n\n  _open (cb) {\n    cb(null)\n  }\n\n  _destroy (cb) {\n    cb(null)\n  }\n\n  _predestroy () {\n    // does nothing\n  }\n\n  get readable () {\n    return this._readableState !== null ? true : undefined\n  }\n\n  get writable () {\n    return this._writableState !== null ? true : undefined\n  }\n\n  get destroyed () {\n    return (this._duplexState & DESTROYED) !== 0\n  }\n\n  get destroying () {\n    return (this._duplexState & DESTROY_STATUS) !== 0\n  }\n\n  destroy (err) {\n    if ((this._duplexState & DESTROY_STATUS) === 0) {\n      if (!err) err = STREAM_DESTROYED\n      this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY\n\n      if (this._readableState !== null) {\n        this._readableState.highWaterMark = 0\n        this._readableState.error = err\n      }\n      if (this._writableState !== null) {\n        this._writableState.highWaterMark = 0\n        this._writableState.error = err\n      }\n\n      this._duplexState |= PREDESTROYING\n      this._predestroy()\n      this._duplexState &= NOT_PREDESTROYING\n\n      if (this._readableState !== null) this._readableState.updateNextTick()\n      if (this._writableState !== null) this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Readable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | WRITE_DONE | READ_READ_AHEAD\n    this._readableState = new ReadableState(this, opts)\n\n    if (opts) {\n      if (this._readableState.readAhead === false) this._duplexState &= READ_NO_READ_AHEAD\n      if (opts.read) this._read = opts.read\n      if (opts.eagerOpen) this._readableState.updateNextTick()\n      if (opts.encoding) this.setEncoding(opts.encoding)\n    }\n  }\n\n  setEncoding (encoding) {\n    const dec = new TextDecoder(encoding)\n    const map = this._readableState.map || echo\n    this._readableState.map = mapOrSkip\n    return this\n\n    function mapOrSkip (data) {\n      const next = dec.push(data)\n      return next === '' && (data.byteLength !== 0 || dec.remaining > 0) ? null : map(next)\n    }\n  }\n\n  _read (cb) {\n    cb(null)\n  }\n\n  pipe (dest, cb) {\n    this._readableState.updateNextTick()\n    this._readableState.pipe(dest, cb)\n    return dest\n  }\n\n  read () {\n    this._readableState.updateNextTick()\n    return this._readableState.read()\n  }\n\n  push (data) {\n    this._readableState.updateNextTickIfOpen()\n    return this._readableState.push(data)\n  }\n\n  unshift (data) {\n    this._readableState.updateNextTickIfOpen()\n    return this._readableState.unshift(data)\n  }\n\n  resume () {\n    this._duplexState |= READ_RESUMED_READ_AHEAD\n    this._readableState.updateNextTick()\n    return this\n  }\n\n  pause () {\n    this._duplexState &= (this._readableState.readAhead === false ? READ_PAUSED_NO_READ_AHEAD : READ_PAUSED)\n    return this\n  }\n\n  static _fromAsyncIterator (ite, opts) {\n    let destroy\n\n    const rs = new Readable({\n      ...opts,\n      read (cb) {\n        ite.next().then(push).then(cb.bind(null, null)).catch(cb)\n      },\n      predestroy () {\n        destroy = ite.return()\n      },\n      destroy (cb) {\n        if (!destroy) return cb(null)\n        destroy.then(cb.bind(null, null)).catch(cb)\n      }\n    })\n\n    return rs\n\n    function push (data) {\n      if (data.done) rs.push(null)\n      else rs.push(data.value)\n    }\n  }\n\n  static from (data, opts) {\n    if (isReadStreamx(data)) return data\n    if (data[asyncIterator]) return this._fromAsyncIterator(data[asyncIterator](), opts)\n    if (!Array.isArray(data)) data = data === undefined ? [] : [data]\n\n    let i = 0\n    return new Readable({\n      ...opts,\n      read (cb) {\n        this.push(i === data.length ? null : data[i++])\n        cb(null)\n      }\n    })\n  }\n\n  static isBackpressured (rs) {\n    return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark\n  }\n\n  static isPaused (rs) {\n    return (rs._duplexState & READ_RESUMED) === 0\n  }\n\n  [asyncIterator] () {\n    const stream = this\n\n    let error = null\n    let promiseResolve = null\n    let promiseReject = null\n\n    this.on('error', (err) => { error = err })\n    this.on('readable', onreadable)\n    this.on('close', onclose)\n\n    return {\n      [asyncIterator] () {\n        return this\n      },\n      next () {\n        return new Promise(function (resolve, reject) {\n          promiseResolve = resolve\n          promiseReject = reject\n          const data = stream.read()\n          if (data !== null) ondata(data)\n          else if ((stream._duplexState & DESTROYED) !== 0) ondata(null)\n        })\n      },\n      return () {\n        return destroy(null)\n      },\n      throw (err) {\n        return destroy(err)\n      }\n    }\n\n    function onreadable () {\n      if (promiseResolve !== null) ondata(stream.read())\n    }\n\n    function onclose () {\n      if (promiseResolve !== null) ondata(null)\n    }\n\n    function ondata (data) {\n      if (promiseReject === null) return\n      if (error) promiseReject(error)\n      else if (data === null && (stream._duplexState & READ_DONE) === 0) promiseReject(STREAM_DESTROYED)\n      else promiseResolve({ value: data, done: data === null })\n      promiseReject = promiseResolve = null\n    }\n\n    function destroy (err) {\n      stream.destroy(err)\n      return new Promise((resolve, reject) => {\n        if (stream._duplexState & DESTROYED) return resolve({ value: undefined, done: true })\n        stream.once('close', function () {\n          if (err) reject(err)\n          else resolve({ value: undefined, done: true })\n        })\n      })\n    }\n  }\n}\n\nclass Writable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | READ_DONE\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n      if (opts.eagerOpen) this._writableState.updateNextTick()\n    }\n  }\n\n  cork () {\n    this._duplexState |= WRITE_CORKED\n  }\n\n  uncork () {\n    this._duplexState &= WRITE_NOT_CORKED\n    this._writableState.updateNextTick()\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  static isBackpressured (ws) {\n    return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0\n  }\n\n  static drained (ws) {\n    if (ws.destroyed) return Promise.resolve(false)\n    const state = ws._writableState\n    const pending = (isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length)\n    const writes = pending + ((ws._duplexState & WRITE_WRITING) ? 1 : 0)\n    if (writes === 0) return Promise.resolve(true)\n    if (state.drains === null) state.drains = []\n    return new Promise((resolve) => {\n      state.drains.push({ writes, resolve })\n    })\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Duplex extends Readable { // and Writable\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState = OPENING | (this._duplexState & READ_READ_AHEAD)\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n    }\n  }\n\n  cork () {\n    this._duplexState |= WRITE_CORKED\n  }\n\n  uncork () {\n    this._duplexState &= WRITE_NOT_CORKED\n    this._writableState.updateNextTick()\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Transform extends Duplex {\n  constructor (opts) {\n    super(opts)\n    this._transformState = new TransformState(this)\n\n    if (opts) {\n      if (opts.transform) this._transform = opts.transform\n      if (opts.flush) this._flush = opts.flush\n    }\n  }\n\n  _write (data, cb) {\n    if (this._readableState.buffered >= this._readableState.highWaterMark) {\n      this._transformState.data = data\n    } else {\n      this._transform(data, this._transformState.afterTransform)\n    }\n  }\n\n  _read (cb) {\n    if (this._transformState.data !== null) {\n      const data = this._transformState.data\n      this._transformState.data = null\n      cb(null)\n      this._transform(data, this._transformState.afterTransform)\n    } else {\n      cb(null)\n    }\n  }\n\n  destroy (err) {\n    super.destroy(err)\n    if (this._transformState.data !== null) {\n      this._transformState.data = null\n      this._transformState.afterTransform()\n    }\n  }\n\n  _transform (data, cb) {\n    cb(null, data)\n  }\n\n  _flush (cb) {\n    cb(null)\n  }\n\n  _final (cb) {\n    this._transformState.afterFinal = cb\n    this._flush(transformAfterFlush.bind(this))\n  }\n}\n\nclass PassThrough extends Transform {}\n\nfunction transformAfterFlush (err, data) {\n  const cb = this._transformState.afterFinal\n  if (err) return cb(err)\n  if (data !== null && data !== undefined) this.push(data)\n  this.push(null)\n  cb(null)\n}\n\nfunction pipelinePromise (...streams) {\n  return new Promise((resolve, reject) => {\n    return pipeline(...streams, (err) => {\n      if (err) return reject(err)\n      resolve()\n    })\n  })\n}\n\nfunction pipeline (stream, ...streams) {\n  const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams]\n  const done = (all.length && typeof all[all.length - 1] === 'function') ? all.pop() : null\n\n  if (all.length < 2) throw new Error('Pipeline requires at least 2 streams')\n\n  let src = all[0]\n  let dest = null\n  let error = null\n\n  for (let i = 1; i < all.length; i++) {\n    dest = all[i]\n\n    if (isStreamx(src)) {\n      src.pipe(dest, onerror)\n    } else {\n      errorHandle(src, true, i > 1, onerror)\n      src.pipe(dest)\n    }\n\n    src = dest\n  }\n\n  if (done) {\n    let fin = false\n\n    const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy)\n\n    dest.on('error', (err) => {\n      if (error === null) error = err\n    })\n\n    dest.on('finish', () => {\n      fin = true\n      if (!autoDestroy) done(error)\n    })\n\n    if (autoDestroy) {\n      dest.on('close', () => done(error || (fin ? null : PREMATURE_CLOSE)))\n    }\n  }\n\n  return dest\n\n  function errorHandle (s, rd, wr, onerror) {\n    s.on('error', onerror)\n    s.on('close', onclose)\n\n    function onclose () {\n      if (rd && s._readableState && !s._readableState.ended) return onerror(PREMATURE_CLOSE)\n      if (wr && s._writableState && !s._writableState.ended) return onerror(PREMATURE_CLOSE)\n    }\n  }\n\n  function onerror (err) {\n    if (!err || error) return\n    error = err\n\n    for (const s of all) {\n      s.destroy(err)\n    }\n  }\n}\n\nfunction echo (s) {\n  return s\n}\n\nfunction isStream (stream) {\n  return !!stream._readableState || !!stream._writableState\n}\n\nfunction isStreamx (stream) {\n  return typeof stream._duplexState === 'number' && isStream(stream)\n}\n\nfunction isEnded (stream) {\n  return !!stream._readableState && stream._readableState.ended\n}\n\nfunction isFinished (stream) {\n  return !!stream._writableState && stream._writableState.ended\n}\n\nfunction getStreamError (stream, opts = {}) {\n  const err = (stream._readableState && stream._readableState.error) || (stream._writableState && stream._writableState.error)\n\n  // avoid implicit errors by default\n  return (!opts.all && err === STREAM_DESTROYED) ? null : err\n}\n\nfunction isReadStreamx (stream) {\n  return isStreamx(stream) && stream.readable\n}\n\nfunction isDisturbed (stream) {\n  return (stream._duplexState & OPENING) !== OPENING || (stream._duplexState & ACTIVE_OR_TICKING) !== 0\n}\n\nfunction isTypedArray (data) {\n  return typeof data === 'object' && data !== null && typeof data.byteLength === 'number'\n}\n\nfunction defaultByteLength (data) {\n  return isTypedArray(data) ? data.byteLength : 1024\n}\n\nfunction noop () {}\n\nfunction abort () {\n  this.destroy(new Error('Stream aborted.'))\n}\n\nfunction isWritev (s) {\n  return s._writev !== Writable.prototype._writev && s._writev !== Duplex.prototype._writev\n}\n\nmodule.exports = {\n  pipeline,\n  pipelinePromise,\n  isStream,\n  isStreamx,\n  isEnded,\n  isFinished,\n  isDisturbed,\n  getStreamError,\n  Stream,\n  Writable,\n  Readable,\n  Duplex,\n  Transform,\n  // Export PassThrough for compatibility with Node.js core's stream module\n  PassThrough\n}\n","'use strict';\n\n/**\n * @typedef {{ [key: string]: any }} Extensions\n * @typedef {Error} Err\n * @property {string} message\n */\n\n/**\n *\n * @param {Error} obj\n * @param {Extensions} props\n * @returns {Error & Extensions}\n */\nfunction assign(obj, props) {\n    for (const key in props) {\n        Object.defineProperty(obj, key, {\n            value: props[key],\n            enumerable: true,\n            configurable: true,\n        });\n    }\n\n    return obj;\n}\n\n/**\n *\n * @param {any} err - An Error\n * @param {string|Extensions} code - A string code or props to set on the error\n * @param {Extensions} [props] - Props to set on the error\n * @returns {Error & Extensions}\n */\nfunction createError(err, code, props) {\n    if (!err || typeof err === 'string') {\n        throw new TypeError('Please pass an Error to err-code');\n    }\n\n    if (!props) {\n        props = {};\n    }\n\n    if (typeof code === 'object') {\n        props = code;\n        code = '';\n    }\n\n    if (code) {\n        props.code = code;\n    }\n\n    try {\n        return assign(err, props);\n    } catch (_) {\n        props.message = err.message;\n        props.stack = err.stack;\n\n        const ErrClass = function () {};\n\n        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));\n\n        // @ts-ignore\n        const output = assign(new ErrClass(), props);\n\n        return output;\n    }\n}\n\nmodule.exports = createError;\n","/* Common package for dealing with hex/string/uint8 conversions (and sha1 hashing)\r\n*\r\n* @author   Jimmy Wrting <jimmy@warting.se> (https://jimmy.warting.se/opensource)\r\n* @license  MIT\r\n*/\r\nexport const alphabet = '0123456789abcdef'\r\nconst encodeLookup = []\r\nconst decodeLookup = []\r\n\r\nfor (let i = 0; i < 256; i++) {\r\n  encodeLookup[i] = alphabet[i >> 4 & 0xf] + alphabet[i & 0xf]\r\n  if (i < 16) {\r\n    if (i < 10) {\r\n      decodeLookup[0x30 + i] = i\r\n    } else {\r\n      decodeLookup[0x61 - 10 + i] = i\r\n    }\r\n  }\r\n}\r\n\r\nexport const arr2hex = data => {\r\n  const length = data.length\r\n  let string = ''\r\n  let i = 0\r\n  while (i < length) {\r\n    string += encodeLookup[data[i++]]\r\n  }\r\n  return string\r\n}\r\n\r\nexport const hex2arr = str => {\r\n  const sizeof = str.length >> 1\r\n  const length = sizeof << 1\r\n  const array = new Uint8Array(sizeof)\r\n  let n = 0\r\n  let i = 0\r\n  while (i < length) {\r\n    array[n++] = decodeLookup[str.charCodeAt(i++)] << 4 | decodeLookup[str.charCodeAt(i++)]\r\n  }\r\n  return array\r\n}\r\n\r\nexport const concat = (chunks, size = 0) => {\r\n  const length = chunks.length || 0\r\n  if (!size) {\r\n    let i = length\r\n    while (i--) size += chunks[i].length\r\n  }\r\n  const b = new Uint8Array(size)\r\n  let offset = size\r\n  let i = length\r\n  while (i--) {\r\n    offset -= chunks[i].length\r\n    b.set(chunks[i], offset)\r\n  }\r\n\r\n  return b\r\n}\r\n\r\nexport const equal = (a, b) => {\r\n  if (a.length !== b.length) return false\r\n  for (let i = a.length; i > -1; i -= 1) {\r\n    if ((a[i] !== b[i])) return false\r\n  }\r\n  return true\r\n}\r\n","/*\n * base64-arraybuffer 1.0.2 <https://github.com/niklasvh/base64-arraybuffer>\n * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>\n * Released under MIT License\n */\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n// Use a lookup table to find the index.\nvar lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\nfor (var i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n}\nvar encode = function (arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';\n    for (i = 0; i < len; i += 3) {\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64 += chars[bytes[i + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + '=';\n    }\n    else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + '==';\n    }\n    return base64;\n};\nvar decode = function (base64) {\n    var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n    if (base64[base64.length - 1] === '=') {\n        bufferLength--;\n        if (base64[base64.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n    var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n    for (i = 0; i < len; i += 4) {\n        encoded1 = lookup[base64.charCodeAt(i)];\n        encoded2 = lookup[base64.charCodeAt(i + 1)];\n        encoded3 = lookup[base64.charCodeAt(i + 2)];\n        encoded4 = lookup[base64.charCodeAt(i + 3)];\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n    return arraybuffer;\n};\n\nexport { decode, encode };\n//# sourceMappingURL=base64-arraybuffer.es5.js.map\n","import { arr2hex, hex2arr, alphabet } from './util.js'\r\nimport { decode, encode } from 'base64-arraybuffer'\r\n\r\nconst decoder = new TextDecoder()\r\n// 50% slower at < 48 chars, but little impact at 4M OPS/s vs 8M OPS/s\r\nexport const arr2text = (data, enc) => {\r\n  if (!enc) return decoder.decode(data)\r\n  const dec = new TextDecoder(enc)\r\n  return dec.decode(data)\r\n}\r\n\r\n// sacrifice ~20% speed for bundle size\r\nconst encoder = new TextEncoder()\r\nexport const text2arr = str => encoder.encode(str)\r\n\r\nexport const arr2base = data => encode(data)\r\n\r\nexport const base2arr = str => new Uint8Array(decode(str))\r\n\r\nexport const bin2hex = str => {\r\n  let res = ''\r\n  let c\r\n  let i = 0\r\n  const len = str.length\r\n\r\n  while (i < len) {\r\n    c = str.charCodeAt(i++)\r\n    res += alphabet[c >> 4] + alphabet[c & 0xF]\r\n  }\r\n\r\n  return res\r\n}\r\n\r\nconst MAX_ARGUMENTS_LENGTH = 0x10000\r\nexport const hex2bin = hex => {\r\n  const points = hex2arr(hex)\r\n  if (points.length <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode(...points)\r\n\r\n  let res = ''\r\n  let i = 0\r\n  while (i < points.length) {\r\n    res += String.fromCharCode(...points.subarray(i, i += MAX_ARGUMENTS_LENGTH))\r\n  }\r\n  return res\r\n}\r\n\r\nconst scope = typeof window !== 'undefined' ? window : self\r\nconst crypto = scope.crypto || scope.msCrypto || {}\r\nconst subtle = crypto.subtle || crypto.webkitSubtle\r\n\r\nconst formatMap = {\r\n  hex: arr2hex,\r\n  base64: arr2base\r\n}\r\n\r\nexport const hash = async (data, format, algo = 'sha-1') => {\r\n  if (!subtle) throw new Error('no web crypto support')\r\n  if (typeof data === 'string') data = text2arr(data)\r\n  const out = new Uint8Array(await subtle.digest(algo, data))\r\n  return format ? formatMap[format](out) : out\r\n}\r\n\r\nexport const randomBytes = size => {\r\n  const view = new Uint8Array(size)\r\n  return crypto.getRandomValues(view)\r\n}\r\n\r\nexport * from './util.js'\r\n","/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\r\nimport debug from 'debug'\r\nimport { RTCPeerConnection, RTCSessionDescription, RTCIceCandidate } from 'webrtc-polyfill'\r\nimport { Duplex } from 'streamx'\r\nimport errCode from 'err-code'\r\nimport { randomBytes, arr2hex, text2arr } from 'uint8-util'\r\n\r\nconst Debug = debug('simple-peer')\r\n\r\nconst MAX_BUFFERED_AMOUNT = 64 * 1024\r\nconst ICECOMPLETE_TIMEOUT = 5 * 1000\r\nconst CHANNEL_CLOSING_TIMEOUT = 5 * 1000\r\n\r\n// HACK: Filter trickle lines when trickle is disabled #354\r\nfunction filterTrickle (sdp) {\r\n  return sdp.replace(/a=ice-options:trickle\\s\\n/g, '')\r\n}\r\n\r\nfunction warn (message) {\r\n  console.warn(message)\r\n}\r\n\r\n/**\r\n * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.\r\n * Duplex stream.\r\n * @param {Object} opts\r\n */\r\nclass Peer extends Duplex {\r\n  /** @type {RTCPeerConnection} */\r\n  _pc\r\n  constructor (opts) {\r\n    opts = Object.assign({\r\n      allowHalfOpen: false\r\n    }, opts)\r\n\r\n    super(opts)\r\n\r\n    this.__objectMode = !!opts.objectMode // streamx is objectMode by default, so implement readable's fuctionality\r\n\r\n    this._id = arr2hex(randomBytes(4)).slice(0, 7)\r\n    this._debug('new peer %o', opts)\r\n\r\n    this.channelName = opts.initiator\r\n      ? opts.channelName || arr2hex(randomBytes(20))\r\n      : null\r\n\r\n    this.initiator = opts.initiator || false\r\n    this.channelConfig = opts.channelConfig || Peer.channelConfig\r\n    this.channelNegotiated = this.channelConfig.negotiated\r\n    this.config = Object.assign({}, Peer.config, opts.config)\r\n    this.offerOptions = opts.offerOptions || {}\r\n    this.answerOptions = opts.answerOptions || {}\r\n    this.sdpTransform = opts.sdpTransform || (sdp => sdp)\r\n    this.trickle = opts.trickle !== undefined ? opts.trickle : true\r\n    this.allowHalfTrickle = opts.allowHalfTrickle !== undefined ? opts.allowHalfTrickle : false\r\n    this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT\r\n\r\n    this._destroying = false\r\n    this._connected = false\r\n\r\n    this.remoteAddress = undefined\r\n    this.remoteFamily = undefined\r\n    this.remotePort = undefined\r\n    this.localAddress = undefined\r\n    this.localFamily = undefined\r\n    this.localPort = undefined\r\n\r\n    if (!RTCPeerConnection) {\r\n      if (typeof window === 'undefined') {\r\n        throw errCode(new Error('No WebRTC support: Specify `opts.wrtc` option in this environment'), 'ERR_WEBRTC_SUPPORT')\r\n      } else {\r\n        throw errCode(new Error('No WebRTC support: Not a supported browser'), 'ERR_WEBRTC_SUPPORT')\r\n      }\r\n    }\r\n\r\n    this._pcReady = false\r\n    this._channelReady = false\r\n    this._iceComplete = false // ice candidate trickle done (got null candidate)\r\n    this._iceCompleteTimer = null // send an offer/answer anyway after some timeout\r\n    this._channel = null\r\n    this._pendingCandidates = []\r\n\r\n    this._isNegotiating = false // is this peer waiting for negotiation to complete?\r\n    this._firstNegotiation = true\r\n    this._batchedNegotiation = false // batch synchronous negotiations\r\n    this._queuedNegotiation = false // is there a queued negotiation request?\r\n    this._sendersAwaitingStable = []\r\n    this._closingInterval = null\r\n\r\n    this._remoteTracks = []\r\n    this._remoteStreams = []\r\n\r\n    this._chunk = null\r\n    this._cb = null\r\n    this._interval = null\r\n\r\n    try {\r\n      this._pc = new RTCPeerConnection(this.config)\r\n    } catch (err) {\r\n      this.__destroy(errCode(err, 'ERR_PC_CONSTRUCTOR'))\r\n      return\r\n    }\r\n\r\n    // We prefer feature detection whenever possible, but sometimes that's not\r\n    // possible for certain implementations.\r\n    this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === 'number'\r\n\r\n    this._pc.oniceconnectionstatechange = () => {\r\n      this._onIceStateChange()\r\n    }\r\n    this._pc.onicegatheringstatechange = () => {\r\n      this._onIceStateChange()\r\n    }\r\n    this._pc.onconnectionstatechange = () => {\r\n      this._onConnectionStateChange()\r\n    }\r\n    this._pc.onsignalingstatechange = () => {\r\n      this._onSignalingStateChange()\r\n    }\r\n    this._pc.onicecandidate = event => {\r\n      this._onIceCandidate(event)\r\n    }\r\n\r\n    // HACK: Fix for odd Firefox behavior, see: https://github.com/feross/simple-peer/pull/783\r\n    if (typeof this._pc.peerIdentity === 'object') {\r\n      this._pc.peerIdentity.catch(err => {\r\n        this.__destroy(errCode(err, 'ERR_PC_PEER_IDENTITY'))\r\n      })\r\n    }\r\n\r\n    // Other spec events, unused by this implementation:\r\n    // - onconnectionstatechange\r\n    // - onicecandidateerror\r\n    // - onfingerprintfailure\r\n    // - onnegotiationneeded\r\n\r\n    if (this.initiator || this.channelNegotiated) {\r\n      this._setupData({\r\n        channel: this._pc.createDataChannel(this.channelName, this.channelConfig)\r\n      })\r\n    } else {\r\n      this._pc.ondatachannel = event => {\r\n        this._setupData(event)\r\n      }\r\n    }\r\n\r\n    this._debug('initial negotiation')\r\n    this._needsNegotiation()\r\n\r\n    this._onFinishBound = () => {\r\n      this._onFinish()\r\n    }\r\n    this.once('finish', this._onFinishBound)\r\n  }\r\n\r\n  get bufferSize () {\r\n    return (this._channel && this._channel.bufferedAmount) || 0\r\n  }\r\n\r\n  // HACK: it's possible channel.readyState is \"closing\" before peer.destroy() fires\r\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\r\n  get connected () {\r\n    return (this._connected && this._channel.readyState === 'open')\r\n  }\r\n\r\n  address () {\r\n    return { port: this.localPort, family: this.localFamily, address: this.localAddress }\r\n  }\r\n\r\n  signal (data) {\r\n    if (this._destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot signal after peer is destroyed'), 'ERR_DESTROYED')\r\n    if (typeof data === 'string') {\r\n      try {\r\n        data = JSON.parse(data)\r\n      } catch (err) {\r\n        data = {}\r\n      }\r\n    }\r\n    this._debug('signal()')\r\n\r\n    if (data.renegotiate && this.initiator) {\r\n      this._debug('got request to renegotiate')\r\n      this._needsNegotiation()\r\n    }\r\n    if (data.transceiverRequest && this.initiator) {\r\n      this._debug('got request for transceiver')\r\n      this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init)\r\n    }\r\n    if (data.candidate) {\r\n      if (this._pc.remoteDescription && this._pc.remoteDescription.type) {\r\n        this._addIceCandidate(data.candidate)\r\n      } else {\r\n        this._pendingCandidates.push(data.candidate)\r\n      }\r\n    }\r\n    if (data.sdp) {\r\n      this._pc.setRemoteDescription(new RTCSessionDescription(data))\r\n        .then(() => {\r\n          if (this.destroyed) return\r\n\r\n          this._pendingCandidates.forEach(candidate => {\r\n            this._addIceCandidate(candidate)\r\n          })\r\n          this._pendingCandidates = []\r\n\r\n          if (this._pc.remoteDescription.type === 'offer') this._createAnswer()\r\n        })\r\n        .catch(err => {\r\n          this.__destroy(errCode(err, 'ERR_SET_REMOTE_DESCRIPTION'))\r\n        })\r\n    }\r\n    if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {\r\n      this.__destroy(errCode(new Error('signal() called with invalid signal data'), 'ERR_SIGNALING'))\r\n    }\r\n  }\r\n\r\n  _addIceCandidate (candidate) {\r\n    const iceCandidateObj = new RTCIceCandidate(candidate)\r\n    this._pc.addIceCandidate(iceCandidateObj)\r\n      .catch(err => {\r\n        if (!iceCandidateObj.address || iceCandidateObj.address.endsWith('.local')) {\r\n          warn('Ignoring unsupported ICE candidate.')\r\n        } else {\r\n          this.__destroy(errCode(err, 'ERR_ADD_ICE_CANDIDATE'))\r\n        }\r\n      })\r\n  }\r\n\r\n  /**\r\n   * Send text/binary data to the remote peer.\r\n   * @param {ArrayBufferView|ArrayBuffer|Uint8Array|string|Blob} chunk\r\n   */\r\n  send (chunk) {\r\n    if (this._destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot send after peer is destroyed'), 'ERR_DESTROYED')\r\n    this._channel.send(chunk)\r\n  }\r\n\r\n  _needsNegotiation () {\r\n    this._debug('_needsNegotiation')\r\n    if (this._batchedNegotiation) return // batch synchronous renegotiations\r\n    this._batchedNegotiation = true\r\n    queueMicrotask(() => {\r\n      this._batchedNegotiation = false\r\n      if (this.initiator || !this._firstNegotiation) {\r\n        this._debug('starting batched negotiation')\r\n        this.negotiate()\r\n      } else {\r\n        this._debug('non-initiator initial negotiation request discarded')\r\n      }\r\n      this._firstNegotiation = false\r\n    })\r\n  }\r\n\r\n  negotiate () {\r\n    if (this._destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot negotiate after peer is destroyed'), 'ERR_DESTROYED')\r\n\r\n    if (this.initiator) {\r\n      if (this._isNegotiating) {\r\n        this._queuedNegotiation = true\r\n        this._debug('already negotiating, queueing')\r\n      } else {\r\n        this._debug('start negotiation')\r\n        setTimeout(() => { // HACK: Chrome crashes if we immediately call createOffer\r\n          this._createOffer()\r\n        }, 0)\r\n      }\r\n    } else {\r\n      if (this._isNegotiating) {\r\n        this._queuedNegotiation = true\r\n        this._debug('already negotiating, queueing')\r\n      } else {\r\n        this._debug('requesting negotiation from initiator')\r\n        this.emit('signal', { // request initiator to renegotiate\r\n          type: 'renegotiate',\r\n          renegotiate: true\r\n        })\r\n      }\r\n    }\r\n    this._isNegotiating = true\r\n  }\r\n\r\n  _final (cb) {\r\n    if (!this._readableState.ended) this.push(null)\r\n    cb(null)\r\n  }\r\n\r\n  __destroy (err) {\r\n    this.end()\r\n    this._destroy(() => {}, err)\r\n  }\r\n\r\n  _destroy (cb, err) {\r\n    if (this.destroyed || this._destroying) return\r\n    this._destroying = true\r\n\r\n    this._debug('destroying (error: %s)', err && (err.message || err))\r\n\r\n    setTimeout(() => { // allow events concurrent with the call to _destroy() to fire (see #692)\r\n      if (this._connected) this.emit('disconnect')\r\n      this._connected = false\r\n      this._pcReady = false\r\n      this._channelReady = false\r\n      this._remoteTracks = null\r\n      this._remoteStreams = null\r\n      this._senderMap = null\r\n\r\n      clearInterval(this._closingInterval)\r\n      this._closingInterval = null\r\n\r\n      clearInterval(this._interval)\r\n      this._interval = null\r\n      this._chunk = null\r\n      this._cb = null\r\n\r\n      if (this._onFinishBound) this.removeListener('finish', this._onFinishBound)\r\n      this._onFinishBound = null\r\n\r\n      if (this._channel) {\r\n        try {\r\n          this._channel.close()\r\n        } catch (err) {}\r\n\r\n        // allow events concurrent with destruction to be handled\r\n        this._channel.onmessage = null\r\n        this._channel.onopen = null\r\n        this._channel.onclose = null\r\n        this._channel.onerror = null\r\n      }\r\n      if (this._pc) {\r\n        try {\r\n          this._pc.close()\r\n        } catch (err) {}\r\n\r\n        // allow events concurrent with destruction to be handled\r\n        this._pc.oniceconnectionstatechange = null\r\n        this._pc.onicegatheringstatechange = null\r\n        this._pc.onsignalingstatechange = null\r\n        this._pc.onicecandidate = null\r\n        this._pc.ontrack = null\r\n        this._pc.ondatachannel = null\r\n      }\r\n      this._pc = null\r\n      this._channel = null\r\n      if (err) this.emit('error', err)\r\n      cb()\r\n    }, 0)\r\n  }\r\n\r\n  _setupData (event) {\r\n    if (!event.channel) {\r\n      // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),\r\n      // which is invalid behavior. Handle it gracefully.\r\n      // See: https://github.com/feross/simple-peer/issues/163\r\n      return this.__destroy(errCode(new Error('Data channel event is missing `channel` property'), 'ERR_DATA_CHANNEL'))\r\n    }\r\n\r\n    this._channel = event.channel\r\n    this._channel.binaryType = 'arraybuffer'\r\n\r\n    if (typeof this._channel.bufferedAmountLowThreshold === 'number') {\r\n      this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT\r\n    }\r\n\r\n    this.channelName = this._channel.label\r\n\r\n    this._channel.onmessage = event => {\r\n      this._onChannelMessage(event)\r\n    }\r\n    this._channel.onbufferedamountlow = () => {\r\n      this._onChannelBufferedAmountLow()\r\n    }\r\n    this._channel.onopen = () => {\r\n      this._onChannelOpen()\r\n    }\r\n    this._channel.onclose = () => {\r\n      this._onChannelClose()\r\n    }\r\n    this._channel.onerror = event => {\r\n      const err = event.error instanceof Error\r\n        ? event.error\r\n        : new Error(`Datachannel error: ${event.message} ${event.filename}:${event.lineno}:${event.colno}`)\r\n      this.__destroy(errCode(err, 'ERR_DATA_CHANNEL'))\r\n    }\r\n\r\n    // HACK: Chrome will sometimes get stuck in readyState \"closing\", let's check for this condition\r\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\r\n    let isClosing = false\r\n    this._closingInterval = setInterval(() => { // No \"onclosing\" event\r\n      if (this._channel && this._channel.readyState === 'closing') {\r\n        if (isClosing) this._onChannelClose() // closing timed out: equivalent to onclose firing\r\n        isClosing = true\r\n      } else {\r\n        isClosing = false\r\n      }\r\n    }, CHANNEL_CLOSING_TIMEOUT)\r\n  }\r\n\r\n  _write (chunk, cb) {\r\n    if (this.destroyed) return cb(errCode(new Error('cannot write after peer is destroyed'), 'ERR_DATA_CHANNEL'))\r\n\r\n    if (this._connected) {\r\n      try {\r\n        this.send(chunk)\r\n      } catch (err) {\r\n        return this.__destroy(errCode(err, 'ERR_DATA_CHANNEL'))\r\n      }\r\n      if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n        this._debug('start backpressure: bufferedAmount %d', this._channel.bufferedAmount)\r\n        this._cb = cb\r\n      } else {\r\n        cb(null)\r\n      }\r\n    } else {\r\n      this._debug('write before connect')\r\n      this._chunk = chunk\r\n      this._cb = cb\r\n    }\r\n  }\r\n\r\n  // When stream finishes writing, close socket. Half open connections are not\r\n  // supported.\r\n  _onFinish () {\r\n    if (this.destroyed) return\r\n\r\n    // Wait a bit before destroying so the socket flushes.\r\n    // TODO: is there a more reliable way to accomplish this?\r\n    const destroySoon = () => {\r\n      setTimeout(() => this.__destroy(), 1000)\r\n    }\r\n\r\n    if (this._connected) {\r\n      destroySoon()\r\n    } else {\r\n      this.once('connect', destroySoon)\r\n    }\r\n  }\r\n\r\n  _startIceCompleteTimeout () {\r\n    if (this.destroyed) return\r\n    if (this._iceCompleteTimer) return\r\n    this._debug('started iceComplete timeout')\r\n    this._iceCompleteTimer = setTimeout(() => {\r\n      if (!this._iceComplete) {\r\n        this._iceComplete = true\r\n        this._debug('iceComplete timeout completed')\r\n        this.emit('iceTimeout')\r\n        this.emit('_iceComplete')\r\n      }\r\n    }, this.iceCompleteTimeout)\r\n  }\r\n\r\n  _createOffer () {\r\n    if (this.destroyed) return\r\n\r\n    this._pc.createOffer(this.offerOptions)\r\n      .then(offer => {\r\n        if (this.destroyed) return\r\n        if (!this.trickle && !this.allowHalfTrickle) offer.sdp = filterTrickle(offer.sdp)\r\n        offer.sdp = this.sdpTransform(offer.sdp)\r\n\r\n        const sendOffer = () => {\r\n          if (this.destroyed) return\r\n          const signal = this._pc.localDescription || offer\r\n          this._debug('signal')\r\n          this.emit('signal', {\r\n            type: signal.type,\r\n            sdp: signal.sdp\r\n          })\r\n        }\r\n\r\n        const onSuccess = () => {\r\n          this._debug('createOffer success')\r\n          if (this.destroyed) return\r\n          if (this.trickle || this._iceComplete) sendOffer()\r\n          else this.once('_iceComplete', sendOffer) // wait for candidates\r\n        }\r\n\r\n        const onError = err => {\r\n          this.__destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))\r\n        }\r\n\r\n        this._pc.setLocalDescription(offer)\r\n          .then(onSuccess)\r\n          .catch(onError)\r\n      })\r\n      .catch(err => {\r\n        this.__destroy(errCode(err, 'ERR_CREATE_OFFER'))\r\n      })\r\n  }\r\n\r\n  _createAnswer () {\r\n    if (this.destroyed) return\r\n\r\n    this._pc.createAnswer(this.answerOptions)\r\n      .then(answer => {\r\n        if (this.destroyed) return\r\n        if (!this.trickle && !this.allowHalfTrickle) answer.sdp = filterTrickle(answer.sdp)\r\n        answer.sdp = this.sdpTransform(answer.sdp)\r\n\r\n        const sendAnswer = () => {\r\n          if (this.destroyed) return\r\n          const signal = this._pc.localDescription || answer\r\n          this._debug('signal')\r\n          this.emit('signal', {\r\n            type: signal.type,\r\n            sdp: signal.sdp\r\n          })\r\n          if (!this.initiator) this._requestMissingTransceivers?.()\r\n        }\r\n\r\n        const onSuccess = () => {\r\n          if (this.destroyed) return\r\n          if (this.trickle || this._iceComplete) sendAnswer()\r\n          else this.once('_iceComplete', sendAnswer)\r\n        }\r\n\r\n        const onError = err => {\r\n          this.__destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))\r\n        }\r\n\r\n        this._pc.setLocalDescription(answer)\r\n          .then(onSuccess)\r\n          .catch(onError)\r\n      })\r\n      .catch(err => {\r\n        this.__destroy(errCode(err, 'ERR_CREATE_ANSWER'))\r\n      })\r\n  }\r\n\r\n  _onConnectionStateChange () {\r\n    if (this.destroyed || this._destroying) return\r\n    if (this._pc.connectionState === 'failed') {\r\n      this.__destroy(errCode(new Error('Connection failed.'), 'ERR_CONNECTION_FAILURE'))\r\n    }\r\n  }\r\n\r\n  _onIceStateChange () {\r\n    if (this.destroyed) return\r\n    const iceConnectionState = this._pc.iceConnectionState\r\n    const iceGatheringState = this._pc.iceGatheringState\r\n\r\n    this._debug(\r\n      'iceStateChange (connection: %s) (gathering: %s)',\r\n      iceConnectionState,\r\n      iceGatheringState\r\n    )\r\n    this.emit('iceStateChange', iceConnectionState, iceGatheringState)\r\n\r\n    if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {\r\n      this._pcReady = true\r\n      this._maybeReady()\r\n    }\r\n    if (iceConnectionState === 'failed') {\r\n      this.__destroy(errCode(new Error('Ice connection failed.'), 'ERR_ICE_CONNECTION_FAILURE'))\r\n    }\r\n    if (iceConnectionState === 'closed') {\r\n      this.__destroy(errCode(new Error('Ice connection closed.'), 'ERR_ICE_CONNECTION_CLOSED'))\r\n    }\r\n  }\r\n\r\n  getStats (cb) {\r\n    // statreports can come with a value array instead of properties\r\n    const flattenValues = report => {\r\n      if (Object.prototype.toString.call(report.values) === '[object Array]') {\r\n        report.values.forEach(value => {\r\n          Object.assign(report, value)\r\n        })\r\n      }\r\n      return report\r\n    }\r\n\r\n    // Promise-based getStats() (standard)\r\n    if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {\r\n      this._pc.getStats()\r\n        .then(res => {\r\n          const reports = []\r\n          res.forEach(report => {\r\n            reports.push(flattenValues(report))\r\n          })\r\n          cb(null, reports)\r\n        }, err => cb(err))\r\n\r\n    // Single-parameter callback-based getStats() (non-standard)\r\n    } else if (this._pc.getStats.length > 0) {\r\n      this._pc.getStats(res => {\r\n        // If we destroy connection in `connect` callback this code might happen to run when actual connection is already closed\r\n        if (this.destroyed) return\r\n\r\n        const reports = []\r\n        res.result().forEach(result => {\r\n          const report = {}\r\n          result.names().forEach(name => {\r\n            report[name] = result.stat(name)\r\n          })\r\n          report.id = result.id\r\n          report.type = result.type\r\n          report.timestamp = result.timestamp\r\n          reports.push(flattenValues(report))\r\n        })\r\n        cb(null, reports)\r\n      }, err => cb(err))\r\n\r\n    // Unknown browser, skip getStats() since it's anyone's guess which style of\r\n    // getStats() they implement.\r\n    } else {\r\n      cb(null, [])\r\n    }\r\n  }\r\n\r\n  _maybeReady () {\r\n    this._debug('maybeReady pc %s channel %s', this._pcReady, this._channelReady)\r\n    if (this._connected || this._connecting || !this._pcReady || !this._channelReady) return\r\n\r\n    this._connecting = true\r\n\r\n    // HACK: We can't rely on order here, for details see https://github.com/js-platform/node-webrtc/issues/339\r\n    const findCandidatePair = () => {\r\n      if (this.destroyed || this._destroying) return\r\n\r\n      this.getStats((err, items) => {\r\n        if (this.destroyed || this._destroying) return\r\n\r\n        // Treat getStats error as non-fatal. It's not essential.\r\n        if (err) items = []\r\n\r\n        const remoteCandidates = {}\r\n        const localCandidates = {}\r\n        const candidatePairs = {}\r\n        let foundSelectedCandidatePair = false\r\n\r\n        items.forEach(item => {\r\n          // TODO: Once all browsers support the hyphenated stats report types, remove\r\n          // the non-hypenated ones\r\n          if (item.type === 'remotecandidate' || item.type === 'remote-candidate') {\r\n            remoteCandidates[item.id] = item\r\n          }\r\n          if (item.type === 'localcandidate' || item.type === 'local-candidate') {\r\n            localCandidates[item.id] = item\r\n          }\r\n          if (item.type === 'candidatepair' || item.type === 'candidate-pair') {\r\n            candidatePairs[item.id] = item\r\n          }\r\n        })\r\n\r\n        const setSelectedCandidatePair = selectedCandidatePair => {\r\n          foundSelectedCandidatePair = true\r\n\r\n          let local = localCandidates[selectedCandidatePair.localCandidateId]\r\n\r\n          if (local && (local.ip || local.address)) {\r\n            // Spec\r\n            this.localAddress = local.ip || local.address\r\n            this.localPort = Number(local.port)\r\n          } else if (local && local.ipAddress) {\r\n            // Firefox\r\n            this.localAddress = local.ipAddress\r\n            this.localPort = Number(local.portNumber)\r\n          } else if (typeof selectedCandidatePair.googLocalAddress === 'string') {\r\n            // TODO: remove this once Chrome 58 is released\r\n            local = selectedCandidatePair.googLocalAddress.split(':')\r\n            this.localAddress = local[0]\r\n            this.localPort = Number(local[1])\r\n          }\r\n          if (this.localAddress) {\r\n            this.localFamily = this.localAddress.includes(':') ? 'IPv6' : 'IPv4'\r\n          }\r\n\r\n          let remote = remoteCandidates[selectedCandidatePair.remoteCandidateId]\r\n\r\n          if (remote && (remote.ip || remote.address)) {\r\n            // Spec\r\n            this.remoteAddress = remote.ip || remote.address\r\n            this.remotePort = Number(remote.port)\r\n          } else if (remote && remote.ipAddress) {\r\n            // Firefox\r\n            this.remoteAddress = remote.ipAddress\r\n            this.remotePort = Number(remote.portNumber)\r\n          } else if (typeof selectedCandidatePair.googRemoteAddress === 'string') {\r\n            // TODO: remove this once Chrome 58 is released\r\n            remote = selectedCandidatePair.googRemoteAddress.split(':')\r\n            this.remoteAddress = remote[0]\r\n            this.remotePort = Number(remote[1])\r\n          }\r\n          if (this.remoteAddress) {\r\n            this.remoteFamily = this.remoteAddress.includes(':') ? 'IPv6' : 'IPv4'\r\n          }\r\n\r\n          this._debug(\r\n            'connect local: %s:%s remote: %s:%s',\r\n            this.localAddress,\r\n            this.localPort,\r\n            this.remoteAddress,\r\n            this.remotePort\r\n          )\r\n        }\r\n\r\n        items.forEach(item => {\r\n          // Spec-compliant\r\n          if (item.type === 'transport' && item.selectedCandidatePairId) {\r\n            setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId])\r\n          }\r\n\r\n          // Old implementations\r\n          if (\r\n            (item.type === 'googCandidatePair' && item.googActiveConnection === 'true') ||\r\n            ((item.type === 'candidatepair' || item.type === 'candidate-pair') && item.selected)\r\n          ) {\r\n            setSelectedCandidatePair(item)\r\n          }\r\n        })\r\n\r\n        // Ignore candidate pair selection in browsers like Safari 11 that do not have any local or remote candidates\r\n        // But wait until at least 1 candidate pair is available\r\n        if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {\r\n          setTimeout(findCandidatePair, 100)\r\n          return\r\n        } else {\r\n          this._connecting = false\r\n          this._connected = true\r\n          this.emit('connect')\r\n        }\r\n\r\n        if (this._chunk) {\r\n          try {\r\n            this.send(this._chunk)\r\n          } catch (err) {\r\n            return this.__destroy(errCode(err, 'ERR_DATA_CHANNEL'))\r\n          }\r\n          this._chunk = null\r\n          this._debug('sent chunk from \"write before connect\"')\r\n\r\n          const cb = this._cb\r\n          this._cb = null\r\n          cb(null)\r\n        }\r\n\r\n        // If `bufferedAmountLowThreshold` and 'onbufferedamountlow' are unsupported,\r\n        // fallback to using setInterval to implement backpressure.\r\n        if (typeof this._channel.bufferedAmountLowThreshold !== 'number') {\r\n          this._interval = setInterval(() => this._onInterval(), 150)\r\n          if (this._interval.unref) this._interval.unref()\r\n        }\r\n\r\n        this._debug('connect')\r\n        this.emit('connect')\r\n      })\r\n    }\r\n    findCandidatePair()\r\n  }\r\n\r\n  _onInterval () {\r\n    if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n      return\r\n    }\r\n    this._onChannelBufferedAmountLow()\r\n  }\r\n\r\n  _onSignalingStateChange () {\r\n    if (this.destroyed) return\r\n\r\n    if (this._pc.signalingState === 'stable') {\r\n      this._isNegotiating = false\r\n\r\n      // HACK: Firefox doesn't yet support removing tracks when signalingState !== 'stable'\r\n      this._debug('flushing sender queue', this._sendersAwaitingStable)\r\n      this._sendersAwaitingStable.forEach(sender => {\r\n        this._pc.removeTrack(sender)\r\n        this._queuedNegotiation = true\r\n      })\r\n      this._sendersAwaitingStable = []\r\n\r\n      if (this._queuedNegotiation) {\r\n        this._debug('flushing negotiation queue')\r\n        this._queuedNegotiation = false\r\n        this._needsNegotiation() // negotiate again\r\n      } else {\r\n        this._debug('negotiated')\r\n        this.emit('negotiated')\r\n      }\r\n    }\r\n\r\n    this._debug('signalingStateChange %s', this._pc.signalingState)\r\n    this.emit('signalingStateChange', this._pc.signalingState)\r\n  }\r\n\r\n  _onIceCandidate (event) {\r\n    if (this.destroyed) return\r\n    if (event.candidate && this.trickle) {\r\n      this.emit('signal', {\r\n        type: 'candidate',\r\n        candidate: {\r\n          candidate: event.candidate.candidate,\r\n          sdpMLineIndex: event.candidate.sdpMLineIndex,\r\n          sdpMid: event.candidate.sdpMid\r\n        }\r\n      })\r\n    } else if (!event.candidate && !this._iceComplete) {\r\n      this._iceComplete = true\r\n      this.emit('_iceComplete')\r\n    }\r\n    // as soon as we've received one valid candidate start timeout\r\n    if (event.candidate) {\r\n      this._startIceCompleteTimeout()\r\n    }\r\n  }\r\n\r\n  _onChannelMessage (event) {\r\n    if (this.destroyed) return\r\n    let data = event.data\r\n    if (data instanceof ArrayBuffer) {\r\n      data = new Uint8Array(data)\r\n    } else if (this.__objectMode === false) {\r\n      data = text2arr(data)\r\n    }\r\n    this.push(data)\r\n  }\r\n\r\n  _onChannelBufferedAmountLow () {\r\n    if (this.destroyed || !this._cb) return\r\n    this._debug('ending backpressure: bufferedAmount %d', this._channel.bufferedAmount)\r\n    const cb = this._cb\r\n    this._cb = null\r\n    cb(null)\r\n  }\r\n\r\n  _onChannelOpen () {\r\n    if (this._connected || this.destroyed) return\r\n    this._debug('on channel open')\r\n    this._channelReady = true\r\n    this._maybeReady()\r\n  }\r\n\r\n  _onChannelClose () {\r\n    if (this.destroyed) return\r\n    this._debug('on channel close')\r\n    this.__destroy()\r\n  }\r\n\r\n  _debug () {\r\n    const args = [].slice.call(arguments)\r\n    args[0] = '[' + this._id + '] ' + args[0]\r\n    Debug.apply(null, args)\r\n  }\r\n}\r\n\r\nPeer.WEBRTC_SUPPORT = !!RTCPeerConnection\r\n\r\n/**\r\n * Expose peer and data channel config for overriding all Peer\r\n * instances. Otherwise, just set opts.config or opts.channelConfig\r\n * when constructing a Peer.\r\n */\r\nPeer.config = {\r\n  iceServers: [\r\n    {\r\n      urls: [\r\n        'stun:stun.l.google.com:19302',\r\n        'stun:global.stun.twilio.com:3478'\r\n      ]\r\n    }\r\n  ],\r\n  sdpSemantics: 'unified-plan'\r\n}\r\n\r\nPeer.channelConfig = {}\r\n\r\nexport default Peer\r\n","export default {}","/**\n * Functions/constants needed by both the client and server.\n */\nimport * as common from './common-node.js'\nexport * from './common-node.js'\n\nexport const DEFAULT_ANNOUNCE_PEERS = 50\nexport const MAX_ANNOUNCE_PEERS = 82\n\n// HACK: Fix for WHATWG URL object not parsing non-standard URL schemes like\n// 'udp:'. Just replace it with 'http:' since we only need a few properties.\n//\n// Note: Only affects Chrome and Firefox. Works fine in Node.js, Safari, and\n// Edge.\n//\n// Note: UDP trackers aren't used in the normal browser build, but they are\n// used in a Chrome App build (i.e. by Brave Browser).\n//\n// Bug reports:\n// - Chrome: https://bugs.chromium.org/p/chromium/issues/detail?id=734880\n// - Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1374505\nexport const parseUrl = str => {\n  const url = new URL(str.replace(/^udp:/, 'http:'))\n\n  if (str.match(/^udp:/)) {\n    Object.defineProperties(url, {\n      href: { value: url.href.replace(/^http/, 'udp') },\n      protocol: { value: url.protocol.replace(/^http/, 'udp') },\n      origin: { value: url.origin.replace(/^http/, 'udp') }\n    })\n  }\n\n  return url\n}\n\nexport default {\n  DEFAULT_ANNOUNCE_PEERS,\n  MAX_ANNOUNCE_PEERS,\n  parseUrl,\n  ...common\n}\n","/*! simple-websocket. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\r\n/* global WebSocket */\r\n\r\nimport Debug from 'debug'\r\nimport queueMicrotask from 'queue-microtask' // TODO: remove when Node 10 is not supported\r\nimport ws from 'ws' // websockets in node - will be empty object in browser\r\nimport { Duplex } from 'streamx'\r\nimport { text2arr, randomBytes, arr2hex } from 'uint8-util'\r\n\r\nconst debug = Debug('simple-websocket')\r\n\r\nconst _WebSocket = typeof ws !== 'function' ? WebSocket : ws\r\n\r\nconst MAX_BUFFERED_AMOUNT = 64 * 1024\r\n\r\n/**\r\n * WebSocket. Same API as node core `net.Socket`. Duplex stream.\r\n * @param {Object} opts\r\n * @param {string=} opts.url websocket server url\r\n * @param {string=} opts.socket raw websocket instance to wrap\r\n */\r\nexport default class Socket extends Duplex {\r\n  constructor (opts = {}) {\r\n    // Support simple usage: `new Socket(url)`\r\n    if (typeof opts === 'string') {\r\n      opts = { url: opts }\r\n    }\r\n\r\n    opts = Object.assign({\r\n      allowHalfOpen: false\r\n    }, opts)\r\n\r\n    super(opts)\r\n\r\n    this.__objectMode = !!opts.objectMode // streamx is objectMode by default, so implement readable's fuctionality\r\n    if (opts.objectMode != null) delete opts.objectMode // causes error with ws...\r\n\r\n    if (opts.url == null && opts.socket == null) {\r\n      throw new Error('Missing required `url` or `socket` option')\r\n    }\r\n    if (opts.url != null && opts.socket != null) {\r\n      throw new Error('Must specify either `url` or `socket` option, not both')\r\n    }\r\n\r\n    this._id = arr2hex(randomBytes(4)).slice(0, 7)\r\n    this._debug('new websocket: %o', opts)\r\n\r\n    this.connected = false\r\n\r\n    this._chunk = null\r\n    this._cb = null\r\n    this._interval = null\r\n\r\n    if (opts.socket) {\r\n      this.url = opts.socket.url\r\n      this._ws = opts.socket\r\n      this.connected = opts.socket.readyState === _WebSocket.OPEN\r\n    } else {\r\n      this.url = opts.url\r\n      try {\r\n        if (typeof ws === 'function') {\r\n          // `ws` package accepts options\r\n          this._ws = new _WebSocket(opts.url, {\r\n            ...opts,\r\n            encoding: undefined // encoding option breaks ws internals\r\n          })\r\n        } else {\r\n          this._ws = new _WebSocket(opts.url)\r\n        }\r\n      } catch (err) {\r\n        queueMicrotask(() => this.destroy(err))\r\n        return\r\n      }\r\n    }\r\n\r\n    this._ws.binaryType = 'arraybuffer'\r\n\r\n    if (opts.socket && this.connected) {\r\n      queueMicrotask(() => this._handleOpen())\r\n    } else {\r\n      this._ws.onopen = () => this._handleOpen()\r\n    }\r\n\r\n    this._ws.onmessage = event => this._handleMessage(event)\r\n    this._ws.onclose = () => this._handleClose()\r\n    this._ws.onerror = err => this._handleError(err)\r\n\r\n    this._handleFinishBound = () => this._handleFinish()\r\n    this.once('finish', this._handleFinishBound)\r\n  }\r\n\r\n  /**\r\n   * Send text/binary data to the WebSocket server.\r\n   * @param {TypedArrayView|ArrayBuffer|Uint8Array|string|Blob|Object} chunk\r\n   */\r\n  send (chunk) {\r\n    this._ws.send(chunk)\r\n  }\r\n\r\n  _final (cb) {\r\n    if (!this._readableState.ended) this.push(null)\r\n    cb(null)\r\n  }\r\n\r\n  _destroy (cb) {\r\n    if (this.destroyed) return\r\n    if (!this._writableState.ended) this.end()\r\n\r\n    this.connected = false\r\n\r\n    clearInterval(this._interval)\r\n    this._interval = null\r\n    this._chunk = null\r\n    this._cb = null\r\n\r\n    if (this._handleFinishBound) {\r\n      this.removeListener('finish', this._handleFinishBound)\r\n    }\r\n    this._handleFinishBound = null\r\n\r\n    if (this._ws) {\r\n      const ws = this._ws\r\n      const onClose = () => {\r\n        ws.onclose = null\r\n      }\r\n      if (ws.readyState === _WebSocket.CLOSED) {\r\n        onClose()\r\n      } else {\r\n        try {\r\n          ws.onclose = onClose\r\n          ws.close()\r\n        } catch (err) {\r\n          onClose()\r\n        }\r\n      }\r\n\r\n      ws.onopen = null\r\n      ws.onmessage = null\r\n      ws.onerror = () => {}\r\n    }\r\n    this._ws = null\r\n\r\n    cb()\r\n  }\r\n\r\n  _write (chunk, cb) {\r\n    if (this.destroyed) return cb(new Error('cannot write after socket is destroyed'))\r\n\r\n    if (this.connected) {\r\n      try {\r\n        this.send(chunk)\r\n      } catch (err) {\r\n        return this.destroy(err)\r\n      }\r\n      if (typeof ws !== 'function' && this._ws.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n        this._debug('start backpressure: bufferedAmount %d', this._ws.bufferedAmount)\r\n        this._cb = cb\r\n      } else {\r\n        cb(null)\r\n      }\r\n    } else {\r\n      this._debug('write before connect')\r\n      this._chunk = chunk\r\n      this._cb = cb\r\n    }\r\n  }\r\n\r\n  _handleOpen () {\r\n    if (this.connected || this.destroyed) return\r\n    this.connected = true\r\n\r\n    if (this._chunk) {\r\n      try {\r\n        this.send(this._chunk)\r\n      } catch (err) {\r\n        return this.destroy(err)\r\n      }\r\n      this._chunk = null\r\n      this._debug('sent chunk from \"write before connect\"')\r\n\r\n      const cb = this._cb\r\n      this._cb = null\r\n      cb(null)\r\n    }\r\n\r\n    // Backpressure is not implemented in Node.js. The `ws` module has a buggy\r\n    // `bufferedAmount` property. See: https://github.com/websockets/ws/issues/492\r\n    if (typeof ws !== 'function') {\r\n      this._interval = setInterval(() => this._onInterval(), 150)\r\n      if (this._interval.unref) this._interval.unref()\r\n    }\r\n\r\n    this._debug('connect')\r\n    this.emit('connect')\r\n  }\r\n\r\n  _handleMessage (event) {\r\n    if (this.destroyed) return\r\n    let data = event.data\r\n    if (data instanceof ArrayBuffer) data = new Uint8Array(data)\r\n    if (this.__objectMode === false) data = text2arr(data)\r\n    this.push(data)\r\n  }\r\n\r\n  _handleClose () {\r\n    if (this.destroyed) return\r\n    this._debug('on close')\r\n    this.destroy()\r\n  }\r\n\r\n  _handleError (_) {\r\n    this.destroy(new Error(`Error connecting to ${this.url}`))\r\n  }\r\n\r\n  // When stream finishes writing, close socket. Half open connections are not\r\n  // supported.\r\n  _handleFinish () {\r\n    if (this.destroyed) return\r\n\r\n    // Wait a bit before destroying so the socket flushes.\r\n    // TODO: is there a more reliable way to accomplish this?\r\n    const destroySoon = () => {\r\n      setTimeout(() => this.destroy(), 1000)\r\n    }\r\n\r\n    if (this.connected) {\r\n      destroySoon()\r\n    } else {\r\n      this.once('connect', destroySoon)\r\n    }\r\n  }\r\n\r\n  _onInterval () {\r\n    if (!this._cb || !this._ws || this._ws.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n      return\r\n    }\r\n    this._debug('ending backpressure: bufferedAmount %d', this._ws.bufferedAmount)\r\n    const cb = this._cb\r\n    this._cb = null\r\n    cb(null)\r\n  }\r\n\r\n  _debug () {\r\n    const args = [].slice.call(arguments)\r\n    args[0] = '[' + this._id + '] ' + args[0]\r\n    debug.apply(null, args)\r\n  }\r\n}\r\n\r\nSocket.WEBSOCKET_SUPPORT = !!_WebSocket\r\n","import EventEmitter from 'events'\n\nclass Tracker extends EventEmitter {\n  constructor (client, announceUrl) {\n    super()\n\n    this.client = client\n    this.announceUrl = announceUrl\n\n    this.interval = null\n    this.destroyed = false\n  }\n\n  setInterval (intervalMs) {\n    if (intervalMs == null) intervalMs = this.DEFAULT_ANNOUNCE_INTERVAL\n\n    clearInterval(this.interval)\n\n    if (intervalMs) {\n      this.interval = setInterval(() => {\n        this.announce(this.client._defaultAnnounceOpts())\n      }, intervalMs)\n      if (this.interval.unref) this.interval.unref()\n    }\n  }\n}\n\nexport default Tracker\n","import Debug from 'debug'\nimport Peer from '@thaunknown/simple-peer/lite.js'\nimport Socket from '@thaunknown/simple-websocket'\nimport { arr2text, arr2hex, hex2bin, bin2hex, randomBytes } from 'uint8-util'\n\nimport common from '../common.js'\nimport Tracker from './tracker.js'\n\nconst debug = Debug('bittorrent-tracker:websocket-tracker')\n\n// Use a socket pool, so tracker clients share WebSocket objects for the same server.\n// In practice, WebSockets are pretty slow to establish, so this gives a nice performance\n// boost, and saves browser resources.\nconst socketPool = {}\n\nconst RECONNECT_MINIMUM = 10 * 1000\nconst RECONNECT_MAXIMUM = 60 * 60 * 1000\nconst RECONNECT_VARIANCE = 5 * 60 * 1000\nconst OFFER_TIMEOUT = 50 * 1000\n\nclass WebSocketTracker extends Tracker {\n  constructor (client, announceUrl) {\n    super(client, announceUrl)\n    debug('new websocket tracker %s', announceUrl)\n\n    this.peers = {} // peers (offer id -> peer)\n    this.socket = null\n\n    this.reconnecting = false\n    this.retries = 0\n    this.reconnectTimer = null\n\n    // Simple boolean flag to track whether the socket has received data from\n    // the websocket server since the last time socket.send() was called.\n    this.expectingResponse = false\n\n    this._openSocket()\n  }\n\n  announce (opts) {\n    if (this.destroyed || this.reconnecting) return\n    if (!this.socket.connected) {\n      this.socket.once('connect', () => {\n        this.announce(opts)\n      })\n      return\n    }\n\n    const params = Object.assign({}, opts, {\n      action: 'announce',\n      info_hash: this.client._infoHashBinary,\n      peer_id: this.client._peerIdBinary\n    })\n    if (this._trackerId) params.trackerid = this._trackerId\n\n    if (opts.event === 'stopped' || opts.event === 'completed') {\n      // Don't include offers with 'stopped' or 'completed' event\n      this._send(params)\n    } else {\n      // Limit the number of offers that are generated, since it can be slow\n      const numwant = Math.min(opts.numwant, 10)\n\n      this._generateOffers(numwant, offers => {\n        params.numwant = numwant\n        params.offers = offers\n        this._send(params)\n      })\n    }\n  }\n\n  scrape (opts) {\n    if (this.destroyed || this.reconnecting) return\n    if (!this.socket.connected) {\n      this.socket.once('connect', () => {\n        this.scrape(opts)\n      })\n      return\n    }\n\n    const infoHashes = (Array.isArray(opts.infoHash) && opts.infoHash.length > 0)\n      ? opts.infoHash.map(infoHash => hex2bin(infoHash))\n      : (opts.infoHash && hex2bin(opts.infoHash)) || this.client._infoHashBinary\n    const params = {\n      action: 'scrape',\n      info_hash: infoHashes\n    }\n\n    this._send(params)\n  }\n\n  destroy (cb = noop) {\n    if (this.destroyed) return cb(null)\n\n    this.destroyed = true\n\n    clearInterval(this.interval)\n    clearTimeout(this.reconnectTimer)\n\n    // Destroy peers\n    for (const peerId in this.peers) {\n      const peer = this.peers[peerId]\n      clearTimeout(peer.trackerTimeout)\n      peer.destroy()\n    }\n    this.peers = null\n\n    if (this.socket) {\n      this.socket.removeListener('connect', this._onSocketConnectBound)\n      this.socket.removeListener('data', this._onSocketDataBound)\n      this.socket.removeListener('close', this._onSocketCloseBound)\n      this.socket.removeListener('error', this._onSocketErrorBound)\n      this.socket = null\n    }\n\n    this._onSocketConnectBound = null\n    this._onSocketErrorBound = null\n    this._onSocketDataBound = null\n    this._onSocketCloseBound = null\n\n    if (socketPool[this.announceUrl]) {\n      socketPool[this.announceUrl].consumers -= 1\n    }\n\n    // Other instances are using the socket, so there's nothing left to do here\n    if (socketPool[this.announceUrl].consumers > 0) return cb()\n\n    let socket = socketPool[this.announceUrl]\n    delete socketPool[this.announceUrl]\n    socket.on('error', noop) // ignore all future errors\n    socket.once('close', cb)\n\n    let timeout\n\n    // If there is no data response expected, destroy immediately.\n    if (!this.expectingResponse) return destroyCleanup()\n\n    // Otherwise, wait a short time for potential responses to come in from the\n    // server, then force close the socket.\n    timeout = setTimeout(destroyCleanup, common.DESTROY_TIMEOUT)\n\n    // But, if a response comes from the server before the timeout fires, do cleanup\n    // right away.\n    socket.once('data', destroyCleanup)\n\n    function destroyCleanup () {\n      if (timeout) {\n        clearTimeout(timeout)\n        timeout = null\n      }\n      socket.removeListener('data', destroyCleanup)\n      socket.destroy()\n      socket = null\n    }\n  }\n\n  _openSocket () {\n    this.destroyed = false\n\n    if (!this.peers) this.peers = {}\n\n    this._onSocketConnectBound = () => {\n      this._onSocketConnect()\n    }\n    this._onSocketErrorBound = err => {\n      this._onSocketError(err)\n    }\n    this._onSocketDataBound = data => {\n      this._onSocketData(data)\n    }\n    this._onSocketCloseBound = () => {\n      this._onSocketClose()\n    }\n\n    this.socket = socketPool[this.announceUrl]\n    if (this.socket) {\n      socketPool[this.announceUrl].consumers += 1\n      if (this.socket.connected) {\n        this._onSocketConnectBound()\n      }\n    } else {\n      const parsedUrl = new URL(this.announceUrl)\n      let agent\n      if (this.client._proxyOpts) {\n        agent = parsedUrl.protocol === 'wss:' ? this.client._proxyOpts.httpsAgent : this.client._proxyOpts.httpAgent\n        if (!agent && this.client._proxyOpts.socksProxy) {\n          agent = this.client._proxyOpts.socksProxy\n        }\n      }\n      this.socket = socketPool[this.announceUrl] = new Socket({ url: this.announceUrl, agent })\n      this.socket.consumers = 1\n      this.socket.once('connect', this._onSocketConnectBound)\n    }\n\n    this.socket.on('data', this._onSocketDataBound)\n    this.socket.once('close', this._onSocketCloseBound)\n    this.socket.once('error', this._onSocketErrorBound)\n  }\n\n  _onSocketConnect () {\n    if (this.destroyed) return\n\n    if (this.reconnecting) {\n      this.reconnecting = false\n      this.retries = 0\n      this.announce(this.client._defaultAnnounceOpts())\n    }\n  }\n\n  _onSocketData (data) {\n    if (this.destroyed) return\n\n    this.expectingResponse = false\n\n    try {\n      data = JSON.parse(arr2text(data))\n    } catch (err) {\n      this.client.emit('warning', new Error('Invalid tracker response'))\n      return\n    }\n\n    if (data.action === 'announce') {\n      this._onAnnounceResponse(data)\n    } else if (data.action === 'scrape') {\n      this._onScrapeResponse(data)\n    } else {\n      this._onSocketError(new Error(`invalid action in WS response: ${data.action}`))\n    }\n  }\n\n  _onAnnounceResponse (data) {\n    if (data.info_hash !== this.client._infoHashBinary) {\n      debug(\n        'ignoring websocket data from %s for %s (looking for %s: reused socket)',\n        this.announceUrl, bin2hex(data.info_hash), this.client.infoHash\n      )\n      return\n    }\n\n    if (data.peer_id && data.peer_id === this.client._peerIdBinary) {\n      // ignore offers/answers from this client\n      return\n    }\n\n    debug(\n      'received %s from %s for %s',\n      JSON.stringify(data), this.announceUrl, this.client.infoHash\n    )\n\n    const failure = data['failure reason']\n    if (failure) return this.client.emit('warning', new Error(failure))\n\n    const warning = data['warning message']\n    if (warning) this.client.emit('warning', new Error(warning))\n\n    const interval = data.interval || data['min interval']\n    if (interval) this.setInterval(interval * 1000)\n\n    const trackerId = data['tracker id']\n    if (trackerId) {\n      // If absent, do not discard previous trackerId value\n      this._trackerId = trackerId\n    }\n\n    if (data.complete != null) {\n      const response = Object.assign({}, data, {\n        announce: this.announceUrl,\n        infoHash: bin2hex(data.info_hash)\n      })\n      this.client.emit('update', response)\n    }\n\n    let peer\n    if (data.offer && data.peer_id) {\n      debug('creating peer (from remote offer)')\n      peer = this._createPeer()\n      peer.id = bin2hex(data.peer_id)\n      peer.once('signal', answer => {\n        const params = {\n          action: 'announce',\n          info_hash: this.client._infoHashBinary,\n          peer_id: this.client._peerIdBinary,\n          to_peer_id: data.peer_id,\n          answer,\n          offer_id: data.offer_id\n        }\n        if (this._trackerId) params.trackerid = this._trackerId\n        this._send(params)\n      })\n      this.client.emit('peer', peer)\n      peer.signal(data.offer)\n    }\n\n    if (data.answer && data.peer_id) {\n      const offerId = bin2hex(data.offer_id)\n      peer = this.peers[offerId]\n      if (peer) {\n        peer.id = bin2hex(data.peer_id)\n        this.client.emit('peer', peer)\n        peer.signal(data.answer)\n\n        clearTimeout(peer.trackerTimeout)\n        peer.trackerTimeout = null\n        delete this.peers[offerId]\n      } else {\n        debug(`got unexpected answer: ${JSON.stringify(data.answer)}`)\n      }\n    }\n  }\n\n  _onScrapeResponse (data) {\n    data = data.files || {}\n\n    const keys = Object.keys(data)\n    if (keys.length === 0) {\n      this.client.emit('warning', new Error('invalid scrape response'))\n      return\n    }\n\n    keys.forEach(infoHash => {\n      // TODO: optionally handle data.flags.min_request_interval\n      // (separate from announce interval)\n      const response = Object.assign(data[infoHash], {\n        announce: this.announceUrl,\n        infoHash: bin2hex(infoHash)\n      })\n      this.client.emit('scrape', response)\n    })\n  }\n\n  _onSocketClose () {\n    if (this.destroyed) return\n    this.destroy()\n    this._startReconnectTimer()\n  }\n\n  _onSocketError (err) {\n    if (this.destroyed) return\n    this.destroy()\n    // errors will often happen if a tracker is offline, so don't treat it as fatal\n    this.client.emit('warning', err)\n    this._startReconnectTimer()\n  }\n\n  _startReconnectTimer () {\n    const ms = Math.floor(Math.random() * RECONNECT_VARIANCE) + Math.min(Math.pow(2, this.retries) * RECONNECT_MINIMUM, RECONNECT_MAXIMUM)\n\n    this.reconnecting = true\n    clearTimeout(this.reconnectTimer)\n    this.reconnectTimer = setTimeout(() => {\n      this.retries++\n      this._openSocket()\n    }, ms)\n    if (this.reconnectTimer.unref) this.reconnectTimer.unref()\n\n    debug('reconnecting socket in %s ms', ms)\n  }\n\n  _send (params) {\n    if (this.destroyed) return\n    this.expectingResponse = true\n    const message = JSON.stringify(params)\n    debug('send %s', message)\n    this.socket.send(message)\n  }\n\n  _generateOffers (numwant, cb) {\n    const self = this\n    const offers = []\n    debug('generating %s offers', numwant)\n\n    for (let i = 0; i < numwant; ++i) {\n      generateOffer()\n    }\n    checkDone()\n\n    function generateOffer () {\n      const offerId = arr2hex(randomBytes(20))\n      debug('creating peer (from _generateOffers)')\n      const peer = self.peers[offerId] = self._createPeer({ initiator: true })\n      peer.once('signal', offer => {\n        offers.push({\n          offer,\n          offer_id: hex2bin(offerId)\n        })\n        checkDone()\n      })\n      peer.trackerTimeout = setTimeout(() => {\n        debug('tracker timeout: destroying peer')\n        peer.trackerTimeout = null\n        delete self.peers[offerId]\n        peer.destroy()\n      }, OFFER_TIMEOUT)\n      if (peer.trackerTimeout.unref) peer.trackerTimeout.unref()\n    }\n\n    function checkDone () {\n      if (offers.length === numwant) {\n        debug('generated %s offers', numwant)\n        cb(offers)\n      }\n    }\n  }\n\n  _createPeer (opts) {\n    const self = this\n\n    opts = Object.assign({\n      trickle: false,\n      config: self.client._rtcConfig,\n      wrtc: self.client._wrtc\n    }, opts)\n\n    const peer = new Peer(opts)\n\n    peer.once('error', onError)\n    peer.once('connect', onConnect)\n\n    return peer\n\n    // Handle peer 'error' events that are fired *before* the peer is emitted in\n    // a 'peer' event.\n    function onError (err) {\n      self.client.emit('warning', new Error(`Connection error: ${err.message}`))\n      peer.destroy()\n    }\n\n    // Once the peer is emitted in a 'peer' event, then it's the consumer's\n    // responsibility to listen for errors, so the listeners are removed here.\n    function onConnect () {\n      peer.removeListener('error', onError)\n      peer.removeListener('connect', onConnect)\n    }\n  }\n}\n\nWebSocketTracker.prototype.DEFAULT_ANNOUNCE_INTERVAL = 10 * 1000 // 30 seconds\n// Normally this shouldn't be accessed but is occasionally useful\nWebSocketTracker._socketPool = socketPool\n\nfunction noop () {}\n\nexport default WebSocketTracker\n","import Debug from 'debug'\nimport EventEmitter from 'events'\nimport once from 'once'\nimport parallel from 'run-parallel'\nimport Peer from '@thaunknown/simple-peer/lite.js'\nimport queueMicrotask from 'queue-microtask'\nimport { hex2arr, hex2bin, text2arr, arr2hex, arr2text } from 'uint8-util'\n\nimport common from './lib/common.js'\nimport HTTPTracker from './lib/client/http-tracker.js' // empty object in browser\nimport UDPTracker from './lib/client/udp-tracker.js' // empty object in browser\nimport WebSocketTracker from './lib/client/websocket-tracker.js'\n\nconst debug = Debug('bittorrent-tracker:client')\n\n/**\n * BitTorrent tracker client.\n *\n * Find torrent peers, to help a torrent client participate in a torrent swarm.\n *\n * @param {Object} opts                          options object\n * @param {string|Uint8Array} opts.infoHash          torrent info hash\n * @param {string|Uint8Array} opts.peerId            peer id\n * @param {string|Array.<string>} opts.announce  announce\n * @param {number} opts.port                     torrent client listening port\n * @param {function} opts.getAnnounceOpts        callback to provide data to tracker\n * @param {number} opts.rtcConfig                RTCPeerConnection configuration object\n * @param {number} opts.userAgent                User-Agent header for http requests\n * @param {number} opts.wrtc                     custom webrtc impl (useful in node.js)\n * @param {object} opts.proxyOpts                proxy options (useful in node.js)\n */\nclass Client extends EventEmitter {\n  constructor (opts = {}) {\n    super()\n\n    if (!opts.peerId) throw new Error('Option `peerId` is required')\n    if (!opts.infoHash) throw new Error('Option `infoHash` is required')\n    if (!opts.announce) throw new Error('Option `announce` is required')\n    if (!process.browser && !opts.port) throw new Error('Option `port` is required')\n\n    this.peerId = typeof opts.peerId === 'string'\n      ? opts.peerId\n      : arr2hex(opts.peerId)\n    this._peerIdBuffer = hex2arr(this.peerId)\n    this._peerIdBinary = hex2bin(this.peerId)\n\n    this.infoHash = typeof opts.infoHash === 'string'\n      ? opts.infoHash.toLowerCase()\n      : arr2hex(opts.infoHash)\n    this._infoHashBuffer = hex2arr(this.infoHash)\n    this._infoHashBinary = hex2bin(this.infoHash)\n\n    debug('new client %s', this.infoHash)\n\n    this.destroyed = false\n\n    this._port = opts.port\n    this._getAnnounceOpts = opts.getAnnounceOpts\n    this._rtcConfig = opts.rtcConfig\n    this._userAgent = opts.userAgent\n    this._proxyOpts = opts.proxyOpts\n\n    // Support lazy 'wrtc' module initialization\n    // See: https://github.com/webtorrent/webtorrent-hybrid/issues/46\n    this._wrtc = typeof opts.wrtc === 'function' ? opts.wrtc() : opts.wrtc\n\n    let announce = typeof opts.announce === 'string'\n      ? [opts.announce]\n      : opts.announce == null ? [] : opts.announce\n\n    // Remove trailing slash from trackers to catch duplicates\n    announce = announce.map(announceUrl => {\n      if (ArrayBuffer.isView(announceUrl)) announceUrl = arr2text(announceUrl)\n      if (announceUrl[announceUrl.length - 1] === '/') {\n        announceUrl = announceUrl.substring(0, announceUrl.length - 1)\n      }\n      return announceUrl\n    })\n    // remove duplicates by converting to Set and back\n    announce = Array.from(new Set(announce))\n\n    const webrtcSupport = this._wrtc !== false && (!!this._wrtc || Peer.WEBRTC_SUPPORT)\n\n    const nextTickWarn = err => {\n      queueMicrotask(() => {\n        this.emit('warning', err)\n      })\n    }\n\n    this._trackers = announce\n      .map(announceUrl => {\n        let parsedUrl\n        try {\n          parsedUrl = common.parseUrl(announceUrl)\n        } catch (err) {\n          nextTickWarn(new Error(`Invalid tracker URL: ${announceUrl}`))\n          return null\n        }\n\n        const port = parsedUrl.port\n        if (port < 0 || port > 65535) {\n          nextTickWarn(new Error(`Invalid tracker port: ${announceUrl}`))\n          return null\n        }\n\n        const protocol = parsedUrl.protocol\n        if ((protocol === 'http:' || protocol === 'https:') &&\n            typeof HTTPTracker === 'function') {\n          return new HTTPTracker(this, announceUrl)\n        } else if (protocol === 'udp:' && typeof UDPTracker === 'function') {\n          return new UDPTracker(this, announceUrl)\n        } else if ((protocol === 'ws:' || protocol === 'wss:') && webrtcSupport) {\n          // Skip ws:// trackers on https:// sites because they throw SecurityError\n          if (protocol === 'ws:' && typeof window !== 'undefined' &&\n              window.location.protocol === 'https:') {\n            nextTickWarn(new Error(`Unsupported tracker protocol: ${announceUrl}`))\n            return null\n          }\n          return new WebSocketTracker(this, announceUrl)\n        } else {\n          nextTickWarn(new Error(`Unsupported tracker protocol: ${announceUrl}`))\n          return null\n        }\n      })\n      .filter(Boolean)\n  }\n\n  /**\n   * Send a `start` announce to the trackers.\n   * @param {Object} opts\n   * @param {number=} opts.uploaded\n   * @param {number=} opts.downloaded\n   * @param {number=} opts.left (if not set, calculated automatically)\n   */\n  start (opts) {\n    opts = this._defaultAnnounceOpts(opts)\n    opts.event = 'started'\n    debug('send `start` %o', opts)\n    this._announce(opts)\n\n    // start announcing on intervals\n    this._trackers.forEach(tracker => {\n      tracker.setInterval()\n    })\n  }\n\n  /**\n   * Send a `stop` announce to the trackers.\n   * @param {Object} opts\n   * @param {number=} opts.uploaded\n   * @param {number=} opts.downloaded\n   * @param {number=} opts.numwant\n   * @param {number=} opts.left (if not set, calculated automatically)\n   */\n  stop (opts) {\n    opts = this._defaultAnnounceOpts(opts)\n    opts.event = 'stopped'\n    debug('send `stop` %o', opts)\n    this._announce(opts)\n  }\n\n  /**\n   * Send a `complete` announce to the trackers.\n   * @param {Object} opts\n   * @param {number=} opts.uploaded\n   * @param {number=} opts.downloaded\n   * @param {number=} opts.numwant\n   * @param {number=} opts.left (if not set, calculated automatically)\n   */\n  complete (opts) {\n    if (!opts) opts = {}\n    opts = this._defaultAnnounceOpts(opts)\n    opts.event = 'completed'\n    debug('send `complete` %o', opts)\n    this._announce(opts)\n  }\n\n  /**\n   * Send a `update` announce to the trackers.\n   * @param {Object} opts\n   * @param {number=} opts.uploaded\n   * @param {number=} opts.downloaded\n   * @param {number=} opts.numwant\n   * @param {number=} opts.left (if not set, calculated automatically)\n   */\n  update (opts) {\n    opts = this._defaultAnnounceOpts(opts)\n    if (opts.event) delete opts.event\n    debug('send `update` %o', opts)\n    this._announce(opts)\n  }\n\n  _announce (opts) {\n    this._trackers.forEach(tracker => {\n      // tracker should not modify `opts` object, it's passed to all trackers\n      tracker.announce(opts)\n    })\n  }\n\n  /**\n   * Send a scrape request to the trackers.\n   * @param {Object} opts\n   */\n  scrape (opts) {\n    debug('send `scrape`')\n    if (!opts) opts = {}\n    this._trackers.forEach(tracker => {\n      // tracker should not modify `opts` object, it's passed to all trackers\n      tracker.scrape(opts)\n    })\n  }\n\n  setInterval (intervalMs) {\n    debug('setInterval %d', intervalMs)\n    this._trackers.forEach(tracker => {\n      tracker.setInterval(intervalMs)\n    })\n  }\n\n  destroy (cb) {\n    if (this.destroyed) return\n    this.destroyed = true\n    debug('destroy')\n\n    const tasks = this._trackers.map(tracker => cb => {\n      tracker.destroy(cb)\n    })\n\n    parallel(tasks, cb)\n\n    this._trackers = []\n    this._getAnnounceOpts = null\n  }\n\n  _defaultAnnounceOpts (opts = {}) {\n    if (opts.numwant == null) opts.numwant = common.DEFAULT_ANNOUNCE_PEERS\n\n    if (opts.uploaded == null) opts.uploaded = 0\n    if (opts.downloaded == null) opts.downloaded = 0\n\n    if (this._getAnnounceOpts) opts = Object.assign({}, opts, this._getAnnounceOpts())\n\n    return opts\n  }\n}\n\n/**\n * Simple convenience function to scrape a tracker for an info hash without needing to\n * create a Client, pass it a parsed torrent, etc. Support scraping a tracker for multiple\n * torrents at the same time.\n * @params {Object} opts\n * @param  {string|Array.<string>} opts.infoHash\n * @param  {string} opts.announce\n * @param  {function} cb\n */\nClient.scrape = (opts, cb) => {\n  cb = once(cb)\n\n  if (!opts.infoHash) throw new Error('Option `infoHash` is required')\n  if (!opts.announce) throw new Error('Option `announce` is required')\n\n  const clientOpts = Object.assign({}, opts, {\n    infoHash: Array.isArray(opts.infoHash) ? opts.infoHash[0] : opts.infoHash,\n    peerId: text2arr('01234567890123456789'), // dummy value\n    port: 6881 // dummy value\n  })\n\n  const client = new Client(clientOpts)\n  client.once('error', cb)\n  client.once('warning', cb)\n\n  let len = Array.isArray(opts.infoHash) ? opts.infoHash.length : 1\n  const results = {}\n  client.on('scrape', data => {\n    len -= 1\n    results[data.infoHash] = data\n    if (len === 0) {\n      client.destroy()\n      const keys = Object.keys(results)\n      if (keys.length === 1) {\n        cb(null, results[keys[0]])\n      } else {\n        cb(null, results)\n      }\n    }\n  })\n\n  client.scrape({ infoHash: opts.infoHash })\n  return client\n}\n\nexport default Client\n","function FF(a, b, c, d, m, s, k) {\n\tvar n = a + (b & c | ~b & d) + (m >>> 0) + k;\n\treturn ((n << s) | (n >>> (32 - s))) + b;\n}\n\nfunction GG(a, b, c, d, m, s, k) {\n\tvar n = a + (b & d | c & ~d) + (m >>> 0) + k;\n\treturn ((n << s) | (n >>> (32 - s))) + b;\n}\n\nfunction HH(a, b, c, d, m, s, k) {\n\tvar n = a + (b ^ c ^ d) + (m >>> 0) + k;\n\treturn ((n << s) | (n >>> (32 - s))) + b;\n}\n\nfunction II(a, b, c, d, m, s, k) {\n\tvar n = a + (c ^ (b | ~d)) + (m >>> 0) + k;\n\treturn ((n << s) | (n >>> (32 - s))) + b;\n}\n\n\nfunction byteToHex(byte) {\n\treturn (256+(byte&255)).toString(16).substr(-2);\n}\n\n\nfunction bs(byte) {\n\treturn String.fromCharCode(byte & 255);\n}\n\nfunction wordToBytes(word) {\n\treturn bs(word) + bs(word >>> 8) + bs(word >>> 16) + bs(word >>> 24);\n}\n\n\n// converts utf8 string to bytes string\nvar utf8toBytes = function (utf8) {\n\treturn unescape(encodeURIComponent(utf8));\n};\n\n\n// converts bytes string to 32-bits words array padded with \"1\" and zeros and bits_length for MD5 message buffer\nfunction bytesToWords(bytes) {\n\tvar bytes_count = bytes.length,\n\t    bits_count = bytes_count << 3,\n\t    words = new Uint32Array((bytes_count + 72) >>> 6 << 4);\n\tfor (var i = 0, n = bytes.length; i < n; ++i)\n\t\twords[i >>> 2] |= bytes.charCodeAt(i) << ((i & 3) << 3);\n\twords[bytes_count >> 2] |= 0x80 << (bits_count & 31); // append \"1\" bit to message\n\twords[words.length - 2] = bits_count;\n\treturn words;\n}\n\n\nvar exports = module.exports = function md5(utf8) {\n\treturn utf8toMD5(utf8).toHex();\n};\n\nvar bytesToMD5 = exports.fromBytes = function (bytes) {\n\tvar words = bytesToWords(bytes),\n\t    a = 0x67452301,\n\t    b = 0xEFCDAB89,\n\t    c = 0x98BADCFE,\n\t    d = 0x10325476,\n\t    S11 = 7, S12 = 12, S13 = 17, S14 = 22,\n\t    S21 = 5, S22 = 9 , S23 = 14, S24 = 20,\n\t    S31 = 4, S32 = 11, S33 = 16, S34 = 23,\n\t    S41 = 6, S42 = 10, S43 = 15, S44 = 21;\n\n\tfor (var i = 0, ws = words.length; i < ws; i += 16) {\n\t\tvar AA = a, BB = b, CC = c, DD = d;\n\t\ta = FF(a, b, c, d, words[i+0], S11, 0xD76AA478);\n\t\td = FF(d, a, b, c, words[i+1], S12, 0xE8C7B756);\n\t\tc = FF(c, d, a, b, words[i+2], S13, 0x242070DB);\n\t\tb = FF(b, c, d, a, words[i+3], S14, 0xC1BDCEEE);\n\t\ta = FF(a, b, c, d, words[i+4], S11, 0xF57C0FAF);\n\t\td = FF(d, a, b, c, words[i+5], S12, 0x4787C62A);\n\t\tc = FF(c, d, a, b, words[i+6], S13, 0xA8304613);\n\t\tb = FF(b, c, d, a, words[i+7], S14, 0xFD469501);\n\t\ta = FF(a, b, c, d, words[i+8], S11, 0x698098D8);\n\t\td = FF(d, a, b, c, words[i+9], S12, 0x8B44F7AF);\n\t\tc = FF(c, d, a, b, words[i+10],S13, 0xFFFF5BB1);\n\t\tb = FF(b, c, d, a, words[i+11],S14, 0x895CD7BE);\n\t\ta = FF(a, b, c, d, words[i+12],S11, 0x6B901122);\n\t\td = FF(d, a, b, c, words[i+13],S12, 0xFD987193);\n\t\tc = FF(c, d, a, b, words[i+14],S13, 0xA679438E);\n\t\tb = FF(b, c, d, a, words[i+15],S14, 0x49B40821);\n\t\ta = GG(a, b, c, d, words[i+1], S21, 0xF61E2562);\n\t\td = GG(d, a, b, c, words[i+6], S22, 0xC040B340);\n\t\tc = GG(c, d, a, b, words[i+11],S23, 0x265E5A51);\n\t\tb = GG(b, c, d, a, words[i+0], S24, 0xE9B6C7AA);\n\t\ta = GG(a, b, c, d, words[i+5], S21, 0xD62F105D);\n\t\td = GG(d, a, b, c, words[i+10],S22, 0x2441453);\n\t\tc = GG(c, d, a, b, words[i+15],S23, 0xD8A1E681);\n\t\tb = GG(b, c, d, a, words[i+4], S24, 0xE7D3FBC8);\n\t\ta = GG(a, b, c, d, words[i+9], S21, 0x21E1CDE6);\n\t\td = GG(d, a, b, c, words[i+14],S22, 0xC33707D6);\n\t\tc = GG(c, d, a, b, words[i+3], S23, 0xF4D50D87);\n\t\tb = GG(b, c, d, a, words[i+8], S24, 0x455A14ED);\n\t\ta = GG(a, b, c, d, words[i+13],S21, 0xA9E3E905);\n\t\td = GG(d, a, b, c, words[i+2], S22, 0xFCEFA3F8);\n\t\tc = GG(c, d, a, b, words[i+7], S23, 0x676F02D9);\n\t\tb = GG(b, c, d, a, words[i+12],S24, 0x8D2A4C8A);\n\t\ta = HH(a, b, c, d, words[i+5], S31, 0xFFFA3942);\n\t\td = HH(d, a, b, c, words[i+8], S32, 0x8771F681);\n\t\tc = HH(c, d, a, b, words[i+11],S33, 0x6D9D6122);\n\t\tb = HH(b, c, d, a, words[i+14],S34, 0xFDE5380C);\n\t\ta = HH(a, b, c, d, words[i+1], S31, 0xA4BEEA44);\n\t\td = HH(d, a, b, c, words[i+4], S32, 0x4BDECFA9);\n\t\tc = HH(c, d, a, b, words[i+7], S33, 0xF6BB4B60);\n\t\tb = HH(b, c, d, a, words[i+10],S34, 0xBEBFBC70);\n\t\ta = HH(a, b, c, d, words[i+13],S31, 0x289B7EC6);\n\t\td = HH(d, a, b, c, words[i+0], S32, 0xEAA127FA);\n\t\tc = HH(c, d, a, b, words[i+3], S33, 0xD4EF3085);\n\t\tb = HH(b, c, d, a, words[i+6], S34, 0x4881D05);\n\t\ta = HH(a, b, c, d, words[i+9], S31, 0xD9D4D039);\n\t\td = HH(d, a, b, c, words[i+12],S32, 0xE6DB99E5);\n\t\tc = HH(c, d, a, b, words[i+15],S33, 0x1FA27CF8);\n\t\tb = HH(b, c, d, a, words[i+2], S34, 0xC4AC5665);\n\t\ta = II(a, b, c, d, words[i+0], S41, 0xF4292244);\n\t\td = II(d, a, b, c, words[i+7], S42, 0x432AFF97);\n\t\tc = II(c, d, a, b, words[i+14],S43, 0xAB9423A7);\n\t\tb = II(b, c, d, a, words[i+5], S44, 0xFC93A039);\n\t\ta = II(a, b, c, d, words[i+12],S41, 0x655B59C3);\n\t\td = II(d, a, b, c, words[i+3], S42, 0x8F0CCC92);\n\t\tc = II(c, d, a, b, words[i+10],S43, 0xFFEFF47D);\n\t\tb = II(b, c, d, a, words[i+1], S44, 0x85845DD1);\n\t\ta = II(a, b, c, d, words[i+8], S41, 0x6FA87E4F);\n\t\td = II(d, a, b, c, words[i+15],S42, 0xFE2CE6E0);\n\t\tc = II(c, d, a, b, words[i+6], S43, 0xA3014314);\n\t\tb = II(b, c, d, a, words[i+13],S44, 0x4E0811A1);\n\t\ta = II(a, b, c, d, words[i+4], S41, 0xF7537E82);\n\t\td = II(d, a, b, c, words[i+11],S42, 0xBD3AF235);\n\t\tc = II(c, d, a, b, words[i+2], S43, 0x2AD7D2BB);\n\t\tb = II(b, c, d, a, words[i+9], S44, 0xEB86D391);\n\t\ta = (a + AA) >>> 0;\n\t\tb = (b + BB) >>> 0;\n\t\tc = (c + CC) >>> 0;\n\t\td = (d + DD) >>> 0;\n\t}\n\n\tvar hash_bytes = new String(wordToBytes(a) + wordToBytes(b) + wordToBytes(c) + wordToBytes(d));\n\thash_bytes.toHex = function () {\n\t\tvar hex = '';\n\t\tfor (var i = 0, n = hash_bytes.length; i < n; ++i)\n\t\t\thex += byteToHex(hash_bytes.charCodeAt(i));\n\t\treturn hex;\n\t};\n\treturn hash_bytes;\n};\n\n\nvar utf8toMD5 = exports.fromUtf8 = function (utf8) {\n\treturn bytesToMD5(utf8toBytes(utf8));\n};\n\n\n\nvar b64 = './0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';\n\nfunction to64(u, n) {\n\tfor (var s = ''; --n >= 0; u >>>= 6)\n\t\ts += b64.charAt(u & 63);\n\treturn s;\n}\n\n\nvar MAX_KEY_LENGTH = 64,\n    b64_map = [ 0,6,12, 1,7,13, 2,8,14, 3,9,15, 4,10,5, 11 ];\n\n\nvar gen_salt = exports.salt = function (n) {\n\tvar s = '';\n\tif (!n)\n\t\tn = 8;\n\tdo {\n\t\ts += b64.charAt( 64*Math.random() >>> 0 );\n\t} while (--n);\n\treturn s;\n};\n\n\nexports.crypt = function (key, setting) {\n\n\tif (key.length > MAX_KEY_LENGTH)\n\t\tthrow Error(\"too long key\");\n\n\tif (!setting)\n\t\tsetting = '$1$'+gen_salt();\n\n\tkey = utf8toBytes(key);\n\n\tvar salt = utf8toBytes(setting.replace(/^\\$1\\$([^$]+)(?:\\$.*)?$/, '$1')),\n\t    md = bytesToMD5(key + salt + key),\n\t    s = key + '$1$' + salt;\n\n\tfor (var kl = key.length; kl > 16; kl -= 16)\n\t\ts += md;\n\n\ts += md.slice(0, kl);\n\n\tfor (var kl = key.length; kl; kl >>= 1)\n\t\ts += kl & 1 ? \"\\0\" : key.charAt(0);\n\n\tmd = bytesToMD5(s);\n\n\tfor (var i = 0; i < 1000; ++i)\n\t\tmd = bytesToMD5((i & 1 ? key : md) + (i % 3 ? salt : '') + (i % 7 ? key : '') + (i & 1 ? md : key));\n\n\tvar h = '$1$'+salt+'$';\n\n\tfor (var i = 0; i < 15; i += 3)\n\t\th += to64(\n\t\t\tmd.charCodeAt(b64_map[i+0]) << 16 |\n\t\t\tmd.charCodeAt(b64_map[i+1]) << 8 |\n\t\t\tmd.charCodeAt(b64_map[i+2]), 4);\n\n\treturn h + to64(md.charCodeAt(b64_map[15]), 2);\n};\n","export const PACKAGE_VERSION = \"2.2.2\";\n","import md5 from \"nano-md5\";\nimport { PACKAGE_VERSION } from \"./version.js\";\n\nexport const TRACKER_CLIENT_VERSION_PREFIX = `-PM${formatVersion(PACKAGE_VERSION)}-`;\n\nconst HASH_SYMBOLS =\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\nconst PEER_ID_LENGTH = 20;\n\nexport function getStreamHash(streamId: string): string {\n  // slice one byte to have 15 bytes binary string\n  const binary15BytesHashString = md5.fromUtf8(streamId).slice(1);\n  const base64Hash20CharsString = btoa(binary15BytesHashString);\n  return base64Hash20CharsString;\n}\n\nexport function generatePeerId(trackerClientVersionPrefix: string): string {\n  const trackerClientId = [trackerClientVersionPrefix];\n  const randomCharsCount = PEER_ID_LENGTH - trackerClientVersionPrefix.length;\n\n  for (let i = 0; i < randomCharsCount; i++) {\n    trackerClientId.push(\n      HASH_SYMBOLS[Math.floor(Math.random() * HASH_SYMBOLS.length)],\n    );\n  }\n\n  return trackerClientId.join(\"\");\n}\n\nfunction formatVersion(versionString: string) {\n  const splittedVersion = versionString.split(\".\");\n\n  return `${splittedVersion[0].padStart(2, \"0\")}${splittedVersion[1].padStart(2, \"0\")}`;\n}\n","import { SegmentWithStream, Stream } from \"../types.js\";\nimport { SegmentPlaybackStatuses } from \"./stream.js\";\n\nexport function getStreamString(stream: Stream) {\n  return `${stream.type}-${stream.index}`;\n}\n\nexport function getSegmentString(segment: SegmentWithStream) {\n  const { externalId } = segment;\n  return `(${getStreamString(segment.stream)} | ${externalId})`;\n}\n\nexport function getSegmentPlaybackStatusesString(\n  statuses: SegmentPlaybackStatuses,\n): string {\n  const { isHighDemand, isHttpDownloadable, isP2PDownloadable } = statuses;\n  if (isHighDemand) return \"high-demand\";\n  if (isHttpDownloadable && isP2PDownloadable) return \"http-p2p-window\";\n  if (isHttpDownloadable) return \"http-window\";\n  if (isP2PDownloadable) return \"p2p-window\";\n  return \"-\";\n}\n","import { CommonCoreConfig, CoreConfig, StreamConfig } from \"../types.js\";\n\nexport function getControlledPromise<T = void>() {\n  let resolve: (value: T) => void;\n  let reject: (reason?: unknown) => void;\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return {\n    promise,\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    resolve: resolve!,\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    reject: reject!,\n  };\n}\n\nexport function joinChunks(chunks: Uint8Array[], totalBytes?: number) {\n  totalBytes ??= chunks.reduce((sum, chunk) => sum + chunk.byteLength, 0);\n\n  const buffer = new Uint8Array(totalBytes);\n  let offset = 0;\n  for (const chunk of chunks) {\n    buffer.set(chunk, offset);\n    offset += chunk.byteLength;\n  }\n\n  return buffer;\n}\n\nexport function getPercent(numerator: number, denominator: number): number {\n  return (numerator / denominator) * 100;\n}\n\nexport function getRandomItem<T>(items: T[]): T {\n  return items[Math.floor(Math.random() * items.length)];\n}\n\nexport function utf8ToUintArray(utf8String: string): Uint8Array {\n  const encoder = new TextEncoder();\n  const bytes = new Uint8Array(utf8String.length);\n  encoder.encodeInto(utf8String, bytes);\n  return bytes;\n}\n\nexport function hexToUtf8(hexString: string) {\n  const bytes = new Uint8Array(hexString.length / 2);\n\n  for (let i = 0; i < hexString.length; i += 2) {\n    bytes[i / 2] = parseInt(hexString.slice(i, i + 2), 16);\n  }\n  const decoder = new TextDecoder();\n  return decoder.decode(bytes);\n}\n\nexport function* arrayBackwards<T>(arr: T[]) {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    yield arr[i];\n  }\n}\n\nfunction isObject(item: unknown): item is Record<string, unknown> {\n  return !!item && typeof item === \"object\" && !Array.isArray(item);\n}\n\nfunction isArray(item: unknown): item is unknown[] {\n  return Array.isArray(item);\n}\n\nexport function filterUndefinedProps<T extends object>(obj: T): Partial<T> {\n  function filter(obj: unknown): unknown {\n    if (isObject(obj)) {\n      const result: Record<string, unknown> = {};\n      Object.keys(obj).forEach((key) => {\n        if (obj[key] !== undefined) {\n          const value = filter(obj[key]);\n          if (value !== undefined) {\n            result[key] = value;\n          }\n        }\n      });\n      return result;\n    } else {\n      return obj;\n    }\n  }\n\n  return filter(obj) as Partial<T>;\n}\n\nexport function deepCopy<T>(item: T): T {\n  if (isArray(item)) {\n    return item.map((element) => deepCopy(element)) as T;\n  } else if (isObject(item)) {\n    const copy = {} as Record<string, unknown>;\n    for (const key of Object.keys(item)) {\n      copy[key] = deepCopy(item[key]);\n    }\n    return copy as T;\n  } else {\n    return item;\n  }\n}\n\nexport function shuffleArray<T>(array: T[]): T[] {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n  return array;\n}\n\ntype RecursivePartial<T> = {\n  [P in keyof T]?: T[P] extends object ? RecursivePartial<T[P]> : T[P];\n};\n\nexport function overrideConfig<T>(\n  target: T,\n  updates: RecursivePartial<T> | null,\n  defaults: RecursivePartial<T> = {} as RecursivePartial<T>,\n): T {\n  if (\n    typeof target !== \"object\" ||\n    target === null ||\n    typeof updates !== \"object\" ||\n    updates === null\n  ) {\n    return target;\n  }\n\n  (Object.keys(updates) as (keyof T)[]).forEach((key) => {\n    const keyStr = typeof key === \"symbol\" ? key.toString() : String(key);\n    if (key === \"__proto__\" || key === \"constructor\" || key === \"prototype\") {\n      throw new Error(`Attempt to modify restricted property '${keyStr}'`);\n    }\n\n    const updateValue = updates[key];\n    const defaultValue = defaults[key];\n\n    if (key in target) {\n      if (updateValue === undefined) {\n        target[key] =\n          defaultValue === undefined\n            ? (undefined as (T & object)[keyof T])\n            : (defaultValue as (T & object)[keyof T]);\n      } else {\n        target[key] = updateValue as (T & object)[keyof T];\n      }\n    }\n  });\n\n  return target;\n}\n\ntype MergeConfigsToTypeOptions = {\n  defaultConfig: StreamConfig | CommonCoreConfig | CoreConfig;\n  baseConfig?: Partial<CoreConfig>;\n  specificStreamConfig?: Partial<StreamConfig>;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-unnecessary-type-parameters\nexport function mergeAndFilterConfig<T>(options: MergeConfigsToTypeOptions) {\n  const { defaultConfig, baseConfig = {}, specificStreamConfig = {} } = options;\n\n  const mergedConfig = deepCopy({\n    ...defaultConfig,\n    ...baseConfig,\n    ...specificStreamConfig,\n  });\n\n  const keysOfT = Object.keys(defaultConfig) as (keyof T)[];\n  const filteredConfig: Partial<T> = {};\n\n  keysOfT.forEach((key) => {\n    if (key in mergedConfig) {\n      filteredConfig[key] = mergedConfig[\n        key as keyof typeof mergedConfig\n      ] as T[keyof T];\n    }\n  });\n\n  return filteredConfig as T;\n}\n","type BasePeerCommand<T extends PeerCommandType = PeerCommandType> = {\n  c: T;\n};\n\nexport const enum PeerCommandType {\n  SegmentsAnnouncement,\n  SegmentRequest,\n  SegmentData,\n  SegmentDataSendingCompleted,\n  SegmentAbsent,\n  CancelSegmentRequest,\n}\n\nexport type PeerSegmentCommand = BasePeerCommand<\n  | PeerCommandType.SegmentAbsent\n  | PeerCommandType.CancelSegmentRequest\n  | PeerCommandType.SegmentDataSendingCompleted\n> & {\n  i: number; // segment id\n  r: number; // request id\n};\n\nexport type PeerRequestSegmentCommand =\n  BasePeerCommand<PeerCommandType.SegmentRequest> & {\n    i: number; // segment id\n    r: number; // request id\n    b?: number; // byte from\n  };\n\nexport type PeerSegmentAnnouncementCommand =\n  BasePeerCommand<PeerCommandType.SegmentsAnnouncement> & {\n    l?: number[]; // loaded segments\n    p?: number[]; // segments loading by http\n  };\n\nexport type PeerSendSegmentCommand =\n  BasePeerCommand<PeerCommandType.SegmentData> & {\n    i: number; // segment id\n    r: number; // request id\n    s: number; // size in bytes\n  };\n\nexport type PeerCommand =\n  | PeerSegmentCommand\n  | PeerRequestSegmentCommand\n  | PeerSegmentAnnouncementCommand\n  | PeerSendSegmentCommand;\n","import { joinChunks } from \"../../utils/utils.js\";\n\n// restricted up to 16 item types (4 bits to type definition)\nexport const enum SerializedItem {\n  Min = -1,\n  Int,\n  SimilarIntArray,\n  String,\n  Max,\n}\n\nfunction abs(num: bigint): bigint {\n  return num < 0 ? -num : num;\n}\n\nfunction getRequiredBytesForInt(num: bigint): number {\n  const binaryString = num.toString(2);\n  const necessaryBits = num < 0 ? binaryString.length : binaryString.length + 1;\n  return Math.ceil(necessaryBits / 8);\n}\n\nfunction intToBytes(num: bigint): Uint8Array {\n  const isNegative = num < 0;\n  const bytesAmountNumber = getRequiredBytesForInt(num);\n  const bytes = new Uint8Array(bytesAmountNumber);\n  const bytesAmount = BigInt(bytesAmountNumber);\n\n  num = abs(num);\n  for (let i = 0; i < bytesAmountNumber; i++) {\n    const shift = 8n * (bytesAmount - 1n - BigInt(i));\n    const byte = (num >> shift) & 0xffn;\n    bytes[i] = Number(byte);\n  }\n\n  if (isNegative) bytes[0] = bytes[0] | 0b10000000;\n  return bytes;\n}\n\nfunction bytesToInt(bytes: Uint8Array): bigint {\n  const byteLength = BigInt(bytes.length);\n  const getNumberPart = (byte: number, i: number): bigint => {\n    const shift = 8n * (byteLength - 1n - BigInt(i));\n    return BigInt(byte) << shift;\n  };\n\n  // ignore first bit of first byte as it is sign bit\n  let number = getNumberPart(bytes[0] & 0b01111111, 0);\n  for (let i = 1; i < byteLength; i++) {\n    number = getNumberPart(bytes[i], i) | number;\n  }\n  if ((bytes[0] & 0b10000000) >> 7 !== 0) number = -number;\n\n  return number;\n}\n\nexport function serializeInt(num: bigint): Uint8Array {\n  const numBytes = intToBytes(num);\n  const numberMetadata = (SerializedItem.Int << 4) | numBytes.length;\n  return new Uint8Array([numberMetadata, ...numBytes]);\n}\n\nexport function deserializeInt(bytes: Uint8Array) {\n  const metadata = bytes[0];\n  const code: SerializedItem = metadata >> 4;\n  if (code !== SerializedItem.Int) {\n    throw new Error(\n      \"Trying to deserialize integer with invalid serialized item code\",\n    );\n  }\n  const numberBytesLength = metadata & 0b1111;\n  const start = 1;\n  const end = start + numberBytesLength;\n  return {\n    number: bytesToInt(bytes.slice(start, end)),\n    byteLength: numberBytesLength + 1,\n  };\n}\n\nexport function serializeSimilarIntArray(numbers: bigint[]) {\n  const commonPartNumbersMap = new Map<bigint, ResizableUint8Array>();\n\n  for (const number of numbers) {\n    const common = number & ~0xffn;\n    const diffByte = number & 0xffn;\n    const bytes = commonPartNumbersMap.get(common) ?? new ResizableUint8Array();\n    if (!bytes.length) commonPartNumbersMap.set(common, bytes);\n    bytes.push(Number(diffByte));\n  }\n\n  const result = new ResizableUint8Array();\n  result.push([SerializedItem.SimilarIntArray << 4, commonPartNumbersMap.size]);\n\n  for (const [commonPart, binaryArray] of commonPartNumbersMap) {\n    const { length } = binaryArray.getBytesChunks();\n    const commonPartWithLength = commonPart | (BigInt(length) & 0xffn);\n    binaryArray.unshift(serializeInt(commonPartWithLength));\n    result.push(binaryArray.getBuffer());\n  }\n\n  return result.getBuffer();\n}\n\nexport function deserializeSimilarIntArray(bytes: Uint8Array) {\n  const [codeByte, commonPartArraysAmount] = bytes;\n  const code: SerializedItem = codeByte >> 4;\n  if (code !== SerializedItem.SimilarIntArray) {\n    throw new Error(\n      \"Trying to deserialize similar int array with invalid serialized item code\",\n    );\n  }\n\n  let offset = 2;\n  const originalIntArr: bigint[] = [];\n  for (let i = 0; i < commonPartArraysAmount; i++) {\n    const { number: commonPartWithLength, byteLength } = deserializeInt(\n      bytes.slice(offset),\n    );\n    offset += byteLength;\n    const arrayLength = commonPartWithLength & 0xffn;\n    const commonPart = commonPartWithLength & ~0xffn;\n\n    for (let j = 0; j < arrayLength; j++) {\n      const diffPart = BigInt(bytes[offset]);\n      originalIntArr.push(commonPart | diffPart);\n      offset++;\n    }\n  }\n\n  return { numbers: originalIntArr, byteLength: offset };\n}\n\nexport function serializeString(string: string) {\n  const { length } = string;\n  const bytes = new ResizableUint8Array();\n  bytes.push([\n    (SerializedItem.String << 4) | ((length >> 8) & 0x0f),\n    length & 0xff,\n  ]);\n  bytes.push(new TextEncoder().encode(string));\n  return bytes.getBuffer();\n}\n\nexport function deserializeString(bytes: Uint8Array) {\n  const [codeByte, lengthByte] = bytes;\n  const code: SerializedItem = codeByte >> 4;\n  if (code !== SerializedItem.String) {\n    throw new Error(\n      \"Trying to deserialize bytes (sting) with invalid serialized item code.\",\n    );\n  }\n  const length = ((codeByte & 0x0f) << 8) | lengthByte;\n  const stringBytes = bytes.slice(2, length + 2);\n  const string = new TextDecoder(\"utf8\").decode(stringBytes);\n  return { string, byteLength: length + 2 };\n}\n\nexport class ResizableUint8Array {\n  private bytes: Uint8Array[] = [];\n  private _length = 0;\n\n  push(bytes: Uint8Array | number | number[]) {\n    this.addBytes(bytes, \"end\");\n  }\n\n  unshift(bytes: Uint8Array | number | number[]) {\n    this.addBytes(bytes, \"start\");\n  }\n\n  private addBytes(\n    bytes: Uint8Array | number | number[],\n    position: \"start\" | \"end\",\n  ) {\n    let bytesToAdd: Uint8Array;\n    if (bytes instanceof Uint8Array) {\n      bytesToAdd = bytes;\n    } else if (Array.isArray(bytes)) {\n      bytesToAdd = new Uint8Array(bytes);\n    } else {\n      bytesToAdd = new Uint8Array([bytes]);\n    }\n    this._length += bytesToAdd.length;\n    this.bytes[position === \"start\" ? \"unshift\" : \"push\"](bytesToAdd);\n  }\n\n  getBytesChunks(): readonly Uint8Array[] {\n    return this.bytes;\n  }\n\n  getBuffer(): Uint8Array {\n    return joinChunks(this.bytes, this._length);\n  }\n\n  get length() {\n    return this._length;\n  }\n}\n","import * as Serialization from \"./binary-serialization.js\";\nimport { PeerCommandType, PeerCommand } from \"./types.js\";\n\nconst FRAME_PART_LENGTH = 4;\nconst commandFrameStart = stringToUtf8CodesBuffer(\"cstr\", FRAME_PART_LENGTH);\nconst commandFrameEnd = stringToUtf8CodesBuffer(\"cend\", FRAME_PART_LENGTH);\nconst commandDivFrameStart = stringToUtf8CodesBuffer(\"dstr\", FRAME_PART_LENGTH);\nconst commandDivFrameEnd = stringToUtf8CodesBuffer(\"dend\", FRAME_PART_LENGTH);\nconst startFrames = [commandFrameStart, commandDivFrameStart];\nconst endFrames = [commandFrameEnd, commandDivFrameEnd];\nconst commandFramesLength = commandFrameStart.length + commandFrameEnd.length;\n\nexport function isCommandChunk(buffer: Uint8Array) {\n  const { length } = commandFrameStart;\n  const bufferEndingToCompare = buffer.slice(-length);\n  return (\n    startFrames.some((frame) =>\n      areBuffersEqual(buffer, frame, FRAME_PART_LENGTH),\n    ) &&\n    endFrames.some((frame) =>\n      areBuffersEqual(bufferEndingToCompare, frame, FRAME_PART_LENGTH),\n    )\n  );\n}\n\nfunction isFirstCommandChunk(buffer: Uint8Array) {\n  return areBuffersEqual(buffer, commandFrameStart, FRAME_PART_LENGTH);\n}\n\nfunction isLastCommandChunk(buffer: Uint8Array) {\n  return areBuffersEqual(\n    buffer.slice(-FRAME_PART_LENGTH),\n    commandFrameEnd,\n    FRAME_PART_LENGTH,\n  );\n}\n\nexport class BinaryCommandJoiningError extends Error {\n  constructor(readonly type: \"incomplete-joining\" | \"no-first-chunk\") {\n    super();\n  }\n}\n\nexport class BinaryCommandChunksJoiner {\n  private readonly chunks = new Serialization.ResizableUint8Array();\n  private status: \"joining\" | \"completed\" = \"joining\";\n\n  constructor(\n    private readonly onComplete: (commandBuffer: Uint8Array) => void,\n  ) {}\n\n  addCommandChunk(chunk: Uint8Array) {\n    if (this.status === \"completed\") return;\n\n    const isFirstChunk = isFirstCommandChunk(chunk);\n    if (!this.chunks.length && !isFirstChunk) {\n      throw new BinaryCommandJoiningError(\"no-first-chunk\");\n    }\n    if (this.chunks.length && isFirstChunk) {\n      throw new BinaryCommandJoiningError(\"incomplete-joining\");\n    }\n    this.chunks.push(this.unframeCommandChunk(chunk));\n\n    if (!isLastCommandChunk(chunk)) return;\n    this.status = \"completed\";\n    this.onComplete(this.chunks.getBuffer());\n  }\n\n  private unframeCommandChunk(chunk: Uint8Array) {\n    return chunk.slice(FRAME_PART_LENGTH, chunk.length - FRAME_PART_LENGTH);\n  }\n}\n\nexport class BinaryCommandCreator {\n  private readonly bytes = new Serialization.ResizableUint8Array();\n  private resultBuffers: Uint8Array[] = [];\n  private status: \"creating\" | \"completed\" = \"creating\";\n\n  constructor(\n    commandType: PeerCommandType,\n    private readonly maxChunkLength: number,\n  ) {\n    this.bytes.push(commandType);\n  }\n\n  addInteger(name: string, value: number) {\n    this.bytes.push(name.charCodeAt(0));\n    const bytes = Serialization.serializeInt(BigInt(value));\n    this.bytes.push(bytes);\n  }\n\n  addSimilarIntArr(name: string, arr: number[]) {\n    this.bytes.push(name.charCodeAt(0));\n    const bytes = Serialization.serializeSimilarIntArray(\n      arr.map((num) => BigInt(num)),\n    );\n    this.bytes.push(bytes);\n  }\n\n  addString(name: string, string: string) {\n    this.bytes.push(name.charCodeAt(0));\n    const bytes = Serialization.serializeString(string);\n    this.bytes.push(bytes);\n  }\n\n  complete() {\n    if (!this.bytes.length) throw new Error(\"Buffer is empty\");\n    if (this.status === \"completed\") return;\n    this.status = \"completed\";\n\n    const unframedBuffer = this.bytes.getBuffer();\n    if (unframedBuffer.length + commandFramesLength <= this.maxChunkLength) {\n      this.resultBuffers.push(\n        frameBuffer(unframedBuffer, commandFrameStart, commandFrameEnd),\n      );\n      return;\n    }\n\n    let chunksCount = Math.ceil(unframedBuffer.length / this.maxChunkLength);\n    if (\n      Math.ceil(unframedBuffer.length / chunksCount) + commandFramesLength >\n      this.maxChunkLength\n    ) {\n      chunksCount++;\n    }\n\n    for (const [i, chunk] of splitBufferToEqualChunks(\n      unframedBuffer,\n      chunksCount,\n    )) {\n      if (i === 0) {\n        this.resultBuffers.push(\n          frameBuffer(chunk, commandFrameStart, commandDivFrameEnd),\n        );\n      } else if (i === chunksCount - 1) {\n        this.resultBuffers.push(\n          frameBuffer(chunk, commandDivFrameStart, commandFrameEnd),\n        );\n      } else {\n        this.resultBuffers.push(\n          frameBuffer(chunk, commandDivFrameStart, commandDivFrameEnd),\n        );\n      }\n    }\n  }\n\n  getResultBuffers(): Uint8Array[] {\n    if (this.status === \"creating\" || !this.resultBuffers.length) {\n      throw new Error(\"Command is not complete.\");\n    }\n    return this.resultBuffers;\n  }\n}\n\nexport function deserializeCommand(bytes: Uint8Array): PeerCommand {\n  const [commandCode] = bytes;\n  const deserializedCommand: Record<string, unknown> = {\n    c: commandCode,\n  };\n\n  let offset = 1;\n  while (offset < bytes.length) {\n    const name = String.fromCharCode(bytes[offset]);\n    offset++;\n    const dataType = getDataTypeFromByte(bytes[offset]);\n\n    switch (dataType) {\n      case Serialization.SerializedItem.Int:\n        {\n          const { number, byteLength } = Serialization.deserializeInt(\n            bytes.slice(offset),\n          );\n          deserializedCommand[name] = Number(number);\n          offset += byteLength;\n        }\n        break;\n      case Serialization.SerializedItem.SimilarIntArray:\n        {\n          const { numbers, byteLength } =\n            Serialization.deserializeSimilarIntArray(bytes.slice(offset));\n          deserializedCommand[name] = numbers.map((n) => Number(n));\n          offset += byteLength;\n        }\n        break;\n      case Serialization.SerializedItem.String:\n        {\n          const { string, byteLength } = Serialization.deserializeString(\n            bytes.slice(offset),\n          );\n          deserializedCommand[name] = string;\n          offset += byteLength;\n        }\n        break;\n    }\n  }\n  return deserializedCommand as unknown as PeerCommand;\n}\n\nfunction getDataTypeFromByte(byte: number): Serialization.SerializedItem {\n  const typeCode: Serialization.SerializedItem = byte >> 4;\n  if (\n    typeCode <= Serialization.SerializedItem.Min ||\n    typeCode >= Serialization.SerializedItem.Max\n  ) {\n    throw new Error(\"Not existing type\");\n  }\n\n  return typeCode;\n}\n\nfunction stringToUtf8CodesBuffer(string: string, length?: number): Uint8Array {\n  if (length && string.length !== length) {\n    throw new Error(\"Wrong string length\");\n  }\n  const buffer = new Uint8Array(length ?? string.length);\n  for (let i = 0; i < string.length; i++) buffer[i] = string.charCodeAt(i);\n  return buffer;\n}\n\nfunction* splitBufferToEqualChunks(\n  buffer: Uint8Array,\n  chunksCount: number,\n): Generator<[number, Uint8Array], void> {\n  const chunkLength = Math.ceil(buffer.length / chunksCount);\n  for (let i = 0; i < chunksCount; i++) {\n    yield [i, buffer.slice(i * chunkLength, (i + 1) * chunkLength)];\n  }\n}\n\nfunction frameBuffer(\n  buffer: Uint8Array,\n  frameStart: Uint8Array,\n  frameEnd: Uint8Array,\n) {\n  const result = new Uint8Array(\n    buffer.length + frameStart.length + frameEnd.length,\n  );\n  result.set(frameStart);\n  result.set(buffer, frameStart.length);\n  result.set(frameEnd, frameStart.length + buffer.length);\n\n  return result;\n}\n\nfunction areBuffersEqual(\n  buffer1: Uint8Array,\n  buffer2: Uint8Array,\n  length: number,\n) {\n  for (let i = 0; i < length; i++) {\n    if (buffer1[i] !== buffer2[i]) return false;\n  }\n  return true;\n}\n","import { BinaryCommandCreator } from \"./binary-command-creator.js\";\nimport {\n  PeerSegmentCommand,\n  PeerSendSegmentCommand,\n  PeerSegmentAnnouncementCommand,\n  PeerRequestSegmentCommand,\n  PeerCommand,\n  PeerCommandType,\n} from \"./types.js\";\n\nfunction serializeSegmentAnnouncementCommand(\n  command: PeerSegmentAnnouncementCommand,\n  maxChunkSize: number,\n) {\n  const { c: commandCode, p: loadingByHttp, l: loaded } = command;\n  const creator = new BinaryCommandCreator(commandCode, maxChunkSize);\n  if (loaded?.length) creator.addSimilarIntArr(\"l\", loaded);\n  if (loadingByHttp?.length) {\n    creator.addSimilarIntArr(\"p\", loadingByHttp);\n  }\n  creator.complete();\n  return creator.getResultBuffers();\n}\n\nfunction serializePeerSegmentCommand(\n  command: PeerSegmentCommand,\n  maxChunkSize: number,\n) {\n  const creator = new BinaryCommandCreator(command.c, maxChunkSize);\n  creator.addInteger(\"i\", command.i);\n  creator.addInteger(\"r\", command.r);\n  creator.complete();\n  return creator.getResultBuffers();\n}\n\nfunction serializePeerSendSegmentCommand(\n  command: PeerSendSegmentCommand,\n  maxChunkSize: number,\n) {\n  const creator = new BinaryCommandCreator(command.c, maxChunkSize);\n  creator.addInteger(\"i\", command.i);\n  creator.addInteger(\"s\", command.s);\n  creator.addInteger(\"r\", command.r);\n  creator.complete();\n  return creator.getResultBuffers();\n}\n\nfunction serializePeerSegmentRequestCommand(\n  command: PeerRequestSegmentCommand,\n  maxChunkSize: number,\n) {\n  const creator = new BinaryCommandCreator(command.c, maxChunkSize);\n  creator.addInteger(\"i\", command.i);\n  creator.addInteger(\"r\", command.r);\n  if (command.b) creator.addInteger(\"b\", command.b);\n  creator.complete();\n  return creator.getResultBuffers();\n}\n\nexport function serializePeerCommand(\n  command: PeerCommand,\n  maxChunkSize: number,\n) {\n  switch (command.c) {\n    case PeerCommandType.CancelSegmentRequest:\n    case PeerCommandType.SegmentAbsent:\n    case PeerCommandType.SegmentDataSendingCompleted:\n      return serializePeerSegmentCommand(command, maxChunkSize);\n    case PeerCommandType.SegmentRequest:\n      return serializePeerSegmentRequestCommand(command, maxChunkSize);\n    case PeerCommandType.SegmentsAnnouncement:\n      return serializeSegmentAnnouncementCommand(command, maxChunkSize);\n    case PeerCommandType.SegmentData:\n      return serializePeerSendSegmentCommand(command, maxChunkSize);\n  }\n}\n","import { PeerConnection } from \"bittorrent-tracker\";\nimport { CoreEventMap, StreamConfig } from \"../types.js\";\nimport * as Utils from \"../utils/utils.js\";\nimport * as Command from \"./commands/index.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\n\nexport type PeerConfig = Pick<\n  StreamConfig,\n  | \"p2pNotReceivingBytesTimeoutMs\"\n  | \"webRtcMaxMessageSize\"\n  | \"p2pErrorRetries\"\n  | \"validateP2PSegment\"\n>;\n\nexport class PeerProtocol {\n  private commandChunks?: Command.BinaryCommandChunksJoiner;\n  private uploadingContext?: { stopUploading: () => void; requestId: number };\n  private readonly onChunkDownloaded: CoreEventMap[\"onChunkDownloaded\"];\n  private readonly onChunkUploaded: CoreEventMap[\"onChunkUploaded\"];\n\n  constructor(\n    private readonly connection: PeerConnection,\n    private readonly peerConfig: PeerConfig,\n    private readonly eventHandlers: {\n      onCommandReceived: (command: Command.PeerCommand) => void;\n      onSegmentChunkReceived: (data: Uint8Array) => void;\n    },\n    eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    this.onChunkDownloaded =\n      eventTarget.getEventDispatcher(\"onChunkDownloaded\");\n    this.onChunkUploaded = eventTarget.getEventDispatcher(\"onChunkUploaded\");\n    connection.on(\"data\", this.onDataReceived);\n  }\n\n  private onDataReceived = (data: Uint8Array) => {\n    if (Command.isCommandChunk(data)) {\n      this.receivingCommandBytes(data);\n    } else {\n      this.eventHandlers.onSegmentChunkReceived(data);\n\n      this.onChunkDownloaded(data.byteLength, \"p2p\", this.connection.idUtf8);\n    }\n  };\n\n  sendCommand(command: Command.PeerCommand) {\n    const binaryCommandBuffers = Command.serializePeerCommand(\n      command,\n      this.peerConfig.webRtcMaxMessageSize,\n    );\n    for (const buffer of binaryCommandBuffers) {\n      this.connection.write(buffer);\n    }\n  }\n\n  stopUploadingSegmentData() {\n    this.uploadingContext?.stopUploading();\n    this.uploadingContext = undefined;\n  }\n\n  getUploadingRequestId() {\n    return this.uploadingContext?.requestId;\n  }\n\n  async splitSegmentDataToChunksAndUploadAsync(\n    data: ArrayBuffer,\n    requestId: number,\n  ) {\n    if (this.uploadingContext) {\n      throw new Error(`Some segment data is already uploading.`);\n    }\n    const chunks = getBufferChunks(data, this.peerConfig.webRtcMaxMessageSize);\n    const { promise, resolve, reject } = Utils.getControlledPromise();\n\n    let isUploadingSegmentData = false;\n\n    const uploadingContext = {\n      stopUploading: () => {\n        isUploadingSegmentData = false;\n      },\n      requestId,\n    };\n\n    this.uploadingContext = uploadingContext;\n\n    const sendChunk = () => {\n      if (!isUploadingSegmentData) {\n        reject();\n        return;\n      }\n\n      while (true) {\n        const chunk = chunks.next().value;\n\n        if (!chunk) {\n          resolve();\n          break;\n        }\n\n        const drained = this.connection.write(chunk);\n        this.onChunkUploaded(chunk.byteLength, this.connection.idUtf8);\n        if (!drained) break;\n      }\n    };\n\n    try {\n      this.connection.on(\"drain\", sendChunk);\n      isUploadingSegmentData = true;\n      sendChunk();\n      await promise;\n    } finally {\n      this.connection.off(\"drain\", sendChunk);\n\n      if (this.uploadingContext === uploadingContext) {\n        this.uploadingContext = undefined;\n      }\n    }\n  }\n\n  private receivingCommandBytes(buffer: Uint8Array) {\n    this.commandChunks ??= new Command.BinaryCommandChunksJoiner(\n      (commandBuffer) => {\n        this.commandChunks = undefined;\n        const command = Command.deserializeCommand(commandBuffer);\n        this.eventHandlers.onCommandReceived(command);\n      },\n    );\n    try {\n      this.commandChunks.addCommandChunk(buffer);\n    } catch (err) {\n      if (!(err instanceof Command.BinaryCommandJoiningError)) return;\n      this.commandChunks = undefined;\n    }\n  }\n}\n\nfunction* getBufferChunks(\n  data: ArrayBuffer,\n  maxChunkSize: number,\n): Generator<ArrayBuffer, void> {\n  let bytesLeft = data.byteLength;\n  while (bytesLeft > 0) {\n    const bytesToSend = bytesLeft >= maxChunkSize ? maxChunkSize : bytesLeft;\n    const from = data.byteLength - bytesLeft;\n    const buffer = data.slice(from, from + bytesToSend);\n    bytesLeft -= bytesToSend;\n    yield buffer;\n  }\n}\n","import { PeerConnection } from \"bittorrent-tracker\";\nimport debug from \"debug\";\nimport { Request, RequestControls } from \"../requests/request.js\";\nimport {\n  CoreEventMap,\n  PeerRequestErrorType,\n  RequestError,\n  RequestAbortErrorType,\n  SegmentWithStream,\n  StreamType,\n} from \"../types.js\";\nimport * as Utils from \"../utils/utils.js\";\nimport * as Command from \"./commands/index.js\";\nimport { PeerProtocol, PeerConfig } from \"./peer-protocol.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\n\nconst { PeerCommandType } = Command;\ntype PeerEventHandlers = {\n  onPeerClosed: (peer: Peer) => void;\n  onSegmentRequested: (\n    peer: Peer,\n    segmentId: number,\n    requestId: number,\n    byteFrom?: number,\n  ) => void;\n  onSegmentsAnnouncement: () => void;\n};\n\nexport class Peer {\n  readonly id: string;\n  private readonly peerProtocol;\n  private downloadingContext?: {\n    request: Request;\n    controls: RequestControls;\n    isSegmentDataCommandReceived: boolean;\n    requestId: number;\n  };\n  private loadedSegments = new Set<number>();\n  private httpLoadingSegments = new Set<number>();\n  private downloadingErrors: RequestError<\n    PeerRequestErrorType | RequestAbortErrorType\n  >[] = [];\n  private logger = debug(\"p2pml-core:peer\");\n  private readonly onPeerClosed: CoreEventMap[\"onPeerClose\"];\n\n  constructor(\n    private readonly connection: PeerConnection,\n    private readonly eventHandlers: PeerEventHandlers,\n    private readonly peerConfig: PeerConfig,\n    private readonly streamType: StreamType,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    this.onPeerClosed = eventTarget.getEventDispatcher(\"onPeerClose\");\n\n    this.id = Peer.getPeerIdFromConnection(connection);\n    this.peerProtocol = new PeerProtocol(\n      connection,\n      peerConfig,\n      {\n        onSegmentChunkReceived: this.onSegmentChunkReceived,\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        onCommandReceived: this.onCommandReceived,\n      },\n      eventTarget,\n    );\n    eventTarget.getEventDispatcher(\"onPeerConnect\")({\n      peerId: this.id,\n      streamType,\n    });\n\n    connection.on(\"error\", this.onConnectionError);\n    connection.on(\"close\", this.onPeerConnectionClosed);\n    connection.on(\"end\", this.onPeerConnectionClosed);\n    connection.on(\"finish\", this.onPeerConnectionClosed);\n  }\n\n  get downloadingSegment(): SegmentWithStream | undefined {\n    return this.downloadingContext?.request.segment;\n  }\n\n  getSegmentStatus(\n    segment: SegmentWithStream,\n  ): \"loaded\" | \"http-loading\" | undefined {\n    const { externalId } = segment;\n    if (this.loadedSegments.has(externalId)) return \"loaded\";\n    if (this.httpLoadingSegments.has(externalId)) return \"http-loading\";\n  }\n\n  private onCommandReceived = async (command: Command.PeerCommand) => {\n    switch (command.c) {\n      case PeerCommandType.SegmentsAnnouncement:\n        this.loadedSegments = new Set(command.l);\n        this.httpLoadingSegments = new Set(command.p);\n        this.eventHandlers.onSegmentsAnnouncement();\n        break;\n\n      case PeerCommandType.SegmentRequest:\n        this.peerProtocol.stopUploadingSegmentData();\n        this.eventHandlers.onSegmentRequested(\n          this,\n          command.i,\n          command.r,\n          command.b,\n        );\n        break;\n\n      case PeerCommandType.SegmentData:\n        {\n          if (!this.downloadingContext) break;\n          if (this.downloadingContext.isSegmentDataCommandReceived) break;\n\n          const { request, controls, requestId } = this.downloadingContext;\n          if (\n            request.segment.externalId !== command.i ||\n            requestId !== command.r\n          ) {\n            break;\n          }\n\n          this.downloadingContext.isSegmentDataCommandReceived = true;\n          controls.firstBytesReceived();\n\n          if (request.totalBytes === undefined) {\n            request.setTotalBytes(command.s);\n          } else if (request.totalBytes - request.loadedBytes !== command.s) {\n            request.clearLoadedBytes();\n            this.sendCancelSegmentRequestCommand(request.segment, requestId);\n            this.cancelSegmentDownloading(\n              \"peer-response-bytes-length-mismatch\",\n            );\n            this.destroy();\n          }\n        }\n        break;\n\n      case PeerCommandType.SegmentDataSendingCompleted: {\n        const { downloadingContext } = this;\n\n        if (!downloadingContext?.isSegmentDataCommandReceived) return;\n\n        const { request, controls } = downloadingContext;\n\n        const isWrongSegment =\n          downloadingContext.request.segment.externalId !== command.i ||\n          downloadingContext.requestId !== command.r;\n\n        if (isWrongSegment) {\n          request.clearLoadedBytes();\n          this.cancelSegmentDownloading(\"peer-protocol-violation\");\n          this.destroy();\n          return;\n        }\n\n        const isWrongBytes = request.loadedBytes !== request.totalBytes;\n\n        if (isWrongBytes) {\n          request.clearLoadedBytes();\n          this.cancelSegmentDownloading(\"peer-response-bytes-length-mismatch\");\n          this.destroy();\n          return;\n        }\n\n        const isValid =\n          (await this.peerConfig.validateP2PSegment?.(\n            request.segment.url,\n            request.segment.byteRange,\n            request.data,\n          )) ?? true;\n\n        if (this.downloadingContext !== downloadingContext) return;\n\n        if (!isValid) {\n          request.clearLoadedBytes();\n          this.cancelSegmentDownloading(\"p2p-segment-validation-failed\");\n          this.destroy();\n          return;\n        }\n\n        this.downloadingErrors = [];\n        controls.completeOnSuccess();\n        this.downloadingContext = undefined;\n        break;\n      }\n\n      case PeerCommandType.SegmentAbsent:\n        if (\n          this.downloadingContext?.request.segment.externalId === command.i &&\n          this.downloadingContext.requestId === command.r\n        ) {\n          this.cancelSegmentDownloading(\"peer-segment-absent\");\n          this.loadedSegments.delete(command.i);\n        }\n        break;\n\n      case PeerCommandType.CancelSegmentRequest: {\n        const uploadingRequestId = this.peerProtocol.getUploadingRequestId();\n\n        if (uploadingRequestId !== command.r) break;\n\n        this.peerProtocol.stopUploadingSegmentData();\n        break;\n      }\n    }\n  };\n\n  protected onSegmentChunkReceived = (chunk: Uint8Array) => {\n    if (!this.downloadingContext?.isSegmentDataCommandReceived) return;\n\n    const { request, controls } = this.downloadingContext;\n\n    const isOverflow =\n      request.totalBytes !== undefined &&\n      request.loadedBytes + chunk.byteLength > request.totalBytes;\n\n    if (isOverflow) {\n      request.clearLoadedBytes();\n      this.cancelSegmentDownloading(\"peer-response-bytes-length-mismatch\");\n      this.destroy();\n      return;\n    }\n\n    controls.addLoadedChunk(chunk);\n  };\n\n  downloadSegment(segmentRequest: Request) {\n    if (this.downloadingContext) {\n      throw new Error(\"Some segment already is downloading\");\n    }\n    this.downloadingContext = {\n      request: segmentRequest,\n      requestId: Math.floor(Math.random() * 1000),\n      isSegmentDataCommandReceived: false,\n      controls: segmentRequest.start(\n        { downloadSource: \"p2p\", peerId: this.id },\n        {\n          notReceivingBytesTimeoutMs:\n            this.peerConfig.p2pNotReceivingBytesTimeoutMs,\n          abort: (error) => {\n            if (!this.downloadingContext) return;\n            const { request, requestId } = this.downloadingContext;\n            this.sendCancelSegmentRequestCommand(request.segment, requestId);\n            this.downloadingErrors.push(error);\n            this.downloadingContext = undefined;\n\n            const timeoutErrors = this.downloadingErrors.filter(\n              (error) => error.type === \"bytes-receiving-timeout\",\n            );\n\n            if (timeoutErrors.length >= this.peerConfig.p2pErrorRetries) {\n              this.destroy();\n            }\n          },\n        },\n      ),\n    };\n    const command: Command.PeerRequestSegmentCommand = {\n      c: PeerCommandType.SegmentRequest,\n      r: this.downloadingContext.requestId,\n      i: segmentRequest.segment.externalId,\n    };\n    if (segmentRequest.loadedBytes) command.b = segmentRequest.loadedBytes;\n    this.peerProtocol.sendCommand(command);\n  }\n\n  async uploadSegmentData(\n    segment: SegmentWithStream,\n    requestId: number,\n    data: ArrayBuffer,\n  ) {\n    const { externalId } = segment;\n    this.logger(`send segment ${segment.externalId} to ${this.id}`);\n    const command: Command.PeerSendSegmentCommand = {\n      c: PeerCommandType.SegmentData,\n      i: externalId,\n      r: requestId,\n      s: data.byteLength,\n    };\n    this.peerProtocol.sendCommand(command);\n    try {\n      await this.peerProtocol.splitSegmentDataToChunksAndUploadAsync(\n        data,\n        requestId,\n      );\n      this.sendSegmentDataSendingCompletedCommand(segment, requestId);\n      this.logger(`segment ${externalId} has been sent to ${this.id}`);\n    } catch {\n      this.logger(`cancel segment uploading ${externalId}`);\n    }\n  }\n\n  private cancelSegmentDownloading(type: PeerRequestErrorType) {\n    if (!this.downloadingContext) return;\n    const { request, controls } = this.downloadingContext;\n    const { segment } = request;\n    this.logger(`cancel segment request ${segment.externalId} (${type})`);\n    const error = new RequestError(type);\n    controls.abortOnError(error);\n    this.downloadingContext = undefined;\n    this.downloadingErrors.push(error);\n  }\n\n  sendSegmentsAnnouncementCommand(\n    loadedSegmentsIds: number[],\n    httpLoadingSegmentsIds: number[],\n  ) {\n    const command: Command.PeerSegmentAnnouncementCommand = {\n      c: PeerCommandType.SegmentsAnnouncement,\n      p: httpLoadingSegmentsIds,\n      l: loadedSegmentsIds,\n    };\n    this.peerProtocol.sendCommand(command);\n  }\n\n  sendSegmentAbsentCommand(segmentExternalId: number, requestId: number) {\n    this.peerProtocol.sendCommand({\n      c: PeerCommandType.SegmentAbsent,\n      i: segmentExternalId,\n      r: requestId,\n    });\n  }\n\n  private sendCancelSegmentRequestCommand(\n    segment: SegmentWithStream,\n    requestId: number,\n  ) {\n    this.peerProtocol.sendCommand({\n      c: PeerCommandType.CancelSegmentRequest,\n      i: segment.externalId,\n      r: requestId,\n    });\n  }\n\n  private sendSegmentDataSendingCompletedCommand(\n    segment: SegmentWithStream,\n    requestId: number,\n  ) {\n    this.peerProtocol.sendCommand({\n      c: PeerCommandType.SegmentDataSendingCompleted,\n      r: requestId,\n      i: segment.externalId,\n    });\n  }\n\n  private onPeerConnectionClosed = () => {\n    this.destroy();\n  };\n\n  private onConnectionError = (error: Error) => {\n    this.logger(`peer connection error ${this.id} %O`, error);\n    this.eventTarget.getEventDispatcher(\"onPeerError\")({\n      peerId: this.id,\n      streamType: this.streamType,\n      error,\n    });\n\n    const { code } = error as { code?: string };\n\n    if (code === \"ERR_DATA_CHANNEL\") {\n      this.destroy();\n    } else if (code === \"ERR_CONNECTION_FAILURE\") {\n      this.destroy();\n    }\n  };\n\n  destroy = () => {\n    this.cancelSegmentDownloading(\"peer-closed\");\n    this.connection.destroy();\n    this.eventHandlers.onPeerClosed(this);\n    this.onPeerClosed({\n      peerId: this.id,\n      streamType: this.streamType,\n    });\n    this.logger(`peer closed ${this.id}`);\n  };\n\n  static getPeerIdFromConnection(connection: PeerConnection) {\n    return Utils.hexToUtf8(connection.id);\n  }\n}\n","import TrackerClient, {\n  PeerConnection,\n  TrackerClientEvents,\n} from \"bittorrent-tracker\";\nimport { CoreEventMap, StreamConfig, StreamWithSegments } from \"../types.js\";\nimport debug from \"debug\";\nimport * as PeerUtil from \"../utils/peer.js\";\nimport * as LoggerUtils from \"../utils/logger.js\";\nimport { Peer } from \"./peer.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\nimport { utf8ToUintArray } from \"../utils/utils.js\";\n\ntype PeerItem = {\n  peer?: Peer;\n  potentialConnections: Set<PeerConnection>;\n};\n\ntype P2PTrackerClientEventHandlers = {\n  onPeerConnected: (peer: Peer) => void;\n  onSegmentRequested: (\n    peer: Peer,\n    segmentExternalId: number,\n    requestId: number,\n    bytesFrom?: number,\n  ) => void;\n  onSegmentsAnnouncement: () => void;\n};\n\nfunction isSafariOrWkWebview() {\n  const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n  const isWkWebview =\n    /\\b(iPad|iPhone|Macintosh).*AppleWebKit(?!.*Safari)/i.test(\n      navigator.userAgent,\n    );\n\n  return isSafari || isWkWebview;\n}\n\nexport class P2PTrackerClient {\n  private static readonly PEER_ID_BY_INFO_HASH = new Map<string, string>();\n\n  private readonly streamShortId: string;\n  private readonly client: TrackerClient;\n  private readonly _peers = new Map<string, PeerItem>();\n  private readonly logger = debug(\"p2pml-core:p2p-tracker-client\");\n\n  constructor(\n    streamSwarmId: string,\n    private readonly stream: StreamWithSegments,\n    private readonly eventHandlers: P2PTrackerClientEventHandlers,\n    private readonly config: StreamConfig,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    const streamHash = PeerUtil.getStreamHash(streamSwarmId);\n    this.streamShortId = LoggerUtils.getStreamString(stream);\n\n    let peerId = P2PTrackerClient.PEER_ID_BY_INFO_HASH.get(streamHash);\n    if (!peerId) {\n      peerId = PeerUtil.generatePeerId(config.trackerClientVersionPrefix);\n      P2PTrackerClient.PEER_ID_BY_INFO_HASH.set(streamHash, peerId);\n    }\n\n    this.client = new TrackerClient({\n      infoHash: utf8ToUintArray(streamHash),\n      peerId: utf8ToUintArray(peerId),\n      announce: isSafariOrWkWebview()\n        ? config.announceTrackers.slice(0, 1) // Safari has issues with multiple trackers\n        : config.announceTrackers,\n      rtcConfig: this.config.rtcConfig,\n    });\n    this.client.on(\"peer\", this.onReceivePeerConnection);\n    this.client.on(\"warning\", this.onTrackerClientWarning);\n    this.client.on(\"error\", this.onTrackerClientError);\n    this.logger(\n      `create new client; \\nstream: ${this.streamShortId}; hash: ${streamHash}\\npeerId: ${peerId}`,\n    );\n  }\n\n  start() {\n    this.client.start();\n  }\n\n  destroy() {\n    this.client.destroy();\n\n    for (const { peer, potentialConnections } of this._peers.values()) {\n      peer?.destroy();\n      for (const connection of potentialConnections) {\n        connection.destroy();\n      }\n    }\n\n    this._peers.clear();\n    this.logger(\"destroy client; stream:\", this.streamShortId);\n  }\n\n  private onReceivePeerConnection: TrackerClientEvents[\"peer\"] = (\n    peerConnection,\n  ) => {\n    const itemId = Peer.getPeerIdFromConnection(peerConnection);\n    let peerItem = this._peers.get(itemId);\n\n    if (peerItem?.peer) {\n      peerConnection.destroy();\n      return;\n    }\n\n    if (!peerItem) {\n      peerItem = { potentialConnections: new Set() };\n      peerConnection.idUtf8 = itemId;\n      this._peers.set(itemId, peerItem);\n    }\n\n    peerItem.potentialConnections.add(peerConnection);\n\n    peerConnection.on(\"connect\", () => {\n      if (peerItem.peer) return;\n\n      for (const connection of peerItem.potentialConnections) {\n        if (connection !== peerConnection) connection.destroy();\n      }\n\n      peerItem.potentialConnections.clear();\n\n      peerItem.peer = new Peer(\n        peerConnection,\n        {\n          onPeerClosed: this.onPeerClosed,\n          onSegmentRequested: this.eventHandlers.onSegmentRequested,\n          onSegmentsAnnouncement: this.eventHandlers.onSegmentsAnnouncement,\n        },\n        this.config,\n        this.stream.type,\n        this.eventTarget,\n      );\n      this.logger(\n        `connected with peer: ${peerItem.peer.id} ${this.streamShortId}`,\n      );\n      this.eventHandlers.onPeerConnected(peerItem.peer);\n    });\n  };\n\n  private onTrackerClientWarning: TrackerClientEvents[\"warning\"] = (\n    warning,\n  ) => {\n    this.logger(\"tracker warning %s:\", this.streamShortId, warning);\n    this.eventTarget.getEventDispatcher(\"onTrackerWarning\")({\n      streamType: this.stream.type,\n      warning,\n    });\n  };\n\n  private onTrackerClientError: TrackerClientEvents[\"error\"] = (error) => {\n    this.logger(\"tracker error in stream %s:\", this.streamShortId, error);\n    this.eventTarget.getEventDispatcher(\"onTrackerError\")({\n      streamType: this.stream.type,\n      error,\n    });\n  };\n\n  *peers() {\n    for (const peerItem of this._peers.values()) {\n      if (peerItem.peer) yield peerItem.peer;\n    }\n  }\n\n  private onPeerClosed = (peer: Peer) => {\n    this.logger(`peer closed: ${peer.id}`);\n    this._peers.delete(peer.id);\n  };\n\n  static clearPeerIdCache() {\n    P2PTrackerClient.PEER_ID_BY_INFO_HASH.clear();\n  }\n}\n","import {\n  SegmentWithStream,\n  Stream,\n  StreamConfig,\n  StreamWithSegments,\n} from \"../types.js\";\nimport { Playback } from \"../internal-types.js\";\nimport { P2PLoader } from \"../p2p/loader.js\";\n\nexport type SegmentPlaybackStatuses = {\n  isHighDemand: boolean;\n  isHttpDownloadable: boolean;\n  isP2PDownloadable: boolean;\n};\n\nexport type PlaybackTimeWindowsConfig = Pick<\n  StreamConfig,\n  \"highDemandTimeWindow\" | \"httpDownloadTimeWindow\" | \"p2pDownloadTimeWindow\"\n>;\n\nconst PEER_PROTOCOL_VERSION = \"v2\";\n\nexport function getStreamSwarmId(\n  swarmId: string,\n  stream: Readonly<Stream>,\n): string {\n  return `${PEER_PROTOCOL_VERSION}-${swarmId}-${getStreamId(stream)}`;\n}\n\nexport function getSegmentFromStreamsMap(\n  streams: Map<string, StreamWithSegments>,\n  segmentRuntimeId: string,\n): SegmentWithStream | undefined {\n  for (const stream of streams.values()) {\n    const segment = stream.segments.get(segmentRuntimeId);\n    if (segment) return segment;\n  }\n}\n\nexport function getSegmentFromStreamByExternalId(\n  stream: StreamWithSegments,\n  segmentExternalId: number,\n): SegmentWithStream | undefined {\n  for (const segment of stream.segments.values()) {\n    if (segment.externalId === segmentExternalId) return segment;\n  }\n}\n\nexport function getStreamId(stream: Stream) {\n  return `${stream.type}-${stream.index}`;\n}\n\nexport function getSegmentAvgDuration(stream: StreamWithSegments) {\n  const { segments } = stream;\n  let sumDuration = 0;\n  const { size } = segments;\n  for (const segment of segments.values()) {\n    const duration = segment.endTime - segment.startTime;\n    sumDuration += duration;\n  }\n\n  return sumDuration / size;\n}\n\nfunction calculateTimeWindows(\n  timeWindowsConfig: PlaybackTimeWindowsConfig,\n  availableMemoryInPercent: number,\n) {\n  const {\n    highDemandTimeWindow,\n    httpDownloadTimeWindow,\n    p2pDownloadTimeWindow,\n  } = timeWindowsConfig;\n\n  const result = {\n    highDemandTimeWindow,\n    httpDownloadTimeWindow,\n    p2pDownloadTimeWindow,\n  };\n\n  if (availableMemoryInPercent <= 5) {\n    result.httpDownloadTimeWindow = 0;\n    result.p2pDownloadTimeWindow = 0;\n  } else if (availableMemoryInPercent <= 10) {\n    result.p2pDownloadTimeWindow = result.httpDownloadTimeWindow;\n  }\n\n  return result;\n}\n\nexport function getSegmentPlaybackStatuses(\n  segment: SegmentWithStream,\n  playback: Playback,\n  timeWindowsConfig: PlaybackTimeWindowsConfig,\n  currentP2PLoader: P2PLoader,\n  availableMemoryPercent: number,\n): SegmentPlaybackStatuses {\n  const {\n    highDemandTimeWindow,\n    httpDownloadTimeWindow,\n    p2pDownloadTimeWindow,\n  } = calculateTimeWindows(timeWindowsConfig, availableMemoryPercent);\n\n  return {\n    isHighDemand: isSegmentInTimeWindow(\n      segment,\n      playback,\n      highDemandTimeWindow,\n    ),\n    isHttpDownloadable: isSegmentInTimeWindow(\n      segment,\n      playback,\n      httpDownloadTimeWindow,\n    ),\n    isP2PDownloadable:\n      isSegmentInTimeWindow(segment, playback, p2pDownloadTimeWindow) &&\n      currentP2PLoader.isSegmentLoadingOrLoadedBySomeone(segment),\n  };\n}\n\nfunction isSegmentInTimeWindow(\n  segment: SegmentWithStream,\n  playback: Playback,\n  timeWindowLength: number,\n) {\n  const { startTime, endTime } = segment;\n  const { position, rate } = playback;\n  const rightMargin = position + timeWindowLength * rate;\n  return !(rightMargin < startTime || position > endTime);\n}\n","import { Peer } from \"./peer.js\";\nimport {\n  CoreEventMap,\n  SegmentWithStream,\n  StreamConfig,\n  StreamWithSegments,\n} from \"../types.js\";\nimport { RequestsContainer } from \"../requests/request-container.js\";\nimport { P2PTrackerClient } from \"./tracker-client.js\";\nimport * as StreamUtils from \"../utils/stream.js\";\nimport * as Utils from \"../utils/utils.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\nimport { SegmentStorage } from \"../segment-storage/index.js\";\n\nexport type EventTargetMap = Record<`onStorageUpdated-${string}`, () => void> &\n  CoreEventMap;\n\nexport class P2PLoader {\n  private readonly trackerClient: P2PTrackerClient;\n  private isAnnounceMicrotaskCreated = false;\n\n  constructor(\n    private streamManifestUrl: string,\n    private readonly stream: StreamWithSegments,\n    private readonly requests: RequestsContainer,\n    private readonly segmentStorage: SegmentStorage,\n    private readonly config: StreamConfig,\n    private readonly eventTarget: EventTarget<EventTargetMap>,\n    private readonly onSegmentAnnouncement: () => void,\n  ) {\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, this.stream);\n\n    this.trackerClient = new P2PTrackerClient(\n      streamSwarmId,\n      this.stream,\n      {\n        onPeerConnected: this.onPeerConnected,\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        onSegmentRequested: this.onSegmentRequested,\n        onSegmentsAnnouncement: this.onSegmentAnnouncement,\n      },\n      this.config,\n      this.eventTarget,\n    );\n\n    this.eventTarget.addEventListener(\n      `onStorageUpdated-${streamSwarmId}`,\n      this.broadcastAnnouncement,\n    );\n    this.segmentStorage.setSegmentChangeCallback((streamId: string) => {\n      this.eventTarget.dispatchEvent(`onStorageUpdated-${streamId}`);\n    });\n\n    this.trackerClient.start();\n  }\n\n  downloadSegment(segment: SegmentWithStream) {\n    const peersWithSegment: Peer[] = [];\n    for (const peer of this.trackerClient.peers()) {\n      if (\n        !peer.downloadingSegment &&\n        peer.getSegmentStatus(segment) === \"loaded\"\n      ) {\n        peersWithSegment.push(peer);\n      }\n    }\n\n    if (peersWithSegment.length === 0) return;\n    const peer = Utils.getRandomItem(peersWithSegment);\n\n    const request = this.requests.getOrCreateRequest(segment);\n    peer.downloadSegment(request);\n  }\n\n  isSegmentLoadingOrLoadedBySomeone(segment: SegmentWithStream): boolean {\n    for (const peer of this.trackerClient.peers()) {\n      if (peer.getSegmentStatus(segment)) return true;\n    }\n    return false;\n  }\n\n  isSegmentLoadedBySomeone(segment: SegmentWithStream): boolean {\n    for (const peer of this.trackerClient.peers()) {\n      if (peer.getSegmentStatus(segment) === \"loaded\") return true;\n    }\n    return false;\n  }\n\n  get connectedPeerCount() {\n    let count = 0;\n    const iterator = this.trackerClient.peers();\n    while (!iterator.next().done) count++;\n    return count;\n  }\n\n  private getSegmentsAnnouncement() {\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, this.stream);\n\n    const loaded: number[] = this.segmentStorage.getStoredSegmentIds(\n      swarmId,\n      streamSwarmId,\n    );\n    const httpLoading: number[] = [];\n\n    for (const request of this.requests.httpRequests()) {\n      const segment = this.stream.segments.get(request.segment.runtimeId);\n      if (!segment) continue;\n\n      httpLoading.push(segment.externalId);\n    }\n    return { loaded, httpLoading };\n  }\n\n  private onPeerConnected = (peer: Peer) => {\n    if (this.config.isP2PUploadDisabled) return;\n\n    const { httpLoading, loaded } = this.getSegmentsAnnouncement();\n    peer.sendSegmentsAnnouncementCommand(loaded, httpLoading);\n  };\n\n  broadcastAnnouncement = (sendEmptyAnnouncement = false) => {\n    if (sendEmptyAnnouncement) {\n      this.sendSegmentsAnnouncement([], []);\n      return;\n    }\n\n    if (this.isAnnounceMicrotaskCreated || this.config.isP2PUploadDisabled) {\n      return;\n    }\n\n    const { loaded, httpLoading } = this.getSegmentsAnnouncement();\n    this.sendSegmentsAnnouncement(loaded, httpLoading);\n  };\n\n  private sendSegmentsAnnouncement = (\n    loaded: number[],\n    httpLoading: number[],\n  ) => {\n    this.isAnnounceMicrotaskCreated = true;\n\n    queueMicrotask(() => {\n      for (const peer of this.trackerClient.peers()) {\n        peer.sendSegmentsAnnouncementCommand(loaded, httpLoading);\n      }\n      this.isAnnounceMicrotaskCreated = false;\n    });\n  };\n\n  private onSegmentRequested = async (\n    peer: Peer,\n    segmentExternalId: number,\n    requestId: number,\n    byteFrom?: number,\n  ) => {\n    const segment = StreamUtils.getSegmentFromStreamByExternalId(\n      this.stream,\n      segmentExternalId,\n    );\n    if (!segment) return;\n    if (this.config.isP2PUploadDisabled) {\n      peer.sendSegmentAbsentCommand(segmentExternalId, requestId);\n      return;\n    }\n\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, this.stream);\n\n    const segmentData = await this.segmentStorage.getSegmentData(\n      swarmId,\n      streamSwarmId,\n      segment.externalId,\n    );\n    if (!segmentData) {\n      peer.sendSegmentAbsentCommand(segmentExternalId, requestId);\n      return;\n    }\n    await peer.uploadSegmentData(\n      segment,\n      requestId,\n      byteFrom !== undefined ? segmentData.slice(byteFrom) : segmentData,\n    );\n  };\n\n  destroy() {\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, this.stream);\n\n    this.eventTarget.removeEventListener(\n      `onStorageUpdated-${streamSwarmId}`,\n      this.broadcastAnnouncement,\n    );\n    this.trackerClient.destroy();\n  }\n}\n","import { P2PLoader } from \"./loader.js\";\nimport debug from \"debug\";\nimport {\n  CoreEventMap,\n  Stream,\n  StreamConfig,\n  StreamWithSegments,\n  SegmentStorage,\n} from \"../index.js\";\nimport { RequestsContainer } from \"../requests/request-container.js\";\nimport * as LoggerUtils from \"../utils/logger.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\nimport * as StreamUtils from \"../utils/stream.js\";\n\ntype P2PLoaderContainerItem = {\n  stream: Stream;\n  loader: P2PLoader;\n  destroyTimeoutId?: number;\n  loggerInfo: string;\n};\n\nexport class P2PLoadersContainer {\n  private readonly loaders = new Map<string, P2PLoaderContainerItem>();\n  private _currentLoaderItem: P2PLoaderContainerItem;\n  private readonly logger = debug(\"p2pml-core:p2p-loaders-container\");\n\n  constructor(\n    private readonly streamManifestUrl: string,\n    stream: StreamWithSegments,\n    private readonly requests: RequestsContainer,\n    private readonly segmentStorage: SegmentStorage,\n    private readonly config: StreamConfig,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n    private onSegmentAnnouncement: () => void,\n  ) {\n    this._currentLoaderItem = this.findOrCreateLoaderForStream(stream);\n    this.logger(\n      `set current p2p loader: ${LoggerUtils.getStreamString(stream)}`,\n    );\n  }\n\n  private createLoader(stream: StreamWithSegments): P2PLoaderContainerItem {\n    if (this.loaders.has(stream.runtimeId)) {\n      throw new Error(\"Loader for this stream already exists\");\n    }\n    const loader = new P2PLoader(\n      this.streamManifestUrl,\n      stream,\n      this.requests,\n      this.segmentStorage,\n      this.config,\n      this.eventTarget,\n      () => {\n        if (this._currentLoaderItem.loader === loader) {\n          this.onSegmentAnnouncement();\n        }\n      },\n    );\n    const loggerInfo = LoggerUtils.getStreamString(stream);\n    this.logger(`created new loader: ${loggerInfo}`);\n    return {\n      loader,\n      stream,\n      loggerInfo: LoggerUtils.getStreamString(stream),\n    };\n  }\n\n  private findOrCreateLoaderForStream(stream: StreamWithSegments) {\n    const loaderItem = this.loaders.get(stream.runtimeId);\n    if (loaderItem) {\n      clearTimeout(loaderItem.destroyTimeoutId);\n      loaderItem.destroyTimeoutId = undefined;\n      return loaderItem;\n    } else {\n      const loader = this.createLoader(stream);\n      this.loaders.set(stream.runtimeId, loader);\n      return loader;\n    }\n  }\n\n  changeCurrentLoader(stream: StreamWithSegments) {\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(\n      swarmId,\n      this._currentLoaderItem.stream,\n    );\n    const ids = this.segmentStorage.getStoredSegmentIds(swarmId, streamSwarmId);\n    if (!ids.length) this.destroyAndRemoveLoader(this._currentLoaderItem);\n    else this.setLoaderDestroyTimeout(this._currentLoaderItem);\n\n    this._currentLoaderItem = this.findOrCreateLoaderForStream(stream);\n\n    this.logger(\n      `change current p2p loader: ${LoggerUtils.getStreamString(stream)}`,\n    );\n  }\n\n  private setLoaderDestroyTimeout(item: P2PLoaderContainerItem) {\n    item.destroyTimeoutId = window.setTimeout(\n      () => this.destroyAndRemoveLoader(item),\n      this.config.p2pInactiveLoaderDestroyTimeoutMs,\n    );\n  }\n\n  private destroyAndRemoveLoader(item: P2PLoaderContainerItem) {\n    item.loader.destroy();\n    this.loaders.delete(item.stream.runtimeId);\n    this.logger(`destroy p2p loader: `, item.loggerInfo);\n  }\n\n  get currentLoader() {\n    return this._currentLoaderItem.loader;\n  }\n\n  destroy() {\n    for (const { loader, destroyTimeoutId } of this.loaders.values()) {\n      loader.destroy();\n      clearTimeout(destroyTimeoutId);\n    }\n    this.loaders.clear();\n  }\n}\n","import debug from \"debug\";\nimport { BandwidthCalculators, Playback } from \"../internal-types.js\";\nimport {\n  CoreEventMap,\n  RequestError,\n  RequestAbortErrorType,\n  SegmentWithStream,\n  Segment,\n} from \"../types.js\";\nimport * as StreamUtils from \"../utils/stream.js\";\nimport * as Utils from \"../utils/utils.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\n\nexport type LoadProgress = {\n  startTimestamp: number;\n  lastLoadedChunkTimestamp?: number;\n  startFromByte?: number;\n  loadedBytes: number;\n};\n\ntype HttpRequestAttempt = {\n  downloadSource: \"http\";\n  error?: RequestError;\n};\n\ntype P2PRequestAttempt = {\n  downloadSource: \"p2p\";\n  peerId: string;\n  error?: RequestError;\n};\n\nexport type RequestAttempt = HttpRequestAttempt | P2PRequestAttempt;\n\nexport type RequestControls = Readonly<{\n  firstBytesReceived: Request[\"firstBytesReceived\"];\n  addLoadedChunk: Request[\"addLoadedChunk\"];\n  completeOnSuccess: Request[\"completeOnSuccess\"];\n  abortOnError: Request[\"abortOnError\"];\n}>;\n\ntype OmitEncapsulated<T extends RequestAttempt> = Omit<\n  T,\n  \"error\" | \"errorTimestamp\"\n>;\ntype StartRequestParameters =\n  | OmitEncapsulated<HttpRequestAttempt>\n  | OmitEncapsulated<P2PRequestAttempt>;\n\nexport type RequestStatus =\n  | \"not-started\"\n  | \"loading\"\n  | \"succeed\"\n  | \"failed\"\n  | \"aborted\";\n\nfunction mapSegmentWithStreamToSegment(segment: SegmentWithStream): Segment {\n  return {\n    runtimeId: segment.runtimeId,\n    externalId: segment.externalId,\n    url: segment.url,\n    byteRange: segment.byteRange,\n    startTime: segment.startTime,\n    endTime: segment.endTime,\n  };\n}\n\nexport class Request {\n  private currentAttempt?: RequestAttempt;\n  private _failedAttempts = new FailedRequestAttempts();\n  private finalData?: ArrayBuffer;\n  private bytes: Uint8Array[] = [];\n  private _loadedBytes = 0;\n  private _totalBytes?: number;\n  private _status: RequestStatus = \"not-started\";\n  private progress?: LoadProgress;\n  private notReceivingBytesTimeout: Timeout;\n  private _abortRequestCallback?: (\n    error: RequestError<RequestAbortErrorType>,\n  ) => void;\n  private readonly _logger: debug.Debugger;\n  private _isHandledByProcessQueue = false;\n  private readonly onSegmentError: CoreEventMap[\"onSegmentError\"];\n  private readonly onSegmentAbort: CoreEventMap[\"onSegmentAbort\"];\n  private readonly onSegmentStart: CoreEventMap[\"onSegmentStart\"];\n  private readonly onSegmentLoaded: CoreEventMap[\"onSegmentLoaded\"];\n\n  constructor(\n    readonly segment: SegmentWithStream,\n    private readonly requestProcessQueueCallback: () => void,\n    private readonly bandwidthCalculators: BandwidthCalculators,\n    private readonly playback: Playback,\n    private readonly playbackConfig: StreamUtils.PlaybackTimeWindowsConfig,\n    eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    this.onSegmentError = eventTarget.getEventDispatcher(\"onSegmentError\");\n    this.onSegmentAbort = eventTarget.getEventDispatcher(\"onSegmentAbort\");\n    this.onSegmentStart = eventTarget.getEventDispatcher(\"onSegmentStart\");\n    this.onSegmentLoaded = eventTarget.getEventDispatcher(\"onSegmentLoaded\");\n\n    const { byteRange } = this.segment;\n    if (byteRange) {\n      const { end, start } = byteRange;\n      this._totalBytes = end - start + 1;\n    }\n    this.notReceivingBytesTimeout = new Timeout(this.abortOnTimeout);\n\n    const { type } = this.segment.stream;\n    this._logger = debug(`p2pml-core:request-${type}`);\n  }\n\n  clearLoadedBytes() {\n    this._loadedBytes = 0;\n    this.bytes = [];\n    this._totalBytes = undefined;\n    this.finalData = undefined;\n  }\n\n  get status() {\n    return this._status;\n  }\n\n  private setStatus(status: RequestStatus) {\n    this._status = status;\n    this._isHandledByProcessQueue = false;\n  }\n\n  get downloadSource() {\n    return this.currentAttempt?.downloadSource;\n  }\n\n  get loadedBytes() {\n    return this._loadedBytes;\n  }\n\n  get totalBytes(): number | undefined {\n    return this._totalBytes;\n  }\n\n  get data(): ArrayBuffer {\n    this.finalData ??= Utils.joinChunks(this.bytes).buffer;\n    return this.finalData;\n  }\n\n  get failedAttempts() {\n    return this._failedAttempts;\n  }\n\n  get isHandledByProcessQueue() {\n    return this._isHandledByProcessQueue;\n  }\n\n  markHandledByProcessQueue() {\n    this._isHandledByProcessQueue = true;\n  }\n\n  setTotalBytes(value: number) {\n    if (this._totalBytes !== undefined) {\n      throw new Error(\"Request total bytes value is already set\");\n    }\n    this._totalBytes = value;\n  }\n\n  start(\n    requestData: StartRequestParameters,\n    controls: {\n      notReceivingBytesTimeoutMs?: number;\n      abort: (errorType: RequestError<RequestAbortErrorType>) => void;\n    },\n  ): RequestControls {\n    if (this._status === \"succeed\") {\n      throw new Error(\n        `Request ${this.segment.externalId} has been already succeed.`,\n      );\n    }\n    if (this._status === \"loading\") {\n      throw new Error(\n        `Request ${this.segment.externalId} has been already started.`,\n      );\n    }\n\n    this.setStatus(\"loading\");\n    this.currentAttempt = { ...requestData };\n    this.progress = {\n      startFromByte: this._loadedBytes,\n      loadedBytes: 0,\n      startTimestamp: performance.now(),\n    };\n    this.manageBandwidthCalculatorsState(\"start\");\n\n    const { notReceivingBytesTimeoutMs, abort } = controls;\n    this._abortRequestCallback = abort;\n\n    if (notReceivingBytesTimeoutMs !== undefined) {\n      this.notReceivingBytesTimeout.start(notReceivingBytesTimeoutMs);\n    }\n\n    this.logger(\n      `${requestData.downloadSource} ${this.segment.externalId} started`,\n    );\n\n    this.onSegmentStart({\n      segment: mapSegmentWithStreamToSegment(this.segment),\n      downloadSource: requestData.downloadSource,\n      peerId:\n        requestData.downloadSource === \"p2p\" ? requestData.peerId : undefined,\n    });\n\n    return {\n      firstBytesReceived: this.firstBytesReceived,\n      addLoadedChunk: this.addLoadedChunk,\n      completeOnSuccess: this.completeOnSuccess,\n      abortOnError: this.abortOnError,\n    };\n  }\n\n  abortFromProcessQueue() {\n    this.throwErrorIfNotLoadingStatus();\n    this.setStatus(\"aborted\");\n    this.logger(\n      `${this.currentAttempt?.downloadSource} ${this.segment.externalId} aborted`,\n    );\n    this._abortRequestCallback?.(new RequestError(\"abort\"));\n    this.onSegmentAbort({\n      segment: mapSegmentWithStreamToSegment(this.segment),\n      downloadSource: this.currentAttempt?.downloadSource,\n      peerId:\n        this.currentAttempt?.downloadSource === \"p2p\"\n          ? this.currentAttempt.peerId\n          : undefined,\n      streamType: this.segment.stream.type,\n    });\n    this._abortRequestCallback = undefined;\n    this.manageBandwidthCalculatorsState(\"stop\");\n    this.notReceivingBytesTimeout.clear();\n  }\n\n  private abortOnTimeout = () => {\n    this.throwErrorIfNotLoadingStatus();\n    if (!this.currentAttempt) return;\n\n    this.setStatus(\"failed\");\n    const error = new RequestError(\"bytes-receiving-timeout\");\n    this._abortRequestCallback?.(error);\n    this.logger(\n      `${this.downloadSource} ${this.segment.externalId} failed ${error.type}`,\n    );\n    this._failedAttempts.add({\n      ...this.currentAttempt,\n      error,\n    });\n    this.onSegmentError({\n      segment: mapSegmentWithStreamToSegment(this.segment),\n      error,\n      downloadSource: this.currentAttempt.downloadSource,\n      peerId:\n        this.currentAttempt.downloadSource === \"p2p\"\n          ? this.currentAttempt.peerId\n          : undefined,\n      streamType: this.segment.stream.type,\n    });\n    this.notReceivingBytesTimeout.clear();\n    this.manageBandwidthCalculatorsState(\"stop\");\n    this.requestProcessQueueCallback();\n  };\n\n  private abortOnError = (error: RequestError) => {\n    this.throwErrorIfNotLoadingStatus();\n    if (!this.currentAttempt) return;\n\n    this.setStatus(\"failed\");\n    this.logger(\n      `${this.downloadSource} ${this.segment.externalId} failed ${error.type}`,\n    );\n    this._failedAttempts.add({\n      ...this.currentAttempt,\n      error,\n    });\n    this.onSegmentError({\n      segment: mapSegmentWithStreamToSegment(this.segment),\n      error,\n      downloadSource: this.currentAttempt.downloadSource,\n      peerId:\n        this.currentAttempt.downloadSource === \"p2p\"\n          ? this.currentAttempt.peerId\n          : undefined,\n      streamType: this.segment.stream.type,\n    });\n    this.notReceivingBytesTimeout.clear();\n    this.manageBandwidthCalculatorsState(\"stop\");\n    this.requestProcessQueueCallback();\n  };\n\n  private completeOnSuccess = () => {\n    this.throwErrorIfNotLoadingStatus();\n    if (!this.currentAttempt) return;\n\n    this.manageBandwidthCalculatorsState(\"stop\");\n    this.notReceivingBytesTimeout.clear();\n    this.setStatus(\"succeed\");\n    this._totalBytes = this._loadedBytes;\n    this.onSegmentLoaded({\n      segmentUrl: this.segment.url,\n      bytesLength: this.data.byteLength,\n      downloadSource: this.currentAttempt.downloadSource,\n      peerId:\n        this.currentAttempt.downloadSource === \"p2p\"\n          ? this.currentAttempt.peerId\n          : undefined,\n      streamType: this.segment.stream.type,\n    });\n\n    this.logger(\n      `${this.currentAttempt.downloadSource} ${this.segment.externalId} succeed`,\n    );\n    this.requestProcessQueueCallback();\n  };\n\n  private addLoadedChunk = (chunk: Uint8Array) => {\n    this.throwErrorIfNotLoadingStatus();\n    if (!this.currentAttempt || !this.progress) return;\n    this.notReceivingBytesTimeout.restart();\n\n    const { byteLength } = chunk;\n    const { all: allBC, http: httpBC } = this.bandwidthCalculators;\n    allBC.addBytes(byteLength);\n    if (this.currentAttempt.downloadSource === \"http\") {\n      httpBC.addBytes(byteLength);\n    }\n\n    this.bytes.push(chunk);\n    this.progress.lastLoadedChunkTimestamp = performance.now();\n    this.progress.loadedBytes += byteLength;\n    this._loadedBytes += byteLength;\n  };\n\n  private firstBytesReceived = () => {\n    this.throwErrorIfNotLoadingStatus();\n    this.notReceivingBytesTimeout.restart();\n  };\n\n  private throwErrorIfNotLoadingStatus() {\n    if (this._status !== \"loading\") {\n      throw new Error(`Request has been already ${this.status}.`);\n    }\n  }\n\n  private logger(message: string) {\n    this._logger.color =\n      this.currentAttempt?.downloadSource === \"http\" ? \"green\" : \"red\";\n    this._logger(message);\n    this._logger.color = \"\";\n  }\n\n  private manageBandwidthCalculatorsState(state: \"start\" | \"stop\") {\n    const { all, http } = this.bandwidthCalculators;\n    const method = state === \"start\" ? \"startLoading\" : \"stopLoading\";\n    if (this.currentAttempt?.downloadSource === \"http\") http[method]();\n    all[method]();\n  }\n}\n\nclass FailedRequestAttempts {\n  private attempts: Required<RequestAttempt>[] = [];\n\n  add(attempt: Required<RequestAttempt>) {\n    this.attempts.push(attempt);\n  }\n\n  get httpAttemptsCount() {\n    return this.attempts.reduce(\n      (sum, attempt) => (attempt.downloadSource === \"http\" ? sum + 1 : sum),\n      0,\n    );\n  }\n\n  get lastAttempt(): Readonly<Required<RequestAttempt>> | undefined {\n    return this.attempts[this.attempts.length - 1];\n  }\n\n  clear() {\n    this.attempts = [];\n  }\n}\n\nexport class Timeout {\n  private timeoutId?: number;\n  private ms?: number;\n\n  constructor(private readonly action: () => void) {}\n\n  start(ms: number) {\n    if (this.timeoutId) {\n      throw new Error(\"Timeout is already started.\");\n    }\n    this.ms = ms;\n    this.timeoutId = window.setTimeout(this.action, this.ms);\n  }\n\n  restart(ms?: number) {\n    if (this.timeoutId) clearTimeout(this.timeoutId);\n    if (ms) this.ms = ms;\n    if (!this.ms) return;\n    this.timeoutId = window.setTimeout(this.action, this.ms);\n  }\n\n  clear() {\n    clearTimeout(this.timeoutId);\n    this.timeoutId = undefined;\n  }\n}\n","import { Playback, BandwidthCalculators } from \"../internal-types.js\";\nimport { CoreEventMap, SegmentWithStream, StreamConfig } from \"../types.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\nimport { Request } from \"./request.js\";\n\nexport class RequestsContainer {\n  private readonly requests = new Map<SegmentWithStream, Request>();\n\n  constructor(\n    private readonly requestProcessQueueCallback: () => void,\n    private readonly bandwidthCalculators: BandwidthCalculators,\n    private readonly playback: Playback,\n    private readonly config: StreamConfig,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n  ) {}\n\n  get executingHttpCount() {\n    let count = 0;\n    for (const request of this.httpRequests()) {\n      if (request.status === \"loading\") count++;\n    }\n    return count;\n  }\n\n  get executingP2PCount() {\n    let count = 0;\n    for (const request of this.p2pRequests()) {\n      if (request.status === \"loading\") count++;\n    }\n    return count;\n  }\n\n  get(segment: SegmentWithStream) {\n    return this.requests.get(segment);\n  }\n\n  getOrCreateRequest(segment: SegmentWithStream) {\n    let request = this.requests.get(segment);\n    if (!request) {\n      request = new Request(\n        segment,\n        this.requestProcessQueueCallback,\n        this.bandwidthCalculators,\n        this.playback,\n        this.config,\n        this.eventTarget,\n      );\n      this.requests.set(segment, request);\n    }\n    return request;\n  }\n\n  remove(request: Request) {\n    this.requests.delete(request.segment);\n  }\n\n  items() {\n    return this.requests.values();\n  }\n\n  *httpRequests(): Generator<Request, void> {\n    for (const request of this.requests.values()) {\n      if (request.downloadSource === \"http\") yield request;\n    }\n  }\n\n  *p2pRequests(): Generator<Request, void> {\n    for (const request of this.requests.values()) {\n      if (request.downloadSource === \"p2p\") yield request;\n    }\n  }\n\n  destroy() {\n    for (const request of this.requests.values()) {\n      if (request.status !== \"loading\") continue;\n      request.abortFromProcessQueue();\n    }\n    this.requests.clear();\n  }\n}\n","import {\n  CoreRequestError,\n  EngineCallbacks,\n  SegmentWithStream,\n} from \"../types.js\";\n\nexport class EngineRequest {\n  private _status: \"pending\" | \"succeed\" | \"failed\" | \"aborted\" = \"pending\";\n  private _shouldBeStartedImmediately = false;\n\n  constructor(\n    readonly segment: SegmentWithStream,\n    readonly engineCallbacks: EngineCallbacks,\n  ) {}\n\n  get status() {\n    return this._status;\n  }\n\n  get shouldBeStartedImmediately() {\n    return this._shouldBeStartedImmediately;\n  }\n\n  resolve(data: ArrayBuffer, bandwidth: number) {\n    if (this._status !== \"pending\") return;\n    this._status = \"succeed\";\n    this.engineCallbacks.onSuccess({ data, bandwidth });\n  }\n\n  reject() {\n    if (this._status !== \"pending\") return;\n    this._status = \"failed\";\n    this.engineCallbacks.onError(new CoreRequestError(\"failed\"));\n  }\n\n  abort() {\n    if (this._status !== \"pending\") return;\n    this._status = \"aborted\";\n    this.engineCallbacks.onError(new CoreRequestError(\"aborted\"));\n  }\n\n  markAsShouldBeStartedImmediately() {\n    this._shouldBeStartedImmediately = true;\n  }\n}\n","import { Playback } from \"../internal-types.js\";\nimport { P2PLoader } from \"../p2p/loader.js\";\nimport { SegmentWithStream } from \"../types.js\";\nimport {\n  getSegmentPlaybackStatuses,\n  SegmentPlaybackStatuses,\n  PlaybackTimeWindowsConfig,\n} from \"./stream.js\";\n\nexport type QueueItem = {\n  segment: SegmentWithStream;\n  statuses: SegmentPlaybackStatuses;\n};\n\nexport function* generateQueue(\n  lastRequestedSegment: Readonly<SegmentWithStream>,\n  playback: Readonly<Playback>,\n  playbackConfig: PlaybackTimeWindowsConfig,\n  currentP2PLoader: P2PLoader,\n  availablePercentMemory: number,\n): Generator<QueueItem, void> {\n  const { runtimeId, stream } = lastRequestedSegment;\n\n  const requestedSegment = stream.segments.get(runtimeId);\n  if (!requestedSegment) return;\n\n  const queueSegments = stream.segments.values();\n\n  let first: SegmentWithStream;\n\n  do {\n    const next = queueSegments.next();\n    if (next.done) return; // should never happen\n    first = next.value;\n  } while (first !== requestedSegment);\n\n  const firstStatuses = getSegmentPlaybackStatuses(\n    first,\n    playback,\n    playbackConfig,\n    currentP2PLoader,\n    availablePercentMemory,\n  );\n  if (isNotActualStatuses(firstStatuses)) {\n    const next = queueSegments.next();\n\n    // for cases when engine requests segment that is a little bit\n    // earlier than current playhead position\n    // it could happen when playhead position is significantly changed by user\n    if (next.done) return;\n\n    const second = next.value;\n\n    const secondStatuses = getSegmentPlaybackStatuses(\n      second,\n      playback,\n      playbackConfig,\n      currentP2PLoader,\n      availablePercentMemory,\n    );\n\n    if (isNotActualStatuses(secondStatuses)) return;\n    firstStatuses.isHighDemand = true;\n    yield { segment: first, statuses: firstStatuses };\n    yield { segment: second, statuses: secondStatuses };\n  } else {\n    yield { segment: first, statuses: firstStatuses };\n  }\n\n  for (const segment of queueSegments) {\n    const statuses = getSegmentPlaybackStatuses(\n      segment,\n      playback,\n      playbackConfig,\n      currentP2PLoader,\n      availablePercentMemory,\n    );\n    if (isNotActualStatuses(statuses)) break;\n    yield { segment, statuses };\n  }\n}\n\nfunction isNotActualStatuses(statuses: SegmentPlaybackStatuses) {\n  const {\n    isHighDemand = false,\n    isHttpDownloadable = false,\n    isP2PDownloadable = false,\n  } = statuses;\n  return !isHighDemand && !isHttpDownloadable && !isP2PDownloadable;\n}\n","import { HttpRequestExecutor } from \"./http-loader.js\";\nimport {\n  CoreEventMap,\n  EngineCallbacks,\n  SegmentWithStream,\n  StreamConfig,\n  StreamWithSegments,\n} from \"./types.js\";\nimport {\n  Playback,\n  BandwidthCalculators,\n  StreamDetails,\n} from \"./internal-types.js\";\nimport { P2PLoadersContainer } from \"./p2p/loaders-container.js\";\nimport { RequestsContainer } from \"./requests/request-container.js\";\nimport { EngineRequest } from \"./requests/engine-request.js\";\nimport * as QueueUtils from \"./utils/queue.js\";\nimport * as LoggerUtils from \"./utils/logger.js\";\nimport * as StreamUtils from \"./utils/stream.js\";\nimport * as Utils from \"./utils/utils.js\";\nimport debug from \"debug\";\nimport { QueueItem } from \"./utils/queue.js\";\nimport { EventTarget } from \"./utils/event-target.js\";\nimport { SegmentStorage } from \"./segment-storage/index.js\";\n\nconst FAILED_ATTEMPTS_CLEAR_INTERVAL = 60000;\nconst PEER_UPDATE_LATENCY = 1000;\n\nexport class HybridLoader {\n  private readonly requests: RequestsContainer;\n  private engineRequest?: EngineRequest;\n  private readonly p2pLoaders: P2PLoadersContainer;\n  private readonly playback: Playback;\n  private readonly segmentAvgDuration: number;\n  private readonly logger: debug.Debugger;\n  private storageCleanUpIntervalId?: number;\n  private levelChangedTimestamp?: number;\n  private lastQueueProcessingTimeStamp?: number;\n  private randomHttpDownloadInterval?: number;\n  private isProcessQueueMicrotaskCreated = false;\n\n  constructor(\n    private streamManifestUrl: string,\n    private lastRequestedSegment: Readonly<SegmentWithStream>,\n    private readonly streamDetails: Required<Readonly<StreamDetails>>,\n    private readonly config: StreamConfig,\n    private readonly bandwidthCalculators: BandwidthCalculators,\n    private readonly segmentStorage: SegmentStorage,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    const activeStream = this.lastRequestedSegment.stream;\n    this.playback = { position: this.lastRequestedSegment.startTime, rate: 1 };\n    this.segmentAvgDuration = StreamUtils.getSegmentAvgDuration(activeStream);\n    this.requests = new RequestsContainer(\n      this.requestProcessQueueMicrotask,\n      this.bandwidthCalculators,\n      this.playback,\n      this.config,\n      this.eventTarget,\n    );\n\n    this.p2pLoaders = new P2PLoadersContainer(\n      this.streamManifestUrl,\n      this.lastRequestedSegment.stream,\n      this.requests,\n      this.segmentStorage,\n      this.config,\n      this.eventTarget,\n      this.requestProcessQueueMicrotask,\n    );\n\n    this.logger = debug(`p2pml-core:hybrid-loader-${activeStream.type}`);\n    this.logger.color = \"coral\";\n\n    this.setIntervalLoading();\n  }\n\n  private setIntervalLoading() {\n    const peersCount = this.p2pLoaders.currentLoader.connectedPeerCount;\n    const randomTimeout =\n      Math.random() * PEER_UPDATE_LATENCY * peersCount + PEER_UPDATE_LATENCY;\n    this.randomHttpDownloadInterval = window.setTimeout(() => {\n      this.loadRandomThroughHttp();\n      this.setIntervalLoading();\n    }, randomTimeout);\n  }\n\n  // api method for engines\n  async loadSegment(\n    segment: Readonly<SegmentWithStream>,\n    callbacks: EngineCallbacks,\n  ) {\n    this.logger(`requests: ${LoggerUtils.getSegmentString(segment)}`);\n    const { stream } = segment;\n    if (stream !== this.lastRequestedSegment.stream) {\n      this.logger(`stream changed to ${LoggerUtils.getStreamString(stream)}`);\n      this.p2pLoaders.changeCurrentLoader(stream);\n    }\n    this.lastRequestedSegment = segment;\n\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, stream);\n\n    this.segmentStorage.onSegmentRequested(\n      swarmId,\n      streamSwarmId,\n      segment.externalId,\n      segment.startTime,\n      segment.endTime,\n      stream.type,\n      this.streamDetails.isLive,\n    );\n    const engineRequest = new EngineRequest(segment, callbacks);\n\n    try {\n      const hasSegment = this.segmentStorage.hasSegment(\n        swarmId,\n        streamSwarmId,\n        segment.externalId,\n      );\n\n      if (hasSegment) {\n        const data = await this.segmentStorage.getSegmentData(\n          swarmId,\n          streamSwarmId,\n          segment.externalId,\n        );\n        if (data) {\n          const { queueDownloadRatio } = this.generateQueue();\n          engineRequest.resolve(data, this.getBandwidth(queueDownloadRatio));\n          return;\n        }\n      }\n\n      this.engineRequest?.abort();\n      this.engineRequest = engineRequest;\n    } catch {\n      engineRequest.reject();\n    } finally {\n      this.requestProcessQueueMicrotask();\n    }\n  }\n\n  private requestProcessQueueMicrotask = (force = true) => {\n    const now = performance.now();\n    if (\n      (!force &&\n        this.lastQueueProcessingTimeStamp !== undefined &&\n        now - this.lastQueueProcessingTimeStamp <= 1000) ||\n      this.isProcessQueueMicrotaskCreated\n    ) {\n      return;\n    }\n\n    this.isProcessQueueMicrotaskCreated = true;\n    queueMicrotask(() => {\n      try {\n        this.processQueue();\n        this.lastQueueProcessingTimeStamp = now;\n      } finally {\n        this.isProcessQueueMicrotaskCreated = false;\n      }\n    });\n  };\n\n  private processRequests(\n    queueSegmentIds: Set<string>,\n    queueDownloadRatio: number,\n  ) {\n    const { stream } = this.lastRequestedSegment;\n    const { httpErrorRetries } = this.config;\n    const now = performance.now();\n    for (const request of this.requests.items()) {\n      const {\n        downloadSource: type,\n        status,\n        segment,\n        isHandledByProcessQueue,\n      } = request;\n      const engineRequest =\n        this.engineRequest?.segment === segment\n          ? this.engineRequest\n          : undefined;\n\n      switch (status) {\n        case \"loading\":\n          if (!queueSegmentIds.has(segment.runtimeId) && !engineRequest) {\n            request.abortFromProcessQueue();\n            this.requests.remove(request);\n          }\n          break;\n\n        case \"succeed\": {\n          if (!type) break;\n          if (type === \"http\") {\n            this.p2pLoaders.currentLoader.broadcastAnnouncement();\n          }\n          if (engineRequest) {\n            engineRequest.resolve(\n              request.data,\n              this.getBandwidth(queueDownloadRatio),\n            );\n            this.engineRequest = undefined;\n          }\n          this.requests.remove(request);\n\n          const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n          const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, stream);\n\n          void this.segmentStorage.storeSegment(\n            swarmId,\n            streamSwarmId,\n            segment.externalId,\n            request.data,\n            segment.startTime,\n            segment.endTime,\n            segment.stream.type,\n            this.streamDetails.isLive,\n          );\n          break;\n        }\n\n        case \"failed\":\n          if (type === \"http\" && !isHandledByProcessQueue) {\n            this.p2pLoaders.currentLoader.broadcastAnnouncement();\n          }\n          if (\n            !engineRequest &&\n            !stream.segments.has(request.segment.runtimeId)\n          ) {\n            this.requests.remove(request);\n          }\n          if (\n            request.failedAttempts.httpAttemptsCount >= httpErrorRetries &&\n            engineRequest\n          ) {\n            this.engineRequest = undefined;\n            engineRequest.reject();\n          }\n          break;\n\n        case \"not-started\":\n          this.requests.remove(request);\n          break;\n\n        case \"aborted\":\n          this.requests.remove(request);\n          break;\n      }\n\n      request.markHandledByProcessQueue();\n      const { lastAttempt } = request.failedAttempts;\n      if (\n        lastAttempt &&\n        now - lastAttempt.error.timestamp > FAILED_ATTEMPTS_CLEAR_INTERVAL\n      ) {\n        request.failedAttempts.clear();\n      }\n    }\n  }\n\n  private processQueue() {\n    const { queue, queueSegmentIds, queueDownloadRatio } = this.generateQueue();\n    this.processRequests(queueSegmentIds, queueDownloadRatio);\n\n    const {\n      simultaneousHttpDownloads,\n      simultaneousP2PDownloads,\n      httpErrorRetries,\n    } = this.config;\n\n    if (\n      this.engineRequest?.shouldBeStartedImmediately &&\n      this.engineRequest.status === \"pending\" &&\n      this.requests.executingHttpCount < simultaneousHttpDownloads\n    ) {\n      const { segment } = this.engineRequest;\n      const request = this.requests.get(segment);\n      if (\n        !request ||\n        request.status === \"not-started\" ||\n        (request.status === \"failed\" &&\n          request.failedAttempts.httpAttemptsCount <\n            this.config.httpErrorRetries)\n      ) {\n        this.loadThroughHttp(segment);\n      }\n    }\n\n    for (const item of queue) {\n      const { statuses, segment } = item;\n      const request = this.requests.get(segment);\n\n      if (statuses.isHighDemand) {\n        if (\n          request?.downloadSource === \"http\" &&\n          request.status === \"loading\"\n        ) {\n          continue;\n        }\n\n        if (\n          request?.downloadSource === \"http\" &&\n          request.status === \"failed\" &&\n          request.failedAttempts.httpAttemptsCount >= httpErrorRetries\n        ) {\n          continue;\n        }\n\n        const isP2PLoadingRequest =\n          request?.status === \"loading\" && request.downloadSource === \"p2p\";\n\n        if (this.requests.executingHttpCount < simultaneousHttpDownloads) {\n          if (isP2PLoadingRequest) request.abortFromProcessQueue();\n          this.loadThroughHttp(segment);\n          continue;\n        }\n\n        if (\n          this.abortLastHttpLoadingInQueueAfterItem(queue, segment) &&\n          this.requests.executingHttpCount < simultaneousHttpDownloads\n        ) {\n          if (isP2PLoadingRequest) request.abortFromProcessQueue();\n          this.loadThroughHttp(segment);\n          continue;\n        }\n\n        if (isP2PLoadingRequest) continue;\n\n        if (this.requests.executingP2PCount < simultaneousP2PDownloads) {\n          this.loadThroughP2P(segment);\n          continue;\n        }\n\n        if (\n          this.abortLastP2PLoadingInQueueAfterItem(queue, segment) &&\n          this.requests.executingP2PCount < simultaneousP2PDownloads\n        ) {\n          this.loadThroughP2P(segment);\n          continue;\n        }\n      } else if (statuses.isP2PDownloadable) {\n        if (request?.status === \"loading\") continue;\n\n        if (this.requests.executingP2PCount < simultaneousP2PDownloads) {\n          this.loadThroughP2P(segment);\n        } else if (\n          this.p2pLoaders.currentLoader.isSegmentLoadedBySomeone(segment)\n        ) {\n          if (\n            this.abortLastP2PLoadingInQueueAfterItem(queue, segment) &&\n            this.requests.executingP2PCount < simultaneousP2PDownloads\n          ) {\n            this.loadThroughP2P(segment);\n          }\n        }\n      }\n    }\n  }\n\n  // api method for engines\n  abortSegmentRequest(segmentRuntimeId: string) {\n    if (this.engineRequest?.segment.runtimeId !== segmentRuntimeId) return;\n    this.engineRequest.abort();\n    this.logger(\n      \"abort: \",\n      LoggerUtils.getSegmentString(this.engineRequest.segment),\n    );\n    this.engineRequest = undefined;\n    this.requestProcessQueueMicrotask();\n  }\n\n  private loadThroughHttp(segment: SegmentWithStream) {\n    const request = this.requests.getOrCreateRequest(segment);\n    new HttpRequestExecutor(request, this.config, this.eventTarget);\n    this.p2pLoaders.currentLoader.broadcastAnnouncement();\n  }\n\n  private loadThroughP2P(segment: SegmentWithStream) {\n    this.p2pLoaders.currentLoader.downloadSegment(segment);\n  }\n\n  private loadRandomThroughHttp() {\n    const availableStorageCapacityPercent =\n      this.getAvailableStorageCapacityPercent();\n    if (availableStorageCapacityPercent <= 10) return;\n\n    const { simultaneousHttpDownloads, httpErrorRetries } = this.config;\n    const p2pLoader = this.p2pLoaders.currentLoader;\n\n    if (\n      this.requests.executingHttpCount >= simultaneousHttpDownloads ||\n      !p2pLoader.connectedPeerCount\n    ) {\n      return;\n    }\n\n    const segmentsToLoad: SegmentWithStream[] = [];\n    for (const { segment, statuses } of QueueUtils.generateQueue(\n      this.lastRequestedSegment,\n      this.playback,\n      this.config,\n      this.p2pLoaders.currentLoader,\n      availableStorageCapacityPercent,\n    )) {\n      const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n      const streamSwarmId = StreamUtils.getStreamSwarmId(\n        swarmId,\n        segment.stream,\n      );\n\n      if (\n        !statuses.isHttpDownloadable ||\n        statuses.isP2PDownloadable ||\n        this.segmentStorage.hasSegment(\n          swarmId,\n          streamSwarmId,\n          segment.externalId,\n        )\n      ) {\n        continue;\n      }\n      const request = this.requests.get(segment);\n      if (\n        request &&\n        (request.status === \"loading\" ||\n          request.status === \"succeed\" ||\n          request.failedAttempts.httpAttemptsCount >= httpErrorRetries)\n      ) {\n        continue;\n      }\n      segmentsToLoad.push(segment);\n    }\n\n    if (!segmentsToLoad.length) return;\n\n    const availableHttpDownloads =\n      simultaneousHttpDownloads - this.requests.executingHttpCount;\n\n    if (availableHttpDownloads === 0) return;\n\n    const peersCount = p2pLoader.connectedPeerCount + 1;\n    const safeRandomSegmentsCount = Math.min(\n      segmentsToLoad.length,\n      simultaneousHttpDownloads * peersCount,\n    );\n\n    const randomIndices = Utils.shuffleArray(\n      Array.from({ length: safeRandomSegmentsCount }, (_, i) => i),\n    );\n\n    let probability = safeRandomSegmentsCount / peersCount;\n\n    for (const randomIndex of randomIndices) {\n      if (this.requests.executingHttpCount >= simultaneousHttpDownloads) {\n        break;\n      }\n\n      if (probability >= 1 || Math.random() <= probability) {\n        const segment = segmentsToLoad[randomIndex];\n        this.loadThroughHttp(segment);\n      }\n\n      probability--;\n      if (probability <= 0) break;\n    }\n  }\n\n  private abortLastHttpLoadingInQueueAfterItem(\n    queue: QueueUtils.QueueItem[],\n    segment: SegmentWithStream,\n  ): boolean {\n    for (const { segment: itemSegment } of Utils.arrayBackwards(queue)) {\n      if (itemSegment === segment) break;\n      const request = this.requests.get(itemSegment);\n      if (request?.downloadSource === \"http\" && request.status === \"loading\") {\n        request.abortFromProcessQueue();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private abortLastP2PLoadingInQueueAfterItem(\n    queue: QueueUtils.QueueItem[],\n    segment: SegmentWithStream,\n  ): boolean {\n    for (const { segment: itemSegment } of Utils.arrayBackwards(queue)) {\n      if (itemSegment === segment) break;\n      const request = this.requests.get(itemSegment);\n      if (request?.downloadSource === \"p2p\" && request.status === \"loading\") {\n        request.abortFromProcessQueue();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private getAvailableStorageCapacityPercent(): number {\n    const { totalCapacity, usedCapacity } = this.segmentStorage.getUsage();\n    return 100 - (usedCapacity / totalCapacity) * 100;\n  }\n\n  private generateQueue() {\n    const queue: QueueItem[] = [];\n    const queueSegmentIds = new Set<string>();\n    let maxPossibleLength = 0;\n    let alreadyLoadedCount = 0;\n\n    const availableStorageCapacityPercent =\n      this.getAvailableStorageCapacityPercent();\n    for (const item of QueueUtils.generateQueue(\n      this.lastRequestedSegment,\n      this.playback,\n      this.config,\n      this.p2pLoaders.currentLoader,\n      availableStorageCapacityPercent,\n    )) {\n      maxPossibleLength++;\n      const { segment } = item;\n\n      const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n      const streamSwarmId = StreamUtils.getStreamSwarmId(\n        swarmId,\n        segment.stream,\n      );\n\n      if (\n        this.segmentStorage.hasSegment(\n          swarmId,\n          streamSwarmId,\n          segment.externalId,\n        ) ||\n        this.requests.get(segment)?.status === \"succeed\"\n      ) {\n        alreadyLoadedCount++;\n        continue;\n      }\n      queue.push(item);\n      queueSegmentIds.add(segment.runtimeId);\n    }\n\n    return {\n      queue,\n      queueSegmentIds,\n      maxPossibleLength,\n      alreadyLoadedCount,\n      queueDownloadRatio:\n        maxPossibleLength !== 0 ? alreadyLoadedCount / maxPossibleLength : 0,\n    };\n  }\n\n  private getBandwidth(queueDownloadRatio: number) {\n    const { http, all } = this.bandwidthCalculators;\n    const { activeLevelBitrate } = this.streamDetails;\n    if (this.streamDetails.activeLevelBitrate === 0) {\n      return all.getBandwidthLoadingOnly(3);\n    }\n\n    const bandwidth = Math.max(\n      all.getBandwidth(30, this.levelChangedTimestamp),\n      all.getBandwidth(60, this.levelChangedTimestamp),\n      all.getBandwidth(90, this.levelChangedTimestamp),\n    );\n\n    if (queueDownloadRatio >= 0.8 || bandwidth >= activeLevelBitrate * 0.9) {\n      return Math.max(\n        all.getBandwidthLoadingOnly(1),\n        all.getBandwidthLoadingOnly(3),\n        all.getBandwidthLoadingOnly(5),\n      );\n    }\n\n    const httpRealBandwidth = Math.max(\n      http.getBandwidthLoadingOnly(1),\n      http.getBandwidthLoadingOnly(3),\n      http.getBandwidthLoadingOnly(5),\n    );\n\n    return Math.max(bandwidth, httpRealBandwidth);\n  }\n\n  notifyLevelChanged() {\n    this.levelChangedTimestamp = performance.now();\n  }\n\n  sendBroadcastAnnouncement(sendEmptySegmentsAnnouncement = false) {\n    this.p2pLoaders.currentLoader.broadcastAnnouncement(\n      sendEmptySegmentsAnnouncement,\n    );\n  }\n\n  updatePlayback(position: number, rate: number) {\n    const isRateChanged = this.playback.rate !== rate;\n    const isPositionChanged = this.playback.position !== position;\n\n    if (!isRateChanged && !isPositionChanged) return;\n\n    const isPositionSignificantlyChanged =\n      Math.abs(position - this.playback.position) / this.segmentAvgDuration >\n      0.5;\n\n    if (isPositionChanged) this.playback.position = position;\n    if (isRateChanged && rate !== 0) this.playback.rate = rate;\n    if (isPositionSignificantlyChanged) {\n      this.logger(\"position significantly changed\");\n      this.engineRequest?.markAsShouldBeStartedImmediately();\n    }\n    this.segmentStorage.onPlaybackUpdated(position, rate);\n    this.requestProcessQueueMicrotask(isPositionSignificantlyChanged);\n  }\n\n  updateStream(stream: StreamWithSegments) {\n    if (stream !== this.lastRequestedSegment.stream) return;\n    this.logger(`update stream: ${LoggerUtils.getStreamString(stream)}`);\n    this.requestProcessQueueMicrotask();\n  }\n\n  destroy() {\n    clearInterval(this.storageCleanUpIntervalId);\n    clearInterval(this.randomHttpDownloadInterval);\n    this.storageCleanUpIntervalId = undefined;\n    this.engineRequest?.abort();\n    this.requests.destroy();\n    this.p2pLoaders.destroy();\n  }\n}\n","export class BandwidthCalculator {\n  private loadingsCount = 0;\n  private readonly bytes: number[] = [];\n  private readonly loadingOnlyTimestamps: number[] = [];\n  private readonly timestamps: number[] = [];\n  private noLoadingsTime = 0;\n  private loadingsStoppedAt = 0;\n\n  constructor(private readonly clearThresholdMs = 20000) {}\n\n  addBytes(bytesLength: number, now = performance.now()) {\n    this.bytes.push(bytesLength);\n    this.loadingOnlyTimestamps.push(now - this.noLoadingsTime);\n    this.timestamps.push(now);\n  }\n\n  startLoading(now = performance.now()) {\n    this.clearStale();\n    if (this.loadingsCount === 0 && this.loadingsStoppedAt !== 0) {\n      this.noLoadingsTime += now - this.loadingsStoppedAt;\n    }\n    this.loadingsCount++;\n  }\n\n  stopLoading(now = performance.now()) {\n    if (this.loadingsCount > 0) {\n      this.loadingsCount--;\n      if (this.loadingsCount === 0) this.loadingsStoppedAt = now;\n    }\n  }\n\n  getBandwidthLoadingOnly(\n    seconds: number,\n    ignoreThresholdTimestamp = Number.NEGATIVE_INFINITY,\n  ) {\n    if (!this.loadingOnlyTimestamps.length) return 0;\n    const milliseconds = seconds * 1000;\n    const lastItemTimestamp =\n      this.loadingOnlyTimestamps[this.loadingOnlyTimestamps.length - 1];\n    let lastCountedTimestamp = lastItemTimestamp;\n    const threshold = lastItemTimestamp - milliseconds;\n    let totalBytes = 0;\n\n    for (let i = this.bytes.length - 1; i >= 0; i--) {\n      const timestamp = this.loadingOnlyTimestamps[i];\n      if (\n        timestamp < threshold ||\n        this.timestamps[i] < ignoreThresholdTimestamp\n      ) {\n        break;\n      }\n      lastCountedTimestamp = timestamp;\n      totalBytes += this.bytes[i];\n    }\n\n    return (totalBytes * 8000) / (lastItemTimestamp - lastCountedTimestamp);\n  }\n\n  getBandwidth(\n    seconds: number,\n    ignoreThresholdTimestamp = Number.NEGATIVE_INFINITY,\n    now = performance.now(),\n  ) {\n    if (!this.timestamps.length) return 0;\n    const milliseconds = seconds * 1000;\n    const threshold = now - milliseconds;\n    let lastCountedTimestamp = now;\n    let totalBytes = 0;\n\n    for (let i = this.bytes.length - 1; i >= 0; i--) {\n      const timestamp = this.timestamps[i];\n      if (timestamp < threshold || timestamp < ignoreThresholdTimestamp) break;\n      lastCountedTimestamp = timestamp;\n      totalBytes += this.bytes[i];\n    }\n\n    return (totalBytes * 8000) / (now - lastCountedTimestamp);\n  }\n\n  clearStale() {\n    if (!this.loadingOnlyTimestamps.length) return;\n    const threshold =\n      this.loadingOnlyTimestamps[this.loadingOnlyTimestamps.length - 1] -\n      this.clearThresholdMs;\n\n    let samplesToRemove = 0;\n    for (const timestamp of this.loadingOnlyTimestamps) {\n      if (timestamp > threshold) break;\n      samplesToRemove++;\n    }\n\n    this.bytes.splice(0, samplesToRemove);\n    this.loadingOnlyTimestamps.splice(0, samplesToRemove);\n    this.timestamps.splice(0, samplesToRemove);\n  }\n}\n","export const getStorageItemId = (streamId: string, segmentId: number) =>\n  `${streamId}|${segmentId}`;\n\nexport const isAndroid = (userAgent: string) => /Android/i.test(userAgent);\n\nexport const isIPadOrIPhone = (userAgent: string) =>\n  /iPad|iPhone/i.test(userAgent);\n\nexport const isAndroidWebview = (userAgent: string) =>\n  /Android/i.test(userAgent) && !/Chrome|Firefox/i.test(userAgent);\n","import { CommonCoreConfig, StreamConfig, StreamType } from \"../types.js\";\nimport debug from \"debug\";\nimport { SegmentStorage } from \"./index.js\";\nimport {\n  isAndroid,\n  isIPadOrIPhone,\n  isAndroidWebview,\n  getStorageItemId,\n} from \"./utils.js\";\n\ntype SegmentDataItem = {\n  segmentId: number;\n  streamId: string;\n  data: ArrayBuffer;\n  startTime: number;\n  endTime: number;\n  streamType: StreamType;\n};\n\ntype Playback = {\n  position: number;\n  rate: number;\n};\n\ntype LastRequestedSegmentInfo = {\n  streamId: string;\n  segmentId: number;\n  startTime: number;\n  endTime: number;\n  swarmId: string;\n  streamType: StreamType;\n  isLiveStream: boolean;\n};\n\nconst BYTES_PER_MiB = 1048576;\n\nexport class SegmentMemoryStorage implements SegmentStorage {\n  private readonly userAgent = navigator.userAgent;\n  private segmentMemoryStorageLimit = 4 * 1024;\n  private currentStorageUsage = 0;\n\n  private cache = new Map<string, SegmentDataItem>();\n  private readonly logger: debug.Debugger;\n  private coreConfig?: CommonCoreConfig;\n  private mainStreamConfig?: StreamConfig;\n  private secondaryStreamConfig?: StreamConfig;\n  private currentPlayback?: Playback;\n  private lastRequestedSegment?: LastRequestedSegmentInfo;\n  private segmentChangeCallback?: (streamId: string) => void;\n\n  constructor() {\n    this.logger = debug(\"p2pml-core:segment-memory-storage\");\n    this.logger.color = \"RebeccaPurple\";\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async initialize(\n    coreConfig: CommonCoreConfig,\n    mainStreamConfig: StreamConfig,\n    secondaryStreamConfig: StreamConfig,\n  ) {\n    this.coreConfig = coreConfig;\n    this.mainStreamConfig = mainStreamConfig;\n    this.secondaryStreamConfig = secondaryStreamConfig;\n\n    this.setMemoryStorageLimit();\n    this.logger(\"initialized\");\n  }\n\n  onPlaybackUpdated(position: number, rate: number) {\n    this.currentPlayback = { position, rate };\n  }\n\n  onSegmentRequested(\n    swarmId: string,\n    streamId: string,\n    segmentId: number,\n    startTime: number,\n    endTime: number,\n    streamType: StreamType,\n    isLiveStream: boolean,\n  ): void {\n    this.lastRequestedSegment = {\n      streamId,\n      segmentId,\n      startTime,\n      endTime,\n      swarmId,\n      streamType,\n      isLiveStream,\n    };\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async storeSegment(\n    _swarmId: string,\n    streamId: string,\n    segmentId: number,\n    data: ArrayBuffer,\n    startTime: number,\n    endTime: number,\n    streamType: StreamType,\n    isLiveStream: boolean,\n  ) {\n    this.clear(isLiveStream, data.byteLength);\n\n    const storageId = getStorageItemId(streamId, segmentId);\n    this.cache.set(storageId, {\n      data,\n      segmentId,\n      streamId,\n      startTime,\n      endTime,\n      streamType,\n    });\n    this.increaseStorageUsage(data.byteLength);\n\n    this.logger(`add segment: ${segmentId} to ${streamId}`);\n\n    if (!this.segmentChangeCallback) {\n      throw new Error(\"dispatchStorageUpdatedEvent is not set\");\n    }\n\n    this.segmentChangeCallback(streamId);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async getSegmentData(_swarmId: string, streamId: string, segmentId: number) {\n    const segmentStorageId = getStorageItemId(streamId, segmentId);\n    const dataItem = this.cache.get(segmentStorageId);\n\n    if (dataItem === undefined) return undefined;\n\n    return dataItem.data;\n  }\n\n  getUsage() {\n    if (!this.lastRequestedSegment || !this.currentPlayback) {\n      return {\n        totalCapacity: this.segmentMemoryStorageLimit,\n        usedCapacity: this.currentStorageUsage,\n      };\n    }\n    const playbackPosition = this.currentPlayback.position;\n\n    let calculatedUsedCapacity = 0;\n    for (const { endTime, data } of this.cache.values()) {\n      if (playbackPosition > endTime) continue;\n\n      calculatedUsedCapacity += data.byteLength;\n    }\n\n    return {\n      totalCapacity: this.segmentMemoryStorageLimit,\n      usedCapacity: calculatedUsedCapacity / BYTES_PER_MiB,\n    };\n  }\n\n  hasSegment(_swarmId: string, streamId: string, externalId: number) {\n    const segmentStorageId = getStorageItemId(streamId, externalId);\n    const segment = this.cache.get(segmentStorageId);\n\n    return segment !== undefined;\n  }\n\n  getStoredSegmentIds(_swarmId: string, streamId: string) {\n    const externalIds: number[] = [];\n\n    for (const { segmentId, streamId: streamCacheId } of this.cache.values()) {\n      if (streamCacheId !== streamId) continue;\n      externalIds.push(segmentId);\n    }\n\n    return externalIds;\n  }\n\n  private clear(isLiveStream: boolean, newSegmentSize: number) {\n    if (\n      !this.currentPlayback ||\n      !this.mainStreamConfig ||\n      !this.secondaryStreamConfig ||\n      !this.coreConfig\n    ) {\n      return;\n    }\n\n    const isMemoryLimitReached = this.isMemoryLimitReached(newSegmentSize);\n\n    if (!isMemoryLimitReached && !isLiveStream) return;\n\n    const affectedStreams = new Set<string>();\n    const sortedCache = Array.from(this.cache.values()).sort(\n      (a, b) => a.startTime - b.startTime,\n    );\n\n    for (const segmentData of sortedCache) {\n      const { streamId, segmentId, data } = segmentData;\n      const storageId = getStorageItemId(streamId, segmentId);\n\n      const shouldRemove = this.shouldRemoveSegment(\n        segmentData,\n        isLiveStream,\n        this.currentPlayback.position,\n      );\n\n      if (!shouldRemove) continue;\n\n      this.cache.delete(storageId);\n      affectedStreams.add(streamId);\n      this.decreaseStorageUsage(data.byteLength);\n\n      this.logger(`Removed segment ${segmentId} from stream ${streamId}`);\n\n      if (!this.isMemoryLimitReached(newSegmentSize) && !isLiveStream) break;\n    }\n\n    this.sendUpdatesToAffectedStreams(affectedStreams);\n  }\n\n  private isMemoryLimitReached(segmentByteLength: number) {\n    return (\n      this.currentStorageUsage + segmentByteLength / BYTES_PER_MiB >\n      this.segmentMemoryStorageLimit\n    );\n  }\n\n  setSegmentChangeCallback(callback: (streamId: string) => void) {\n    this.segmentChangeCallback = callback;\n  }\n\n  private sendUpdatesToAffectedStreams(affectedStreams: Set<string>) {\n    if (affectedStreams.size === 0) return;\n\n    affectedStreams.forEach((stream) => {\n      if (!this.segmentChangeCallback) {\n        throw new Error(\"dispatchStorageUpdatedEvent is not set\");\n      }\n\n      this.segmentChangeCallback(stream);\n    });\n  }\n\n  private shouldRemoveSegment(\n    segmentData: SegmentDataItem,\n    isLiveStream: boolean,\n    currentPlaybackPosition: number,\n  ): boolean {\n    const { endTime, streamType } = segmentData;\n    const highDemandTimeWindow = this.getStreamTimeWindow(\n      streamType,\n      \"highDemandTimeWindow\",\n    );\n\n    if (currentPlaybackPosition <= endTime) return false;\n\n    if (isLiveStream) {\n      return currentPlaybackPosition > highDemandTimeWindow + endTime;\n    }\n\n    return true;\n  }\n\n  private increaseStorageUsage(segmentByteLength: number) {\n    this.currentStorageUsage += segmentByteLength / BYTES_PER_MiB;\n  }\n\n  private decreaseStorageUsage(segmentByteLength: number) {\n    this.currentStorageUsage -= segmentByteLength / BYTES_PER_MiB;\n  }\n\n  private setMemoryStorageLimit() {\n    if (this.coreConfig?.segmentMemoryStorageLimit) {\n      this.segmentMemoryStorageLimit =\n        this.coreConfig.segmentMemoryStorageLimit;\n      return;\n    }\n\n    if (isAndroidWebview(this.userAgent) || isIPadOrIPhone(this.userAgent)) {\n      this.segmentMemoryStorageLimit = 1024;\n    } else if (isAndroid(this.userAgent)) {\n      this.segmentMemoryStorageLimit = 2 * 1024;\n    }\n  }\n\n  private getStreamTimeWindow(\n    streamType: string,\n    configKey: \"highDemandTimeWindow\" | \"httpDownloadTimeWindow\",\n  ): number {\n    const config =\n      streamType === \"main\"\n        ? this.mainStreamConfig\n        : this.secondaryStreamConfig;\n\n    return config?.[configKey] ?? 0;\n  }\n\n  public destroy() {\n    this.cache.clear();\n  }\n}\n","export class EventTarget<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  EventTypesMap extends Record<string, (...args: any[]) => unknown>,\n> {\n  private events = new Map<\n    keyof EventTypesMap,\n    EventTypesMap[keyof EventTypesMap][]\n  >();\n\n  public dispatchEvent<K extends keyof EventTypesMap>(\n    eventName: K,\n    ...args: Parameters<EventTypesMap[K]>\n  ) {\n    const listeners = this.events.get(eventName);\n    if (!listeners) return;\n    for (const listener of listeners) {\n      listener(...args);\n    }\n  }\n\n  public getEventDispatcher<K extends keyof EventTypesMap>(eventName: K) {\n    let listeners = this.events.get(eventName);\n    if (!listeners) {\n      listeners = [];\n      this.events.set(eventName, listeners);\n    }\n\n    const definedListeners = listeners;\n\n    return (...args: Parameters<EventTypesMap[K]>) => {\n      for (const listener of definedListeners) {\n        listener(...args);\n      }\n    };\n  }\n\n  public addEventListener<K extends keyof EventTypesMap>(\n    eventName: K,\n    listener: EventTypesMap[K],\n  ) {\n    const listeners = this.events.get(eventName);\n    if (!listeners) {\n      this.events.set(eventName, [listener]);\n    } else {\n      listeners.push(listener);\n    }\n  }\n\n  public removeEventListener<K extends keyof EventTypesMap>(\n    eventName: K,\n    listener: EventTypesMap[K],\n  ) {\n    const listeners = this.events.get(eventName);\n    if (listeners) {\n      const index = listeners.indexOf(listener);\n      if (index !== -1) {\n        listeners.splice(index, 1);\n      }\n    }\n  }\n}\n","import { HybridLoader } from \"./hybrid-loader.js\";\nimport {\n  Stream,\n  CoreConfig,\n  Segment,\n  CoreEventMap,\n  DynamicCoreConfig,\n  EngineCallbacks,\n  StreamWithSegments,\n  SegmentWithStream,\n  CommonCoreConfig,\n  StreamConfig,\n  DefinedCoreConfig,\n  StreamType,\n  DynamicStreamConfig,\n} from \"./types.js\";\nimport { BandwidthCalculators, StreamDetails } from \"./internal-types.js\";\nimport * as StreamUtils from \"./utils/stream.js\";\nimport { BandwidthCalculator } from \"./bandwidth-calculator.js\";\nimport { SegmentMemoryStorage } from \"./segment-storage/segment-memory-storage.js\";\nimport { EventTarget } from \"./utils/event-target.js\";\nimport {\n  overrideConfig,\n  mergeAndFilterConfig,\n  deepCopy,\n  filterUndefinedProps,\n} from \"./utils/utils.js\";\nimport { TRACKER_CLIENT_VERSION_PREFIX } from \"./utils/peer.js\";\nimport { SegmentStorage } from \"./segment-storage/index.js\";\nimport { P2PTrackerClient } from \"./p2p/tracker-client.js\";\n\n/** Core class for managing media streams loading via P2P. */\nexport class Core<TStream extends Stream = Stream> {\n  /** Default configuration for common core settings. */\n  static readonly DEFAULT_COMMON_CORE_CONFIG: CommonCoreConfig = {\n    segmentMemoryStorageLimit: undefined,\n    customSegmentStorageFactory: undefined,\n  };\n\n  /** Default configuration for stream settings. */\n  static readonly DEFAULT_STREAM_CONFIG: StreamConfig = {\n    isP2PUploadDisabled: false,\n    isP2PDisabled: false,\n    simultaneousHttpDownloads: 2,\n    simultaneousP2PDownloads: 3,\n    highDemandTimeWindow: 15,\n    httpDownloadTimeWindow: 3000,\n    p2pDownloadTimeWindow: 6000,\n    webRtcMaxMessageSize: 64 * 1024 - 1,\n    p2pNotReceivingBytesTimeoutMs: 2000,\n    p2pInactiveLoaderDestroyTimeoutMs: 30 * 1000,\n    httpNotReceivingBytesTimeoutMs: 3000,\n    httpErrorRetries: 3,\n    p2pErrorRetries: 3,\n    trackerClientVersionPrefix: TRACKER_CLIENT_VERSION_PREFIX,\n    announceTrackers: [\n      \"wss://tracker.novage.com.ua\",\n      \"wss://tracker.webtorrent.dev\",\n      \"wss://tracker.openwebtorrent.com\",\n    ],\n    rtcConfig: {\n      iceServers: [\n        { urls: \"stun:stun.l.google.com:19302\" },\n        { urls: \"stun:global.stun.twilio.com:3478\" },\n      ],\n    },\n    validateP2PSegment: undefined,\n    validateHTTPSegment: undefined,\n    httpRequestSetup: undefined,\n    swarmId: undefined,\n  };\n\n  private readonly eventTarget = new EventTarget<CoreEventMap>();\n  private manifestResponseUrl?: string;\n  private readonly streams = new Map<string, StreamWithSegments<TStream>>();\n  private mainStreamConfig: StreamConfig;\n  private secondaryStreamConfig: StreamConfig;\n  private commonCoreConfig: CommonCoreConfig;\n  private readonly bandwidthCalculators: BandwidthCalculators = {\n    all: new BandwidthCalculator(),\n    http: new BandwidthCalculator(),\n  };\n  private segmentStorage?: SegmentStorage;\n  private mainStreamLoader?: HybridLoader;\n  private secondaryStreamLoader?: HybridLoader;\n  private streamDetails: StreamDetails = {\n    isLive: false,\n    activeLevelBitrate: 0,\n  };\n\n  /**\n   * Constructs a new Core instance with optional initial configuration.\n   *\n   * @param config - Optional partial configuration to override default settings.\n   *\n   * @example\n   * // Create a Core instance with custom configuration for HTTP and P2P downloads.\n   * const core = new Core({\n   *   simultaneousHttpDownloads: 5,\n   *   simultaneousP2PDownloads: 5,\n   *   httpErrorRetries: 5,\n   *   p2pErrorRetries: 5\n   * });\n   *\n   * @example\n   * // Create a Core instance using the default configuration.\n   * const core = new Core();\n   */\n  constructor(config?: Partial<CoreConfig>) {\n    const filteredConfig = filterUndefinedProps(config ?? {});\n\n    this.commonCoreConfig = mergeAndFilterConfig<CommonCoreConfig>({\n      defaultConfig: Core.DEFAULT_COMMON_CORE_CONFIG,\n      baseConfig: filteredConfig,\n    });\n\n    this.mainStreamConfig = mergeAndFilterConfig<StreamConfig>({\n      defaultConfig: Core.DEFAULT_STREAM_CONFIG,\n      baseConfig: filteredConfig,\n      specificStreamConfig: filteredConfig.mainStream,\n    });\n\n    this.secondaryStreamConfig = mergeAndFilterConfig<StreamConfig>({\n      defaultConfig: Core.DEFAULT_STREAM_CONFIG,\n      baseConfig: filteredConfig,\n      specificStreamConfig: filteredConfig.secondaryStream,\n    });\n  }\n\n  /**\n   * Retrieves the current configuration for the core instance, ensuring immutability.\n   *\n   * @returns A deep readonly version of the core configuration.\n   */\n  getConfig(): DefinedCoreConfig {\n    return {\n      ...deepCopy(this.commonCoreConfig),\n      mainStream: deepCopy(this.mainStreamConfig),\n      secondaryStream: deepCopy(this.secondaryStreamConfig),\n    };\n  }\n\n  /**\n   * Applies a set of dynamic configuration updates to the core, merging with the existing configuration.\n   *\n   * @param dynamicConfig - A set of configuration changes to apply.\n   *\n   * @example\n   * // Example of dynamically updating the download time windows and timeout settings.\n   * const dynamicConfig = {\n   *   httpDownloadTimeWindow: 60,  // Set HTTP download time window to 60 seconds\n   *   p2pDownloadTimeWindow: 60,   // Set P2P download time window to 60 seconds\n   *   httpNotReceivingBytesTimeoutMs: 1500,  // Set HTTP timeout to 1500 milliseconds\n   *   p2pNotReceivingBytesTimeoutMs: 1500    // Set P2P timeout to 1500 milliseconds\n   * };\n   * core.applyDynamicConfig(dynamicConfig);\n   */\n  applyDynamicConfig(dynamicConfig: DynamicCoreConfig) {\n    const { mainStream, secondaryStream } = dynamicConfig;\n\n    const mainStreamConfigCopy = deepCopy(this.mainStreamConfig);\n    const secondaryStreamConfigCopy = deepCopy(this.secondaryStreamConfig);\n\n    this.overrideAllConfigs(dynamicConfig, mainStream, secondaryStream);\n\n    this.processSpecificDynamicConfigParams(\n      mainStreamConfigCopy,\n      dynamicConfig,\n      \"main\",\n    );\n    this.processSpecificDynamicConfigParams(\n      secondaryStreamConfigCopy,\n      dynamicConfig,\n      \"secondary\",\n    );\n  }\n\n  private processSpecificDynamicConfigParams(\n    prevConfig: StreamConfig,\n    updatedConfig: DynamicCoreConfig,\n    streamType: StreamType,\n  ) {\n    const isP2PDisabled = this.getUpdatedStreamProperty(\n      \"isP2PDisabled\",\n      updatedConfig,\n      streamType,\n    );\n\n    if (isP2PDisabled && prevConfig.isP2PDisabled !== isP2PDisabled) {\n      this.destroyStreamLoader(streamType);\n    }\n\n    const isP2PUploadDisabled = this.getUpdatedStreamProperty(\n      \"isP2PUploadDisabled\",\n      updatedConfig,\n      streamType,\n    );\n\n    if (\n      isP2PUploadDisabled !== undefined &&\n      prevConfig.isP2PUploadDisabled !== isP2PUploadDisabled\n    ) {\n      const streamLoader =\n        streamType === \"main\"\n          ? this.mainStreamLoader\n          : this.secondaryStreamLoader;\n\n      streamLoader?.sendBroadcastAnnouncement(isP2PUploadDisabled);\n    }\n  }\n\n  private getUpdatedStreamProperty<K extends keyof DynamicStreamConfig>(\n    propertyName: K,\n    updatedConfig: DynamicCoreConfig,\n    streamType: StreamType,\n  ): DynamicStreamConfig[K] | undefined {\n    const updatedStreamConfig =\n      streamType === \"main\"\n        ? updatedConfig.mainStream\n        : updatedConfig.secondaryStream;\n\n    return updatedStreamConfig?.[propertyName] ?? updatedConfig[propertyName];\n  }\n\n  /**\n   * Adds an event listener for the specified event type on the core event target.\n   *\n   * @param eventName - The name of the event to listen for.\n   * @param listener - The callback function to invoke when the event is fired.\n   */\n  addEventListener<K extends keyof CoreEventMap>(\n    eventName: K,\n    listener: CoreEventMap[K],\n  ) {\n    this.eventTarget.addEventListener(eventName, listener);\n  }\n\n  /**\n   * Removes an event listener for the specified event type on the core event target.\n   *\n   * @param eventName - The name of the event to listen for.\n   * @param listener - The callback function to be removed.\n   */\n  removeEventListener<K extends keyof CoreEventMap>(\n    eventName: K,\n    listener: CoreEventMap[K],\n  ) {\n    this.eventTarget.removeEventListener(eventName, listener);\n  }\n\n  /**\n   * Sets the response URL for the manifest, stripping any query parameters.\n   *\n   * @param url - The full URL to the manifest response.\n   */\n  setManifestResponseUrl(url: string): void {\n    this.manifestResponseUrl = url.split(\"?\")[0];\n  }\n\n  /**\n   * Checks if a segment is already stored within the core.\n   *\n   * @param segmentRuntimeId - The runtime identifier of the segment to check.\n   * @returns `true` if the segment is present, otherwise `false`.\n   */\n  hasSegment(segmentRuntimeId: string): boolean {\n    return !!StreamUtils.getSegmentFromStreamsMap(\n      this.streams,\n      segmentRuntimeId,\n    );\n  }\n\n  /**\n   * Retrieves a specific stream by its runtime identifier, if it exists.\n   *\n   * @param streamRuntimeId - The runtime identifier of the stream to retrieve.\n   * @returns The stream with its segments, or `undefined` if not found.\n   */\n  getStream(streamRuntimeId: string): StreamWithSegments<TStream> | undefined {\n    return this.streams.get(streamRuntimeId);\n  }\n\n  /**\n   * Ensures a stream exists in the map; adds it if it does not.\n   *\n   * @param stream - The stream to potentially add to the map.\n   */\n  addStreamIfNoneExists(stream: TStream): void {\n    if (this.streams.has(stream.runtimeId)) return;\n\n    this.streams.set(stream.runtimeId, {\n      ...stream,\n      segments: new Map<string, SegmentWithStream<TStream>>(),\n    });\n  }\n\n  /**\n   * Updates the segments associated with a specific stream.\n   *\n   * @param streamRuntimeId - The runtime identifier of the stream to update.\n   * @param addSegments - Optional segments to add to the stream.\n   * @param removeSegmentIds - Optional segment IDs to remove from the stream.\n   */\n  updateStream(\n    streamRuntimeId: string,\n    addSegments?: Iterable<Segment>,\n    removeSegmentIds?: Iterable<string>,\n  ): void {\n    const stream = this.streams.get(streamRuntimeId);\n    if (!stream) return;\n\n    if (addSegments) {\n      for (const segment of addSegments) {\n        if (stream.segments.has(segment.runtimeId)) continue; // should not happen\n        stream.segments.set(segment.runtimeId, { ...segment, stream });\n      }\n    }\n\n    if (removeSegmentIds) {\n      for (const id of removeSegmentIds) {\n        stream.segments.delete(id);\n      }\n    }\n\n    this.mainStreamLoader?.updateStream(stream);\n    this.secondaryStreamLoader?.updateStream(stream);\n  }\n\n  /**\n   * Loads a segment given its runtime identifier and invokes the provided callbacks during the process.\n   * Initializes segment storage if it has not been initialized yet.\n   *\n   * @param segmentRuntimeId - The runtime identifier of the segment to load.\n   * @param callbacks - The callbacks to be invoked during segment loading.\n   * @throws {Error} - Throws if the manifest response URL is not defined.\n   */\n  async loadSegment(segmentRuntimeId: string, callbacks: EngineCallbacks) {\n    if (!this.manifestResponseUrl) {\n      throw new Error(\"Manifest response url is not defined\");\n    }\n\n    await this.initializeSegmentStorage();\n\n    const segment = this.identifySegment(segmentRuntimeId);\n\n    const loader = this.getStreamHybridLoader(segment);\n    void loader.loadSegment(segment, callbacks);\n  }\n\n  /**\n   * Aborts the loading of a segment specified by its runtime identifier.\n   *\n   * @param segmentRuntimeId - The runtime identifier of the segment whose loading is to be aborted.\n   */\n  abortSegmentLoading(segmentRuntimeId: string): void {\n    this.mainStreamLoader?.abortSegmentRequest(segmentRuntimeId);\n    this.secondaryStreamLoader?.abortSegmentRequest(segmentRuntimeId);\n  }\n\n  /**\n   * Updates the playback parameters while play head moves, specifically position and playback rate, for stream loaders.\n   *\n   * @param position - The new position in the stream, in seconds.\n   * @param rate - The new playback rate.\n   */\n  updatePlayback(position: number, rate: number): void {\n    this.mainStreamLoader?.updatePlayback(position, rate);\n    this.secondaryStreamLoader?.updatePlayback(position, rate);\n  }\n\n  /**\n   * Sets the active level bitrate, used for adjusting quality levels in adaptive streaming.\n   * Notifies the stream loaders if a change occurs.\n   *\n   * @param bitrate - The new bitrate to set as active.\n   */\n  setActiveLevelBitrate(bitrate: number) {\n    if (bitrate !== this.streamDetails.activeLevelBitrate) {\n      this.streamDetails.activeLevelBitrate = bitrate;\n      this.mainStreamLoader?.notifyLevelChanged();\n      this.secondaryStreamLoader?.notifyLevelChanged();\n    }\n  }\n\n  /**\n   * Updates the 'isLive' status of the stream\n   *\n   * @param isLive - Boolean indicating whether the stream is live.\n   */\n  setIsLive(isLive: boolean) {\n    this.streamDetails.isLive = isLive;\n  }\n\n  /**\n   * Identify if a segment is loadable by the P2P core based on the segment's stream type and configuration.\n   * @param segmentRuntimeId Segment runtime identifier to check.\n   * @returns `true` if the segment is loadable by the P2P core, otherwise `false`.\n   */\n  isSegmentLoadable(segmentRuntimeId: string): boolean {\n    try {\n      const segment = this.identifySegment(segmentRuntimeId);\n\n      if (\n        segment.stream.type === \"main\" &&\n        this.mainStreamConfig.isP2PDisabled\n      ) {\n        return false;\n      }\n\n      if (\n        segment.stream.type === \"secondary\" &&\n        this.secondaryStreamConfig.isP2PDisabled\n      ) {\n        return false;\n      }\n\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Cleans up resources used by the Core instance, including destroying any active stream loaders\n   * and clearing stored segments.\n   */\n  destroy(): void {\n    this.streams.clear();\n    this.mainStreamLoader?.destroy();\n    this.secondaryStreamLoader?.destroy();\n    this.segmentStorage?.destroy();\n    this.mainStreamLoader = undefined;\n    this.secondaryStreamLoader = undefined;\n    this.segmentStorage = undefined;\n    this.manifestResponseUrl = undefined;\n    this.streamDetails = { isLive: false, activeLevelBitrate: 0 };\n    P2PTrackerClient.clearPeerIdCache();\n  }\n\n  private async initializeSegmentStorage() {\n    if (this.segmentStorage) return;\n\n    const { isLive } = this.streamDetails;\n    const createCustomStorage =\n      this.commonCoreConfig.customSegmentStorageFactory;\n\n    if (createCustomStorage && typeof createCustomStorage !== \"function\") {\n      throw new Error(\"Storage configuration is invalid\");\n    }\n\n    const segmentStorage = createCustomStorage\n      ? createCustomStorage(isLive)\n      : new SegmentMemoryStorage();\n\n    await segmentStorage.initialize(\n      this.commonCoreConfig,\n      this.mainStreamConfig,\n      this.secondaryStreamConfig,\n    );\n\n    this.segmentStorage = segmentStorage;\n  }\n\n  private identifySegment(segmentRuntimeId: string): SegmentWithStream {\n    if (!this.manifestResponseUrl) {\n      throw new Error(\"Manifest response url is undefined\");\n    }\n\n    const segment = StreamUtils.getSegmentFromStreamsMap(\n      this.streams,\n      segmentRuntimeId,\n    );\n    if (!segment) {\n      throw new Error(`Not found segment with id: ${segmentRuntimeId}`);\n    }\n\n    return segment;\n  }\n\n  private overrideAllConfigs(\n    dynamicConfig: DynamicCoreConfig,\n    mainStream?: Partial<StreamConfig>,\n    secondaryStream?: Partial<StreamConfig>,\n  ) {\n    overrideConfig(this.commonCoreConfig, dynamicConfig);\n    overrideConfig(this.mainStreamConfig, dynamicConfig);\n    overrideConfig(this.secondaryStreamConfig, dynamicConfig);\n\n    if (mainStream) {\n      overrideConfig(this.mainStreamConfig, mainStream);\n    }\n\n    if (secondaryStream) {\n      overrideConfig(this.secondaryStreamConfig, secondaryStream);\n    }\n  }\n\n  private destroyStreamLoader(streamType: StreamType) {\n    if (streamType === \"main\") {\n      this.mainStreamLoader?.destroy();\n      this.mainStreamLoader = undefined;\n    } else {\n      this.secondaryStreamLoader?.destroy();\n      this.secondaryStreamLoader = undefined;\n    }\n  }\n\n  private getStreamHybridLoader(segment: SegmentWithStream) {\n    if (segment.stream.type === \"main\") {\n      this.mainStreamLoader ??= this.createNewHybridLoader(segment);\n      return this.mainStreamLoader;\n    } else {\n      this.secondaryStreamLoader ??= this.createNewHybridLoader(segment);\n      return this.secondaryStreamLoader;\n    }\n  }\n\n  private createNewHybridLoader(segment: SegmentWithStream) {\n    if (!this.manifestResponseUrl) {\n      throw new Error(\"Manifest response url is not defined\");\n    }\n\n    if (!this.segmentStorage) {\n      throw new Error(\"Segment storage is not initialized\");\n    }\n\n    const streamConfig =\n      segment.stream.type === \"main\"\n        ? this.mainStreamConfig\n        : this.secondaryStreamConfig;\n\n    return new HybridLoader(\n      this.manifestResponseUrl,\n      segment,\n      this.streamDetails,\n      streamConfig,\n      this.bandwidthCalculators,\n      this.segmentStorage,\n      this.eventTarget,\n    );\n  }\n}\n"],"names":["getDefaultExportFromCjs","browser","e","i","noop","browserExports","ms","require$$0","debug","self","common","exports","module","process","ReflectApply","ReflectOwnKeys","NumberIsNaN","EventEmitter","eventsModule","once","events","cb","onceModule","global","queueMicrotask","scope","require$$1","TextDecoder","require$$2","data","onerror","errCode","MAX_BUFFERED_AMOUNT","Peer","Duplex","err","event","Debug","ws","HTTPTracker","md5Module","md5","encoder","decoder","obj","PeerCommandType","SerializedItem","Serialization.ResizableUint8Array","Serialization.serializeInt","Serialization.serializeSimilarIntArray","Serialization.serializeString","Serialization.SerializedItem","Serialization.deserializeInt","Serialization.deserializeSimilarIntArray","Serialization.deserializeString","Command.isCommandChunk","Command.serializePeerCommand","Utils.getControlledPromise","Command.BinaryCommandChunksJoiner","Command.deserializeCommand","Command.BinaryCommandJoiningError","error","Utils.hexToUtf8","PeerUtil.getStreamHash","LoggerUtils.getStreamString","PeerUtil.generatePeerId","TrackerClient","StreamUtils.getStreamSwarmId","peer","Utils.getRandomItem","StreamUtils.getSegmentFromStreamByExternalId","Utils.joinChunks","Request","StreamUtils.getSegmentAvgDuration","LoggerUtils.getSegmentString","queue","QueueUtils.generateQueue","Utils.shuffleArray","Utils.arrayBackwards","StreamUtils.getSegmentFromStreamsMap"],"mappings":"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","x_google_ignoreList":[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,24,25,26,27,28,29]}