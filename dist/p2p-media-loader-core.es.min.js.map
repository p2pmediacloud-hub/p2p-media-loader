{"version":3,"file":"p2p-media-loader-core.es.min.js","sources":["../src/types.ts","../src/http-loader.ts","../../../node_modules/.pnpm/vite-plugin-node-polyfills@0.24.0_rollup@4.53.2_vite@7.2.2_@types+node@24.10.1_terser@5.44.1_yaml@2.8.1_/node_modules/vite-plugin-node-polyfills/shims/process/dist/index.js","../../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js","../../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/browser.js","../../../node_modules/.pnpm/debug@4.4.3/node_modules/debug/src/common.js","../../../node_modules/.pnpm/events@3.3.0/node_modules/events/events.js","../../../node_modules/.pnpm/once@1.4.0/node_modules/once/once.js","../../../node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js","../../../node_modules/.pnpm/queue-microtask@1.2.3/node_modules/queue-microtask/index.js","../../../node_modules/.pnpm/run-parallel@1.2.0/node_modules/run-parallel/index.js","../../../node_modules/.pnpm/webrtc-polyfill@1.1.10/node_modules/webrtc-polyfill/browser.js","../../../node_modules/.pnpm/fast-fifo@1.3.2/node_modules/fast-fifo/index.js","../../../node_modules/.pnpm/fast-fifo@1.3.2/node_modules/fast-fifo/fixed-size.js","../../../node_modules/.pnpm/text-decoder@1.2.3/node_modules/text-decoder/lib/browser-decoder.js","../../../node_modules/.pnpm/text-decoder@1.2.3/node_modules/text-decoder/index.js","../../../node_modules/.pnpm/streamx@2.23.0/node_modules/streamx/index.js","../../../node_modules/.pnpm/events-universal@1.0.1/node_modules/events-universal/default.js","../../../node_modules/.pnpm/err-code@3.0.1/node_modules/err-code/index.js","../../../node_modules/.pnpm/uint8-util@2.2.5/node_modules/uint8-util/util.js","../../../node_modules/.pnpm/base64-arraybuffer@1.0.2/node_modules/base64-arraybuffer/dist/base64-arraybuffer.es5.js","../../../node_modules/.pnpm/uint8-util@2.2.5/node_modules/uint8-util/browser.js","../../../node_modules/.pnpm/@thaunknown+simple-peer@10.0.12/node_modules/@thaunknown/simple-peer/lite.js","../__vite-browser-external","../../../node_modules/.pnpm/bittorrent-tracker@11.2.2/node_modules/bittorrent-tracker/lib/common.js","../../../node_modules/.pnpm/@thaunknown+simple-websocket@9.1.3_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/@thaunknown/simple-websocket/index.js","../../../node_modules/.pnpm/bittorrent-tracker@11.2.2/node_modules/bittorrent-tracker/lib/client/tracker.js","../../../node_modules/.pnpm/bittorrent-tracker@11.2.2/node_modules/bittorrent-tracker/lib/client/websocket-tracker.js","../../../node_modules/.pnpm/bittorrent-tracker@11.2.2/node_modules/bittorrent-tracker/client.js","../../../node_modules/.pnpm/nano-md5@1.0.5/node_modules/nano-md5/md5.js","../src/utils/peer.ts","../src/utils/version.ts","../src/utils/logger.ts","../src/utils/utils.ts","../src/p2p/commands/types.ts","../src/p2p/commands/binary-serialization.ts","../src/p2p/commands/binary-command-creator.ts","../src/p2p/commands/commands.ts","../src/p2p/peer-protocol.ts","../src/p2p/peer.ts","../src/p2p/tracker-client.ts","../src/utils/stream.ts","../src/p2p/loader.ts","../src/p2p/loaders-container.ts","../src/requests/request.ts","../src/requests/request-container.ts","../src/requests/engine-request.ts","../src/utils/queue.ts","../src/hybrid-loader.ts","../src/bandwidth-calculator.ts","../src/segment-storage/utils.ts","../src/segment-storage/segment-memory-storage.ts","../src/utils/event-target.ts","../src/core.ts"],"sourcesContent":["import { SegmentStorage } from \"./segment-storage/index.js\";\n\n/** Represents the types of streams available, either primary (main) or secondary. */\nexport type StreamType = \"main\" | \"secondary\";\n\n/** Represents a range of bytes, used for specifying a segment of data to download. */\nexport type ByteRange = {\n  /** The starting byte index of the range. */\n  start: number;\n  /** The ending byte index of the range. */\n  end: number;\n};\n\n/** Describes a media segment with its unique identifiers, location, and timing information. */\nexport type Segment = {\n  /** A runtime identifier for the segment that includes URL and byte range from its manifest. */\n  readonly runtimeId: string;\n\n  /** An unique identifier of the segment in its stream used for P2P communications: sequence number for HLS or playtime for MPEG-DASH. */\n  readonly externalId: number;\n\n  /** The URL from which the segment can be downloaded. */\n  readonly url: string;\n\n  /** An optional property specifying the range of bytes that represent the segment. */\n  readonly byteRange?: ByteRange;\n\n  /** The start time of the segment in seconds, relative to the beginning of the stream. */\n  readonly startTime: number;\n\n  /** The end time of the segment in seconds, relative to the beginning of the stream. */\n  readonly endTime: number;\n};\n\n/** Extends a Segment with a reference to its associated stream. */\nexport type SegmentWithStream<TStream extends Stream = Stream> = Segment & {\n  readonly stream: StreamWithSegments<TStream>;\n};\n\n/**\n * Represents a stream that includes multiple segments, each associated with the stream.\n * @template TStream Type of the underlying stream data structure.\n */\nexport type StreamWithSegments<TStream extends Stream = Stream> = TStream & {\n  readonly segments: Map<string, SegmentWithStream<TStream>>;\n};\n\n/** Represents a media stream with various defining characteristics. */\nexport type Stream = {\n  /** Runtime identifier of the stream from an engine. */\n  readonly runtimeId: string;\n\n  /** Stream type. */\n  readonly type: StreamType;\n\n  /** Stream index in the manifest. */\n  readonly index: number;\n};\n\n/** Represents a defined Core configuration with specific settings for the main and secondary streams. */\nexport type DefinedCoreConfig = CommonCoreConfig & {\n  /** Configuration for the main stream. */\n  mainStream: StreamConfig;\n  /** Configuration for the secondary stream. */\n  secondaryStream: StreamConfig;\n};\n\n/** Represents a set of properties that can be dynamically modified at runtime. */\nexport type DynamicStreamProperties =\n  | \"highDemandTimeWindow\"\n  | \"httpDownloadTimeWindow\"\n  | \"p2pDownloadTimeWindow\"\n  | \"simultaneousHttpDownloads\"\n  | \"simultaneousP2PDownloads\"\n  | \"webRtcMaxMessageSize\"\n  | \"p2pNotReceivingBytesTimeoutMs\"\n  | \"p2pInactiveLoaderDestroyTimeoutMs\"\n  | \"httpNotReceivingBytesTimeoutMs\"\n  | \"httpErrorRetries\"\n  | \"p2pErrorRetries\"\n  | \"validateP2PSegment\"\n  | \"httpRequestSetup\"\n  | \"isP2PDisabled\"\n  | \"isP2PUploadDisabled\";\n\n/**\n * Represents a dynamically modifiable configuration, allowing updates to selected CoreConfig properties at runtime.\n *\n * @example\n * ```typescript\n * const dynamicConfig: DynamicCoreConfig = {\n *   core: {\n *     cachedSegmentsCount: 200,\n *   },\n *   mainStream: {\n *     swarmId: \"custom swarm ID for video stream\",\n *     p2pDownloadTimeWindow: 6000,\n *   },\n *   secondaryStream: {\n *     swarmId: \"custom swarm ID for audio stream\",\n *     p2pDownloadTimeWindow: 3000,\n *   }\n * };\n * ```\n */\nexport type DynamicCoreConfig = Partial<\n  Pick<CoreConfig, DynamicStreamProperties>\n> &\n  Partial<CommonCoreConfig> & {\n    /** Optional dynamic configuration for the main stream. */\n    mainStream?: DynamicStreamConfig;\n    /** Optional dynamic configuration for the secondary stream. */\n    secondaryStream?: DynamicStreamConfig;\n  };\n\n/** Represents a partial configuration for a stream with dynamic properties. */\nexport type DynamicStreamConfig = Partial<\n  Pick<StreamConfig, DynamicStreamProperties>\n>;\n\n/** Represents the configuration for the Core functionality that is common to all streams. */\nexport type CommonCoreConfig = {\n  /**\n   * Defines the memory storage limit for media segments, in MiB.\n   *\n   * @default\n   * ```typescript\n   * segmentMemoryStorageLimit: undefined\n   * ```\n   *\n   * - When `undefined`, the default limit is determined based on the device type and browser:\n   *    - Desktop: 4096 MiB\n   *    - Android: 2048 MiB\n   *    - iOS: 1024 MiB\n   *    - Android WebView: 1024 MiB\n   *    - iOS WebView: 1024 MiB\n   *\n   */\n  segmentMemoryStorageLimit: number | undefined;\n\n  /**\n   * Optional custom storage factory for the segments storage.\n   *\n   * @default\n   * ```typescript\n   * customSegmentStorageFactory: undefined\n   * ```\n   */\n  customSegmentStorageFactory?: (isLive: boolean) => SegmentStorage;\n};\n\n/**\n * Represents a set of configuration parameters that can be used to override or extend the\n * default configuration settings for a specific stream (main or secondary).\n *\n * @example Configuration for basic video stream\n *\n * ```typescript\n * const config: CoreConfig = {\n *  highDemandTimeWindow: 15,\n *  httpDownloadTimeWindow: 3000,\n *  p2pDownloadTimeWindow: 6000,\n *  swarmId: \"custom swarm ID for video stream\",\n * }\n * ```\n *\n * @example Configuration for advanced video stream\n *\n * ```typescript\n * const config: CoreConfig = {\n *  // Configuration for both streams\n *  highDemandTimeWindow: 20,\n *  httpDownloadTimeWindow: 3000,\n *  p2pDownloadTimeWindow: 6000,\n *  mainStream: {\n *   // Optional configuration for the main stream\n *   swarmId: \"custom swarm ID for video stream\",\n *  },\n *  secondaryStream: {\n *   // Optional configuration for the secondary stream\n *   swarmId: \"custom swarm ID for audio stream\",\n *  },\n *  ```\n */\nexport type CoreConfig = Partial<StreamConfig> &\n  Partial<CommonCoreConfig> & {\n    /** Optional configuration for the main stream. */\n    mainStream?: Partial<StreamConfig>;\n    /** Optional configuration for the secondary stream. */\n    secondaryStream?: Partial<StreamConfig>;\n  };\n\n/** Configuration options for the Core functionality, including network and processing parameters. */\nexport type StreamConfig = {\n  /**\n   * Controls if peer-to-peer upload is disabled for the stream.\n   * If `true`, the stream only downloads segments without uploading to peers.\n   *\n   * @default\n   * ```typescript\n   * isP2PUploadDisabled: false\n   * ```\n   */\n  isP2PUploadDisabled: boolean;\n  /**\n   * Controls whether peer-to-peer functionality is disabled for the stream.\n   *\n   * @default\n   * ```typescript\n   * isP2PDisabled: false\n   * ```\n   */\n  isP2PDisabled: boolean;\n  /**\n   * Defines the duration of the time window, in seconds, during which segments are pre-loaded to ensure smooth playback.\n   * This window helps prioritize the fetching of media segments that are imminent to playback.\n   *\n   * @default\n   * ```typescript\n   * highDemandTimeWindow: 15\n   * ```\n   */\n  highDemandTimeWindow: number;\n\n  /**\n   * Defines the time window, in seconds, for HTTP segment downloads. This property specifies the duration\n   * over which media segments are pre-fetched using HTTP requests.\n   *\n   * For a better P2P ratio, it is recommended to set this `httpDownloadTimeWindow` to be lower than `p2pDownloadTimeWindow`.\n   *\n   * NOTE: This setting only takes effect if there is at least one peer connection and the connected peer\n   * does not have the requested segments available to share via P2P.\n   *\n   * @default\n   * ```typescript\n   * httpDownloadTimeWindow: 3000\n   * ```\n   */\n  httpDownloadTimeWindow: number;\n\n  /**\n   * Defines the time window, in seconds, dedicated to pre-fetching media segments via Peer-to-Peer (P2P) downloads.\n   * This duration determines how much content is downloaded in advance using P2P connections to ensure smooth playback and reduce reliance on HTTP downloads.\n   *\n   * For a better P2P ratio, it is recommended to set this time window to be greater than `httpDownloadTimeWindow` to maximize P2P usage.\n   *\n   * @default\n   * ```typescript\n   * p2pDownloadTimeWindow: 6000\n   * ```\n   */\n  p2pDownloadTimeWindow: number;\n\n  /**\n   * Maximum number of simultaneous HTTP downloads allowed.\n   *\n   * @default\n   * ```typescript\n   * simultaneousHttpDownloads: 2\n   * ```\n   */\n  simultaneousHttpDownloads: number;\n\n  /**\n   * Maximum number of simultaneous P2P downloads allowed.\n   *\n   * @default\n   * ```typescript\n   * simultaneousP2PDownloads: 3\n   * ```\n   */\n  simultaneousP2PDownloads: number;\n\n  /**\n   * Maximum message size for WebRTC communications, in bytes.\n   *\n   * @default\n   * ```typescript\n   * webRtcMaxMessageSize: 64 * 1024 - 1\n   * ```\n   */\n  webRtcMaxMessageSize: number;\n\n  /**\n   * Timeout for not receiving bytes from P2P, in milliseconds.\n   *\n   * @default\n   * ```typescript\n   * p2pNotReceivingBytesTimeoutMs: 2000\n   * ```\n   */\n  p2pNotReceivingBytesTimeoutMs: number;\n\n  /**\n   * Timeout for destroying the P2P loader if inactive, in milliseconds.\n   *\n   * @default\n   * ```typescript\n   * p2pInactiveLoaderDestroyTimeoutMs: 30 * 1000\n   * ```\n   */\n  p2pInactiveLoaderDestroyTimeoutMs: number;\n\n  /**\n   * Timeout for not receiving bytes from HTTP downloads, in milliseconds.\n   *\n   * @default\n   * ```typescript\n   * httpNotReceivingBytesTimeoutMs: 3000\n   * ```\n   */\n  httpNotReceivingBytesTimeoutMs: number;\n\n  /**\n   * Number of retries allowed after an HTTP error.\n   *\n   * @default\n   * ```typescript\n   * httpErrorRetries: 3\n   * ```\n   */\n  httpErrorRetries: number;\n\n  /**\n   * Number of retries allowed after a P2P error.\n   *\n   * @default\n   * ```typescript\n   * p2pErrorRetries: 3\n   * ```\n   */\n  p2pErrorRetries: number;\n\n  /**\n   * List of URLs to the WebTorrent trackers used for announcing and discovering peers (i.e. WebRTC signaling).\n   *\n   * WARNING: In the Safari browser, only the first tracker will be used. Safari has issues with multiple trackers,\n   * leading to problems with sending SDP messages for WebRTC signaling.\n   *\n   * @default\n   * The default trackers used are:\n   * ```typescript\n   * [\n   *   \"wss://tracker.novage.com.ua\",\n   *   \"wss://tracker.webtorrent.dev\",\n   *   \"wss://tracker.openwebtorrent.com\",\n   * ]\n   * ```\n   */\n  announceTrackers: string[];\n\n  /**\n   * Configuration for the RTC layer, used in WebRTC communication.\n   * This configuration specifies the STUN/TURN servers used by WebRTC to establish connections through NATs and firewalls.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/RTCConfiguration\n   *\n   * @default\n   * ```json\n   * {\n   *   \"rtcConfig\": {\n   *     \"iceServers\": [\n   *       { \"urls\": \"stun:stun.l.google.com:19302\" },\n   *       { \"urls\": \"stun:global.stun.twilio.com:3478\" }\n   *     ]\n   *   }\n   * }\n   * ```\n   */\n  rtcConfig: RTCConfiguration;\n\n  /**\n   * Prefix to use for the WebTorrent client version in tracker communications.\n   * If undefined, the default version prefix is used, which is calculated based on the package version.\n   *\n   * @default\n   * ```typescript\n   * trackerClientVersionPrefix: undefined\n   * ```\n   */\n  trackerClientVersionPrefix: string;\n\n  /**\n   * Optional unique identifier for the swarm, used to isolate peer pools by media stream.\n   * If undefined, the URL of the manifest is used as the swarm ID.\n   * @default\n   * ```typescript\n   * swarmId: undefined\n   * ```\n   */\n  swarmId?: string;\n\n  /**\n   * Optional function to validate a P2P segment before fully integrating it into the playback buffer.\n   * @param url URL of the segment to validate.\n   * @param byteRange Optional byte range of the segment.\n   * @param data Downloaded segment data.\n   * @returns A promise that resolves with a boolean indicating if the segment is valid.\n   *\n   * @default\n   * ```typescript\n   * validateP2PSegment: undefined\n   * ```\n   */\n  validateP2PSegment?: (\n    url: string,\n    byteRange: ByteRange | undefined,\n    data: ArrayBuffer,\n  ) => Promise<boolean>;\n\n  /**\n   * Optional function to validate a HTTP segment before fully integrating it into the playback buffer.\n   * @param url URL of the segment to validate.\n   * @param byteRange Optional byte range of the segment.\n   * @param data Downloaded segment data.\n   * @returns A promise that resolves with a boolean indicating if the segment is valid.\n   *\n   * @default\n   * ```typescript\n   * validateHTTPSegment: undefined\n   * ```\n   */\n  validateHTTPSegment?: (\n    url: string,\n    byteRange: ByteRange | undefined,\n    data: ArrayBuffer,\n  ) => Promise<boolean>;\n\n  /**\n   * Optional function to customize the setup of HTTP requests for segment downloads.\n   * @param segmentUrl URL of the segment.\n   * @param segmentByteRange The range of bytes requested for the segment.\n   * @param requestAbortSignal An abort signal to cancel the request if needed.\n   * @param requestByteRange Additional byte range for partial requests, if required.\n   * @returns A promise that resolves with the configured request, or undefined if no customization should be made.\n   *\n   * @default\n   * ```typescript\n   * httpRequestSetup: undefined\n   * ```\n   */\n  httpRequestSetup?: (\n    segmentUrl: string,\n    segmentByteRange: ByteRange | undefined,\n    requestAbortSignal: AbortSignal,\n    requestByteRange: { start: number; end?: number } | undefined,\n  ) => Promise<Request | undefined | null>;\n};\n\n/**\n * Specifies the source of a download within a media streaming context.\n *\n * \"http\" - Indicates that the segment was downloaded using the HTTP protocol.\n *\n * \"p2p\"- Indicates that the segment was downloaded through a peer-to-peer network.\n */\nexport type DownloadSource = \"http\" | \"p2p\";\n\n/** Represents details about a segment event. */\nexport type SegmentStartDetails = {\n  /** The segment that the event is about. */\n  segment: Segment;\n\n  /** The origin of the segment download. */\n  downloadSource: DownloadSource;\n\n  /** The peer ID, if the segment is downloaded from a peer. */\n  peerId: string | undefined;\n};\n\n/** Represents details about a segment error event. */\nexport type SegmentErrorDetails = {\n  /** The error that occurred during the segment download. */\n  error: RequestError;\n\n  /** The segment that the event is about. */\n  segment: Segment;\n\n  /** The source of the download. */\n  downloadSource: DownloadSource;\n\n  /** The peer ID, if the segment was downloaded from a peer. */\n  peerId: string | undefined;\n\n  /** The type of stream that the segment is associated with. */\n  streamType: StreamType;\n};\n\n/** Represents details about a segment abort event. */\nexport type SegmentAbortDetails = {\n  /** The segment that the event is about. */\n  segment: Segment;\n\n  /** The source of the download. */\n  downloadSource: DownloadSource | undefined;\n\n  /** The peer ID, if the segment was downloaded from a peer. */\n  peerId: string | undefined;\n\n  /** The type of stream that the segment is associated with. */\n  streamType: StreamType;\n};\n\n/** Represents the details about a loaded segment. */\nexport type SegmentLoadDetails = {\n  /** The URL of the loaded segment */\n  segmentUrl: string;\n\n  /** The length of the segment in bytes. */\n  bytesLength: number;\n\n  /** The source of the download. */\n  downloadSource: DownloadSource;\n\n  /** The peer ID, if the segment was downloaded from a peer. */\n  peerId: string | undefined;\n\n  /** The segment that the event is about. */\n  streamType: StreamType;\n};\n\n/** Represents the details of a peer in a peer-to-peer network. */\nexport type PeerDetails = {\n  /** The unique identifier for a peer in the network. */\n  peerId: string;\n  /** The type of stream that the peer is connected to. */\n  streamType: StreamType;\n};\n\n/** Represents the details of a peer error event. */\nexport type PeerErrorDetails = {\n  /** The unique identifier for a peer in the network. */\n  peerId: string;\n  /** The type of stream that the peer is connected to. */\n  streamType: StreamType;\n  /** The error that occurred during the peer-to-peer connection. */\n  error: Error;\n};\n\n/** Represents the details of a tracker error event. */\nexport type TrackerErrorDetails = {\n  /** The type of stream that the tracker is for. */\n  streamType: StreamType;\n  /** The error that occurred during the tracker request. */\n  error: unknown;\n};\n\nexport type TrackerWarningDetails = {\n  /** The type of stream that the tracker is for. */\n  streamType: StreamType;\n  /** The warning that occurred during the tracker request. */\n  warning: unknown;\n};\n\n/**\n * The CoreEventMap defines a comprehensive suite of event handlers crucial for monitoring and controlling the lifecycle\n * of segment downloading and uploading processes.\n */\nexport type CoreEventMap = {\n  /**\n   * Invoked when a segment is fully downloaded and available for use.\n   *\n   * @param params - Contains information about the loaded segment.\n   */\n  onSegmentLoaded: (params: SegmentLoadDetails) => void;\n\n  /**\n   * Triggered when an error occurs during the download of a segment.\n   *\n   * @param params - Contains information about the errored segment.\n   */\n  onSegmentError: (params: SegmentErrorDetails) => void;\n\n  /**\n   * Called if the download of a segment is aborted before completion.\n   *\n   * @param params - Contains information about the aborted segment.\n   */\n  onSegmentAbort: (params: SegmentAbortDetails) => void;\n\n  /**\n   * Fired at the beginning of a segment download process.\n   *\n   * @param params - Provides details about the segment being downloaded.\n   */\n  onSegmentStart: (params: SegmentStartDetails) => void;\n\n  /**\n   * Occurs when a new peer-to-peer connection is established.\n   *\n   * @param params - Contains details about the peer that the event is about.\n   */\n  onPeerConnect: (params: PeerDetails) => void;\n\n  /**\n   * Triggered when an existing peer-to-peer connection is closed.\n   *\n   * @param params - Contains details about the peer that the event is about.\n   */\n  onPeerClose: (params: PeerDetails) => void;\n\n  /**\n   * Triggered when an error occurs during a peer-to-peer connection.\n   *\n   * @param params - Contains details about the error and the peer that the event is about.\n   */\n  onPeerError: (params: PeerErrorDetails) => void;\n\n  /**\n   * Invoked after a chunk of data from a segment has been successfully downloaded.\n   *\n   * @param bytesLength - The size of the downloaded chunk in bytes.\n   * @param downloadSource - The source of the download.\n   * @param peerId - The peer ID of the peer that the event is about, if applicable.\n   */\n  onChunkDownloaded: (\n    bytesLength: number,\n    downloadSource: DownloadSource,\n    peerId?: string,\n  ) => void;\n\n  /**\n   * Called when a chunk of data has been successfully uploaded to a peer.\n   *\n   * @param bytesLength - The length of the segment in bytes.\n   * @param peerId - The peer ID, if the segment was downloaded from a peer\n   */\n  onChunkUploaded: (bytesLength: number, peerId: string) => void;\n\n  /**\n   * Called when an error occurs during the tracker request process.\n   *\n   * @param params - Contains information about the tracker error.\n   */\n  onTrackerError: (params: TrackerErrorDetails) => void;\n\n  /**\n   * Called when a warning occurs during the tracker request process.\n   *\n   * @param params - Contains information about the tracker warning.\n   */\n  onTrackerWarning: (params: TrackerWarningDetails) => void;\n};\n\n/** Defines the types of errors that can occur during a request abortion process. */\nexport type RequestAbortErrorType = \"abort\" | \"bytes-receiving-timeout\";\n\n/** Defines the types of errors specific to HTTP requests. */\nexport type HttpRequestErrorType =\n  | \"http-error\"\n  | \"http-bytes-mismatch\"\n  | \"http-unexpected-status-code\"\n  | \"http-segment-validation-failed\";\n\n/** Defines the types of errors specific to peer-to-peer requests. */\nexport type PeerRequestErrorType =\n  | \"peer-response-bytes-length-mismatch\"\n  | \"peer-protocol-violation\"\n  | \"peer-segment-absent\"\n  | \"peer-closed\"\n  | \"p2p-segment-validation-failed\";\n\n/** Enumerates all possible request error types, including HTTP and peer-related errors. */\nexport type RequestErrorType =\n  | RequestAbortErrorType\n  | PeerRequestErrorType\n  | HttpRequestErrorType;\n\n/**\n * Represents an error that can occur during the request process, with a timestamp for when the error occurred.\n * @template T - The specific type of request error.\n */\nexport class RequestError<\n  T extends RequestErrorType = RequestErrorType,\n> extends Error {\n  /** Error timestamp. */\n  readonly timestamp: number;\n\n  /**\n   * Constructs a new RequestError.\n   * @param type - The specific error type.\n   * @param message - Optional message describing the error.\n   */\n  constructor(\n    readonly type: T,\n    message?: string,\n  ) {\n    super(message);\n    this.timestamp = performance.now();\n  }\n}\n\n/** Represents the response from a segment request, including the data and measured bandwidth. */\nexport type SegmentResponse = {\n  /** Segment data as an ArrayBuffer. */\n  data: ArrayBuffer;\n\n  /** Measured bandwidth for the segment download, in bytes per second. */\n  bandwidth: number;\n};\n\n/** Custom error class for errors that occur during core network requests. */\nexport class CoreRequestError extends Error {\n  /**\n   * Constructs a new CoreRequestError.\n   * @param type - The type of the error, either 'failed' or 'aborted'.\n   */\n  constructor(readonly type: \"failed\" | \"aborted\") {\n    super();\n  }\n}\n\n/** Callbacks for handling the success or failure of an engine operation. */\nexport type EngineCallbacks = {\n  /**\n   * Called when the operation is successful.\n   * @param response - The response from the successful operation.\n   */\n  onSuccess: (response: SegmentResponse) => void;\n\n  /**\n   * Called when the operation encounters an error.\n   * @param reason - The error encountered during the operation.\n   */\n  onError: (reason: CoreRequestError) => void;\n};\n","import {\n  CoreConfig,\n  CoreEventMap,\n  RequestError,\n  HttpRequestErrorType,\n} from \"./types.js\";\nimport {\n  Request as SegmentRequest,\n  RequestControls,\n} from \"./requests/request.js\";\nimport { EventTarget } from \"./utils/event-target.js\";\n\ntype HttpConfig = Pick<\n  CoreConfig,\n  \"httpNotReceivingBytesTimeoutMs\" | \"httpRequestSetup\" | \"validateHTTPSegment\"\n>;\n\nexport class HttpRequestExecutor {\n  private readonly requestControls: RequestControls;\n  private readonly abortController = new AbortController();\n  private readonly expectedBytesLength?: number;\n  private readonly requestByteRange?: { start: number; end?: number };\n  private readonly onChunkDownloaded: CoreEventMap[\"onChunkDownloaded\"];\n\n  constructor(\n    private readonly request: SegmentRequest,\n    private readonly httpConfig: HttpConfig,\n    eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    this.onChunkDownloaded =\n      eventTarget.getEventDispatcher(\"onChunkDownloaded\");\n\n    const { byteRange } = this.request.segment;\n    if (byteRange) this.requestByteRange = { ...byteRange };\n\n    if (request.loadedBytes !== 0) {\n      this.requestByteRange = this.requestByteRange ?? { start: 0 };\n      this.requestByteRange.start =\n        this.requestByteRange.start + request.loadedBytes;\n    }\n    if (this.request.totalBytes) {\n      this.expectedBytesLength =\n        this.request.totalBytes - this.request.loadedBytes;\n    }\n\n    this.requestControls = this.request.start(\n      { downloadSource: \"http\" },\n      {\n        abort: () => this.abortController.abort(\"abort\"),\n        notReceivingBytesTimeoutMs:\n          this.httpConfig.httpNotReceivingBytesTimeoutMs,\n      },\n    );\n    void this.fetch();\n  }\n\n  private async fetch() {\n    const { segment } = this.request;\n    try {\n      let request = await this.httpConfig.httpRequestSetup?.(\n        segment.url,\n        segment.byteRange,\n        this.abortController.signal,\n        this.requestByteRange,\n      );\n\n      if (!request) {\n        const headers = new Headers(\n          this.requestByteRange\n            ? {\n                Range: `bytes=${this.requestByteRange.start}-${\n                  this.requestByteRange.end ?? \"\"\n                }`,\n              }\n            : undefined,\n        );\n\n        request = new Request(segment.url, {\n          headers,\n          signal: this.abortController.signal,\n        });\n      }\n\n      if (this.abortController.signal.aborted) {\n        throw new DOMException(\n          \"Request aborted before request fetch\",\n          \"AbortError\",\n        );\n      }\n\n      const response = await window.fetch(request);\n\n      this.handleResponseHeaders(response);\n\n      if (!response.body) return;\n      const { requestControls } = this;\n      requestControls.firstBytesReceived();\n\n      const reader = response.body.getReader();\n      for await (const chunk of readStream(reader)) {\n        this.requestControls.addLoadedChunk(chunk);\n        this.onChunkDownloaded(chunk.byteLength, \"http\");\n      }\n\n      const isValid =\n        (await this.httpConfig.validateHTTPSegment?.(\n          segment.url,\n          segment.byteRange,\n          this.request.data,\n        )) ?? true;\n\n      if (!isValid) {\n        this.request.clearLoadedBytes();\n        throw new RequestError<\"http-segment-validation-failed\">(\n          \"http-segment-validation-failed\",\n        );\n      }\n\n      requestControls.completeOnSuccess();\n    } catch (error) {\n      this.handleError(error);\n    }\n  }\n\n  private handleResponseHeaders(response: Response) {\n    if (!response.ok) {\n      if (response.status === 406) {\n        this.request.clearLoadedBytes();\n        throw new RequestError<\"http-bytes-mismatch\">(\n          \"http-bytes-mismatch\",\n          response.statusText,\n        );\n      } else {\n        throw new RequestError<\"http-error\">(\"http-error\", response.statusText);\n      }\n    }\n\n    const { requestByteRange } = this;\n    if (requestByteRange) {\n      if (response.status === 200) {\n        if (this.request.segment.byteRange) {\n          throw new RequestError(\"http-unexpected-status-code\");\n        } else {\n          this.request.clearLoadedBytes();\n        }\n      } else {\n        if (response.status !== 206) {\n          throw new RequestError(\n            \"http-unexpected-status-code\",\n            response.statusText,\n          );\n        }\n        const contentLengthHeader = response.headers.get(\"Content-Length\");\n        if (\n          contentLengthHeader &&\n          this.expectedBytesLength !== undefined &&\n          this.expectedBytesLength !== +contentLengthHeader\n        ) {\n          this.request.clearLoadedBytes();\n          throw new RequestError(\"http-bytes-mismatch\", response.statusText);\n        }\n\n        const contentRangeHeader = response.headers.get(\"Content-Range\");\n        const contentRange = contentRangeHeader\n          ? parseContentRangeHeader(contentRangeHeader)\n          : undefined;\n        if (contentRange) {\n          const { from, to } = contentRange;\n          const responseExpectedBytesLength =\n            to !== undefined && from !== undefined ? to - from + 1 : undefined;\n\n          if (\n            (responseExpectedBytesLength !== undefined &&\n              this.expectedBytesLength !== responseExpectedBytesLength) ||\n            (from !== undefined && requestByteRange.start !== from) ||\n            (to !== undefined &&\n              requestByteRange.end !== undefined &&\n              requestByteRange.end !== to)\n          ) {\n            this.request.clearLoadedBytes();\n            throw new RequestError(\"http-bytes-mismatch\", response.statusText);\n          }\n        }\n      }\n    }\n\n    if (response.status === 200 && this.request.totalBytes === undefined) {\n      const contentLengthHeader = response.headers.get(\"Content-Length\");\n      if (contentLengthHeader) this.request.setTotalBytes(+contentLengthHeader);\n    }\n  }\n\n  private handleError(error: unknown) {\n    if (error instanceof Error) {\n      if (error.name !== \"abort\") return;\n\n      const httpLoaderError =\n        error instanceof RequestError\n          ? (error as RequestError<HttpRequestErrorType>)\n          : new RequestError(\"http-error\", error.message);\n\n      this.requestControls.abortOnError(httpLoaderError);\n    }\n  }\n}\n\nasync function* readStream(\n  reader: ReadableStreamDefaultReader<Uint8Array>,\n): AsyncGenerator<Uint8Array> {\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) break;\n    yield value;\n  }\n}\n\nconst rangeHeaderRegex = /^bytes (?:(?:(\\d+)|)-(?:(\\d+)|)|\\*)\\/(?:(\\d+)|\\*)$/;\n\nfunction parseContentRangeHeader(headerValue: string) {\n  const match = rangeHeaderRegex.exec(headerValue.trim());\n  if (!match) return;\n\n  const [, from, to, total] = match;\n  return {\n    from: from ? parseInt(from) : undefined,\n    to: to ? parseInt(to) : undefined,\n    total: total ? parseInt(total) : undefined,\n  };\n}\n","function getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar browser = {exports: {}};\n\n// shim for using process in browser\nvar process = browser.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ());\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] };\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\nvar browserExports = browser.exports;\nconst process$1 = /*@__PURE__*/getDefaultExportFromCjs(browserExports);\n\nexport { process$1 as default, process$1 as process };\n//# sourceMappingURL=index.js.map\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\tlet m;\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\t// eslint-disable-next-line no-return-assign\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)) && parseInt(m[1], 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug') || exports.storage.getItem('DEBUG') ;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '')\n\t\t\t.trim()\n\t\t\t.replace(/\\s+/g, ',')\n\t\t\t.split(',')\n\t\t\t.filter(Boolean);\n\n\t\tfor (const ns of split) {\n\t\t\tif (ns[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(ns.slice(1));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(ns);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Checks if the given string matches a namespace template, honoring\n\t * asterisks as wildcards.\n\t *\n\t * @param {String} search\n\t * @param {String} template\n\t * @return {Boolean}\n\t */\n\tfunction matchesTemplate(search, template) {\n\t\tlet searchIndex = 0;\n\t\tlet templateIndex = 0;\n\t\tlet starIndex = -1;\n\t\tlet matchIndex = 0;\n\n\t\twhile (searchIndex < search.length) {\n\t\t\tif (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {\n\t\t\t\t// Match character or proceed with wildcard\n\t\t\t\tif (template[templateIndex] === '*') {\n\t\t\t\t\tstarIndex = templateIndex;\n\t\t\t\t\tmatchIndex = searchIndex;\n\t\t\t\t\ttemplateIndex++; // Skip the '*'\n\t\t\t\t} else {\n\t\t\t\t\tsearchIndex++;\n\t\t\t\t\ttemplateIndex++;\n\t\t\t\t}\n\t\t\t} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition\n\t\t\t\t// Backtrack to the last '*' and try to match more characters\n\t\t\t\ttemplateIndex = starIndex + 1;\n\t\t\t\tmatchIndex++;\n\t\t\t\tsearchIndex = matchIndex;\n\t\t\t} else {\n\t\t\t\treturn false; // No match\n\t\t\t}\n\t\t}\n\n\t\t// Handle trailing '*' in template\n\t\twhile (templateIndex < template.length && template[templateIndex] === '*') {\n\t\t\ttemplateIndex++;\n\t\t}\n\n\t\treturn templateIndex === template.length;\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names,\n\t\t\t...createDebug.skips.map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tfor (const skip of createDebug.skips) {\n\t\t\tif (matchesTemplate(name, skip)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (const ns of createDebug.names) {\n\t\t\tif (matchesTemplate(name, ns)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","var wrappy = require('wrappy')\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n","// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n","/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nlet promise\n\nmodule.exports = typeof queueMicrotask === 'function'\n  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : global)\n  // reuse resolved promise, and allocate it lazily\n  : cb => (promise || (promise = Promise.resolve()))\n    .then(cb)\n    .catch(err => setTimeout(() => { throw err }, 0))\n","/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nmodule.exports = runParallel\n\nconst queueMicrotask = require('queue-microtask')\n\nfunction runParallel (tasks, cb) {\n  let results, pending, keys\n  let isSync = true\n\n  if (Array.isArray(tasks)) {\n    results = []\n    pending = tasks.length\n  } else {\n    keys = Object.keys(tasks)\n    results = {}\n    pending = keys.length\n  }\n\n  function done (err) {\n    function end () {\n      if (cb) cb(err, results)\n      cb = null\n    }\n    if (isSync) queueMicrotask(end)\n    else end()\n  }\n\n  function each (i, err, result) {\n    results[i] = result\n    if (--pending === 0 || err) {\n      done(err)\n    }\n  }\n\n  if (!pending) {\n    // empty\n    done(null)\n  } else if (keys) {\n    // object\n    keys.forEach(function (key) {\n      tasks[key](function (err, result) { each(key, err, result) })\n    })\n  } else {\n    // array\n    tasks.forEach(function (task, i) {\n      task(function (err, result) { each(i, err, result) })\n    })\n  }\n\n  isSync = false\n}\n","const scope = typeof window !== 'undefined' ? window : self\r\n\r\n// @ts-ignore\r\nexport const RTCPeerConnection = scope.RTCPeerConnection || scope.mozRTCPeerConnection || scope.webkitRTCPeerConnection\r\n// @ts-ignore\r\nexport const RTCSessionDescription = scope.RTCSessionDescription || scope.mozRTCSessionDescription || scope.webkitRTCSessionDescription\r\n// @ts-ignore\r\nexport const RTCIceCandidate = scope.RTCIceCandidate || scope.mozRTCIceCandidate || scope.webkitRTCIceCandidate\r\nexport const RTCIceTransport = scope.RTCIceTransport\r\nexport const RTCDataChannel = scope.RTCDataChannel\r\nexport const RTCSctpTransport = scope.RTCSctpTransport\r\nexport const RTCDtlsTransport = scope.RTCDtlsTransport\r\nexport const RTCCertificate = scope.RTCCertificate\r\nexport const MediaStream = scope.MediaStream\r\nexport const MediaStreamTrack = scope.MediaStreamTrack\r\nexport const MediaStreamTrackEvent = scope.MediaStreamTrackEvent\r\nexport const RTCPeerConnectionIceEvent = scope.RTCPeerConnectionIceEvent\r\nexport const RTCDataChannelEvent = scope.RTCDataChannelEvent\r\nexport const RTCTrackEvent = scope.RTCTrackEvent\r\nexport const RTCError = scope.RTCError\r\nexport const RTCErrorEvent = scope.RTCErrorEvent\r\nexport const RTCRtpTransceiver = scope.RTCRtpTransceiver\r\nexport const RTCRtpReceiver = scope.RTCRtpReceiver\r\nexport const RTCRtpSender = scope.RTCRtpSender\r\n\r\nexport * as default from './browser.js'\r\n","const FixedFIFO = require('./fixed-size')\n\nmodule.exports = class FastFIFO {\n  constructor (hwm) {\n    this.hwm = hwm || 16\n    this.head = new FixedFIFO(this.hwm)\n    this.tail = this.head\n    this.length = 0\n  }\n\n  clear () {\n    this.head = this.tail\n    this.head.clear()\n    this.length = 0\n  }\n\n  push (val) {\n    this.length++\n    if (!this.head.push(val)) {\n      const prev = this.head\n      this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length)\n      this.head.push(val)\n    }\n  }\n\n  shift () {\n    if (this.length !== 0) this.length--\n    const val = this.tail.shift()\n    if (val === undefined && this.tail.next) {\n      const next = this.tail.next\n      this.tail.next = null\n      this.tail = next\n      return this.tail.shift()\n    }\n\n    return val\n  }\n\n  peek () {\n    const val = this.tail.peek()\n    if (val === undefined && this.tail.next) return this.tail.next.peek()\n    return val\n  }\n\n  isEmpty () {\n    return this.length === 0\n  }\n}\n","module.exports = class FixedFIFO {\n  constructor (hwm) {\n    if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) throw new Error('Max size for a FixedFIFO should be a power of two')\n    this.buffer = new Array(hwm)\n    this.mask = hwm - 1\n    this.top = 0\n    this.btm = 0\n    this.next = null\n  }\n\n  clear () {\n    this.top = this.btm = 0\n    this.next = null\n    this.buffer.fill(undefined)\n  }\n\n  push (data) {\n    if (this.buffer[this.top] !== undefined) return false\n    this.buffer[this.top] = data\n    this.top = (this.top + 1) & this.mask\n    return true\n  }\n\n  shift () {\n    const last = this.buffer[this.btm]\n    if (last === undefined) return undefined\n    this.buffer[this.btm] = undefined\n    this.btm = (this.btm + 1) & this.mask\n    return last\n  }\n\n  peek () {\n    return this.buffer[this.btm]\n  }\n\n  isEmpty () {\n    return this.buffer[this.btm] === undefined\n  }\n}\n","module.exports = class BrowserDecoder {\n  constructor (encoding) {\n    this.decoder = new TextDecoder(encoding === 'utf16le' ? 'utf16-le' : encoding)\n  }\n\n  get remaining () {\n    return -1\n  }\n\n  decode (data) {\n    return this.decoder.decode(data, { stream: true })\n  }\n\n  flush () {\n    return this.decoder.decode(new Uint8Array(0))\n  }\n}\n","const PassThroughDecoder = require('./lib/pass-through-decoder')\nconst UTF8Decoder = require('./lib/utf8-decoder')\n\nmodule.exports = class TextDecoder {\n  constructor (encoding = 'utf8') {\n    this.encoding = normalizeEncoding(encoding)\n\n    switch (this.encoding) {\n      case 'utf8':\n        this.decoder = new UTF8Decoder()\n        break\n      case 'utf16le':\n      case 'base64':\n        throw new Error('Unsupported encoding: ' + this.encoding)\n      default:\n        this.decoder = new PassThroughDecoder(this.encoding)\n    }\n  }\n\n  get remaining () {\n    return this.decoder.remaining\n  }\n\n  push (data) {\n    if (typeof data === 'string') return data\n    return this.decoder.decode(data)\n  }\n\n  // For Node.js compatibility\n  write (data) {\n    return this.push(data)\n  }\n\n  end (data) {\n    let result = ''\n    if (data) result = this.push(data)\n    result += this.decoder.flush()\n    return result\n  }\n}\n\nfunction normalizeEncoding (encoding) {\n  encoding = encoding.toLowerCase()\n\n  switch (encoding) {\n    case 'utf8':\n    case 'utf-8':\n      return 'utf8'\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return 'utf16le'\n    case 'latin1':\n    case 'binary':\n      return 'latin1'\n    case 'base64':\n    case 'ascii':\n    case 'hex':\n      return encoding\n    default:\n      throw new Error('Unknown encoding: ' + encoding)\n  }\n};\n","const { EventEmitter } = require('events-universal')\nconst STREAM_DESTROYED = new Error('Stream was destroyed')\nconst PREMATURE_CLOSE = new Error('Premature close')\n\nconst FIFO = require('fast-fifo')\nconst TextDecoder = require('text-decoder')\n\n// if we do a future major, expect queue microtask to be there always, for now a bit defensive\nconst qmt = typeof queueMicrotask === 'undefined' ? fn => global.process.nextTick(fn) : queueMicrotask\n\n/* eslint-disable no-multi-spaces */\n\n// 29 bits used total (4 from shared, 14 from read, and 11 from write)\nconst MAX = ((1 << 29) - 1)\n\n// Shared state\nconst OPENING       = 0b0001\nconst PREDESTROYING = 0b0010\nconst DESTROYING    = 0b0100\nconst DESTROYED     = 0b1000\n\nconst NOT_OPENING = MAX ^ OPENING\nconst NOT_PREDESTROYING = MAX ^ PREDESTROYING\n\n// Read state (4 bit offset from shared state)\nconst READ_ACTIVE           = 0b00000000000001 << 4\nconst READ_UPDATING         = 0b00000000000010 << 4\nconst READ_PRIMARY          = 0b00000000000100 << 4\nconst READ_QUEUED           = 0b00000000001000 << 4\nconst READ_RESUMED          = 0b00000000010000 << 4\nconst READ_PIPE_DRAINED     = 0b00000000100000 << 4\nconst READ_ENDING           = 0b00000001000000 << 4\nconst READ_EMIT_DATA        = 0b00000010000000 << 4\nconst READ_EMIT_READABLE    = 0b00000100000000 << 4\nconst READ_EMITTED_READABLE = 0b00001000000000 << 4\nconst READ_DONE             = 0b00010000000000 << 4\nconst READ_NEXT_TICK        = 0b00100000000000 << 4\nconst READ_NEEDS_PUSH       = 0b01000000000000 << 4\nconst READ_READ_AHEAD       = 0b10000000000000 << 4\n\n// Combined read state\nconst READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED\nconst READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH\nconst READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE\nconst READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED\nconst READ_RESUMED_READ_AHEAD = READ_RESUMED | READ_READ_AHEAD\n\nconst READ_NOT_ACTIVE             = MAX ^ READ_ACTIVE\nconst READ_NON_PRIMARY            = MAX ^ READ_PRIMARY\nconst READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH)\nconst READ_PUSHED                 = MAX ^ READ_NEEDS_PUSH\nconst READ_PAUSED                 = MAX ^ READ_RESUMED\nconst READ_NOT_QUEUED             = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE)\nconst READ_NOT_ENDING             = MAX ^ READ_ENDING\nconst READ_PIPE_NOT_DRAINED       = MAX ^ READ_FLOWING\nconst READ_NOT_NEXT_TICK          = MAX ^ READ_NEXT_TICK\nconst READ_NOT_UPDATING           = MAX ^ READ_UPDATING\nconst READ_NO_READ_AHEAD          = MAX ^ READ_READ_AHEAD\nconst READ_PAUSED_NO_READ_AHEAD   = MAX ^ READ_RESUMED_READ_AHEAD\n\n// Write state (18 bit offset, 4 bit offset from shared state and 14 from read state)\nconst WRITE_ACTIVE     = 0b00000000001 << 18\nconst WRITE_UPDATING   = 0b00000000010 << 18\nconst WRITE_PRIMARY    = 0b00000000100 << 18\nconst WRITE_QUEUED     = 0b00000001000 << 18\nconst WRITE_UNDRAINED  = 0b00000010000 << 18\nconst WRITE_DONE       = 0b00000100000 << 18\nconst WRITE_EMIT_DRAIN = 0b00001000000 << 18\nconst WRITE_NEXT_TICK  = 0b00010000000 << 18\nconst WRITE_WRITING    = 0b00100000000 << 18\nconst WRITE_FINISHING  = 0b01000000000 << 18\nconst WRITE_CORKED     = 0b10000000000 << 18\n\nconst WRITE_NOT_ACTIVE    = MAX ^ (WRITE_ACTIVE | WRITE_WRITING)\nconst WRITE_NON_PRIMARY   = MAX ^ WRITE_PRIMARY\nconst WRITE_NOT_FINISHING = MAX ^ (WRITE_ACTIVE | WRITE_FINISHING)\nconst WRITE_DRAINED       = MAX ^ WRITE_UNDRAINED\nconst WRITE_NOT_QUEUED    = MAX ^ WRITE_QUEUED\nconst WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK\nconst WRITE_NOT_UPDATING  = MAX ^ WRITE_UPDATING\nconst WRITE_NOT_CORKED    = MAX ^ WRITE_CORKED\n\n// Combined shared state\nconst ACTIVE = READ_ACTIVE | WRITE_ACTIVE\nconst NOT_ACTIVE = MAX ^ ACTIVE\nconst DONE = READ_DONE | WRITE_DONE\nconst DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING\nconst OPEN_STATUS = DESTROY_STATUS | OPENING\nconst AUTO_DESTROY = DESTROY_STATUS | DONE\nconst NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY\nconst ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK\nconst TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE\nconst IS_OPENING = OPEN_STATUS | TICKING\n\n// Combined shared state and read state\nconst READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE\nconst READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED\nconst READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED\nconst READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE\nconst SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH | READ_READ_AHEAD\nconst READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE\nconst READ_UPDATE_SYNC_STATUS = READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY\nconst READ_NEXT_TICK_OR_OPENING = READ_NEXT_TICK | OPENING\n\n// Combined write state\nconst WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED\nconst WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE\nconst WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE\nconst WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED | WRITE_CORKED\nconst WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE\nconst WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING\nconst WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE\nconst WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE\nconst WRITE_UPDATE_SYNC_STATUS = WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY\nconst WRITE_DROP_DATA = WRITE_FINISHING | WRITE_DONE | DESTROY_STATUS\n\nconst asyncIterator = Symbol.asyncIterator || Symbol('asyncIterator')\n\nclass WritableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapWritable, byteLength, byteLengthWritable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark\n    this.buffered = 0\n    this.error = null\n    this.pipeline = null\n    this.drains = null // if we add more seldomly used helpers we might them into a subobject so its a single ptr\n    this.byteLength = byteLengthWritable || byteLength || defaultByteLength\n    this.map = mapWritable || map\n    this.afterWrite = afterWrite.bind(this)\n    this.afterUpdateNextTick = updateWriteNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & WRITE_DONE) !== 0\n  }\n\n  push (data) {\n    if ((this.stream._duplexState & WRITE_DROP_DATA) !== 0) return false\n    if (this.map !== null) data = this.map(data)\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    if (this.buffered < this.highWaterMark) {\n      this.stream._duplexState |= WRITE_QUEUED\n      return true\n    }\n\n    this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED\n    return false\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= WRITE_NOT_QUEUED\n\n    return data\n  }\n\n  end (data) {\n    if (typeof data === 'function') this.stream.once('finish', data)\n    else if (data !== undefined && data !== null) this.push(data)\n    this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY\n  }\n\n  autoBatch (data, cb) {\n    const buffer = []\n    const stream = this.stream\n\n    buffer.push(data)\n    while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {\n      buffer.push(stream._writableState.shift())\n    }\n\n    if ((stream._duplexState & OPEN_STATUS) !== 0) return cb(null)\n    stream._writev(buffer, cb)\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= WRITE_UPDATING\n\n    do {\n      while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {\n        const data = this.shift()\n        stream._duplexState |= WRITE_ACTIVE_AND_WRITING\n        stream._write(data, this.afterWrite)\n      }\n\n      if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= WRITE_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {\n      stream._duplexState = stream._duplexState | WRITE_ACTIVE\n      stream._final(afterFinal.bind(this))\n      return\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= WRITE_NEXT_TICK\n    if ((this.stream._duplexState & WRITE_UPDATING) === 0) qmt(this.afterUpdateNextTick)\n  }\n}\n\nclass ReadableState {\n  constructor (stream, { highWaterMark = 16384, map = null, mapReadable, byteLength, byteLengthReadable } = {}) {\n    this.stream = stream\n    this.queue = new FIFO()\n    this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark\n    this.buffered = 0\n    this.readAhead = highWaterMark > 0\n    this.error = null\n    this.pipeline = null\n    this.byteLength = byteLengthReadable || byteLength || defaultByteLength\n    this.map = mapReadable || map\n    this.pipeTo = null\n    this.afterRead = afterRead.bind(this)\n    this.afterUpdateNextTick = updateReadNT.bind(this)\n  }\n\n  get ended () {\n    return (this.stream._duplexState & READ_DONE) !== 0\n  }\n\n  pipe (pipeTo, cb) {\n    if (this.pipeTo !== null) throw new Error('Can only pipe to one destination')\n    if (typeof cb !== 'function') cb = null\n\n    this.stream._duplexState |= READ_PIPE_DRAINED\n    this.pipeTo = pipeTo\n    this.pipeline = new Pipeline(this.stream, pipeTo, cb)\n\n    if (cb) this.stream.on('error', noop) // We already error handle this so supress crashes\n\n    if (isStreamx(pipeTo)) {\n      pipeTo._writableState.pipeline = this.pipeline\n      if (cb) pipeTo.on('error', noop) // We already error handle this so supress crashes\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline)) // TODO: just call finished from pipeTo itself\n    } else {\n      const onerror = this.pipeline.done.bind(this.pipeline, pipeTo)\n      const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null) // onclose has a weird bool arg\n      pipeTo.on('error', onerror)\n      pipeTo.on('close', onclose)\n      pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline))\n    }\n\n    pipeTo.on('drain', afterDrain.bind(this))\n    this.stream.emit('piping', pipeTo)\n    pipeTo.emit('pipe', this.stream)\n  }\n\n  push (data) {\n    const stream = this.stream\n\n    if (data === null) {\n      this.highWaterMark = 0\n      stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED\n      return false\n    }\n\n    if (this.map !== null) {\n      data = this.map(data)\n      if (data === null) {\n        stream._duplexState &= READ_PUSHED\n        return this.buffered < this.highWaterMark\n      }\n    }\n\n    this.buffered += this.byteLength(data)\n    this.queue.push(data)\n\n    stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED\n\n    return this.buffered < this.highWaterMark\n  }\n\n  shift () {\n    const data = this.queue.shift()\n\n    this.buffered -= this.byteLength(data)\n    if (this.buffered === 0) this.stream._duplexState &= READ_NOT_QUEUED\n    return data\n  }\n\n  unshift (data) {\n    const pending = [this.map !== null ? this.map(data) : data]\n    while (this.buffered > 0) pending.push(this.shift())\n\n    for (let i = 0; i < pending.length - 1; i++) {\n      const data = pending[i]\n      this.buffered += this.byteLength(data)\n      this.queue.push(data)\n    }\n\n    this.push(pending[pending.length - 1])\n  }\n\n  read () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n      return data\n    }\n\n    if (this.readAhead === false) {\n      stream._duplexState |= READ_READ_AHEAD\n      this.updateNextTick()\n    }\n\n    return null\n  }\n\n  drain () {\n    const stream = this.stream\n\n    while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {\n      const data = this.shift()\n      if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED\n      if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data)\n    }\n  }\n\n  update () {\n    const stream = this.stream\n\n    stream._duplexState |= READ_UPDATING\n\n    do {\n      this.drain()\n\n      while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === READ_READ_AHEAD) {\n        stream._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH\n        stream._read(this.afterRead)\n        this.drain()\n      }\n\n      if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {\n        stream._duplexState |= READ_EMITTED_READABLE\n        stream.emit('readable')\n      }\n\n      if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary()\n    } while (this.continueUpdate() === true)\n\n    stream._duplexState &= READ_NOT_UPDATING\n  }\n\n  updateNonPrimary () {\n    const stream = this.stream\n\n    if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {\n      stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING\n      stream.emit('end')\n      if ((stream._duplexState & AUTO_DESTROY) === DONE) stream._duplexState |= DESTROYING\n      if (this.pipeTo !== null) this.pipeTo.end()\n    }\n\n    if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {\n      if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {\n        stream._duplexState |= ACTIVE\n        stream._destroy(afterDestroy.bind(this))\n      }\n      return\n    }\n\n    if ((stream._duplexState & IS_OPENING) === OPENING) {\n      stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING\n      stream._open(afterOpen.bind(this))\n    }\n  }\n\n  continueUpdate () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) === 0) return false\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    return true\n  }\n\n  updateCallback () {\n    if ((this.stream._duplexState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY) this.update()\n    else this.updateNextTick()\n  }\n\n  updateNextTickIfOpen () {\n    if ((this.stream._duplexState & READ_NEXT_TICK_OR_OPENING) !== 0) return\n    this.stream._duplexState |= READ_NEXT_TICK\n    if ((this.stream._duplexState & READ_UPDATING) === 0) qmt(this.afterUpdateNextTick)\n  }\n\n  updateNextTick () {\n    if ((this.stream._duplexState & READ_NEXT_TICK) !== 0) return\n    this.stream._duplexState |= READ_NEXT_TICK\n    if ((this.stream._duplexState & READ_UPDATING) === 0) qmt(this.afterUpdateNextTick)\n  }\n}\n\nclass TransformState {\n  constructor (stream) {\n    this.data = null\n    this.afterTransform = afterTransform.bind(stream)\n    this.afterFinal = null\n  }\n}\n\nclass Pipeline {\n  constructor (src, dst, cb) {\n    this.from = src\n    this.to = dst\n    this.afterPipe = cb\n    this.error = null\n    this.pipeToFinished = false\n  }\n\n  finished () {\n    this.pipeToFinished = true\n  }\n\n  done (stream, err) {\n    if (err) this.error = err\n\n    if (stream === this.to) {\n      this.to = null\n\n      if (this.from !== null) {\n        if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {\n          this.from.destroy(this.error || new Error('Writable stream closed prematurely'))\n        }\n        return\n      }\n    }\n\n    if (stream === this.from) {\n      this.from = null\n\n      if (this.to !== null) {\n        if ((stream._duplexState & READ_DONE) === 0) {\n          this.to.destroy(this.error || new Error('Readable stream closed before ending'))\n        }\n        return\n      }\n    }\n\n    if (this.afterPipe !== null) this.afterPipe(this.error)\n    this.to = this.from = this.afterPipe = null\n  }\n}\n\nfunction afterDrain () {\n  this.stream._duplexState |= READ_PIPE_DRAINED\n  this.updateCallback()\n}\n\nfunction afterFinal (err) {\n  const stream = this.stream\n  if (err) stream.destroy(err)\n  if ((stream._duplexState & DESTROY_STATUS) === 0) {\n    stream._duplexState |= WRITE_DONE\n    stream.emit('finish')\n  }\n  if ((stream._duplexState & AUTO_DESTROY) === DONE) {\n    stream._duplexState |= DESTROYING\n  }\n\n  stream._duplexState &= WRITE_NOT_FINISHING\n\n  // no need to wait the extra tick here, so we short circuit that\n  if ((stream._duplexState & WRITE_UPDATING) === 0) this.update()\n  else this.updateNextTick()\n}\n\nfunction afterDestroy (err) {\n  const stream = this.stream\n\n  if (!err && this.error !== STREAM_DESTROYED) err = this.error\n  if (err) stream.emit('error', err)\n  stream._duplexState |= DESTROYED\n  stream.emit('close')\n\n  const rs = stream._readableState\n  const ws = stream._writableState\n\n  if (rs !== null && rs.pipeline !== null) rs.pipeline.done(stream, err)\n\n  if (ws !== null) {\n    while (ws.drains !== null && ws.drains.length > 0) ws.drains.shift().resolve(false)\n    if (ws.pipeline !== null) ws.pipeline.done(stream, err)\n  }\n}\n\nfunction afterWrite (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n  stream._duplexState &= WRITE_NOT_ACTIVE\n\n  if (this.drains !== null) tickDrains(this.drains)\n\n  if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {\n    stream._duplexState &= WRITE_DRAINED\n    if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {\n      stream.emit('drain')\n    }\n  }\n\n  this.updateCallback()\n}\n\nfunction afterRead (err) {\n  if (err) this.stream.destroy(err)\n  this.stream._duplexState &= READ_NOT_ACTIVE\n  if (this.readAhead === false && (this.stream._duplexState & READ_RESUMED) === 0) this.stream._duplexState &= READ_NO_READ_AHEAD\n  this.updateCallback()\n}\n\nfunction updateReadNT () {\n  if ((this.stream._duplexState & READ_UPDATING) === 0) {\n    this.stream._duplexState &= READ_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction updateWriteNT () {\n  if ((this.stream._duplexState & WRITE_UPDATING) === 0) {\n    this.stream._duplexState &= WRITE_NOT_NEXT_TICK\n    this.update()\n  }\n}\n\nfunction tickDrains (drains) {\n  for (let i = 0; i < drains.length; i++) {\n    // drains.writes are monotonic, so if one is 0 its always the first one\n    if (--drains[i].writes === 0) {\n      drains.shift().resolve(true)\n      i--\n    }\n  }\n}\n\nfunction afterOpen (err) {\n  const stream = this.stream\n\n  if (err) stream.destroy(err)\n\n  if ((stream._duplexState & DESTROYING) === 0) {\n    if ((stream._duplexState & READ_PRIMARY_STATUS) === 0) stream._duplexState |= READ_PRIMARY\n    if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0) stream._duplexState |= WRITE_PRIMARY\n    stream.emit('open')\n  }\n\n  stream._duplexState &= NOT_ACTIVE\n\n  if (stream._writableState !== null) {\n    stream._writableState.updateCallback()\n  }\n\n  if (stream._readableState !== null) {\n    stream._readableState.updateCallback()\n  }\n}\n\nfunction afterTransform (err, data) {\n  if (data !== undefined && data !== null) this.push(data)\n  this._writableState.afterWrite(err)\n}\n\nfunction newListener (name) {\n  if (this._readableState !== null) {\n    if (name === 'data') {\n      this._duplexState |= (READ_EMIT_DATA | READ_RESUMED_READ_AHEAD)\n      this._readableState.updateNextTick()\n    }\n    if (name === 'readable') {\n      this._duplexState |= READ_EMIT_READABLE\n      this._readableState.updateNextTick()\n    }\n  }\n\n  if (this._writableState !== null) {\n    if (name === 'drain') {\n      this._duplexState |= WRITE_EMIT_DRAIN\n      this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Stream extends EventEmitter {\n  constructor (opts) {\n    super()\n\n    this._duplexState = 0\n    this._readableState = null\n    this._writableState = null\n\n    if (opts) {\n      if (opts.open) this._open = opts.open\n      if (opts.destroy) this._destroy = opts.destroy\n      if (opts.predestroy) this._predestroy = opts.predestroy\n      if (opts.signal) {\n        opts.signal.addEventListener('abort', abort.bind(this))\n      }\n    }\n\n    this.on('newListener', newListener)\n  }\n\n  _open (cb) {\n    cb(null)\n  }\n\n  _destroy (cb) {\n    cb(null)\n  }\n\n  _predestroy () {\n    // does nothing\n  }\n\n  get readable () {\n    return this._readableState !== null ? true : undefined\n  }\n\n  get writable () {\n    return this._writableState !== null ? true : undefined\n  }\n\n  get destroyed () {\n    return (this._duplexState & DESTROYED) !== 0\n  }\n\n  get destroying () {\n    return (this._duplexState & DESTROY_STATUS) !== 0\n  }\n\n  destroy (err) {\n    if ((this._duplexState & DESTROY_STATUS) === 0) {\n      if (!err) err = STREAM_DESTROYED\n      this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY\n\n      if (this._readableState !== null) {\n        this._readableState.highWaterMark = 0\n        this._readableState.error = err\n      }\n      if (this._writableState !== null) {\n        this._writableState.highWaterMark = 0\n        this._writableState.error = err\n      }\n\n      this._duplexState |= PREDESTROYING\n      this._predestroy()\n      this._duplexState &= NOT_PREDESTROYING\n\n      if (this._readableState !== null) this._readableState.updateNextTick()\n      if (this._writableState !== null) this._writableState.updateNextTick()\n    }\n  }\n}\n\nclass Readable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | WRITE_DONE | READ_READ_AHEAD\n    this._readableState = new ReadableState(this, opts)\n\n    if (opts) {\n      if (this._readableState.readAhead === false) this._duplexState &= READ_NO_READ_AHEAD\n      if (opts.read) this._read = opts.read\n      if (opts.eagerOpen) this._readableState.updateNextTick()\n      if (opts.encoding) this.setEncoding(opts.encoding)\n    }\n  }\n\n  setEncoding (encoding) {\n    const dec = new TextDecoder(encoding)\n    const map = this._readableState.map || echo\n    this._readableState.map = mapOrSkip\n    return this\n\n    function mapOrSkip (data) {\n      const next = dec.push(data)\n      return next === '' && (data.byteLength !== 0 || dec.remaining > 0) ? null : map(next)\n    }\n  }\n\n  _read (cb) {\n    cb(null)\n  }\n\n  pipe (dest, cb) {\n    this._readableState.updateNextTick()\n    this._readableState.pipe(dest, cb)\n    return dest\n  }\n\n  read () {\n    this._readableState.updateNextTick()\n    return this._readableState.read()\n  }\n\n  push (data) {\n    this._readableState.updateNextTickIfOpen()\n    return this._readableState.push(data)\n  }\n\n  unshift (data) {\n    this._readableState.updateNextTickIfOpen()\n    return this._readableState.unshift(data)\n  }\n\n  resume () {\n    this._duplexState |= READ_RESUMED_READ_AHEAD\n    this._readableState.updateNextTick()\n    return this\n  }\n\n  pause () {\n    this._duplexState &= (this._readableState.readAhead === false ? READ_PAUSED_NO_READ_AHEAD : READ_PAUSED)\n    return this\n  }\n\n  static _fromAsyncIterator (ite, opts) {\n    let destroy\n\n    const rs = new Readable({\n      ...opts,\n      read (cb) {\n        ite.next().then(push).then(cb.bind(null, null)).catch(cb)\n      },\n      predestroy () {\n        destroy = ite.return()\n      },\n      destroy (cb) {\n        if (!destroy) return cb(null)\n        destroy.then(cb.bind(null, null)).catch(cb)\n      }\n    })\n\n    return rs\n\n    function push (data) {\n      if (data.done) rs.push(null)\n      else rs.push(data.value)\n    }\n  }\n\n  static from (data, opts) {\n    if (isReadStreamx(data)) return data\n    if (data[asyncIterator]) return this._fromAsyncIterator(data[asyncIterator](), opts)\n    if (!Array.isArray(data)) data = data === undefined ? [] : [data]\n\n    let i = 0\n    return new Readable({\n      ...opts,\n      read (cb) {\n        this.push(i === data.length ? null : data[i++])\n        cb(null)\n      }\n    })\n  }\n\n  static isBackpressured (rs) {\n    return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark\n  }\n\n  static isPaused (rs) {\n    return (rs._duplexState & READ_RESUMED) === 0\n  }\n\n  [asyncIterator] () {\n    const stream = this\n\n    let error = null\n    let promiseResolve = null\n    let promiseReject = null\n\n    this.on('error', (err) => { error = err })\n    this.on('readable', onreadable)\n    this.on('close', onclose)\n\n    return {\n      [asyncIterator] () {\n        return this\n      },\n      next () {\n        return new Promise(function (resolve, reject) {\n          promiseResolve = resolve\n          promiseReject = reject\n          const data = stream.read()\n          if (data !== null) ondata(data)\n          else if ((stream._duplexState & DESTROYED) !== 0) ondata(null)\n        })\n      },\n      return () {\n        return destroy(null)\n      },\n      throw (err) {\n        return destroy(err)\n      }\n    }\n\n    function onreadable () {\n      if (promiseResolve !== null) ondata(stream.read())\n    }\n\n    function onclose () {\n      if (promiseResolve !== null) ondata(null)\n    }\n\n    function ondata (data) {\n      if (promiseReject === null) return\n      if (error) promiseReject(error)\n      else if (data === null && (stream._duplexState & READ_DONE) === 0) promiseReject(STREAM_DESTROYED)\n      else promiseResolve({ value: data, done: data === null })\n      promiseReject = promiseResolve = null\n    }\n\n    function destroy (err) {\n      stream.destroy(err)\n      return new Promise((resolve, reject) => {\n        if (stream._duplexState & DESTROYED) return resolve({ value: undefined, done: true })\n        stream.once('close', function () {\n          if (err) reject(err)\n          else resolve({ value: undefined, done: true })\n        })\n      })\n    }\n  }\n}\n\nclass Writable extends Stream {\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState |= OPENING | READ_DONE\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n      if (opts.eagerOpen) this._writableState.updateNextTick()\n    }\n  }\n\n  cork () {\n    this._duplexState |= WRITE_CORKED\n  }\n\n  uncork () {\n    this._duplexState &= WRITE_NOT_CORKED\n    this._writableState.updateNextTick()\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  static isBackpressured (ws) {\n    return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0\n  }\n\n  static drained (ws) {\n    if (ws.destroyed) return Promise.resolve(false)\n    const state = ws._writableState\n    const pending = (isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length)\n    const writes = pending + ((ws._duplexState & WRITE_WRITING) ? 1 : 0)\n    if (writes === 0) return Promise.resolve(true)\n    if (state.drains === null) state.drains = []\n    return new Promise((resolve) => {\n      state.drains.push({ writes, resolve })\n    })\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Duplex extends Readable { // and Writable\n  constructor (opts) {\n    super(opts)\n\n    this._duplexState = OPENING | (this._duplexState & READ_READ_AHEAD)\n    this._writableState = new WritableState(this, opts)\n\n    if (opts) {\n      if (opts.writev) this._writev = opts.writev\n      if (opts.write) this._write = opts.write\n      if (opts.final) this._final = opts.final\n    }\n  }\n\n  cork () {\n    this._duplexState |= WRITE_CORKED\n  }\n\n  uncork () {\n    this._duplexState &= WRITE_NOT_CORKED\n    this._writableState.updateNextTick()\n  }\n\n  _writev (batch, cb) {\n    cb(null)\n  }\n\n  _write (data, cb) {\n    this._writableState.autoBatch(data, cb)\n  }\n\n  _final (cb) {\n    cb(null)\n  }\n\n  write (data) {\n    this._writableState.updateNextTick()\n    return this._writableState.push(data)\n  }\n\n  end (data) {\n    this._writableState.updateNextTick()\n    this._writableState.end(data)\n    return this\n  }\n}\n\nclass Transform extends Duplex {\n  constructor (opts) {\n    super(opts)\n    this._transformState = new TransformState(this)\n\n    if (opts) {\n      if (opts.transform) this._transform = opts.transform\n      if (opts.flush) this._flush = opts.flush\n    }\n  }\n\n  _write (data, cb) {\n    if (this._readableState.buffered >= this._readableState.highWaterMark) {\n      this._transformState.data = data\n    } else {\n      this._transform(data, this._transformState.afterTransform)\n    }\n  }\n\n  _read (cb) {\n    if (this._transformState.data !== null) {\n      const data = this._transformState.data\n      this._transformState.data = null\n      cb(null)\n      this._transform(data, this._transformState.afterTransform)\n    } else {\n      cb(null)\n    }\n  }\n\n  destroy (err) {\n    super.destroy(err)\n    if (this._transformState.data !== null) {\n      this._transformState.data = null\n      this._transformState.afterTransform()\n    }\n  }\n\n  _transform (data, cb) {\n    cb(null, data)\n  }\n\n  _flush (cb) {\n    cb(null)\n  }\n\n  _final (cb) {\n    this._transformState.afterFinal = cb\n    this._flush(transformAfterFlush.bind(this))\n  }\n}\n\nclass PassThrough extends Transform {}\n\nfunction transformAfterFlush (err, data) {\n  const cb = this._transformState.afterFinal\n  if (err) return cb(err)\n  if (data !== null && data !== undefined) this.push(data)\n  this.push(null)\n  cb(null)\n}\n\nfunction pipelinePromise (...streams) {\n  return new Promise((resolve, reject) => {\n    return pipeline(...streams, (err) => {\n      if (err) return reject(err)\n      resolve()\n    })\n  })\n}\n\nfunction pipeline (stream, ...streams) {\n  const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams]\n  const done = (all.length && typeof all[all.length - 1] === 'function') ? all.pop() : null\n\n  if (all.length < 2) throw new Error('Pipeline requires at least 2 streams')\n\n  let src = all[0]\n  let dest = null\n  let error = null\n\n  for (let i = 1; i < all.length; i++) {\n    dest = all[i]\n\n    if (isStreamx(src)) {\n      src.pipe(dest, onerror)\n    } else {\n      errorHandle(src, true, i > 1, onerror)\n      src.pipe(dest)\n    }\n\n    src = dest\n  }\n\n  if (done) {\n    let fin = false\n\n    const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy)\n\n    dest.on('error', (err) => {\n      if (error === null) error = err\n    })\n\n    dest.on('finish', () => {\n      fin = true\n      if (!autoDestroy) done(error)\n    })\n\n    if (autoDestroy) {\n      dest.on('close', () => done(error || (fin ? null : PREMATURE_CLOSE)))\n    }\n  }\n\n  return dest\n\n  function errorHandle (s, rd, wr, onerror) {\n    s.on('error', onerror)\n    s.on('close', onclose)\n\n    function onclose () {\n      if (rd && s._readableState && !s._readableState.ended) return onerror(PREMATURE_CLOSE)\n      if (wr && s._writableState && !s._writableState.ended) return onerror(PREMATURE_CLOSE)\n    }\n  }\n\n  function onerror (err) {\n    if (!err || error) return\n    error = err\n\n    for (const s of all) {\n      s.destroy(err)\n    }\n  }\n}\n\nfunction echo (s) {\n  return s\n}\n\nfunction isStream (stream) {\n  return !!stream._readableState || !!stream._writableState\n}\n\nfunction isStreamx (stream) {\n  return typeof stream._duplexState === 'number' && isStream(stream)\n}\n\nfunction isEnded (stream) {\n  return !!stream._readableState && stream._readableState.ended\n}\n\nfunction isFinished (stream) {\n  return !!stream._writableState && stream._writableState.ended\n}\n\nfunction getStreamError (stream, opts = {}) {\n  const err = (stream._readableState && stream._readableState.error) || (stream._writableState && stream._writableState.error)\n\n  // avoid implicit errors by default\n  return (!opts.all && err === STREAM_DESTROYED) ? null : err\n}\n\nfunction isReadStreamx (stream) {\n  return isStreamx(stream) && stream.readable\n}\n\nfunction isDisturbed (stream) {\n  return (stream._duplexState & OPENING) !== OPENING || (stream._duplexState & ACTIVE_OR_TICKING) !== 0\n}\n\nfunction isTypedArray (data) {\n  return typeof data === 'object' && data !== null && typeof data.byteLength === 'number'\n}\n\nfunction defaultByteLength (data) {\n  return isTypedArray(data) ? data.byteLength : 1024\n}\n\nfunction noop () {}\n\nfunction abort () {\n  this.destroy(new Error('Stream aborted.'))\n}\n\nfunction isWritev (s) {\n  return s._writev !== Writable.prototype._writev && s._writev !== Duplex.prototype._writev\n}\n\nmodule.exports = {\n  pipeline,\n  pipelinePromise,\n  isStream,\n  isStreamx,\n  isEnded,\n  isFinished,\n  isDisturbed,\n  getStreamError,\n  Stream,\n  Writable,\n  Readable,\n  Duplex,\n  Transform,\n  // Export PassThrough for compatibility with Node.js core's stream module\n  PassThrough\n}\n","module.exports = require('events')\n","'use strict';\n\n/**\n * @typedef {{ [key: string]: any }} Extensions\n * @typedef {Error} Err\n * @property {string} message\n */\n\n/**\n *\n * @param {Error} obj\n * @param {Extensions} props\n * @returns {Error & Extensions}\n */\nfunction assign(obj, props) {\n    for (const key in props) {\n        Object.defineProperty(obj, key, {\n            value: props[key],\n            enumerable: true,\n            configurable: true,\n        });\n    }\n\n    return obj;\n}\n\n/**\n *\n * @param {any} err - An Error\n * @param {string|Extensions} code - A string code or props to set on the error\n * @param {Extensions} [props] - Props to set on the error\n * @returns {Error & Extensions}\n */\nfunction createError(err, code, props) {\n    if (!err || typeof err === 'string') {\n        throw new TypeError('Please pass an Error to err-code');\n    }\n\n    if (!props) {\n        props = {};\n    }\n\n    if (typeof code === 'object') {\n        props = code;\n        code = '';\n    }\n\n    if (code) {\n        props.code = code;\n    }\n\n    try {\n        return assign(err, props);\n    } catch (_) {\n        props.message = err.message;\n        props.stack = err.stack;\n\n        const ErrClass = function () {};\n\n        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));\n\n        // @ts-ignore\n        const output = assign(new ErrClass(), props);\n\n        return output;\n    }\n}\n\nmodule.exports = createError;\n","/* Common package for dealing with hex/string/uint8 conversions (and sha1 hashing)\r\n*\r\n* @author   Jimmy Wrting <jimmy@warting.se> (https://jimmy.warting.se/opensource)\r\n* @license  MIT\r\n*/\r\nexport const alphabet = '0123456789abcdef'\r\nconst encodeLookup = []\r\nconst decodeLookup = []\r\n\r\nfor (let i = 0; i < 256; i++) {\r\n  encodeLookup[i] = alphabet[i >> 4 & 0xf] + alphabet[i & 0xf]\r\n  if (i < 16) {\r\n    if (i < 10) {\r\n      decodeLookup[0x30 + i] = i\r\n    } else {\r\n      decodeLookup[0x61 - 10 + i] = i\r\n    }\r\n  }\r\n}\r\n\r\nexport const arr2hex = data => {\r\n  const length = data.length\r\n  let string = ''\r\n  let i = 0\r\n  while (i < length) {\r\n    string += encodeLookup[data[i++]]\r\n  }\r\n  return string\r\n}\r\n\r\nexport const hex2arr = str => {\r\n  const sizeof = str.length >> 1\r\n  const length = sizeof << 1\r\n  const array = new Uint8Array(sizeof)\r\n  let n = 0\r\n  let i = 0\r\n  while (i < length) {\r\n    array[n++] = decodeLookup[str.charCodeAt(i++)] << 4 | decodeLookup[str.charCodeAt(i++)]\r\n  }\r\n  return array\r\n}\r\n\r\nexport const concat = (chunks, size = 0) => {\r\n  const length = chunks.length || 0\r\n  if (!size) {\r\n    let i = length\r\n    while (i--) size += chunks[i].length\r\n  }\r\n  const b = new Uint8Array(size)\r\n  let offset = size\r\n  let i = length\r\n  while (i--) {\r\n    offset -= chunks[i].length\r\n    b.set(chunks[i], offset)\r\n  }\r\n\r\n  return b\r\n}\r\n\r\nexport const equal = (a, b) => {\r\n  if (a.length !== b.length) return false\r\n  for (let i = a.length; i > -1; i -= 1) {\r\n    if ((a[i] !== b[i])) return false\r\n  }\r\n  return true\r\n}\r\n","/*\n * base64-arraybuffer 1.0.2 <https://github.com/niklasvh/base64-arraybuffer>\n * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>\n * Released under MIT License\n */\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n// Use a lookup table to find the index.\nvar lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\nfor (var i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n}\nvar encode = function (arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';\n    for (i = 0; i < len; i += 3) {\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64 += chars[bytes[i + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + '=';\n    }\n    else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + '==';\n    }\n    return base64;\n};\nvar decode = function (base64) {\n    var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n    if (base64[base64.length - 1] === '=') {\n        bufferLength--;\n        if (base64[base64.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n    var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n    for (i = 0; i < len; i += 4) {\n        encoded1 = lookup[base64.charCodeAt(i)];\n        encoded2 = lookup[base64.charCodeAt(i + 1)];\n        encoded3 = lookup[base64.charCodeAt(i + 2)];\n        encoded4 = lookup[base64.charCodeAt(i + 3)];\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n    return arraybuffer;\n};\n\nexport { decode, encode };\n//# sourceMappingURL=base64-arraybuffer.es5.js.map\n","import { arr2hex, hex2arr, alphabet } from './util.js'\r\nimport { decode, encode } from 'base64-arraybuffer'\r\n\r\nconst decoder = new TextDecoder()\r\n// 50% slower at < 48 chars, but little impact at 4M OPS/s vs 8M OPS/s\r\nexport const arr2text = (data, enc) => {\r\n  if (!enc) return decoder.decode(data)\r\n  const dec = new TextDecoder(enc)\r\n  return dec.decode(data)\r\n}\r\n\r\n// sacrifice ~20% speed for bundle size\r\nconst encoder = new TextEncoder()\r\nexport const text2arr = str => encoder.encode(str)\r\n\r\nexport const arr2base = data => encode(data)\r\n\r\nexport const base2arr = str => new Uint8Array(decode(str))\r\n\r\nexport const bin2hex = str => {\r\n  let res = ''\r\n  let c\r\n  let i = 0\r\n  const len = str.length\r\n\r\n  while (i < len) {\r\n    c = str.charCodeAt(i++)\r\n    res += alphabet[c >> 4] + alphabet[c & 0xF]\r\n  }\r\n\r\n  return res\r\n}\r\n\r\nconst MAX_ARGUMENTS_LENGTH = 0x10000\r\nexport const hex2bin = hex => {\r\n  const points = hex2arr(hex)\r\n  if (points.length <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode(...points)\r\n\r\n  let res = ''\r\n  let i = 0\r\n  while (i < points.length) {\r\n    res += String.fromCharCode(...points.subarray(i, i += MAX_ARGUMENTS_LENGTH))\r\n  }\r\n  return res\r\n}\r\n\r\nconst scope = typeof window !== 'undefined' ? window : self\r\nconst crypto = scope.crypto || scope.msCrypto || {}\r\nconst subtle = crypto.subtle || crypto.webkitSubtle\r\n\r\nconst formatMap = {\r\n  hex: arr2hex,\r\n  base64: arr2base\r\n}\r\n\r\nexport const hash = async (data, format, algo = 'sha-1') => {\r\n  if (!subtle) throw new Error('no web crypto support')\r\n  if (typeof data === 'string') data = text2arr(data)\r\n  const out = new Uint8Array(await subtle.digest(algo, data))\r\n  return format ? formatMap[format](out) : out\r\n}\r\n\r\nexport const randomBytes = size => {\r\n  const view = new Uint8Array(size)\r\n  return crypto.getRandomValues(view)\r\n}\r\n\r\nexport * from './util.js'\r\n","/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\r\nimport debug from 'debug'\r\nimport { RTCPeerConnection, RTCSessionDescription, RTCIceCandidate } from 'webrtc-polyfill'\r\nimport { Duplex } from 'streamx'\r\nimport errCode from 'err-code'\r\nimport { randomBytes, arr2hex, text2arr } from 'uint8-util'\r\n\r\nconst Debug = debug('simple-peer')\r\n\r\nconst MAX_BUFFERED_AMOUNT = 64 * 1024\r\nconst ICECOMPLETE_TIMEOUT = 5 * 1000\r\nconst CHANNEL_CLOSING_TIMEOUT = 5 * 1000\r\n\r\n// HACK: Filter trickle lines when trickle is disabled #354\r\nfunction filterTrickle (sdp) {\r\n  return sdp.replace(/a=ice-options:trickle\\s\\n/g, '')\r\n}\r\n\r\nfunction warn (message) {\r\n  console.warn(message)\r\n}\r\n\r\n/**\r\n * WebRTC peer connection. Same API as node core `net.Socket`, plus a few extra methods.\r\n * Duplex stream.\r\n * @param {Object} opts\r\n */\r\nclass Peer extends Duplex {\r\n  /** @type {RTCPeerConnection} */\r\n  _pc\r\n  constructor (opts) {\r\n    opts = Object.assign({\r\n      allowHalfOpen: false\r\n    }, opts)\r\n\r\n    super(opts)\r\n\r\n    this.__objectMode = !!opts.objectMode // streamx is objectMode by default, so implement readable's fuctionality\r\n\r\n    this._id = arr2hex(randomBytes(4)).slice(0, 7)\r\n    this._debug('new peer %o', opts)\r\n\r\n    this.channelName = opts.initiator\r\n      ? opts.channelName || arr2hex(randomBytes(20))\r\n      : null\r\n\r\n    this.initiator = opts.initiator || false\r\n    this.channelConfig = opts.channelConfig || Peer.channelConfig\r\n    this.channelNegotiated = this.channelConfig.negotiated\r\n    this.config = Object.assign({}, Peer.config, opts.config)\r\n    this.offerOptions = opts.offerOptions || {}\r\n    this.answerOptions = opts.answerOptions || {}\r\n    this.sdpTransform = opts.sdpTransform || (sdp => sdp)\r\n    this.trickle = opts.trickle !== undefined ? opts.trickle : true\r\n    this.allowHalfTrickle = opts.allowHalfTrickle !== undefined ? opts.allowHalfTrickle : false\r\n    this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT\r\n\r\n    this._destroying = false\r\n    this._connected = false\r\n\r\n    this.remoteAddress = undefined\r\n    this.remoteFamily = undefined\r\n    this.remotePort = undefined\r\n    this.localAddress = undefined\r\n    this.localFamily = undefined\r\n    this.localPort = undefined\r\n\r\n    if (!RTCPeerConnection) {\r\n      if (typeof window === 'undefined') {\r\n        throw errCode(new Error('No WebRTC support: Specify `opts.wrtc` option in this environment'), 'ERR_WEBRTC_SUPPORT')\r\n      } else {\r\n        throw errCode(new Error('No WebRTC support: Not a supported browser'), 'ERR_WEBRTC_SUPPORT')\r\n      }\r\n    }\r\n\r\n    this._pcReady = false\r\n    this._channelReady = false\r\n    this._iceComplete = false // ice candidate trickle done (got null candidate)\r\n    this._iceCompleteTimer = null // send an offer/answer anyway after some timeout\r\n    this._channel = null\r\n    this._pendingCandidates = []\r\n\r\n    this._isNegotiating = false // is this peer waiting for negotiation to complete?\r\n    this._firstNegotiation = true\r\n    this._batchedNegotiation = false // batch synchronous negotiations\r\n    this._queuedNegotiation = false // is there a queued negotiation request?\r\n    this._sendersAwaitingStable = []\r\n    this._closingInterval = null\r\n\r\n    this._remoteTracks = []\r\n    this._remoteStreams = []\r\n\r\n    this._chunk = null\r\n    this._cb = null\r\n    this._interval = null\r\n\r\n    try {\r\n      this._pc = new RTCPeerConnection(this.config)\r\n    } catch (err) {\r\n      this.__destroy(errCode(err, 'ERR_PC_CONSTRUCTOR'))\r\n      return\r\n    }\r\n\r\n    // We prefer feature detection whenever possible, but sometimes that's not\r\n    // possible for certain implementations.\r\n    this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === 'number'\r\n\r\n    this._pc.oniceconnectionstatechange = () => {\r\n      this._onIceStateChange()\r\n    }\r\n    this._pc.onicegatheringstatechange = () => {\r\n      this._onIceStateChange()\r\n    }\r\n    this._pc.onconnectionstatechange = () => {\r\n      this._onConnectionStateChange()\r\n    }\r\n    this._pc.onsignalingstatechange = () => {\r\n      this._onSignalingStateChange()\r\n    }\r\n    this._pc.onicecandidate = event => {\r\n      this._onIceCandidate(event)\r\n    }\r\n\r\n    // HACK: Fix for odd Firefox behavior, see: https://github.com/feross/simple-peer/pull/783\r\n    if (typeof this._pc.peerIdentity === 'object') {\r\n      this._pc.peerIdentity.catch(err => {\r\n        this.__destroy(errCode(err, 'ERR_PC_PEER_IDENTITY'))\r\n      })\r\n    }\r\n\r\n    // Other spec events, unused by this implementation:\r\n    // - onconnectionstatechange\r\n    // - onicecandidateerror\r\n    // - onfingerprintfailure\r\n    // - onnegotiationneeded\r\n\r\n    if (this.initiator || this.channelNegotiated) {\r\n      this._setupData({\r\n        channel: this._pc.createDataChannel(this.channelName, this.channelConfig)\r\n      })\r\n    } else {\r\n      this._pc.ondatachannel = event => {\r\n        this._setupData(event)\r\n      }\r\n    }\r\n\r\n    this._debug('initial negotiation')\r\n    this._needsNegotiation()\r\n\r\n    this._onFinishBound = () => {\r\n      this._onFinish()\r\n    }\r\n    this.once('finish', this._onFinishBound)\r\n  }\r\n\r\n  get bufferSize () {\r\n    return (this._channel && this._channel.bufferedAmount) || 0\r\n  }\r\n\r\n  // HACK: it's possible channel.readyState is \"closing\" before peer.destroy() fires\r\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\r\n  get connected () {\r\n    return (this._connected && this._channel.readyState === 'open')\r\n  }\r\n\r\n  address () {\r\n    return { port: this.localPort, family: this.localFamily, address: this.localAddress }\r\n  }\r\n\r\n  signal (data) {\r\n    if (this._destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot signal after peer is destroyed'), 'ERR_DESTROYED')\r\n    if (typeof data === 'string') {\r\n      try {\r\n        data = JSON.parse(data)\r\n      } catch (err) {\r\n        data = {}\r\n      }\r\n    }\r\n    this._debug('signal()')\r\n\r\n    if (data.renegotiate && this.initiator) {\r\n      this._debug('got request to renegotiate')\r\n      this._needsNegotiation()\r\n    }\r\n    if (data.transceiverRequest && this.initiator) {\r\n      this._debug('got request for transceiver')\r\n      this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init)\r\n    }\r\n    if (data.candidate) {\r\n      if (this._pc.remoteDescription && this._pc.remoteDescription.type) {\r\n        this._addIceCandidate(data.candidate)\r\n      } else {\r\n        this._pendingCandidates.push(data.candidate)\r\n      }\r\n    }\r\n    if (data.sdp) {\r\n      this._pc.setRemoteDescription(new RTCSessionDescription(data))\r\n        .then(() => {\r\n          if (this.destroyed) return\r\n\r\n          this._pendingCandidates.forEach(candidate => {\r\n            this._addIceCandidate(candidate)\r\n          })\r\n          this._pendingCandidates = []\r\n\r\n          if (this._pc.remoteDescription.type === 'offer') this._createAnswer()\r\n        })\r\n        .catch(err => {\r\n          this.__destroy(errCode(err, 'ERR_SET_REMOTE_DESCRIPTION'))\r\n        })\r\n    }\r\n    if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {\r\n      this.__destroy(errCode(new Error('signal() called with invalid signal data'), 'ERR_SIGNALING'))\r\n    }\r\n  }\r\n\r\n  _addIceCandidate (candidate) {\r\n    const iceCandidateObj = new RTCIceCandidate(candidate)\r\n    this._pc.addIceCandidate(iceCandidateObj)\r\n      .catch(err => {\r\n        if (!iceCandidateObj.address || iceCandidateObj.address.endsWith('.local')) {\r\n          warn('Ignoring unsupported ICE candidate.')\r\n        } else {\r\n          this.__destroy(errCode(err, 'ERR_ADD_ICE_CANDIDATE'))\r\n        }\r\n      })\r\n  }\r\n\r\n  /**\r\n   * Send text/binary data to the remote peer.\r\n   * @param {ArrayBufferView|ArrayBuffer|Uint8Array|string|Blob} chunk\r\n   */\r\n  send (chunk) {\r\n    if (this._destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot send after peer is destroyed'), 'ERR_DESTROYED')\r\n    this._channel.send(chunk)\r\n  }\r\n\r\n  _needsNegotiation () {\r\n    this._debug('_needsNegotiation')\r\n    if (this._batchedNegotiation) return // batch synchronous renegotiations\r\n    this._batchedNegotiation = true\r\n    queueMicrotask(() => {\r\n      this._batchedNegotiation = false\r\n      if (this.initiator || !this._firstNegotiation) {\r\n        this._debug('starting batched negotiation')\r\n        this.negotiate()\r\n      } else {\r\n        this._debug('non-initiator initial negotiation request discarded')\r\n      }\r\n      this._firstNegotiation = false\r\n    })\r\n  }\r\n\r\n  negotiate () {\r\n    if (this._destroying) return\r\n    if (this.destroyed) throw errCode(new Error('cannot negotiate after peer is destroyed'), 'ERR_DESTROYED')\r\n\r\n    if (this.initiator) {\r\n      if (this._isNegotiating) {\r\n        this._queuedNegotiation = true\r\n        this._debug('already negotiating, queueing')\r\n      } else {\r\n        this._debug('start negotiation')\r\n        setTimeout(() => { // HACK: Chrome crashes if we immediately call createOffer\r\n          this._createOffer()\r\n        }, 0)\r\n      }\r\n    } else {\r\n      if (this._isNegotiating) {\r\n        this._queuedNegotiation = true\r\n        this._debug('already negotiating, queueing')\r\n      } else {\r\n        this._debug('requesting negotiation from initiator')\r\n        this.emit('signal', { // request initiator to renegotiate\r\n          type: 'renegotiate',\r\n          renegotiate: true\r\n        })\r\n      }\r\n    }\r\n    this._isNegotiating = true\r\n  }\r\n\r\n  _final (cb) {\r\n    if (!this._readableState.ended) this.push(null)\r\n    cb(null)\r\n  }\r\n\r\n  __destroy (err) {\r\n    this.end()\r\n    this._destroy(() => {}, err)\r\n  }\r\n\r\n  _destroy (cb, err) {\r\n    if (this.destroyed || this._destroying) return\r\n    this._destroying = true\r\n\r\n    this._debug('destroying (error: %s)', err && (err.message || err))\r\n\r\n    setTimeout(() => { // allow events concurrent with the call to _destroy() to fire (see #692)\r\n      if (this._connected) this.emit('disconnect')\r\n      this._connected = false\r\n      this._pcReady = false\r\n      this._channelReady = false\r\n      this._remoteTracks = null\r\n      this._remoteStreams = null\r\n      this._senderMap = null\r\n\r\n      clearInterval(this._closingInterval)\r\n      this._closingInterval = null\r\n\r\n      clearInterval(this._interval)\r\n      this._interval = null\r\n      this._chunk = null\r\n      this._cb = null\r\n\r\n      if (this._onFinishBound) this.removeListener('finish', this._onFinishBound)\r\n      this._onFinishBound = null\r\n\r\n      if (this._channel) {\r\n        try {\r\n          this._channel.close()\r\n        } catch (err) {}\r\n\r\n        // allow events concurrent with destruction to be handled\r\n        this._channel.onmessage = null\r\n        this._channel.onopen = null\r\n        this._channel.onclose = null\r\n        this._channel.onerror = null\r\n      }\r\n      if (this._pc) {\r\n        try {\r\n          this._pc.close()\r\n        } catch (err) {}\r\n\r\n        // allow events concurrent with destruction to be handled\r\n        this._pc.oniceconnectionstatechange = null\r\n        this._pc.onicegatheringstatechange = null\r\n        this._pc.onsignalingstatechange = null\r\n        this._pc.onicecandidate = null\r\n        this._pc.ontrack = null\r\n        this._pc.ondatachannel = null\r\n      }\r\n      this._pc = null\r\n      this._channel = null\r\n      if (err) this.emit('error', err)\r\n      cb()\r\n    }, 0)\r\n  }\r\n\r\n  _setupData (event) {\r\n    if (!event.channel) {\r\n      // In some situations `pc.createDataChannel()` returns `undefined` (in wrtc),\r\n      // which is invalid behavior. Handle it gracefully.\r\n      // See: https://github.com/feross/simple-peer/issues/163\r\n      return this.__destroy(errCode(new Error('Data channel event is missing `channel` property'), 'ERR_DATA_CHANNEL'))\r\n    }\r\n\r\n    this._channel = event.channel\r\n    this._channel.binaryType = 'arraybuffer'\r\n\r\n    if (typeof this._channel.bufferedAmountLowThreshold === 'number') {\r\n      this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT\r\n    }\r\n\r\n    this.channelName = this._channel.label\r\n\r\n    this._channel.onmessage = event => {\r\n      this._onChannelMessage(event)\r\n    }\r\n    this._channel.onbufferedamountlow = () => {\r\n      this._onChannelBufferedAmountLow()\r\n    }\r\n    this._channel.onopen = () => {\r\n      this._onChannelOpen()\r\n    }\r\n    this._channel.onclose = () => {\r\n      this._onChannelClose()\r\n    }\r\n    this._channel.onerror = event => {\r\n      const err = event.error instanceof Error\r\n        ? event.error\r\n        : new Error(`Datachannel error: ${event.message} ${event.filename}:${event.lineno}:${event.colno}`)\r\n      this.__destroy(errCode(err, 'ERR_DATA_CHANNEL'))\r\n    }\r\n\r\n    // HACK: Chrome will sometimes get stuck in readyState \"closing\", let's check for this condition\r\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=882743\r\n    let isClosing = false\r\n    this._closingInterval = setInterval(() => { // No \"onclosing\" event\r\n      if (this._channel && this._channel.readyState === 'closing') {\r\n        if (isClosing) this._onChannelClose() // closing timed out: equivalent to onclose firing\r\n        isClosing = true\r\n      } else {\r\n        isClosing = false\r\n      }\r\n    }, CHANNEL_CLOSING_TIMEOUT)\r\n  }\r\n\r\n  _write (chunk, cb) {\r\n    if (this.destroyed) return cb(errCode(new Error('cannot write after peer is destroyed'), 'ERR_DATA_CHANNEL'))\r\n\r\n    if (this._connected) {\r\n      try {\r\n        this.send(chunk)\r\n      } catch (err) {\r\n        return this.__destroy(errCode(err, 'ERR_DATA_CHANNEL'))\r\n      }\r\n      if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n        this._debug('start backpressure: bufferedAmount %d', this._channel.bufferedAmount)\r\n        this._cb = cb\r\n      } else {\r\n        cb(null)\r\n      }\r\n    } else {\r\n      this._debug('write before connect')\r\n      this._chunk = chunk\r\n      this._cb = cb\r\n    }\r\n  }\r\n\r\n  // When stream finishes writing, close socket. Half open connections are not\r\n  // supported.\r\n  _onFinish () {\r\n    if (this.destroyed) return\r\n\r\n    // Wait a bit before destroying so the socket flushes.\r\n    // TODO: is there a more reliable way to accomplish this?\r\n    const destroySoon = () => {\r\n      setTimeout(() => this.__destroy(), 1000)\r\n    }\r\n\r\n    if (this._connected) {\r\n      destroySoon()\r\n    } else {\r\n      this.once('connect', destroySoon)\r\n    }\r\n  }\r\n\r\n  _startIceCompleteTimeout () {\r\n    if (this.destroyed) return\r\n    if (this._iceCompleteTimer) return\r\n    this._debug('started iceComplete timeout')\r\n    this._iceCompleteTimer = setTimeout(() => {\r\n      if (!this._iceComplete) {\r\n        this._iceComplete = true\r\n        this._debug('iceComplete timeout completed')\r\n        this.emit('iceTimeout')\r\n        this.emit('_iceComplete')\r\n      }\r\n    }, this.iceCompleteTimeout)\r\n  }\r\n\r\n  _createOffer () {\r\n    if (this.destroyed) return\r\n\r\n    this._pc.createOffer(this.offerOptions)\r\n      .then(offer => {\r\n        if (this.destroyed) return\r\n        if (!this.trickle && !this.allowHalfTrickle) offer.sdp = filterTrickle(offer.sdp)\r\n        offer.sdp = this.sdpTransform(offer.sdp)\r\n\r\n        const sendOffer = () => {\r\n          if (this.destroyed) return\r\n          const signal = this._pc.localDescription || offer\r\n          this._debug('signal')\r\n          this.emit('signal', {\r\n            type: signal.type,\r\n            sdp: signal.sdp\r\n          })\r\n        }\r\n\r\n        const onSuccess = () => {\r\n          this._debug('createOffer success')\r\n          if (this.destroyed) return\r\n          if (this.trickle || this._iceComplete) sendOffer()\r\n          else this.once('_iceComplete', sendOffer) // wait for candidates\r\n        }\r\n\r\n        const onError = err => {\r\n          this.__destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))\r\n        }\r\n\r\n        this._pc.setLocalDescription(offer)\r\n          .then(onSuccess)\r\n          .catch(onError)\r\n      })\r\n      .catch(err => {\r\n        this.__destroy(errCode(err, 'ERR_CREATE_OFFER'))\r\n      })\r\n  }\r\n\r\n  _createAnswer () {\r\n    if (this.destroyed) return\r\n\r\n    this._pc.createAnswer(this.answerOptions)\r\n      .then(answer => {\r\n        if (this.destroyed) return\r\n        if (!this.trickle && !this.allowHalfTrickle) answer.sdp = filterTrickle(answer.sdp)\r\n        answer.sdp = this.sdpTransform(answer.sdp)\r\n\r\n        const sendAnswer = () => {\r\n          if (this.destroyed) return\r\n          const signal = this._pc.localDescription || answer\r\n          this._debug('signal')\r\n          this.emit('signal', {\r\n            type: signal.type,\r\n            sdp: signal.sdp\r\n          })\r\n          if (!this.initiator) this._requestMissingTransceivers?.()\r\n        }\r\n\r\n        const onSuccess = () => {\r\n          if (this.destroyed) return\r\n          if (this.trickle || this._iceComplete) sendAnswer()\r\n          else this.once('_iceComplete', sendAnswer)\r\n        }\r\n\r\n        const onError = err => {\r\n          this.__destroy(errCode(err, 'ERR_SET_LOCAL_DESCRIPTION'))\r\n        }\r\n\r\n        this._pc.setLocalDescription(answer)\r\n          .then(onSuccess)\r\n          .catch(onError)\r\n      })\r\n      .catch(err => {\r\n        this.__destroy(errCode(err, 'ERR_CREATE_ANSWER'))\r\n      })\r\n  }\r\n\r\n  _onConnectionStateChange () {\r\n    if (this.destroyed || this._destroying) return\r\n    if (this._pc.connectionState === 'failed') {\r\n      this.__destroy(errCode(new Error('Connection failed.'), 'ERR_CONNECTION_FAILURE'))\r\n    }\r\n  }\r\n\r\n  _onIceStateChange () {\r\n    if (this.destroyed) return\r\n    const iceConnectionState = this._pc.iceConnectionState\r\n    const iceGatheringState = this._pc.iceGatheringState\r\n\r\n    this._debug(\r\n      'iceStateChange (connection: %s) (gathering: %s)',\r\n      iceConnectionState,\r\n      iceGatheringState\r\n    )\r\n    this.emit('iceStateChange', iceConnectionState, iceGatheringState)\r\n\r\n    if (iceConnectionState === 'connected' || iceConnectionState === 'completed') {\r\n      this._pcReady = true\r\n      this._maybeReady()\r\n    }\r\n    if (iceConnectionState === 'failed') {\r\n      this.__destroy(errCode(new Error('Ice connection failed.'), 'ERR_ICE_CONNECTION_FAILURE'))\r\n    }\r\n    if (iceConnectionState === 'closed') {\r\n      this.__destroy(errCode(new Error('Ice connection closed.'), 'ERR_ICE_CONNECTION_CLOSED'))\r\n    }\r\n  }\r\n\r\n  getStats (cb) {\r\n    // statreports can come with a value array instead of properties\r\n    const flattenValues = report => {\r\n      if (Object.prototype.toString.call(report.values) === '[object Array]') {\r\n        report.values.forEach(value => {\r\n          Object.assign(report, value)\r\n        })\r\n      }\r\n      return report\r\n    }\r\n\r\n    // Promise-based getStats() (standard)\r\n    if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {\r\n      this._pc.getStats()\r\n        .then(res => {\r\n          const reports = []\r\n          res.forEach(report => {\r\n            reports.push(flattenValues(report))\r\n          })\r\n          cb(null, reports)\r\n        }, err => cb(err))\r\n\r\n    // Single-parameter callback-based getStats() (non-standard)\r\n    } else if (this._pc.getStats.length > 0) {\r\n      this._pc.getStats(res => {\r\n        // If we destroy connection in `connect` callback this code might happen to run when actual connection is already closed\r\n        if (this.destroyed) return\r\n\r\n        const reports = []\r\n        res.result().forEach(result => {\r\n          const report = {}\r\n          result.names().forEach(name => {\r\n            report[name] = result.stat(name)\r\n          })\r\n          report.id = result.id\r\n          report.type = result.type\r\n          report.timestamp = result.timestamp\r\n          reports.push(flattenValues(report))\r\n        })\r\n        cb(null, reports)\r\n      }, err => cb(err))\r\n\r\n    // Unknown browser, skip getStats() since it's anyone's guess which style of\r\n    // getStats() they implement.\r\n    } else {\r\n      cb(null, [])\r\n    }\r\n  }\r\n\r\n  _maybeReady () {\r\n    this._debug('maybeReady pc %s channel %s', this._pcReady, this._channelReady)\r\n    if (this._connected || this._connecting || !this._pcReady || !this._channelReady) return\r\n\r\n    this._connecting = true\r\n\r\n    // HACK: We can't rely on order here, for details see https://github.com/js-platform/node-webrtc/issues/339\r\n    const findCandidatePair = () => {\r\n      if (this.destroyed || this._destroying) return\r\n\r\n      this.getStats((err, items) => {\r\n        if (this.destroyed || this._destroying) return\r\n\r\n        // Treat getStats error as non-fatal. It's not essential.\r\n        if (err) items = []\r\n\r\n        const remoteCandidates = {}\r\n        const localCandidates = {}\r\n        const candidatePairs = {}\r\n        let foundSelectedCandidatePair = false\r\n\r\n        items.forEach(item => {\r\n          // TODO: Once all browsers support the hyphenated stats report types, remove\r\n          // the non-hypenated ones\r\n          if (item.type === 'remotecandidate' || item.type === 'remote-candidate') {\r\n            remoteCandidates[item.id] = item\r\n          }\r\n          if (item.type === 'localcandidate' || item.type === 'local-candidate') {\r\n            localCandidates[item.id] = item\r\n          }\r\n          if (item.type === 'candidatepair' || item.type === 'candidate-pair') {\r\n            candidatePairs[item.id] = item\r\n          }\r\n        })\r\n\r\n        const setSelectedCandidatePair = selectedCandidatePair => {\r\n          foundSelectedCandidatePair = true\r\n\r\n          let local = localCandidates[selectedCandidatePair.localCandidateId]\r\n\r\n          if (local && (local.ip || local.address)) {\r\n            // Spec\r\n            this.localAddress = local.ip || local.address\r\n            this.localPort = Number(local.port)\r\n          } else if (local && local.ipAddress) {\r\n            // Firefox\r\n            this.localAddress = local.ipAddress\r\n            this.localPort = Number(local.portNumber)\r\n          } else if (typeof selectedCandidatePair.googLocalAddress === 'string') {\r\n            // TODO: remove this once Chrome 58 is released\r\n            local = selectedCandidatePair.googLocalAddress.split(':')\r\n            this.localAddress = local[0]\r\n            this.localPort = Number(local[1])\r\n          }\r\n          if (this.localAddress) {\r\n            this.localFamily = this.localAddress.includes(':') ? 'IPv6' : 'IPv4'\r\n          }\r\n\r\n          let remote = remoteCandidates[selectedCandidatePair.remoteCandidateId]\r\n\r\n          if (remote && (remote.ip || remote.address)) {\r\n            // Spec\r\n            this.remoteAddress = remote.ip || remote.address\r\n            this.remotePort = Number(remote.port)\r\n          } else if (remote && remote.ipAddress) {\r\n            // Firefox\r\n            this.remoteAddress = remote.ipAddress\r\n            this.remotePort = Number(remote.portNumber)\r\n          } else if (typeof selectedCandidatePair.googRemoteAddress === 'string') {\r\n            // TODO: remove this once Chrome 58 is released\r\n            remote = selectedCandidatePair.googRemoteAddress.split(':')\r\n            this.remoteAddress = remote[0]\r\n            this.remotePort = Number(remote[1])\r\n          }\r\n          if (this.remoteAddress) {\r\n            this.remoteFamily = this.remoteAddress.includes(':') ? 'IPv6' : 'IPv4'\r\n          }\r\n\r\n          this._debug(\r\n            'connect local: %s:%s remote: %s:%s',\r\n            this.localAddress,\r\n            this.localPort,\r\n            this.remoteAddress,\r\n            this.remotePort\r\n          )\r\n        }\r\n\r\n        items.forEach(item => {\r\n          // Spec-compliant\r\n          if (item.type === 'transport' && item.selectedCandidatePairId) {\r\n            setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId])\r\n          }\r\n\r\n          // Old implementations\r\n          if (\r\n            (item.type === 'googCandidatePair' && item.googActiveConnection === 'true') ||\r\n            ((item.type === 'candidatepair' || item.type === 'candidate-pair') && item.selected)\r\n          ) {\r\n            setSelectedCandidatePair(item)\r\n          }\r\n        })\r\n\r\n        // Ignore candidate pair selection in browsers like Safari 11 that do not have any local or remote candidates\r\n        // But wait until at least 1 candidate pair is available\r\n        if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {\r\n          setTimeout(findCandidatePair, 100)\r\n          return\r\n        } else {\r\n          this._connecting = false\r\n          this._connected = true\r\n          this.emit('connect')\r\n        }\r\n\r\n        if (this._chunk) {\r\n          try {\r\n            this.send(this._chunk)\r\n          } catch (err) {\r\n            return this.__destroy(errCode(err, 'ERR_DATA_CHANNEL'))\r\n          }\r\n          this._chunk = null\r\n          this._debug('sent chunk from \"write before connect\"')\r\n\r\n          const cb = this._cb\r\n          this._cb = null\r\n          cb(null)\r\n        }\r\n\r\n        // If `bufferedAmountLowThreshold` and 'onbufferedamountlow' are unsupported,\r\n        // fallback to using setInterval to implement backpressure.\r\n        if (typeof this._channel.bufferedAmountLowThreshold !== 'number') {\r\n          this._interval = setInterval(() => this._onInterval(), 150)\r\n          if (this._interval.unref) this._interval.unref()\r\n        }\r\n\r\n        this._debug('connect')\r\n        this.emit('connect')\r\n      })\r\n    }\r\n    findCandidatePair()\r\n  }\r\n\r\n  _onInterval () {\r\n    if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n      return\r\n    }\r\n    this._onChannelBufferedAmountLow()\r\n  }\r\n\r\n  _onSignalingStateChange () {\r\n    if (this.destroyed) return\r\n\r\n    if (this._pc.signalingState === 'stable') {\r\n      this._isNegotiating = false\r\n\r\n      // HACK: Firefox doesn't yet support removing tracks when signalingState !== 'stable'\r\n      this._debug('flushing sender queue', this._sendersAwaitingStable)\r\n      this._sendersAwaitingStable.forEach(sender => {\r\n        this._pc.removeTrack(sender)\r\n        this._queuedNegotiation = true\r\n      })\r\n      this._sendersAwaitingStable = []\r\n\r\n      if (this._queuedNegotiation) {\r\n        this._debug('flushing negotiation queue')\r\n        this._queuedNegotiation = false\r\n        this._needsNegotiation() // negotiate again\r\n      } else {\r\n        this._debug('negotiated')\r\n        this.emit('negotiated')\r\n      }\r\n    }\r\n\r\n    this._debug('signalingStateChange %s', this._pc.signalingState)\r\n    this.emit('signalingStateChange', this._pc.signalingState)\r\n  }\r\n\r\n  _onIceCandidate (event) {\r\n    if (this.destroyed) return\r\n    if (event.candidate && this.trickle) {\r\n      this.emit('signal', {\r\n        type: 'candidate',\r\n        candidate: {\r\n          candidate: event.candidate.candidate,\r\n          sdpMLineIndex: event.candidate.sdpMLineIndex,\r\n          sdpMid: event.candidate.sdpMid\r\n        }\r\n      })\r\n    } else if (!event.candidate && !this._iceComplete) {\r\n      this._iceComplete = true\r\n      this.emit('_iceComplete')\r\n    }\r\n    // as soon as we've received one valid candidate start timeout\r\n    if (event.candidate) {\r\n      this._startIceCompleteTimeout()\r\n    }\r\n  }\r\n\r\n  _onChannelMessage (event) {\r\n    if (this.destroyed) return\r\n    let data = event.data\r\n    if (data instanceof ArrayBuffer) {\r\n      data = new Uint8Array(data)\r\n    } else if (this.__objectMode === false) {\r\n      data = text2arr(data)\r\n    }\r\n    this.push(data)\r\n  }\r\n\r\n  _onChannelBufferedAmountLow () {\r\n    if (this.destroyed || !this._cb) return\r\n    this._debug('ending backpressure: bufferedAmount %d', this._channel.bufferedAmount)\r\n    const cb = this._cb\r\n    this._cb = null\r\n    cb(null)\r\n  }\r\n\r\n  _onChannelOpen () {\r\n    if (this._connected || this.destroyed) return\r\n    this._debug('on channel open')\r\n    this._channelReady = true\r\n    this._maybeReady()\r\n  }\r\n\r\n  _onChannelClose () {\r\n    if (this.destroyed) return\r\n    this._debug('on channel close')\r\n    this.__destroy()\r\n  }\r\n\r\n  _debug () {\r\n    const args = [].slice.call(arguments)\r\n    args[0] = '[' + this._id + '] ' + args[0]\r\n    Debug.apply(null, args)\r\n  }\r\n}\r\n\r\nPeer.WEBRTC_SUPPORT = !!RTCPeerConnection\r\n\r\n/**\r\n * Expose peer and data channel config for overriding all Peer\r\n * instances. Otherwise, just set opts.config or opts.channelConfig\r\n * when constructing a Peer.\r\n */\r\nPeer.config = {\r\n  iceServers: [\r\n    {\r\n      urls: [\r\n        'stun:stun.l.google.com:19302',\r\n        'stun:global.stun.twilio.com:3478'\r\n      ]\r\n    }\r\n  ],\r\n  sdpSemantics: 'unified-plan'\r\n}\r\n\r\nPeer.channelConfig = {}\r\n\r\nexport default Peer\r\n","export default {}","/**\n * Functions/constants needed by both the client and server.\n */\nimport * as common from './common-node.js'\nexport * from './common-node.js'\n\nexport const DEFAULT_ANNOUNCE_PEERS = 50\nexport const MAX_ANNOUNCE_PEERS = 82\n\n// HACK: Fix for WHATWG URL object not parsing non-standard URL schemes like\n// 'udp:'. Just replace it with 'http:' since we only need a few properties.\n//\n// Note: Only affects Chrome and Firefox. Works fine in Node.js, Safari, and\n// Edge.\n//\n// Note: UDP trackers aren't used in the normal browser build, but they are\n// used in a Chrome App build (i.e. by Brave Browser).\n//\n// Bug reports:\n// - Chrome: https://bugs.chromium.org/p/chromium/issues/detail?id=734880\n// - Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1374505\nexport const parseUrl = str => {\n  const url = new URL(str.replace(/^udp:/, 'http:'))\n\n  if (str.match(/^udp:/)) {\n    Object.defineProperties(url, {\n      href: { value: url.href.replace(/^http/, 'udp') },\n      protocol: { value: url.protocol.replace(/^http/, 'udp') },\n      origin: { value: url.origin.replace(/^http/, 'udp') }\n    })\n  }\n\n  return url\n}\n\nexport default {\n  DEFAULT_ANNOUNCE_PEERS,\n  MAX_ANNOUNCE_PEERS,\n  parseUrl,\n  ...common\n}\n","/*! simple-websocket. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\r\n/* global WebSocket */\r\n\r\nimport Debug from 'debug'\r\nimport queueMicrotask from 'queue-microtask' // TODO: remove when Node 10 is not supported\r\nimport ws from 'ws' // websockets in node - will be empty object in browser\r\nimport { Duplex } from 'streamx'\r\nimport { text2arr, randomBytes, arr2hex } from 'uint8-util'\r\n\r\nconst debug = Debug('simple-websocket')\r\n\r\nconst _WebSocket = typeof ws !== 'function' ? WebSocket : ws\r\n\r\nconst MAX_BUFFERED_AMOUNT = 64 * 1024\r\n\r\n/**\r\n * WebSocket. Same API as node core `net.Socket`. Duplex stream.\r\n * @param {Object} opts\r\n * @param {string=} opts.url websocket server url\r\n * @param {string=} opts.socket raw websocket instance to wrap\r\n */\r\nexport default class Socket extends Duplex {\r\n  constructor (opts = {}) {\r\n    // Support simple usage: `new Socket(url)`\r\n    if (typeof opts === 'string') {\r\n      opts = { url: opts }\r\n    }\r\n\r\n    opts = Object.assign({\r\n      allowHalfOpen: false\r\n    }, opts)\r\n\r\n    super(opts)\r\n\r\n    this.__objectMode = !!opts.objectMode // streamx is objectMode by default, so implement readable's fuctionality\r\n    if (opts.objectMode != null) delete opts.objectMode // causes error with ws...\r\n\r\n    if (opts.url == null && opts.socket == null) {\r\n      throw new Error('Missing required `url` or `socket` option')\r\n    }\r\n    if (opts.url != null && opts.socket != null) {\r\n      throw new Error('Must specify either `url` or `socket` option, not both')\r\n    }\r\n\r\n    this._id = arr2hex(randomBytes(4)).slice(0, 7)\r\n    this._debug('new websocket: %o', opts)\r\n\r\n    this.connected = false\r\n\r\n    this._chunk = null\r\n    this._cb = null\r\n    this._interval = null\r\n\r\n    if (opts.socket) {\r\n      this.url = opts.socket.url\r\n      this._ws = opts.socket\r\n      this.connected = opts.socket.readyState === _WebSocket.OPEN\r\n    } else {\r\n      this.url = opts.url\r\n      try {\r\n        if (typeof ws === 'function') {\r\n          // `ws` package accepts options\r\n          this._ws = new _WebSocket(opts.url, {\r\n            ...opts,\r\n            encoding: undefined // encoding option breaks ws internals\r\n          })\r\n        } else {\r\n          this._ws = new _WebSocket(opts.url)\r\n        }\r\n      } catch (err) {\r\n        queueMicrotask(() => this.destroy(err))\r\n        return\r\n      }\r\n    }\r\n\r\n    this._ws.binaryType = 'arraybuffer'\r\n\r\n    if (opts.socket && this.connected) {\r\n      queueMicrotask(() => this._handleOpen())\r\n    } else {\r\n      this._ws.onopen = () => this._handleOpen()\r\n    }\r\n\r\n    this._ws.onmessage = event => this._handleMessage(event)\r\n    this._ws.onclose = () => this._handleClose()\r\n    this._ws.onerror = err => this._handleError(err)\r\n\r\n    this._handleFinishBound = () => this._handleFinish()\r\n    this.once('finish', this._handleFinishBound)\r\n  }\r\n\r\n  /**\r\n   * Send text/binary data to the WebSocket server.\r\n   * @param {TypedArrayView|ArrayBuffer|Uint8Array|string|Blob|Object} chunk\r\n   */\r\n  send (chunk) {\r\n    this._ws.send(chunk)\r\n  }\r\n\r\n  _final (cb) {\r\n    if (!this._readableState.ended) this.push(null)\r\n    cb(null)\r\n  }\r\n\r\n  _destroy (cb) {\r\n    if (this.destroyed) return\r\n    if (!this._writableState.ended) this.end()\r\n\r\n    this.connected = false\r\n\r\n    clearInterval(this._interval)\r\n    this._interval = null\r\n    this._chunk = null\r\n    this._cb = null\r\n\r\n    if (this._handleFinishBound) {\r\n      this.removeListener('finish', this._handleFinishBound)\r\n    }\r\n    this._handleFinishBound = null\r\n\r\n    if (this._ws) {\r\n      const ws = this._ws\r\n      const onClose = () => {\r\n        ws.onclose = null\r\n      }\r\n      if (ws.readyState === _WebSocket.CLOSED) {\r\n        onClose()\r\n      } else {\r\n        try {\r\n          ws.onclose = onClose\r\n          ws.close()\r\n        } catch (err) {\r\n          onClose()\r\n        }\r\n      }\r\n\r\n      ws.onopen = null\r\n      ws.onmessage = null\r\n      ws.onerror = () => {}\r\n    }\r\n    this._ws = null\r\n\r\n    cb()\r\n  }\r\n\r\n  _write (chunk, cb) {\r\n    if (this.destroyed) return cb(new Error('cannot write after socket is destroyed'))\r\n\r\n    if (this.connected) {\r\n      try {\r\n        this.send(chunk)\r\n      } catch (err) {\r\n        return this.destroy(err)\r\n      }\r\n      if (typeof ws !== 'function' && this._ws.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n        this._debug('start backpressure: bufferedAmount %d', this._ws.bufferedAmount)\r\n        this._cb = cb\r\n      } else {\r\n        cb(null)\r\n      }\r\n    } else {\r\n      this._debug('write before connect')\r\n      this._chunk = chunk\r\n      this._cb = cb\r\n    }\r\n  }\r\n\r\n  _handleOpen () {\r\n    if (this.connected || this.destroyed) return\r\n    this.connected = true\r\n\r\n    if (this._chunk) {\r\n      try {\r\n        this.send(this._chunk)\r\n      } catch (err) {\r\n        return this.destroy(err)\r\n      }\r\n      this._chunk = null\r\n      this._debug('sent chunk from \"write before connect\"')\r\n\r\n      const cb = this._cb\r\n      this._cb = null\r\n      cb(null)\r\n    }\r\n\r\n    // Backpressure is not implemented in Node.js. The `ws` module has a buggy\r\n    // `bufferedAmount` property. See: https://github.com/websockets/ws/issues/492\r\n    if (typeof ws !== 'function') {\r\n      this._interval = setInterval(() => this._onInterval(), 150)\r\n      if (this._interval.unref) this._interval.unref()\r\n    }\r\n\r\n    this._debug('connect')\r\n    this.emit('connect')\r\n  }\r\n\r\n  _handleMessage (event) {\r\n    if (this.destroyed) return\r\n    let data = event.data\r\n    if (data instanceof ArrayBuffer) data = new Uint8Array(data)\r\n    if (this.__objectMode === false) data = text2arr(data)\r\n    this.push(data)\r\n  }\r\n\r\n  _handleClose () {\r\n    if (this.destroyed) return\r\n    this._debug('on close')\r\n    this.destroy()\r\n  }\r\n\r\n  _handleError (_) {\r\n    this.destroy(new Error(`Error connecting to ${this.url}`))\r\n  }\r\n\r\n  // When stream finishes writing, close socket. Half open connections are not\r\n  // supported.\r\n  _handleFinish () {\r\n    if (this.destroyed) return\r\n\r\n    // Wait a bit before destroying so the socket flushes.\r\n    // TODO: is there a more reliable way to accomplish this?\r\n    const destroySoon = () => {\r\n      setTimeout(() => this.destroy(), 1000)\r\n    }\r\n\r\n    if (this.connected) {\r\n      destroySoon()\r\n    } else {\r\n      this.once('connect', destroySoon)\r\n    }\r\n  }\r\n\r\n  _onInterval () {\r\n    if (!this._cb || !this._ws || this._ws.bufferedAmount > MAX_BUFFERED_AMOUNT) {\r\n      return\r\n    }\r\n    this._debug('ending backpressure: bufferedAmount %d', this._ws.bufferedAmount)\r\n    const cb = this._cb\r\n    this._cb = null\r\n    cb(null)\r\n  }\r\n\r\n  _debug () {\r\n    const args = [].slice.call(arguments)\r\n    args[0] = '[' + this._id + '] ' + args[0]\r\n    debug.apply(null, args)\r\n  }\r\n}\r\n\r\nSocket.WEBSOCKET_SUPPORT = !!_WebSocket\r\n","import EventEmitter from 'events'\n\nclass Tracker extends EventEmitter {\n  constructor (client, announceUrl) {\n    super()\n\n    this.client = client\n    this.announceUrl = announceUrl\n\n    this.interval = null\n    this.destroyed = false\n  }\n\n  setInterval (intervalMs) {\n    if (intervalMs == null) intervalMs = this.DEFAULT_ANNOUNCE_INTERVAL\n\n    clearInterval(this.interval)\n\n    if (intervalMs) {\n      this.interval = setInterval(() => {\n        this.announce(this.client._defaultAnnounceOpts())\n      }, intervalMs)\n      if (this.interval.unref) this.interval.unref()\n    }\n  }\n}\n\nexport default Tracker\n","import Debug from 'debug'\nimport Peer from '@thaunknown/simple-peer/lite.js'\nimport Socket from '@thaunknown/simple-websocket'\nimport { arr2text, arr2hex, hex2bin, bin2hex, randomBytes } from 'uint8-util'\n\nimport common from '../common.js'\nimport Tracker from './tracker.js'\n\nconst debug = Debug('bittorrent-tracker:websocket-tracker')\n\n// Use a socket pool, so tracker clients share WebSocket objects for the same server.\n// In practice, WebSockets are pretty slow to establish, so this gives a nice performance\n// boost, and saves browser resources.\nconst socketPool = {}\n\nconst RECONNECT_MINIMUM = 10 * 1000\nconst RECONNECT_MAXIMUM = 60 * 60 * 1000\nconst RECONNECT_VARIANCE = 5 * 60 * 1000\nconst OFFER_TIMEOUT = 50 * 1000\n\nclass WebSocketTracker extends Tracker {\n  constructor (client, announceUrl) {\n    super(client, announceUrl)\n    debug('new websocket tracker %s', announceUrl)\n\n    this.peers = {} // peers (offer id -> peer)\n    this.socket = null\n\n    this.reconnecting = false\n    this.retries = 0\n    this.reconnectTimer = null\n\n    // Simple boolean flag to track whether the socket has received data from\n    // the websocket server since the last time socket.send() was called.\n    this.expectingResponse = false\n\n    this._openSocket()\n  }\n\n  announce (opts) {\n    if (this.destroyed || this.reconnecting) return\n    if (!this.socket.connected) {\n      this.socket.once('connect', () => {\n        this.announce(opts)\n      })\n      return\n    }\n\n    const params = Object.assign({}, opts, {\n      action: 'announce',\n      info_hash: this.client._infoHashBinary,\n      peer_id: this.client._peerIdBinary\n    })\n    if (this._trackerId) params.trackerid = this._trackerId\n\n    if (opts.event === 'stopped' || opts.event === 'completed') {\n      // Don't include offers with 'stopped' or 'completed' event\n      this._send(params)\n    } else {\n      // Limit the number of offers that are generated, since it can be slow\n      const numwant = Math.min(opts.numwant, 10)\n\n      this._generateOffers(numwant, offers => {\n        params.numwant = numwant\n        params.offers = offers\n        this._send(params)\n      })\n    }\n  }\n\n  scrape (opts) {\n    if (this.destroyed || this.reconnecting) return\n    if (!this.socket.connected) {\n      this.socket.once('connect', () => {\n        this.scrape(opts)\n      })\n      return\n    }\n\n    const infoHashes = (Array.isArray(opts.infoHash) && opts.infoHash.length > 0)\n      ? opts.infoHash.map(infoHash => hex2bin(infoHash))\n      : (opts.infoHash && hex2bin(opts.infoHash)) || this.client._infoHashBinary\n    const params = {\n      action: 'scrape',\n      info_hash: infoHashes\n    }\n\n    this._send(params)\n  }\n\n  destroy (cb = noop) {\n    if (this.destroyed) return cb(null)\n\n    this.destroyed = true\n\n    clearInterval(this.interval)\n    clearTimeout(this.reconnectTimer)\n\n    // Destroy peers\n    for (const peerId in this.peers) {\n      const peer = this.peers[peerId]\n      clearTimeout(peer.trackerTimeout)\n      peer.destroy()\n    }\n    this.peers = null\n\n    if (this.socket) {\n      this.socket.removeListener('connect', this._onSocketConnectBound)\n      this.socket.removeListener('data', this._onSocketDataBound)\n      this.socket.removeListener('close', this._onSocketCloseBound)\n      this.socket.removeListener('error', this._onSocketErrorBound)\n      this.socket = null\n    }\n\n    this._onSocketConnectBound = null\n    this._onSocketErrorBound = null\n    this._onSocketDataBound = null\n    this._onSocketCloseBound = null\n\n    if (socketPool[this.announceUrl]) {\n      socketPool[this.announceUrl].consumers -= 1\n    }\n\n    // Other instances are using the socket, so there's nothing left to do here\n    if (socketPool[this.announceUrl].consumers > 0) return cb()\n\n    let socket = socketPool[this.announceUrl]\n    delete socketPool[this.announceUrl]\n    socket.on('error', noop) // ignore all future errors\n    socket.once('close', cb)\n\n    let timeout\n\n    // If there is no data response expected, destroy immediately.\n    if (!this.expectingResponse) return destroyCleanup()\n\n    // Otherwise, wait a short time for potential responses to come in from the\n    // server, then force close the socket.\n    timeout = setTimeout(destroyCleanup, common.DESTROY_TIMEOUT)\n\n    // But, if a response comes from the server before the timeout fires, do cleanup\n    // right away.\n    socket.once('data', destroyCleanup)\n\n    function destroyCleanup () {\n      if (timeout) {\n        clearTimeout(timeout)\n        timeout = null\n      }\n      socket.removeListener('data', destroyCleanup)\n      socket.destroy()\n      socket = null\n    }\n  }\n\n  _openSocket () {\n    this.destroyed = false\n\n    if (!this.peers) this.peers = {}\n\n    this._onSocketConnectBound = () => {\n      this._onSocketConnect()\n    }\n    this._onSocketErrorBound = err => {\n      this._onSocketError(err)\n    }\n    this._onSocketDataBound = data => {\n      this._onSocketData(data)\n    }\n    this._onSocketCloseBound = () => {\n      this._onSocketClose()\n    }\n\n    this.socket = socketPool[this.announceUrl]\n    if (this.socket) {\n      socketPool[this.announceUrl].consumers += 1\n      if (this.socket.connected) {\n        this._onSocketConnectBound()\n      }\n    } else {\n      const parsedUrl = new URL(this.announceUrl)\n      let agent\n      if (this.client._proxyOpts) {\n        agent = parsedUrl.protocol === 'wss:' ? this.client._proxyOpts.httpsAgent : this.client._proxyOpts.httpAgent\n        if (!agent && this.client._proxyOpts.socksProxy) {\n          agent = this.client._proxyOpts.socksProxy\n        }\n      }\n      this.socket = socketPool[this.announceUrl] = new Socket({ url: this.announceUrl, agent })\n      this.socket.consumers = 1\n      this.socket.once('connect', this._onSocketConnectBound)\n    }\n\n    this.socket.on('data', this._onSocketDataBound)\n    this.socket.once('close', this._onSocketCloseBound)\n    this.socket.once('error', this._onSocketErrorBound)\n  }\n\n  _onSocketConnect () {\n    if (this.destroyed) return\n\n    if (this.reconnecting) {\n      this.reconnecting = false\n      this.retries = 0\n      this.announce(this.client._defaultAnnounceOpts())\n    }\n  }\n\n  _onSocketData (data) {\n    if (this.destroyed) return\n\n    this.expectingResponse = false\n\n    try {\n      data = JSON.parse(arr2text(data))\n    } catch (err) {\n      this.client.emit('warning', new Error('Invalid tracker response'))\n      return\n    }\n\n    if (data.action === 'announce') {\n      this._onAnnounceResponse(data)\n    } else if (data.action === 'scrape') {\n      this._onScrapeResponse(data)\n    } else {\n      this._onSocketError(new Error(`invalid action in WS response: ${data.action}`))\n    }\n  }\n\n  _onAnnounceResponse (data) {\n    if (data.info_hash !== this.client._infoHashBinary) {\n      debug(\n        'ignoring websocket data from %s for %s (looking for %s: reused socket)',\n        this.announceUrl, bin2hex(data.info_hash), this.client.infoHash\n      )\n      return\n    }\n\n    if (data.peer_id && data.peer_id === this.client._peerIdBinary) {\n      // ignore offers/answers from this client\n      return\n    }\n\n    debug(\n      'received %s from %s for %s',\n      JSON.stringify(data), this.announceUrl, this.client.infoHash\n    )\n\n    const failure = data['failure reason']\n    if (failure) return this.client.emit('warning', new Error(failure))\n\n    const warning = data['warning message']\n    if (warning) this.client.emit('warning', new Error(warning))\n\n    const interval = data.interval || data['min interval']\n    if (interval) this.setInterval(interval * 1000)\n\n    const trackerId = data['tracker id']\n    if (trackerId) {\n      // If absent, do not discard previous trackerId value\n      this._trackerId = trackerId\n    }\n\n    if (data.complete != null) {\n      const response = Object.assign({}, data, {\n        announce: this.announceUrl,\n        infoHash: bin2hex(data.info_hash)\n      })\n      this.client.emit('update', response)\n    }\n\n    let peer\n    if (data.offer && data.peer_id) {\n      debug('creating peer (from remote offer)')\n      peer = this._createPeer()\n      peer.id = bin2hex(data.peer_id)\n      peer.once('signal', answer => {\n        const params = {\n          action: 'announce',\n          info_hash: this.client._infoHashBinary,\n          peer_id: this.client._peerIdBinary,\n          to_peer_id: data.peer_id,\n          answer,\n          offer_id: data.offer_id\n        }\n        if (this._trackerId) params.trackerid = this._trackerId\n        this._send(params)\n      })\n      this.client.emit('peer', peer)\n      peer.signal(data.offer)\n    }\n\n    if (data.answer && data.peer_id) {\n      const offerId = bin2hex(data.offer_id)\n      peer = this.peers[offerId]\n      if (peer) {\n        peer.id = bin2hex(data.peer_id)\n        this.client.emit('peer', peer)\n        peer.signal(data.answer)\n\n        clearTimeout(peer.trackerTimeout)\n        peer.trackerTimeout = null\n        delete this.peers[offerId]\n      } else {\n        debug(`got unexpected answer: ${JSON.stringify(data.answer)}`)\n      }\n    }\n  }\n\n  _onScrapeResponse (data) {\n    data = data.files || {}\n\n    const keys = Object.keys(data)\n    if (keys.length === 0) {\n      this.client.emit('warning', new Error('invalid scrape response'))\n      return\n    }\n\n    keys.forEach(infoHash => {\n      // TODO: optionally handle data.flags.min_request_interval\n      // (separate from announce interval)\n      const response = Object.assign(data[infoHash], {\n        announce: this.announceUrl,\n        infoHash: bin2hex(infoHash)\n      })\n      this.client.emit('scrape', response)\n    })\n  }\n\n  _onSocketClose () {\n    if (this.destroyed) return\n    this.destroy()\n    this._startReconnectTimer()\n  }\n\n  _onSocketError (err) {\n    if (this.destroyed) return\n    this.destroy()\n    // errors will often happen if a tracker is offline, so don't treat it as fatal\n    this.client.emit('warning', err)\n    this._startReconnectTimer()\n  }\n\n  _startReconnectTimer () {\n    const ms = Math.floor(Math.random() * RECONNECT_VARIANCE) + Math.min(Math.pow(2, this.retries) * RECONNECT_MINIMUM, RECONNECT_MAXIMUM)\n\n    this.reconnecting = true\n    clearTimeout(this.reconnectTimer)\n    this.reconnectTimer = setTimeout(() => {\n      this.retries++\n      this._openSocket()\n    }, ms)\n    if (this.reconnectTimer.unref) this.reconnectTimer.unref()\n\n    debug('reconnecting socket in %s ms', ms)\n  }\n\n  _send (params) {\n    if (this.destroyed) return\n    this.expectingResponse = true\n    const message = JSON.stringify(params)\n    debug('send %s', message)\n    this.socket.send(message)\n  }\n\n  _generateOffers (numwant, cb) {\n    const self = this\n    const offers = []\n    debug('generating %s offers', numwant)\n\n    for (let i = 0; i < numwant; ++i) {\n      generateOffer()\n    }\n    checkDone()\n\n    function generateOffer () {\n      const offerId = arr2hex(randomBytes(20))\n      debug('creating peer (from _generateOffers)')\n      const peer = self.peers[offerId] = self._createPeer({ initiator: true })\n      peer.once('signal', offer => {\n        offers.push({\n          offer,\n          offer_id: hex2bin(offerId)\n        })\n        checkDone()\n      })\n      peer.trackerTimeout = setTimeout(() => {\n        debug('tracker timeout: destroying peer')\n        peer.trackerTimeout = null\n        delete self.peers[offerId]\n        peer.destroy()\n      }, OFFER_TIMEOUT)\n      if (peer.trackerTimeout.unref) peer.trackerTimeout.unref()\n    }\n\n    function checkDone () {\n      if (offers.length === numwant) {\n        debug('generated %s offers', numwant)\n        cb(offers)\n      }\n    }\n  }\n\n  _createPeer (opts) {\n    const self = this\n\n    opts = Object.assign({\n      trickle: false,\n      config: self.client._rtcConfig,\n      wrtc: self.client._wrtc\n    }, opts)\n\n    const peer = new Peer(opts)\n\n    peer.once('error', onError)\n    peer.once('connect', onConnect)\n\n    return peer\n\n    // Handle peer 'error' events that are fired *before* the peer is emitted in\n    // a 'peer' event.\n    function onError (err) {\n      self.client.emit('warning', new Error(`Connection error: ${err.message}`))\n      peer.destroy()\n    }\n\n    // Once the peer is emitted in a 'peer' event, then it's the consumer's\n    // responsibility to listen for errors, so the listeners are removed here.\n    function onConnect () {\n      peer.removeListener('error', onError)\n      peer.removeListener('connect', onConnect)\n    }\n  }\n}\n\nWebSocketTracker.prototype.DEFAULT_ANNOUNCE_INTERVAL = 10 * 1000 // 30 seconds\n// Normally this shouldn't be accessed but is occasionally useful\nWebSocketTracker._socketPool = socketPool\n\nfunction noop () {}\n\nexport default WebSocketTracker\n","import Debug from 'debug'\nimport EventEmitter from 'events'\nimport once from 'once'\nimport parallel from 'run-parallel'\nimport Peer from '@thaunknown/simple-peer/lite.js'\nimport queueMicrotask from 'queue-microtask'\nimport { hex2arr, hex2bin, text2arr, arr2hex, arr2text } from 'uint8-util'\n\nimport common from './lib/common.js'\nimport HTTPTracker from './lib/client/http-tracker.js' // empty object in browser\nimport UDPTracker from './lib/client/udp-tracker.js' // empty object in browser\nimport WebSocketTracker from './lib/client/websocket-tracker.js'\n\nconst debug = Debug('bittorrent-tracker:client')\n\n/**\n * BitTorrent tracker client.\n *\n * Find torrent peers, to help a torrent client participate in a torrent swarm.\n *\n * @param {Object} opts                          options object\n * @param {string|Uint8Array} opts.infoHash          torrent info hash\n * @param {string|Uint8Array} opts.peerId            peer id\n * @param {string|Array.<string>} opts.announce  announce\n * @param {number} opts.port                     torrent client listening port\n * @param {function} opts.getAnnounceOpts        callback to provide data to tracker\n * @param {number} opts.rtcConfig                RTCPeerConnection configuration object\n * @param {number} opts.userAgent                User-Agent header for http requests\n * @param {number} opts.wrtc                     custom webrtc impl (useful in node.js)\n * @param {object} opts.proxyOpts                proxy options (useful in node.js)\n */\nclass Client extends EventEmitter {\n  constructor (opts = {}) {\n    super()\n\n    if (!opts.peerId) throw new Error('Option `peerId` is required')\n    if (!opts.infoHash) throw new Error('Option `infoHash` is required')\n    if (!opts.announce) throw new Error('Option `announce` is required')\n    if (!process.browser && !opts.port) throw new Error('Option `port` is required')\n\n    this.peerId = typeof opts.peerId === 'string'\n      ? opts.peerId\n      : arr2hex(opts.peerId)\n    this._peerIdBuffer = hex2arr(this.peerId)\n    this._peerIdBinary = hex2bin(this.peerId)\n\n    this.infoHash = typeof opts.infoHash === 'string'\n      ? opts.infoHash.toLowerCase()\n      : arr2hex(opts.infoHash)\n    this._infoHashBuffer = hex2arr(this.infoHash)\n    this._infoHashBinary = hex2bin(this.infoHash)\n\n    debug('new client %s', this.infoHash)\n\n    this.destroyed = false\n\n    this._port = opts.port\n    this._getAnnounceOpts = opts.getAnnounceOpts\n    this._rtcConfig = opts.rtcConfig\n    this._userAgent = opts.userAgent\n    this._proxyOpts = opts.proxyOpts\n\n    // Support lazy 'wrtc' module initialization\n    // See: https://github.com/webtorrent/webtorrent-hybrid/issues/46\n    this._wrtc = typeof opts.wrtc === 'function' ? opts.wrtc() : opts.wrtc\n\n    let announce = typeof opts.announce === 'string'\n      ? [opts.announce]\n      : opts.announce == null ? [] : opts.announce\n\n    // Remove trailing slash from trackers to catch duplicates\n    announce = announce.map(announceUrl => {\n      if (ArrayBuffer.isView(announceUrl)) announceUrl = arr2text(announceUrl)\n      if (announceUrl[announceUrl.length - 1] === '/') {\n        announceUrl = announceUrl.substring(0, announceUrl.length - 1)\n      }\n      return announceUrl\n    })\n    // remove duplicates by converting to Set and back\n    announce = Array.from(new Set(announce))\n\n    const webrtcSupport = this._wrtc !== false && (!!this._wrtc || Peer.WEBRTC_SUPPORT)\n\n    const nextTickWarn = err => {\n      queueMicrotask(() => {\n        this.emit('warning', err)\n      })\n    }\n\n    this._trackers = announce\n      .map(announceUrl => {\n        let parsedUrl\n        try {\n          parsedUrl = common.parseUrl(announceUrl)\n        } catch (err) {\n          nextTickWarn(new Error(`Invalid tracker URL: ${announceUrl}`))\n          return null\n        }\n\n        const port = parsedUrl.port\n        if (port < 0 || port > 65535) {\n          nextTickWarn(new Error(`Invalid tracker port: ${announceUrl}`))\n          return null\n        }\n\n        const protocol = parsedUrl.protocol\n        if ((protocol === 'http:' || protocol === 'https:') &&\n            typeof HTTPTracker === 'function') {\n          return new HTTPTracker(this, announceUrl)\n        } else if (protocol === 'udp:' && typeof UDPTracker === 'function') {\n          return new UDPTracker(this, announceUrl)\n        } else if ((protocol === 'ws:' || protocol === 'wss:') && webrtcSupport) {\n          // Skip ws:// trackers on https:// sites because they throw SecurityError\n          if (protocol === 'ws:' && typeof window !== 'undefined' &&\n              window.location.protocol === 'https:') {\n            nextTickWarn(new Error(`Unsupported tracker protocol: ${announceUrl}`))\n            return null\n          }\n          return new WebSocketTracker(this, announceUrl)\n        } else {\n          nextTickWarn(new Error(`Unsupported tracker protocol: ${announceUrl}`))\n          return null\n        }\n      })\n      .filter(Boolean)\n  }\n\n  /**\n   * Send a `start` announce to the trackers.\n   * @param {Object} opts\n   * @param {number=} opts.uploaded\n   * @param {number=} opts.downloaded\n   * @param {number=} opts.left (if not set, calculated automatically)\n   */\n  start (opts) {\n    opts = this._defaultAnnounceOpts(opts)\n    opts.event = 'started'\n    debug('send `start` %o', opts)\n    this._announce(opts)\n\n    // start announcing on intervals\n    this._trackers.forEach(tracker => {\n      tracker.setInterval()\n    })\n  }\n\n  /**\n   * Send a `stop` announce to the trackers.\n   * @param {Object} opts\n   * @param {number=} opts.uploaded\n   * @param {number=} opts.downloaded\n   * @param {number=} opts.numwant\n   * @param {number=} opts.left (if not set, calculated automatically)\n   */\n  stop (opts) {\n    opts = this._defaultAnnounceOpts(opts)\n    opts.event = 'stopped'\n    debug('send `stop` %o', opts)\n    this._announce(opts)\n  }\n\n  /**\n   * Send a `complete` announce to the trackers.\n   * @param {Object} opts\n   * @param {number=} opts.uploaded\n   * @param {number=} opts.downloaded\n   * @param {number=} opts.numwant\n   * @param {number=} opts.left (if not set, calculated automatically)\n   */\n  complete (opts) {\n    if (!opts) opts = {}\n    opts = this._defaultAnnounceOpts(opts)\n    opts.event = 'completed'\n    debug('send `complete` %o', opts)\n    this._announce(opts)\n  }\n\n  /**\n   * Send a `update` announce to the trackers.\n   * @param {Object} opts\n   * @param {number=} opts.uploaded\n   * @param {number=} opts.downloaded\n   * @param {number=} opts.numwant\n   * @param {number=} opts.left (if not set, calculated automatically)\n   */\n  update (opts) {\n    opts = this._defaultAnnounceOpts(opts)\n    if (opts.event) delete opts.event\n    debug('send `update` %o', opts)\n    this._announce(opts)\n  }\n\n  _announce (opts) {\n    this._trackers.forEach(tracker => {\n      // tracker should not modify `opts` object, it's passed to all trackers\n      tracker.announce(opts)\n    })\n  }\n\n  /**\n   * Send a scrape request to the trackers.\n   * @param {Object} opts\n   */\n  scrape (opts) {\n    debug('send `scrape`')\n    if (!opts) opts = {}\n    this._trackers.forEach(tracker => {\n      // tracker should not modify `opts` object, it's passed to all trackers\n      tracker.scrape(opts)\n    })\n  }\n\n  setInterval (intervalMs) {\n    debug('setInterval %d', intervalMs)\n    this._trackers.forEach(tracker => {\n      tracker.setInterval(intervalMs)\n    })\n  }\n\n  destroy (cb) {\n    if (this.destroyed) return\n    this.destroyed = true\n    debug('destroy')\n\n    const tasks = this._trackers.map(tracker => cb => {\n      tracker.destroy(cb)\n    })\n\n    parallel(tasks, cb)\n\n    this._trackers = []\n    this._getAnnounceOpts = null\n  }\n\n  _defaultAnnounceOpts (opts = {}) {\n    if (opts.numwant == null) opts.numwant = common.DEFAULT_ANNOUNCE_PEERS\n\n    if (opts.uploaded == null) opts.uploaded = 0\n    if (opts.downloaded == null) opts.downloaded = 0\n\n    if (this._getAnnounceOpts) opts = Object.assign({}, opts, this._getAnnounceOpts())\n\n    return opts\n  }\n}\n\n/**\n * Simple convenience function to scrape a tracker for an info hash without needing to\n * create a Client, pass it a parsed torrent, etc. Support scraping a tracker for multiple\n * torrents at the same time.\n * @params {Object} opts\n * @param  {string|Array.<string>} opts.infoHash\n * @param  {string} opts.announce\n * @param  {function} cb\n */\nClient.scrape = (opts, cb) => {\n  cb = once(cb)\n\n  if (!opts.infoHash) throw new Error('Option `infoHash` is required')\n  if (!opts.announce) throw new Error('Option `announce` is required')\n\n  const clientOpts = Object.assign({}, opts, {\n    infoHash: Array.isArray(opts.infoHash) ? opts.infoHash[0] : opts.infoHash,\n    peerId: text2arr('01234567890123456789'), // dummy value\n    port: 6881 // dummy value\n  })\n\n  const client = new Client(clientOpts)\n  client.once('error', cb)\n  client.once('warning', cb)\n\n  let len = Array.isArray(opts.infoHash) ? opts.infoHash.length : 1\n  const results = {}\n  client.on('scrape', data => {\n    len -= 1\n    results[data.infoHash] = data\n    if (len === 0) {\n      client.destroy()\n      const keys = Object.keys(results)\n      if (keys.length === 1) {\n        cb(null, results[keys[0]])\n      } else {\n        cb(null, results)\n      }\n    }\n  })\n\n  client.scrape({ infoHash: opts.infoHash })\n  return client\n}\n\nexport default Client\n","function FF(a, b, c, d, m, s, k) {\n\tvar n = a + (b & c | ~b & d) + (m >>> 0) + k;\n\treturn ((n << s) | (n >>> (32 - s))) + b;\n}\n\nfunction GG(a, b, c, d, m, s, k) {\n\tvar n = a + (b & d | c & ~d) + (m >>> 0) + k;\n\treturn ((n << s) | (n >>> (32 - s))) + b;\n}\n\nfunction HH(a, b, c, d, m, s, k) {\n\tvar n = a + (b ^ c ^ d) + (m >>> 0) + k;\n\treturn ((n << s) | (n >>> (32 - s))) + b;\n}\n\nfunction II(a, b, c, d, m, s, k) {\n\tvar n = a + (c ^ (b | ~d)) + (m >>> 0) + k;\n\treturn ((n << s) | (n >>> (32 - s))) + b;\n}\n\n\nfunction byteToHex(byte) {\n\treturn (256+(byte&255)).toString(16).substr(-2);\n}\n\n\nfunction bs(byte) {\n\treturn String.fromCharCode(byte & 255);\n}\n\nfunction wordToBytes(word) {\n\treturn bs(word) + bs(word >>> 8) + bs(word >>> 16) + bs(word >>> 24);\n}\n\n\n// converts utf8 string to bytes string\nvar utf8toBytes = function (utf8) {\n\treturn unescape(encodeURIComponent(utf8));\n};\n\n\n// converts bytes string to 32-bits words array padded with \"1\" and zeros and bits_length for MD5 message buffer\nfunction bytesToWords(bytes) {\n\tvar bytes_count = bytes.length,\n\t    bits_count = bytes_count << 3,\n\t    words = new Uint32Array((bytes_count + 72) >>> 6 << 4);\n\tfor (var i = 0, n = bytes.length; i < n; ++i)\n\t\twords[i >>> 2] |= bytes.charCodeAt(i) << ((i & 3) << 3);\n\twords[bytes_count >> 2] |= 0x80 << (bits_count & 31); // append \"1\" bit to message\n\twords[words.length - 2] = bits_count;\n\treturn words;\n}\n\n\nvar exports = module.exports = function md5(utf8) {\n\treturn utf8toMD5(utf8).toHex();\n};\n\nvar bytesToMD5 = exports.fromBytes = function (bytes) {\n\tvar words = bytesToWords(bytes),\n\t    a = 0x67452301,\n\t    b = 0xEFCDAB89,\n\t    c = 0x98BADCFE,\n\t    d = 0x10325476,\n\t    S11 = 7, S12 = 12, S13 = 17, S14 = 22,\n\t    S21 = 5, S22 = 9 , S23 = 14, S24 = 20,\n\t    S31 = 4, S32 = 11, S33 = 16, S34 = 23,\n\t    S41 = 6, S42 = 10, S43 = 15, S44 = 21;\n\n\tfor (var i = 0, ws = words.length; i < ws; i += 16) {\n\t\tvar AA = a, BB = b, CC = c, DD = d;\n\t\ta = FF(a, b, c, d, words[i+0], S11, 0xD76AA478);\n\t\td = FF(d, a, b, c, words[i+1], S12, 0xE8C7B756);\n\t\tc = FF(c, d, a, b, words[i+2], S13, 0x242070DB);\n\t\tb = FF(b, c, d, a, words[i+3], S14, 0xC1BDCEEE);\n\t\ta = FF(a, b, c, d, words[i+4], S11, 0xF57C0FAF);\n\t\td = FF(d, a, b, c, words[i+5], S12, 0x4787C62A);\n\t\tc = FF(c, d, a, b, words[i+6], S13, 0xA8304613);\n\t\tb = FF(b, c, d, a, words[i+7], S14, 0xFD469501);\n\t\ta = FF(a, b, c, d, words[i+8], S11, 0x698098D8);\n\t\td = FF(d, a, b, c, words[i+9], S12, 0x8B44F7AF);\n\t\tc = FF(c, d, a, b, words[i+10],S13, 0xFFFF5BB1);\n\t\tb = FF(b, c, d, a, words[i+11],S14, 0x895CD7BE);\n\t\ta = FF(a, b, c, d, words[i+12],S11, 0x6B901122);\n\t\td = FF(d, a, b, c, words[i+13],S12, 0xFD987193);\n\t\tc = FF(c, d, a, b, words[i+14],S13, 0xA679438E);\n\t\tb = FF(b, c, d, a, words[i+15],S14, 0x49B40821);\n\t\ta = GG(a, b, c, d, words[i+1], S21, 0xF61E2562);\n\t\td = GG(d, a, b, c, words[i+6], S22, 0xC040B340);\n\t\tc = GG(c, d, a, b, words[i+11],S23, 0x265E5A51);\n\t\tb = GG(b, c, d, a, words[i+0], S24, 0xE9B6C7AA);\n\t\ta = GG(a, b, c, d, words[i+5], S21, 0xD62F105D);\n\t\td = GG(d, a, b, c, words[i+10],S22, 0x2441453);\n\t\tc = GG(c, d, a, b, words[i+15],S23, 0xD8A1E681);\n\t\tb = GG(b, c, d, a, words[i+4], S24, 0xE7D3FBC8);\n\t\ta = GG(a, b, c, d, words[i+9], S21, 0x21E1CDE6);\n\t\td = GG(d, a, b, c, words[i+14],S22, 0xC33707D6);\n\t\tc = GG(c, d, a, b, words[i+3], S23, 0xF4D50D87);\n\t\tb = GG(b, c, d, a, words[i+8], S24, 0x455A14ED);\n\t\ta = GG(a, b, c, d, words[i+13],S21, 0xA9E3E905);\n\t\td = GG(d, a, b, c, words[i+2], S22, 0xFCEFA3F8);\n\t\tc = GG(c, d, a, b, words[i+7], S23, 0x676F02D9);\n\t\tb = GG(b, c, d, a, words[i+12],S24, 0x8D2A4C8A);\n\t\ta = HH(a, b, c, d, words[i+5], S31, 0xFFFA3942);\n\t\td = HH(d, a, b, c, words[i+8], S32, 0x8771F681);\n\t\tc = HH(c, d, a, b, words[i+11],S33, 0x6D9D6122);\n\t\tb = HH(b, c, d, a, words[i+14],S34, 0xFDE5380C);\n\t\ta = HH(a, b, c, d, words[i+1], S31, 0xA4BEEA44);\n\t\td = HH(d, a, b, c, words[i+4], S32, 0x4BDECFA9);\n\t\tc = HH(c, d, a, b, words[i+7], S33, 0xF6BB4B60);\n\t\tb = HH(b, c, d, a, words[i+10],S34, 0xBEBFBC70);\n\t\ta = HH(a, b, c, d, words[i+13],S31, 0x289B7EC6);\n\t\td = HH(d, a, b, c, words[i+0], S32, 0xEAA127FA);\n\t\tc = HH(c, d, a, b, words[i+3], S33, 0xD4EF3085);\n\t\tb = HH(b, c, d, a, words[i+6], S34, 0x4881D05);\n\t\ta = HH(a, b, c, d, words[i+9], S31, 0xD9D4D039);\n\t\td = HH(d, a, b, c, words[i+12],S32, 0xE6DB99E5);\n\t\tc = HH(c, d, a, b, words[i+15],S33, 0x1FA27CF8);\n\t\tb = HH(b, c, d, a, words[i+2], S34, 0xC4AC5665);\n\t\ta = II(a, b, c, d, words[i+0], S41, 0xF4292244);\n\t\td = II(d, a, b, c, words[i+7], S42, 0x432AFF97);\n\t\tc = II(c, d, a, b, words[i+14],S43, 0xAB9423A7);\n\t\tb = II(b, c, d, a, words[i+5], S44, 0xFC93A039);\n\t\ta = II(a, b, c, d, words[i+12],S41, 0x655B59C3);\n\t\td = II(d, a, b, c, words[i+3], S42, 0x8F0CCC92);\n\t\tc = II(c, d, a, b, words[i+10],S43, 0xFFEFF47D);\n\t\tb = II(b, c, d, a, words[i+1], S44, 0x85845DD1);\n\t\ta = II(a, b, c, d, words[i+8], S41, 0x6FA87E4F);\n\t\td = II(d, a, b, c, words[i+15],S42, 0xFE2CE6E0);\n\t\tc = II(c, d, a, b, words[i+6], S43, 0xA3014314);\n\t\tb = II(b, c, d, a, words[i+13],S44, 0x4E0811A1);\n\t\ta = II(a, b, c, d, words[i+4], S41, 0xF7537E82);\n\t\td = II(d, a, b, c, words[i+11],S42, 0xBD3AF235);\n\t\tc = II(c, d, a, b, words[i+2], S43, 0x2AD7D2BB);\n\t\tb = II(b, c, d, a, words[i+9], S44, 0xEB86D391);\n\t\ta = (a + AA) >>> 0;\n\t\tb = (b + BB) >>> 0;\n\t\tc = (c + CC) >>> 0;\n\t\td = (d + DD) >>> 0;\n\t}\n\n\tvar hash_bytes = new String(wordToBytes(a) + wordToBytes(b) + wordToBytes(c) + wordToBytes(d));\n\thash_bytes.toHex = function () {\n\t\tvar hex = '';\n\t\tfor (var i = 0, n = hash_bytes.length; i < n; ++i)\n\t\t\thex += byteToHex(hash_bytes.charCodeAt(i));\n\t\treturn hex;\n\t};\n\treturn hash_bytes;\n};\n\n\nvar utf8toMD5 = exports.fromUtf8 = function (utf8) {\n\treturn bytesToMD5(utf8toBytes(utf8));\n};\n\n\n\nvar b64 = './0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';\n\nfunction to64(u, n) {\n\tfor (var s = ''; --n >= 0; u >>>= 6)\n\t\ts += b64.charAt(u & 63);\n\treturn s;\n}\n\n\nvar MAX_KEY_LENGTH = 64,\n    b64_map = [ 0,6,12, 1,7,13, 2,8,14, 3,9,15, 4,10,5, 11 ];\n\n\nvar gen_salt = exports.salt = function (n) {\n\tvar s = '';\n\tif (!n)\n\t\tn = 8;\n\tdo {\n\t\ts += b64.charAt( 64*Math.random() >>> 0 );\n\t} while (--n);\n\treturn s;\n};\n\n\nexports.crypt = function (key, setting) {\n\n\tif (key.length > MAX_KEY_LENGTH)\n\t\tthrow Error(\"too long key\");\n\n\tif (!setting)\n\t\tsetting = '$1$'+gen_salt();\n\n\tkey = utf8toBytes(key);\n\n\tvar salt = utf8toBytes(setting.replace(/^\\$1\\$([^$]+)(?:\\$.*)?$/, '$1')),\n\t    md = bytesToMD5(key + salt + key),\n\t    s = key + '$1$' + salt;\n\n\tfor (var kl = key.length; kl > 16; kl -= 16)\n\t\ts += md;\n\n\ts += md.slice(0, kl);\n\n\tfor (var kl = key.length; kl; kl >>= 1)\n\t\ts += kl & 1 ? \"\\0\" : key.charAt(0);\n\n\tmd = bytesToMD5(s);\n\n\tfor (var i = 0; i < 1000; ++i)\n\t\tmd = bytesToMD5((i & 1 ? key : md) + (i % 3 ? salt : '') + (i % 7 ? key : '') + (i & 1 ? md : key));\n\n\tvar h = '$1$'+salt+'$';\n\n\tfor (var i = 0; i < 15; i += 3)\n\t\th += to64(\n\t\t\tmd.charCodeAt(b64_map[i+0]) << 16 |\n\t\t\tmd.charCodeAt(b64_map[i+1]) << 8 |\n\t\t\tmd.charCodeAt(b64_map[i+2]), 4);\n\n\treturn h + to64(md.charCodeAt(b64_map[15]), 2);\n};\n","import md5 from \"nano-md5\";\nimport { PACKAGE_VERSION } from \"./version.js\";\n\nexport const TRACKER_CLIENT_VERSION_PREFIX = `-PM${formatVersion(PACKAGE_VERSION)}-`;\n\nconst HASH_SYMBOLS =\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\nconst PEER_ID_LENGTH = 20;\n\nexport function getStreamHash(streamId: string): string {\n  // slice one byte to have 15 bytes binary string\n  const binary15BytesHashString = md5.fromUtf8(streamId).slice(1);\n  const base64Hash20CharsString = btoa(binary15BytesHashString);\n  return base64Hash20CharsString;\n}\n\nexport function generatePeerId(trackerClientVersionPrefix: string): string {\n  const trackerClientId = [trackerClientVersionPrefix];\n  const randomCharsCount = PEER_ID_LENGTH - trackerClientVersionPrefix.length;\n\n  for (let i = 0; i < randomCharsCount; i++) {\n    trackerClientId.push(\n      HASH_SYMBOLS[Math.floor(Math.random() * HASH_SYMBOLS.length)],\n    );\n  }\n\n  return trackerClientId.join(\"\");\n}\n\nfunction formatVersion(versionString: string) {\n  const splittedVersion = versionString.split(\".\");\n\n  return `${splittedVersion[0].padStart(2, \"0\")}${splittedVersion[1].padStart(2, \"0\")}`;\n}\n","export const PACKAGE_VERSION = \"2.2.2\";\n","import { SegmentWithStream, Stream } from \"../types.js\";\nimport { SegmentPlaybackStatuses } from \"./stream.js\";\n\nexport function getStreamString(stream: Stream) {\n  return `${stream.type}-${stream.index}`;\n}\n\nexport function getSegmentString(segment: SegmentWithStream) {\n  const { externalId } = segment;\n  return `(${getStreamString(segment.stream)} | ${externalId})`;\n}\n\nexport function getSegmentPlaybackStatusesString(\n  statuses: SegmentPlaybackStatuses,\n): string {\n  const { isHighDemand, isHttpDownloadable, isP2PDownloadable } = statuses;\n  if (isHighDemand) return \"high-demand\";\n  if (isHttpDownloadable && isP2PDownloadable) return \"http-p2p-window\";\n  if (isHttpDownloadable) return \"http-window\";\n  if (isP2PDownloadable) return \"p2p-window\";\n  return \"-\";\n}\n","import { CommonCoreConfig, CoreConfig, StreamConfig } from \"../types.js\";\n\nexport function getControlledPromise<T = void>() {\n  let resolve: (value: T) => void;\n  let reject: (reason?: unknown) => void;\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return {\n    promise,\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    resolve: resolve!,\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    reject: reject!,\n  };\n}\n\nexport function joinChunks(chunks: Uint8Array[], totalBytes?: number) {\n  totalBytes ??= chunks.reduce((sum, chunk) => sum + chunk.byteLength, 0);\n\n  const buffer = new Uint8Array(totalBytes);\n  let offset = 0;\n  for (const chunk of chunks) {\n    buffer.set(chunk, offset);\n    offset += chunk.byteLength;\n  }\n\n  return buffer;\n}\n\nexport function getPercent(numerator: number, denominator: number): number {\n  return (numerator / denominator) * 100;\n}\n\nexport function getRandomItem<T>(items: T[]): T {\n  return items[Math.floor(Math.random() * items.length)];\n}\n\nexport function utf8ToUintArray(utf8String: string): Uint8Array {\n  const encoder = new TextEncoder();\n  const bytes = new Uint8Array(utf8String.length);\n  encoder.encodeInto(utf8String, bytes);\n  return bytes;\n}\n\nexport function hexToUtf8(hexString: string) {\n  const bytes = new Uint8Array(hexString.length / 2);\n\n  for (let i = 0; i < hexString.length; i += 2) {\n    bytes[i / 2] = parseInt(hexString.slice(i, i + 2), 16);\n  }\n  const decoder = new TextDecoder();\n  return decoder.decode(bytes);\n}\n\nexport function* arrayBackwards<T>(arr: T[]) {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    yield arr[i];\n  }\n}\n\nfunction isObject(item: unknown): item is Record<string, unknown> {\n  return !!item && typeof item === \"object\" && !Array.isArray(item);\n}\n\nfunction isArray(item: unknown): item is unknown[] {\n  return Array.isArray(item);\n}\n\nexport function filterUndefinedProps<T extends object>(obj: T): Partial<T> {\n  function filter(obj: unknown): unknown {\n    if (isObject(obj)) {\n      const result: Record<string, unknown> = {};\n      Object.keys(obj).forEach((key) => {\n        if (obj[key] !== undefined) {\n          const value = filter(obj[key]);\n          if (value !== undefined) {\n            result[key] = value;\n          }\n        }\n      });\n      return result;\n    } else {\n      return obj;\n    }\n  }\n\n  return filter(obj) as Partial<T>;\n}\n\nexport function deepCopy<T>(item: T): T {\n  if (isArray(item)) {\n    return item.map((element) => deepCopy(element)) as T;\n  } else if (isObject(item)) {\n    const copy = {} as Record<string, unknown>;\n    for (const key of Object.keys(item)) {\n      copy[key] = deepCopy(item[key]);\n    }\n    return copy as T;\n  } else {\n    return item;\n  }\n}\n\nexport function shuffleArray<T>(array: T[]): T[] {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n  return array;\n}\n\ntype RecursivePartial<T> = {\n  [P in keyof T]?: T[P] extends object ? RecursivePartial<T[P]> : T[P];\n};\n\nexport function overrideConfig<T>(\n  target: T,\n  updates: RecursivePartial<T> | null,\n  defaults: RecursivePartial<T> = {} as RecursivePartial<T>,\n): T {\n  if (\n    typeof target !== \"object\" ||\n    target === null ||\n    typeof updates !== \"object\" ||\n    updates === null\n  ) {\n    return target;\n  }\n\n  (Object.keys(updates) as (keyof T)[]).forEach((key) => {\n    const keyStr = typeof key === \"symbol\" ? key.toString() : String(key);\n    if (key === \"__proto__\" || key === \"constructor\" || key === \"prototype\") {\n      throw new Error(`Attempt to modify restricted property '${keyStr}'`);\n    }\n\n    const updateValue = updates[key];\n    const defaultValue = defaults[key];\n\n    if (key in target) {\n      if (updateValue === undefined) {\n        target[key] =\n          defaultValue === undefined\n            ? (undefined as (T & object)[keyof T])\n            : (defaultValue as (T & object)[keyof T]);\n      } else {\n        target[key] = updateValue as (T & object)[keyof T];\n      }\n    }\n  });\n\n  return target;\n}\n\ntype MergeConfigsToTypeOptions = {\n  defaultConfig: StreamConfig | CommonCoreConfig | CoreConfig;\n  baseConfig?: Partial<CoreConfig>;\n  specificStreamConfig?: Partial<StreamConfig>;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-unnecessary-type-parameters\nexport function mergeAndFilterConfig<T>(options: MergeConfigsToTypeOptions) {\n  const { defaultConfig, baseConfig = {}, specificStreamConfig = {} } = options;\n\n  const mergedConfig = deepCopy({\n    ...defaultConfig,\n    ...baseConfig,\n    ...specificStreamConfig,\n  });\n\n  const keysOfT = Object.keys(defaultConfig) as (keyof T)[];\n  const filteredConfig: Partial<T> = {};\n\n  keysOfT.forEach((key) => {\n    if (key in mergedConfig) {\n      filteredConfig[key] = mergedConfig[\n        key as keyof typeof mergedConfig\n      ] as T[keyof T];\n    }\n  });\n\n  return filteredConfig as T;\n}\n","type BasePeerCommand<T extends PeerCommandType = PeerCommandType> = {\n  c: T;\n};\n\nexport const enum PeerCommandType {\n  SegmentsAnnouncement,\n  SegmentRequest,\n  SegmentData,\n  SegmentDataSendingCompleted,\n  SegmentAbsent,\n  CancelSegmentRequest,\n}\n\nexport type PeerSegmentCommand = BasePeerCommand<\n  | PeerCommandType.SegmentAbsent\n  | PeerCommandType.CancelSegmentRequest\n  | PeerCommandType.SegmentDataSendingCompleted\n> & {\n  i: number; // segment id\n  r: number; // request id\n};\n\nexport type PeerRequestSegmentCommand =\n  BasePeerCommand<PeerCommandType.SegmentRequest> & {\n    i: number; // segment id\n    r: number; // request id\n    b?: number; // byte from\n  };\n\nexport type PeerSegmentAnnouncementCommand =\n  BasePeerCommand<PeerCommandType.SegmentsAnnouncement> & {\n    l?: number[]; // loaded segments\n    p?: number[]; // segments loading by http\n  };\n\nexport type PeerSendSegmentCommand =\n  BasePeerCommand<PeerCommandType.SegmentData> & {\n    i: number; // segment id\n    r: number; // request id\n    s: number; // size in bytes\n  };\n\nexport type PeerCommand =\n  | PeerSegmentCommand\n  | PeerRequestSegmentCommand\n  | PeerSegmentAnnouncementCommand\n  | PeerSendSegmentCommand;\n","import { joinChunks } from \"../../utils/utils.js\";\n\n// restricted up to 16 item types (4 bits to type definition)\nexport const enum SerializedItem {\n  Min = -1,\n  Int,\n  SimilarIntArray,\n  String,\n  Max,\n}\n\nfunction abs(num: bigint): bigint {\n  return num < 0 ? -num : num;\n}\n\nfunction getRequiredBytesForInt(num: bigint): number {\n  const binaryString = num.toString(2);\n  const necessaryBits = num < 0 ? binaryString.length : binaryString.length + 1;\n  return Math.ceil(necessaryBits / 8);\n}\n\nfunction intToBytes(num: bigint): Uint8Array {\n  const isNegative = num < 0;\n  const bytesAmountNumber = getRequiredBytesForInt(num);\n  const bytes = new Uint8Array(bytesAmountNumber);\n  const bytesAmount = BigInt(bytesAmountNumber);\n\n  num = abs(num);\n  for (let i = 0; i < bytesAmountNumber; i++) {\n    const shift = 8n * (bytesAmount - 1n - BigInt(i));\n    const byte = (num >> shift) & 0xffn;\n    bytes[i] = Number(byte);\n  }\n\n  if (isNegative) bytes[0] = bytes[0] | 0b10000000;\n  return bytes;\n}\n\nfunction bytesToInt(bytes: Uint8Array): bigint {\n  const byteLength = BigInt(bytes.length);\n  const getNumberPart = (byte: number, i: number): bigint => {\n    const shift = 8n * (byteLength - 1n - BigInt(i));\n    return BigInt(byte) << shift;\n  };\n\n  // ignore first bit of first byte as it is sign bit\n  let number = getNumberPart(bytes[0] & 0b01111111, 0);\n  for (let i = 1; i < byteLength; i++) {\n    number = getNumberPart(bytes[i], i) | number;\n  }\n  if ((bytes[0] & 0b10000000) >> 7 !== 0) number = -number;\n\n  return number;\n}\n\nexport function serializeInt(num: bigint): Uint8Array {\n  const numBytes = intToBytes(num);\n  const numberMetadata = (SerializedItem.Int << 4) | numBytes.length;\n  return new Uint8Array([numberMetadata, ...numBytes]);\n}\n\nexport function deserializeInt(bytes: Uint8Array) {\n  const metadata = bytes[0];\n  const code: SerializedItem = metadata >> 4;\n  if (code !== SerializedItem.Int) {\n    throw new Error(\n      \"Trying to deserialize integer with invalid serialized item code\",\n    );\n  }\n  const numberBytesLength = metadata & 0b1111;\n  const start = 1;\n  const end = start + numberBytesLength;\n  return {\n    number: bytesToInt(bytes.slice(start, end)),\n    byteLength: numberBytesLength + 1,\n  };\n}\n\nexport function serializeSimilarIntArray(numbers: bigint[]) {\n  const commonPartNumbersMap = new Map<bigint, ResizableUint8Array>();\n\n  for (const number of numbers) {\n    const common = number & ~0xffn;\n    const diffByte = number & 0xffn;\n    const bytes = commonPartNumbersMap.get(common) ?? new ResizableUint8Array();\n    if (!bytes.length) commonPartNumbersMap.set(common, bytes);\n    bytes.push(Number(diffByte));\n  }\n\n  const result = new ResizableUint8Array();\n  result.push([SerializedItem.SimilarIntArray << 4, commonPartNumbersMap.size]);\n\n  for (const [commonPart, binaryArray] of commonPartNumbersMap) {\n    const { length } = binaryArray.getBytesChunks();\n    const commonPartWithLength = commonPart | (BigInt(length) & 0xffn);\n    binaryArray.unshift(serializeInt(commonPartWithLength));\n    result.push(binaryArray.getBuffer());\n  }\n\n  return result.getBuffer();\n}\n\nexport function deserializeSimilarIntArray(bytes: Uint8Array) {\n  const [codeByte, commonPartArraysAmount] = bytes;\n  const code: SerializedItem = codeByte >> 4;\n  if (code !== SerializedItem.SimilarIntArray) {\n    throw new Error(\n      \"Trying to deserialize similar int array with invalid serialized item code\",\n    );\n  }\n\n  let offset = 2;\n  const originalIntArr: bigint[] = [];\n  for (let i = 0; i < commonPartArraysAmount; i++) {\n    const { number: commonPartWithLength, byteLength } = deserializeInt(\n      bytes.slice(offset),\n    );\n    offset += byteLength;\n    const arrayLength = commonPartWithLength & 0xffn;\n    const commonPart = commonPartWithLength & ~0xffn;\n\n    for (let j = 0; j < arrayLength; j++) {\n      const diffPart = BigInt(bytes[offset]);\n      originalIntArr.push(commonPart | diffPart);\n      offset++;\n    }\n  }\n\n  return { numbers: originalIntArr, byteLength: offset };\n}\n\nexport function serializeString(string: string) {\n  const { length } = string;\n  const bytes = new ResizableUint8Array();\n  bytes.push([\n    (SerializedItem.String << 4) | ((length >> 8) & 0x0f),\n    length & 0xff,\n  ]);\n  bytes.push(new TextEncoder().encode(string));\n  return bytes.getBuffer();\n}\n\nexport function deserializeString(bytes: Uint8Array) {\n  const [codeByte, lengthByte] = bytes;\n  const code: SerializedItem = codeByte >> 4;\n  if (code !== SerializedItem.String) {\n    throw new Error(\n      \"Trying to deserialize bytes (sting) with invalid serialized item code.\",\n    );\n  }\n  const length = ((codeByte & 0x0f) << 8) | lengthByte;\n  const stringBytes = bytes.slice(2, length + 2);\n  const string = new TextDecoder(\"utf8\").decode(stringBytes);\n  return { string, byteLength: length + 2 };\n}\n\nexport class ResizableUint8Array {\n  private bytes: Uint8Array[] = [];\n  private _length = 0;\n\n  push(bytes: Uint8Array | number | number[]) {\n    this.addBytes(bytes, \"end\");\n  }\n\n  unshift(bytes: Uint8Array | number | number[]) {\n    this.addBytes(bytes, \"start\");\n  }\n\n  private addBytes(\n    bytes: Uint8Array | number | number[],\n    position: \"start\" | \"end\",\n  ) {\n    let bytesToAdd: Uint8Array;\n    if (bytes instanceof Uint8Array) {\n      bytesToAdd = bytes;\n    } else if (Array.isArray(bytes)) {\n      bytesToAdd = new Uint8Array(bytes);\n    } else {\n      bytesToAdd = new Uint8Array([bytes]);\n    }\n    this._length += bytesToAdd.length;\n    this.bytes[position === \"start\" ? \"unshift\" : \"push\"](bytesToAdd);\n  }\n\n  getBytesChunks(): readonly Uint8Array[] {\n    return this.bytes;\n  }\n\n  getBuffer(): Uint8Array {\n    return joinChunks(this.bytes, this._length);\n  }\n\n  get length() {\n    return this._length;\n  }\n}\n","import * as Serialization from \"./binary-serialization.js\";\nimport { PeerCommandType, PeerCommand } from \"./types.js\";\n\nconst FRAME_PART_LENGTH = 4;\nconst commandFrameStart = stringToUtf8CodesBuffer(\"cstr\", FRAME_PART_LENGTH);\nconst commandFrameEnd = stringToUtf8CodesBuffer(\"cend\", FRAME_PART_LENGTH);\nconst commandDivFrameStart = stringToUtf8CodesBuffer(\"dstr\", FRAME_PART_LENGTH);\nconst commandDivFrameEnd = stringToUtf8CodesBuffer(\"dend\", FRAME_PART_LENGTH);\nconst startFrames = [commandFrameStart, commandDivFrameStart];\nconst endFrames = [commandFrameEnd, commandDivFrameEnd];\nconst commandFramesLength = commandFrameStart.length + commandFrameEnd.length;\n\nexport function isCommandChunk(buffer: Uint8Array) {\n  const { length } = commandFrameStart;\n  const bufferEndingToCompare = buffer.slice(-length);\n  return (\n    startFrames.some((frame) =>\n      areBuffersEqual(buffer, frame, FRAME_PART_LENGTH),\n    ) &&\n    endFrames.some((frame) =>\n      areBuffersEqual(bufferEndingToCompare, frame, FRAME_PART_LENGTH),\n    )\n  );\n}\n\nfunction isFirstCommandChunk(buffer: Uint8Array) {\n  return areBuffersEqual(buffer, commandFrameStart, FRAME_PART_LENGTH);\n}\n\nfunction isLastCommandChunk(buffer: Uint8Array) {\n  return areBuffersEqual(\n    buffer.slice(-FRAME_PART_LENGTH),\n    commandFrameEnd,\n    FRAME_PART_LENGTH,\n  );\n}\n\nexport class BinaryCommandJoiningError extends Error {\n  constructor(readonly type: \"incomplete-joining\" | \"no-first-chunk\") {\n    super();\n  }\n}\n\nexport class BinaryCommandChunksJoiner {\n  private readonly chunks = new Serialization.ResizableUint8Array();\n  private status: \"joining\" | \"completed\" = \"joining\";\n\n  constructor(\n    private readonly onComplete: (commandBuffer: Uint8Array) => void,\n  ) {}\n\n  addCommandChunk(chunk: Uint8Array) {\n    if (this.status === \"completed\") return;\n\n    const isFirstChunk = isFirstCommandChunk(chunk);\n    if (!this.chunks.length && !isFirstChunk) {\n      throw new BinaryCommandJoiningError(\"no-first-chunk\");\n    }\n    if (this.chunks.length && isFirstChunk) {\n      throw new BinaryCommandJoiningError(\"incomplete-joining\");\n    }\n    this.chunks.push(this.unframeCommandChunk(chunk));\n\n    if (!isLastCommandChunk(chunk)) return;\n    this.status = \"completed\";\n    this.onComplete(this.chunks.getBuffer());\n  }\n\n  private unframeCommandChunk(chunk: Uint8Array) {\n    return chunk.slice(FRAME_PART_LENGTH, chunk.length - FRAME_PART_LENGTH);\n  }\n}\n\nexport class BinaryCommandCreator {\n  private readonly bytes = new Serialization.ResizableUint8Array();\n  private resultBuffers: Uint8Array[] = [];\n  private status: \"creating\" | \"completed\" = \"creating\";\n\n  constructor(\n    commandType: PeerCommandType,\n    private readonly maxChunkLength: number,\n  ) {\n    this.bytes.push(commandType);\n  }\n\n  addInteger(name: string, value: number) {\n    this.bytes.push(name.charCodeAt(0));\n    const bytes = Serialization.serializeInt(BigInt(value));\n    this.bytes.push(bytes);\n  }\n\n  addSimilarIntArr(name: string, arr: number[]) {\n    this.bytes.push(name.charCodeAt(0));\n    const bytes = Serialization.serializeSimilarIntArray(\n      arr.map((num) => BigInt(num)),\n    );\n    this.bytes.push(bytes);\n  }\n\n  addString(name: string, string: string) {\n    this.bytes.push(name.charCodeAt(0));\n    const bytes = Serialization.serializeString(string);\n    this.bytes.push(bytes);\n  }\n\n  complete() {\n    if (!this.bytes.length) throw new Error(\"Buffer is empty\");\n    if (this.status === \"completed\") return;\n    this.status = \"completed\";\n\n    const unframedBuffer = this.bytes.getBuffer();\n    if (unframedBuffer.length + commandFramesLength <= this.maxChunkLength) {\n      this.resultBuffers.push(\n        frameBuffer(unframedBuffer, commandFrameStart, commandFrameEnd),\n      );\n      return;\n    }\n\n    let chunksCount = Math.ceil(unframedBuffer.length / this.maxChunkLength);\n    if (\n      Math.ceil(unframedBuffer.length / chunksCount) + commandFramesLength >\n      this.maxChunkLength\n    ) {\n      chunksCount++;\n    }\n\n    for (const [i, chunk] of splitBufferToEqualChunks(\n      unframedBuffer,\n      chunksCount,\n    )) {\n      if (i === 0) {\n        this.resultBuffers.push(\n          frameBuffer(chunk, commandFrameStart, commandDivFrameEnd),\n        );\n      } else if (i === chunksCount - 1) {\n        this.resultBuffers.push(\n          frameBuffer(chunk, commandDivFrameStart, commandFrameEnd),\n        );\n      } else {\n        this.resultBuffers.push(\n          frameBuffer(chunk, commandDivFrameStart, commandDivFrameEnd),\n        );\n      }\n    }\n  }\n\n  getResultBuffers(): Uint8Array[] {\n    if (this.status === \"creating\" || !this.resultBuffers.length) {\n      throw new Error(\"Command is not complete.\");\n    }\n    return this.resultBuffers;\n  }\n}\n\nexport function deserializeCommand(bytes: Uint8Array): PeerCommand {\n  const [commandCode] = bytes;\n  const deserializedCommand: Record<string, unknown> = {\n    c: commandCode,\n  };\n\n  let offset = 1;\n  while (offset < bytes.length) {\n    const name = String.fromCharCode(bytes[offset]);\n    offset++;\n    const dataType = getDataTypeFromByte(bytes[offset]);\n\n    switch (dataType) {\n      case Serialization.SerializedItem.Int:\n        {\n          const { number, byteLength } = Serialization.deserializeInt(\n            bytes.slice(offset),\n          );\n          deserializedCommand[name] = Number(number);\n          offset += byteLength;\n        }\n        break;\n      case Serialization.SerializedItem.SimilarIntArray:\n        {\n          const { numbers, byteLength } =\n            Serialization.deserializeSimilarIntArray(bytes.slice(offset));\n          deserializedCommand[name] = numbers.map((n) => Number(n));\n          offset += byteLength;\n        }\n        break;\n      case Serialization.SerializedItem.String:\n        {\n          const { string, byteLength } = Serialization.deserializeString(\n            bytes.slice(offset),\n          );\n          deserializedCommand[name] = string;\n          offset += byteLength;\n        }\n        break;\n    }\n  }\n  return deserializedCommand as unknown as PeerCommand;\n}\n\nfunction getDataTypeFromByte(byte: number): Serialization.SerializedItem {\n  const typeCode: Serialization.SerializedItem = byte >> 4;\n  if (\n    typeCode <= Serialization.SerializedItem.Min ||\n    typeCode >= Serialization.SerializedItem.Max\n  ) {\n    throw new Error(\"Not existing type\");\n  }\n\n  return typeCode;\n}\n\nfunction stringToUtf8CodesBuffer(string: string, length?: number): Uint8Array {\n  if (length && string.length !== length) {\n    throw new Error(\"Wrong string length\");\n  }\n  const buffer = new Uint8Array(length ?? string.length);\n  for (let i = 0; i < string.length; i++) buffer[i] = string.charCodeAt(i);\n  return buffer;\n}\n\nfunction* splitBufferToEqualChunks(\n  buffer: Uint8Array,\n  chunksCount: number,\n): Generator<[number, Uint8Array], void> {\n  const chunkLength = Math.ceil(buffer.length / chunksCount);\n  for (let i = 0; i < chunksCount; i++) {\n    yield [i, buffer.slice(i * chunkLength, (i + 1) * chunkLength)];\n  }\n}\n\nfunction frameBuffer(\n  buffer: Uint8Array,\n  frameStart: Uint8Array,\n  frameEnd: Uint8Array,\n) {\n  const result = new Uint8Array(\n    buffer.length + frameStart.length + frameEnd.length,\n  );\n  result.set(frameStart);\n  result.set(buffer, frameStart.length);\n  result.set(frameEnd, frameStart.length + buffer.length);\n\n  return result;\n}\n\nfunction areBuffersEqual(\n  buffer1: Uint8Array,\n  buffer2: Uint8Array,\n  length: number,\n) {\n  for (let i = 0; i < length; i++) {\n    if (buffer1[i] !== buffer2[i]) return false;\n  }\n  return true;\n}\n","import { BinaryCommandCreator } from \"./binary-command-creator.js\";\nimport {\n  PeerSegmentCommand,\n  PeerSendSegmentCommand,\n  PeerSegmentAnnouncementCommand,\n  PeerRequestSegmentCommand,\n  PeerCommand,\n  PeerCommandType,\n} from \"./types.js\";\n\nfunction serializeSegmentAnnouncementCommand(\n  command: PeerSegmentAnnouncementCommand,\n  maxChunkSize: number,\n) {\n  const { c: commandCode, p: loadingByHttp, l: loaded } = command;\n  const creator = new BinaryCommandCreator(commandCode, maxChunkSize);\n  if (loaded?.length) creator.addSimilarIntArr(\"l\", loaded);\n  if (loadingByHttp?.length) {\n    creator.addSimilarIntArr(\"p\", loadingByHttp);\n  }\n  creator.complete();\n  return creator.getResultBuffers();\n}\n\nfunction serializePeerSegmentCommand(\n  command: PeerSegmentCommand,\n  maxChunkSize: number,\n) {\n  const creator = new BinaryCommandCreator(command.c, maxChunkSize);\n  creator.addInteger(\"i\", command.i);\n  creator.addInteger(\"r\", command.r);\n  creator.complete();\n  return creator.getResultBuffers();\n}\n\nfunction serializePeerSendSegmentCommand(\n  command: PeerSendSegmentCommand,\n  maxChunkSize: number,\n) {\n  const creator = new BinaryCommandCreator(command.c, maxChunkSize);\n  creator.addInteger(\"i\", command.i);\n  creator.addInteger(\"s\", command.s);\n  creator.addInteger(\"r\", command.r);\n  creator.complete();\n  return creator.getResultBuffers();\n}\n\nfunction serializePeerSegmentRequestCommand(\n  command: PeerRequestSegmentCommand,\n  maxChunkSize: number,\n) {\n  const creator = new BinaryCommandCreator(command.c, maxChunkSize);\n  creator.addInteger(\"i\", command.i);\n  creator.addInteger(\"r\", command.r);\n  if (command.b) creator.addInteger(\"b\", command.b);\n  creator.complete();\n  return creator.getResultBuffers();\n}\n\nexport function serializePeerCommand(\n  command: PeerCommand,\n  maxChunkSize: number,\n) {\n  switch (command.c) {\n    case PeerCommandType.CancelSegmentRequest:\n    case PeerCommandType.SegmentAbsent:\n    case PeerCommandType.SegmentDataSendingCompleted:\n      return serializePeerSegmentCommand(command, maxChunkSize);\n    case PeerCommandType.SegmentRequest:\n      return serializePeerSegmentRequestCommand(command, maxChunkSize);\n    case PeerCommandType.SegmentsAnnouncement:\n      return serializeSegmentAnnouncementCommand(command, maxChunkSize);\n    case PeerCommandType.SegmentData:\n      return serializePeerSendSegmentCommand(command, maxChunkSize);\n  }\n}\n","import { PeerConnection } from \"bittorrent-tracker\";\nimport { CoreEventMap, StreamConfig } from \"../types.js\";\nimport * as Utils from \"../utils/utils.js\";\nimport * as Command from \"./commands/index.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\n\nexport type PeerConfig = Pick<\n  StreamConfig,\n  | \"p2pNotReceivingBytesTimeoutMs\"\n  | \"webRtcMaxMessageSize\"\n  | \"p2pErrorRetries\"\n  | \"validateP2PSegment\"\n>;\n\nexport class PeerProtocol {\n  private commandChunks?: Command.BinaryCommandChunksJoiner;\n  private uploadingContext?: { stopUploading: () => void; requestId: number };\n  private readonly onChunkDownloaded: CoreEventMap[\"onChunkDownloaded\"];\n  private readonly onChunkUploaded: CoreEventMap[\"onChunkUploaded\"];\n\n  constructor(\n    private readonly connection: PeerConnection,\n    private readonly peerConfig: PeerConfig,\n    private readonly eventHandlers: {\n      onCommandReceived: (command: Command.PeerCommand) => void;\n      onSegmentChunkReceived: (data: Uint8Array) => void;\n    },\n    eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    this.onChunkDownloaded =\n      eventTarget.getEventDispatcher(\"onChunkDownloaded\");\n    this.onChunkUploaded = eventTarget.getEventDispatcher(\"onChunkUploaded\");\n    connection.on(\"data\", this.onDataReceived);\n  }\n\n  private onDataReceived = (data: Uint8Array) => {\n    if (Command.isCommandChunk(data)) {\n      this.receivingCommandBytes(data);\n    } else {\n      this.eventHandlers.onSegmentChunkReceived(data);\n\n      this.onChunkDownloaded(data.byteLength, \"p2p\", this.connection.idUtf8);\n    }\n  };\n\n  sendCommand(command: Command.PeerCommand) {\n    const binaryCommandBuffers = Command.serializePeerCommand(\n      command,\n      this.peerConfig.webRtcMaxMessageSize,\n    );\n    for (const buffer of binaryCommandBuffers) {\n      this.connection.write(buffer);\n    }\n  }\n\n  stopUploadingSegmentData() {\n    this.uploadingContext?.stopUploading();\n    this.uploadingContext = undefined;\n  }\n\n  getUploadingRequestId() {\n    return this.uploadingContext?.requestId;\n  }\n\n  async splitSegmentDataToChunksAndUploadAsync(\n    data: ArrayBuffer,\n    requestId: number,\n  ) {\n    if (this.uploadingContext) {\n      throw new Error(`Some segment data is already uploading.`);\n    }\n    const chunks = getBufferChunks(data, this.peerConfig.webRtcMaxMessageSize);\n    const { promise, resolve, reject } = Utils.getControlledPromise();\n\n    let isUploadingSegmentData = false;\n\n    const uploadingContext = {\n      stopUploading: () => {\n        isUploadingSegmentData = false;\n      },\n      requestId,\n    };\n\n    this.uploadingContext = uploadingContext;\n\n    const sendChunk = () => {\n      if (!isUploadingSegmentData) {\n        reject();\n        return;\n      }\n\n      while (true) {\n        const chunk = chunks.next().value;\n\n        if (!chunk) {\n          resolve();\n          break;\n        }\n\n        const drained = this.connection.write(chunk);\n        this.onChunkUploaded(chunk.byteLength, this.connection.idUtf8);\n        if (!drained) break;\n      }\n    };\n\n    try {\n      this.connection.on(\"drain\", sendChunk);\n      isUploadingSegmentData = true;\n      sendChunk();\n      await promise;\n    } finally {\n      this.connection.off(\"drain\", sendChunk);\n\n      if (this.uploadingContext === uploadingContext) {\n        this.uploadingContext = undefined;\n      }\n    }\n  }\n\n  private receivingCommandBytes(buffer: Uint8Array) {\n    this.commandChunks ??= new Command.BinaryCommandChunksJoiner(\n      (commandBuffer) => {\n        this.commandChunks = undefined;\n        const command = Command.deserializeCommand(commandBuffer);\n        this.eventHandlers.onCommandReceived(command);\n      },\n    );\n    try {\n      this.commandChunks.addCommandChunk(buffer);\n    } catch (err) {\n      if (!(err instanceof Command.BinaryCommandJoiningError)) return;\n      this.commandChunks = undefined;\n    }\n  }\n}\n\nfunction* getBufferChunks(\n  data: ArrayBuffer,\n  maxChunkSize: number,\n): Generator<ArrayBuffer, void> {\n  let bytesLeft = data.byteLength;\n  while (bytesLeft > 0) {\n    const bytesToSend = bytesLeft >= maxChunkSize ? maxChunkSize : bytesLeft;\n    const from = data.byteLength - bytesLeft;\n    const buffer = data.slice(from, from + bytesToSend);\n    bytesLeft -= bytesToSend;\n    yield buffer;\n  }\n}\n","import { PeerConnection } from \"bittorrent-tracker\";\nimport debug from \"debug\";\nimport { Request, RequestControls } from \"../requests/request.js\";\nimport {\n  CoreEventMap,\n  PeerRequestErrorType,\n  RequestError,\n  RequestAbortErrorType,\n  SegmentWithStream,\n  StreamType,\n} from \"../types.js\";\nimport * as Utils from \"../utils/utils.js\";\nimport * as Command from \"./commands/index.js\";\nimport { PeerProtocol, PeerConfig } from \"./peer-protocol.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\n\nconst { PeerCommandType } = Command;\ntype PeerEventHandlers = {\n  onPeerClosed: (peer: Peer) => void;\n  onSegmentRequested: (\n    peer: Peer,\n    segmentId: number,\n    requestId: number,\n    byteFrom?: number,\n  ) => void;\n  onSegmentsAnnouncement: () => void;\n};\n\nexport class Peer {\n  readonly id: string;\n  private readonly peerProtocol;\n  private downloadingContext?: {\n    request: Request;\n    controls: RequestControls;\n    isSegmentDataCommandReceived: boolean;\n    requestId: number;\n  };\n  private loadedSegments = new Set<number>();\n  private httpLoadingSegments = new Set<number>();\n  private downloadingErrors: RequestError<\n    PeerRequestErrorType | RequestAbortErrorType\n  >[] = [];\n  private logger = debug(\"p2pml-core:peer\");\n  private readonly onPeerClosed: CoreEventMap[\"onPeerClose\"];\n\n  constructor(\n    private readonly connection: PeerConnection,\n    private readonly eventHandlers: PeerEventHandlers,\n    private readonly peerConfig: PeerConfig,\n    private readonly streamType: StreamType,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    this.onPeerClosed = eventTarget.getEventDispatcher(\"onPeerClose\");\n\n    this.id = Peer.getPeerIdFromConnection(connection);\n    this.peerProtocol = new PeerProtocol(\n      connection,\n      peerConfig,\n      {\n        onSegmentChunkReceived: this.onSegmentChunkReceived,\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        onCommandReceived: this.onCommandReceived,\n      },\n      eventTarget,\n    );\n    eventTarget.getEventDispatcher(\"onPeerConnect\")({\n      peerId: this.id,\n      streamType,\n    });\n\n    connection.on(\"error\", this.onConnectionError);\n    connection.on(\"close\", this.onPeerConnectionClosed);\n    connection.on(\"end\", this.onPeerConnectionClosed);\n    connection.on(\"finish\", this.onPeerConnectionClosed);\n  }\n\n  get downloadingSegment(): SegmentWithStream | undefined {\n    return this.downloadingContext?.request.segment;\n  }\n\n  getSegmentStatus(\n    segment: SegmentWithStream,\n  ): \"loaded\" | \"http-loading\" | undefined {\n    const { externalId } = segment;\n    if (this.loadedSegments.has(externalId)) return \"loaded\";\n    if (this.httpLoadingSegments.has(externalId)) return \"http-loading\";\n  }\n\n  private onCommandReceived = async (command: Command.PeerCommand) => {\n    switch (command.c) {\n      case PeerCommandType.SegmentsAnnouncement:\n        this.loadedSegments = new Set(command.l);\n        this.httpLoadingSegments = new Set(command.p);\n        this.eventHandlers.onSegmentsAnnouncement();\n        break;\n\n      case PeerCommandType.SegmentRequest:\n        this.peerProtocol.stopUploadingSegmentData();\n        this.eventHandlers.onSegmentRequested(\n          this,\n          command.i,\n          command.r,\n          command.b,\n        );\n        break;\n\n      case PeerCommandType.SegmentData:\n        {\n          if (!this.downloadingContext) break;\n          if (this.downloadingContext.isSegmentDataCommandReceived) break;\n\n          const { request, controls, requestId } = this.downloadingContext;\n          if (\n            request.segment.externalId !== command.i ||\n            requestId !== command.r\n          ) {\n            break;\n          }\n\n          this.downloadingContext.isSegmentDataCommandReceived = true;\n          controls.firstBytesReceived();\n\n          if (request.totalBytes === undefined) {\n            request.setTotalBytes(command.s);\n          } else if (request.totalBytes - request.loadedBytes !== command.s) {\n            request.clearLoadedBytes();\n            this.sendCancelSegmentRequestCommand(request.segment, requestId);\n            this.cancelSegmentDownloading(\n              \"peer-response-bytes-length-mismatch\",\n            );\n            this.destroy();\n          }\n        }\n        break;\n\n      case PeerCommandType.SegmentDataSendingCompleted: {\n        const { downloadingContext } = this;\n\n        if (!downloadingContext?.isSegmentDataCommandReceived) return;\n\n        const { request, controls } = downloadingContext;\n\n        const isWrongSegment =\n          downloadingContext.request.segment.externalId !== command.i ||\n          downloadingContext.requestId !== command.r;\n\n        if (isWrongSegment) {\n          request.clearLoadedBytes();\n          this.cancelSegmentDownloading(\"peer-protocol-violation\");\n          this.destroy();\n          return;\n        }\n\n        const isWrongBytes = request.loadedBytes !== request.totalBytes;\n\n        if (isWrongBytes) {\n          request.clearLoadedBytes();\n          this.cancelSegmentDownloading(\"peer-response-bytes-length-mismatch\");\n          this.destroy();\n          return;\n        }\n\n        const isValid =\n          (await this.peerConfig.validateP2PSegment?.(\n            request.segment.url,\n            request.segment.byteRange,\n            request.data,\n          )) ?? true;\n\n        if (this.downloadingContext !== downloadingContext) return;\n\n        if (!isValid) {\n          request.clearLoadedBytes();\n          this.cancelSegmentDownloading(\"p2p-segment-validation-failed\");\n          this.destroy();\n          return;\n        }\n\n        this.downloadingErrors = [];\n        controls.completeOnSuccess();\n        this.downloadingContext = undefined;\n        break;\n      }\n\n      case PeerCommandType.SegmentAbsent:\n        if (\n          this.downloadingContext?.request.segment.externalId === command.i &&\n          this.downloadingContext.requestId === command.r\n        ) {\n          this.cancelSegmentDownloading(\"peer-segment-absent\");\n          this.loadedSegments.delete(command.i);\n        }\n        break;\n\n      case PeerCommandType.CancelSegmentRequest: {\n        const uploadingRequestId = this.peerProtocol.getUploadingRequestId();\n\n        if (uploadingRequestId !== command.r) break;\n\n        this.peerProtocol.stopUploadingSegmentData();\n        break;\n      }\n    }\n  };\n\n  protected onSegmentChunkReceived = (chunk: Uint8Array) => {\n    if (!this.downloadingContext?.isSegmentDataCommandReceived) return;\n\n    const { request, controls } = this.downloadingContext;\n\n    const isOverflow =\n      request.totalBytes !== undefined &&\n      request.loadedBytes + chunk.byteLength > request.totalBytes;\n\n    if (isOverflow) {\n      request.clearLoadedBytes();\n      this.cancelSegmentDownloading(\"peer-response-bytes-length-mismatch\");\n      this.destroy();\n      return;\n    }\n\n    controls.addLoadedChunk(chunk);\n  };\n\n  downloadSegment(segmentRequest: Request) {\n    if (this.downloadingContext) {\n      throw new Error(\"Some segment already is downloading\");\n    }\n    this.downloadingContext = {\n      request: segmentRequest,\n      requestId: Math.floor(Math.random() * 1000),\n      isSegmentDataCommandReceived: false,\n      controls: segmentRequest.start(\n        { downloadSource: \"p2p\", peerId: this.id },\n        {\n          notReceivingBytesTimeoutMs:\n            this.peerConfig.p2pNotReceivingBytesTimeoutMs,\n          abort: (error) => {\n            if (!this.downloadingContext) return;\n            const { request, requestId } = this.downloadingContext;\n            this.sendCancelSegmentRequestCommand(request.segment, requestId);\n            this.downloadingErrors.push(error);\n            this.downloadingContext = undefined;\n\n            const timeoutErrors = this.downloadingErrors.filter(\n              (error) => error.type === \"bytes-receiving-timeout\",\n            );\n\n            if (timeoutErrors.length >= this.peerConfig.p2pErrorRetries) {\n              this.destroy();\n            }\n          },\n        },\n      ),\n    };\n    const command: Command.PeerRequestSegmentCommand = {\n      c: PeerCommandType.SegmentRequest,\n      r: this.downloadingContext.requestId,\n      i: segmentRequest.segment.externalId,\n    };\n    if (segmentRequest.loadedBytes) command.b = segmentRequest.loadedBytes;\n    this.peerProtocol.sendCommand(command);\n  }\n\n  async uploadSegmentData(\n    segment: SegmentWithStream,\n    requestId: number,\n    data: ArrayBuffer,\n  ) {\n    const { externalId } = segment;\n    this.logger(`send segment ${segment.externalId} to ${this.id}`);\n    const command: Command.PeerSendSegmentCommand = {\n      c: PeerCommandType.SegmentData,\n      i: externalId,\n      r: requestId,\n      s: data.byteLength,\n    };\n    this.peerProtocol.sendCommand(command);\n    try {\n      await this.peerProtocol.splitSegmentDataToChunksAndUploadAsync(\n        data,\n        requestId,\n      );\n      this.sendSegmentDataSendingCompletedCommand(segment, requestId);\n      this.logger(`segment ${externalId} has been sent to ${this.id}`);\n    } catch {\n      this.logger(`cancel segment uploading ${externalId}`);\n    }\n  }\n\n  private cancelSegmentDownloading(type: PeerRequestErrorType) {\n    if (!this.downloadingContext) return;\n    const { request, controls } = this.downloadingContext;\n    const { segment } = request;\n    this.logger(`cancel segment request ${segment.externalId} (${type})`);\n    const error = new RequestError(type);\n    controls.abortOnError(error);\n    this.downloadingContext = undefined;\n    this.downloadingErrors.push(error);\n  }\n\n  sendSegmentsAnnouncementCommand(\n    loadedSegmentsIds: number[],\n    httpLoadingSegmentsIds: number[],\n  ) {\n    const command: Command.PeerSegmentAnnouncementCommand = {\n      c: PeerCommandType.SegmentsAnnouncement,\n      p: httpLoadingSegmentsIds,\n      l: loadedSegmentsIds,\n    };\n    this.peerProtocol.sendCommand(command);\n  }\n\n  sendSegmentAbsentCommand(segmentExternalId: number, requestId: number) {\n    this.peerProtocol.sendCommand({\n      c: PeerCommandType.SegmentAbsent,\n      i: segmentExternalId,\n      r: requestId,\n    });\n  }\n\n  private sendCancelSegmentRequestCommand(\n    segment: SegmentWithStream,\n    requestId: number,\n  ) {\n    this.peerProtocol.sendCommand({\n      c: PeerCommandType.CancelSegmentRequest,\n      i: segment.externalId,\n      r: requestId,\n    });\n  }\n\n  private sendSegmentDataSendingCompletedCommand(\n    segment: SegmentWithStream,\n    requestId: number,\n  ) {\n    this.peerProtocol.sendCommand({\n      c: PeerCommandType.SegmentDataSendingCompleted,\n      r: requestId,\n      i: segment.externalId,\n    });\n  }\n\n  private onPeerConnectionClosed = () => {\n    this.destroy();\n  };\n\n  private onConnectionError = (error: Error) => {\n    this.logger(`peer connection error ${this.id} %O`, error);\n    this.eventTarget.getEventDispatcher(\"onPeerError\")({\n      peerId: this.id,\n      streamType: this.streamType,\n      error,\n    });\n\n    const { code } = error as { code?: string };\n\n    if (code === \"ERR_DATA_CHANNEL\") {\n      this.destroy();\n    } else if (code === \"ERR_CONNECTION_FAILURE\") {\n      this.destroy();\n    }\n  };\n\n  destroy = () => {\n    this.cancelSegmentDownloading(\"peer-closed\");\n    this.connection.destroy();\n    this.eventHandlers.onPeerClosed(this);\n    this.onPeerClosed({\n      peerId: this.id,\n      streamType: this.streamType,\n    });\n    this.logger(`peer closed ${this.id}`);\n  };\n\n  static getPeerIdFromConnection(connection: PeerConnection) {\n    return Utils.hexToUtf8(connection.id);\n  }\n}\n","import TrackerClient, {\n  PeerConnection,\n  TrackerClientEvents,\n} from \"bittorrent-tracker\";\nimport { CoreEventMap, StreamConfig, StreamWithSegments } from \"../types.js\";\nimport debug from \"debug\";\nimport * as PeerUtil from \"../utils/peer.js\";\nimport * as LoggerUtils from \"../utils/logger.js\";\nimport { Peer } from \"./peer.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\nimport { utf8ToUintArray } from \"../utils/utils.js\";\n\ntype PeerItem = {\n  peer?: Peer;\n  potentialConnections: Set<PeerConnection>;\n};\n\ntype P2PTrackerClientEventHandlers = {\n  onPeerConnected: (peer: Peer) => void;\n  onSegmentRequested: (\n    peer: Peer,\n    segmentExternalId: number,\n    requestId: number,\n    bytesFrom?: number,\n  ) => void;\n  onSegmentsAnnouncement: () => void;\n};\n\nfunction isSafariOrWkWebview() {\n  const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n  const isWkWebview =\n    /\\b(iPad|iPhone|Macintosh).*AppleWebKit(?!.*Safari)/i.test(\n      navigator.userAgent,\n    );\n\n  return isSafari || isWkWebview;\n}\n\nexport class P2PTrackerClient {\n  private static readonly PEER_ID_BY_INFO_HASH = new Map<string, string>();\n\n  private readonly streamShortId: string;\n  private readonly client: TrackerClient;\n  private readonly _peers = new Map<string, PeerItem>();\n  private readonly logger = debug(\"p2pml-core:p2p-tracker-client\");\n\n  constructor(\n    streamSwarmId: string,\n    private readonly stream: StreamWithSegments,\n    private readonly eventHandlers: P2PTrackerClientEventHandlers,\n    private readonly config: StreamConfig,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    const streamHash = PeerUtil.getStreamHash(streamSwarmId);\n    this.streamShortId = LoggerUtils.getStreamString(stream);\n\n    let peerId = P2PTrackerClient.PEER_ID_BY_INFO_HASH.get(streamHash);\n    if (!peerId) {\n      peerId = PeerUtil.generatePeerId(config.trackerClientVersionPrefix);\n      P2PTrackerClient.PEER_ID_BY_INFO_HASH.set(streamHash, peerId);\n    }\n\n    this.client = new TrackerClient({\n      infoHash: utf8ToUintArray(streamHash),\n      peerId: utf8ToUintArray(peerId),\n      announce: isSafariOrWkWebview()\n        ? config.announceTrackers.slice(0, 1) // Safari has issues with multiple trackers\n        : config.announceTrackers,\n      rtcConfig: this.config.rtcConfig,\n    });\n    this.client.on(\"peer\", this.onReceivePeerConnection);\n    this.client.on(\"warning\", this.onTrackerClientWarning);\n    this.client.on(\"error\", this.onTrackerClientError);\n    this.logger(\n      `create new client; \\nstream: ${this.streamShortId}; hash: ${streamHash}\\npeerId: ${peerId}`,\n    );\n  }\n\n  start() {\n    this.client.start();\n  }\n\n  destroy() {\n    this.client.destroy();\n\n    for (const { peer, potentialConnections } of this._peers.values()) {\n      peer?.destroy();\n      for (const connection of potentialConnections) {\n        connection.destroy();\n      }\n    }\n\n    this._peers.clear();\n    this.logger(\"destroy client; stream:\", this.streamShortId);\n  }\n\n  private onReceivePeerConnection: TrackerClientEvents[\"peer\"] = (\n    peerConnection,\n  ) => {\n    const itemId = Peer.getPeerIdFromConnection(peerConnection);\n    let peerItem = this._peers.get(itemId);\n\n    if (peerItem?.peer) {\n      peerConnection.destroy();\n      return;\n    }\n\n    if (!peerItem) {\n      peerItem = { potentialConnections: new Set() };\n      peerConnection.idUtf8 = itemId;\n      this._peers.set(itemId, peerItem);\n    }\n\n    peerItem.potentialConnections.add(peerConnection);\n\n    peerConnection.on(\"connect\", () => {\n      if (peerItem.peer) return;\n\n      for (const connection of peerItem.potentialConnections) {\n        if (connection !== peerConnection) connection.destroy();\n      }\n\n      peerItem.potentialConnections.clear();\n\n      peerItem.peer = new Peer(\n        peerConnection,\n        {\n          onPeerClosed: this.onPeerClosed,\n          onSegmentRequested: this.eventHandlers.onSegmentRequested,\n          onSegmentsAnnouncement: this.eventHandlers.onSegmentsAnnouncement,\n        },\n        this.config,\n        this.stream.type,\n        this.eventTarget,\n      );\n      this.logger(\n        `connected with peer: ${peerItem.peer.id} ${this.streamShortId}`,\n      );\n      this.eventHandlers.onPeerConnected(peerItem.peer);\n    });\n  };\n\n  private onTrackerClientWarning: TrackerClientEvents[\"warning\"] = (\n    warning,\n  ) => {\n    this.logger(\"tracker warning %s:\", this.streamShortId, warning);\n    this.eventTarget.getEventDispatcher(\"onTrackerWarning\")({\n      streamType: this.stream.type,\n      warning,\n    });\n  };\n\n  private onTrackerClientError: TrackerClientEvents[\"error\"] = (error) => {\n    this.logger(\"tracker error in stream %s:\", this.streamShortId, error);\n    this.eventTarget.getEventDispatcher(\"onTrackerError\")({\n      streamType: this.stream.type,\n      error,\n    });\n  };\n\n  *peers() {\n    for (const peerItem of this._peers.values()) {\n      if (peerItem.peer) yield peerItem.peer;\n    }\n  }\n\n  private onPeerClosed = (peer: Peer) => {\n    this.logger(`peer closed: ${peer.id}`);\n    this._peers.delete(peer.id);\n  };\n\n  static clearPeerIdCache() {\n    P2PTrackerClient.PEER_ID_BY_INFO_HASH.clear();\n  }\n}\n","import {\n  SegmentWithStream,\n  Stream,\n  StreamConfig,\n  StreamWithSegments,\n} from \"../types.js\";\nimport { Playback } from \"../internal-types.js\";\nimport { P2PLoader } from \"../p2p/loader.js\";\n\nexport type SegmentPlaybackStatuses = {\n  isHighDemand: boolean;\n  isHttpDownloadable: boolean;\n  isP2PDownloadable: boolean;\n};\n\nexport type PlaybackTimeWindowsConfig = Pick<\n  StreamConfig,\n  \"highDemandTimeWindow\" | \"httpDownloadTimeWindow\" | \"p2pDownloadTimeWindow\"\n>;\n\nconst PEER_PROTOCOL_VERSION = \"v2\";\n\nexport function getStreamSwarmId(\n  swarmId: string,\n  stream: Readonly<Stream>,\n): string {\n  return `${PEER_PROTOCOL_VERSION}-${swarmId}-${getStreamId(stream)}`;\n}\n\nexport function getSegmentFromStreamsMap(\n  streams: Map<string, StreamWithSegments>,\n  segmentRuntimeId: string,\n): SegmentWithStream | undefined {\n  for (const stream of streams.values()) {\n    const segment = stream.segments.get(segmentRuntimeId);\n    if (segment) return segment;\n  }\n}\n\nexport function getSegmentFromStreamByExternalId(\n  stream: StreamWithSegments,\n  segmentExternalId: number,\n): SegmentWithStream | undefined {\n  for (const segment of stream.segments.values()) {\n    if (segment.externalId === segmentExternalId) return segment;\n  }\n}\n\nexport function getStreamId(stream: Stream) {\n  return `${stream.type}-${stream.index}`;\n}\n\nexport function getSegmentAvgDuration(stream: StreamWithSegments) {\n  const { segments } = stream;\n  let sumDuration = 0;\n  const { size } = segments;\n  for (const segment of segments.values()) {\n    const duration = segment.endTime - segment.startTime;\n    sumDuration += duration;\n  }\n\n  return sumDuration / size;\n}\n\nfunction calculateTimeWindows(\n  timeWindowsConfig: PlaybackTimeWindowsConfig,\n  availableMemoryInPercent: number,\n) {\n  const {\n    highDemandTimeWindow,\n    httpDownloadTimeWindow,\n    p2pDownloadTimeWindow,\n  } = timeWindowsConfig;\n\n  const result = {\n    highDemandTimeWindow,\n    httpDownloadTimeWindow,\n    p2pDownloadTimeWindow,\n  };\n\n  if (availableMemoryInPercent <= 5) {\n    result.httpDownloadTimeWindow = 0;\n    result.p2pDownloadTimeWindow = 0;\n  } else if (availableMemoryInPercent <= 10) {\n    result.p2pDownloadTimeWindow = result.httpDownloadTimeWindow;\n  }\n\n  return result;\n}\n\nexport function getSegmentPlaybackStatuses(\n  segment: SegmentWithStream,\n  playback: Playback,\n  timeWindowsConfig: PlaybackTimeWindowsConfig,\n  currentP2PLoader: P2PLoader,\n  availableMemoryPercent: number,\n): SegmentPlaybackStatuses {\n  const {\n    highDemandTimeWindow,\n    httpDownloadTimeWindow,\n    p2pDownloadTimeWindow,\n  } = calculateTimeWindows(timeWindowsConfig, availableMemoryPercent);\n\n  return {\n    isHighDemand: isSegmentInTimeWindow(\n      segment,\n      playback,\n      highDemandTimeWindow,\n    ),\n    isHttpDownloadable: isSegmentInTimeWindow(\n      segment,\n      playback,\n      httpDownloadTimeWindow,\n    ),\n    isP2PDownloadable:\n      isSegmentInTimeWindow(segment, playback, p2pDownloadTimeWindow) &&\n      currentP2PLoader.isSegmentLoadingOrLoadedBySomeone(segment),\n  };\n}\n\nfunction isSegmentInTimeWindow(\n  segment: SegmentWithStream,\n  playback: Playback,\n  timeWindowLength: number,\n) {\n  const { startTime, endTime } = segment;\n  const { position, rate } = playback;\n  const rightMargin = position + timeWindowLength * rate;\n  return !(rightMargin < startTime || position > endTime);\n}\n","import { Peer } from \"./peer.js\";\nimport {\n  CoreEventMap,\n  SegmentWithStream,\n  StreamConfig,\n  StreamWithSegments,\n} from \"../types.js\";\nimport { RequestsContainer } from \"../requests/request-container.js\";\nimport { P2PTrackerClient } from \"./tracker-client.js\";\nimport * as StreamUtils from \"../utils/stream.js\";\nimport * as Utils from \"../utils/utils.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\nimport { SegmentStorage } from \"../segment-storage/index.js\";\n\nexport type EventTargetMap = Record<`onStorageUpdated-${string}`, () => void> &\n  CoreEventMap;\n\nexport class P2PLoader {\n  private readonly trackerClient: P2PTrackerClient;\n  private isAnnounceMicrotaskCreated = false;\n\n  constructor(\n    private streamManifestUrl: string,\n    private readonly stream: StreamWithSegments,\n    private readonly requests: RequestsContainer,\n    private readonly segmentStorage: SegmentStorage,\n    private readonly config: StreamConfig,\n    private readonly eventTarget: EventTarget<EventTargetMap>,\n    private readonly onSegmentAnnouncement: () => void,\n  ) {\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, this.stream);\n\n    this.trackerClient = new P2PTrackerClient(\n      streamSwarmId,\n      this.stream,\n      {\n        onPeerConnected: this.onPeerConnected,\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        onSegmentRequested: this.onSegmentRequested,\n        onSegmentsAnnouncement: this.onSegmentAnnouncement,\n      },\n      this.config,\n      this.eventTarget,\n    );\n\n    this.eventTarget.addEventListener(\n      `onStorageUpdated-${streamSwarmId}`,\n      this.broadcastAnnouncement,\n    );\n    this.segmentStorage.setSegmentChangeCallback((streamId: string) => {\n      this.eventTarget.dispatchEvent(`onStorageUpdated-${streamId}`);\n    });\n\n    this.trackerClient.start();\n  }\n\n  downloadSegment(segment: SegmentWithStream) {\n    const peersWithSegment: Peer[] = [];\n    for (const peer of this.trackerClient.peers()) {\n      if (\n        !peer.downloadingSegment &&\n        peer.getSegmentStatus(segment) === \"loaded\"\n      ) {\n        peersWithSegment.push(peer);\n      }\n    }\n\n    if (peersWithSegment.length === 0) return;\n    const peer = Utils.getRandomItem(peersWithSegment);\n\n    const request = this.requests.getOrCreateRequest(segment);\n    peer.downloadSegment(request);\n  }\n\n  isSegmentLoadingOrLoadedBySomeone(segment: SegmentWithStream): boolean {\n    for (const peer of this.trackerClient.peers()) {\n      if (peer.getSegmentStatus(segment)) return true;\n    }\n    return false;\n  }\n\n  isSegmentLoadedBySomeone(segment: SegmentWithStream): boolean {\n    for (const peer of this.trackerClient.peers()) {\n      if (peer.getSegmentStatus(segment) === \"loaded\") return true;\n    }\n    return false;\n  }\n\n  get connectedPeerCount() {\n    let count = 0;\n    const iterator = this.trackerClient.peers();\n    while (!iterator.next().done) count++;\n    return count;\n  }\n\n  private getSegmentsAnnouncement() {\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, this.stream);\n\n    const loaded: number[] = this.segmentStorage.getStoredSegmentIds(\n      swarmId,\n      streamSwarmId,\n    );\n    const httpLoading: number[] = [];\n\n    for (const request of this.requests.httpRequests()) {\n      const segment = this.stream.segments.get(request.segment.runtimeId);\n      if (!segment) continue;\n\n      httpLoading.push(segment.externalId);\n    }\n    return { loaded, httpLoading };\n  }\n\n  private onPeerConnected = (peer: Peer) => {\n    if (this.config.isP2PUploadDisabled) return;\n\n    const { httpLoading, loaded } = this.getSegmentsAnnouncement();\n    peer.sendSegmentsAnnouncementCommand(loaded, httpLoading);\n  };\n\n  broadcastAnnouncement = (sendEmptyAnnouncement = false) => {\n    if (sendEmptyAnnouncement) {\n      this.sendSegmentsAnnouncement([], []);\n      return;\n    }\n\n    if (this.isAnnounceMicrotaskCreated || this.config.isP2PUploadDisabled) {\n      return;\n    }\n\n    const { loaded, httpLoading } = this.getSegmentsAnnouncement();\n    this.sendSegmentsAnnouncement(loaded, httpLoading);\n  };\n\n  private sendSegmentsAnnouncement = (\n    loaded: number[],\n    httpLoading: number[],\n  ) => {\n    this.isAnnounceMicrotaskCreated = true;\n\n    queueMicrotask(() => {\n      for (const peer of this.trackerClient.peers()) {\n        peer.sendSegmentsAnnouncementCommand(loaded, httpLoading);\n      }\n      this.isAnnounceMicrotaskCreated = false;\n    });\n  };\n\n  private onSegmentRequested = async (\n    peer: Peer,\n    segmentExternalId: number,\n    requestId: number,\n    byteFrom?: number,\n  ) => {\n    const segment = StreamUtils.getSegmentFromStreamByExternalId(\n      this.stream,\n      segmentExternalId,\n    );\n    if (!segment) return;\n    if (this.config.isP2PUploadDisabled) {\n      peer.sendSegmentAbsentCommand(segmentExternalId, requestId);\n      return;\n    }\n\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, this.stream);\n\n    const segmentData = await this.segmentStorage.getSegmentData(\n      swarmId,\n      streamSwarmId,\n      segment.externalId,\n    );\n    if (!segmentData) {\n      peer.sendSegmentAbsentCommand(segmentExternalId, requestId);\n      return;\n    }\n    await peer.uploadSegmentData(\n      segment,\n      requestId,\n      byteFrom !== undefined ? segmentData.slice(byteFrom) : segmentData,\n    );\n  };\n\n  destroy() {\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, this.stream);\n\n    this.eventTarget.removeEventListener(\n      `onStorageUpdated-${streamSwarmId}`,\n      this.broadcastAnnouncement,\n    );\n    this.trackerClient.destroy();\n  }\n}\n","import { P2PLoader } from \"./loader.js\";\nimport debug from \"debug\";\nimport {\n  CoreEventMap,\n  Stream,\n  StreamConfig,\n  StreamWithSegments,\n  SegmentStorage,\n} from \"../index.js\";\nimport { RequestsContainer } from \"../requests/request-container.js\";\nimport * as LoggerUtils from \"../utils/logger.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\nimport * as StreamUtils from \"../utils/stream.js\";\n\ntype P2PLoaderContainerItem = {\n  stream: Stream;\n  loader: P2PLoader;\n  destroyTimeoutId?: number;\n  loggerInfo: string;\n};\n\nexport class P2PLoadersContainer {\n  private readonly loaders = new Map<string, P2PLoaderContainerItem>();\n  private _currentLoaderItem: P2PLoaderContainerItem;\n  private readonly logger = debug(\"p2pml-core:p2p-loaders-container\");\n\n  constructor(\n    private readonly streamManifestUrl: string,\n    stream: StreamWithSegments,\n    private readonly requests: RequestsContainer,\n    private readonly segmentStorage: SegmentStorage,\n    private readonly config: StreamConfig,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n    private onSegmentAnnouncement: () => void,\n  ) {\n    this._currentLoaderItem = this.findOrCreateLoaderForStream(stream);\n    this.logger(\n      `set current p2p loader: ${LoggerUtils.getStreamString(stream)}`,\n    );\n  }\n\n  private createLoader(stream: StreamWithSegments): P2PLoaderContainerItem {\n    if (this.loaders.has(stream.runtimeId)) {\n      throw new Error(\"Loader for this stream already exists\");\n    }\n    const loader = new P2PLoader(\n      this.streamManifestUrl,\n      stream,\n      this.requests,\n      this.segmentStorage,\n      this.config,\n      this.eventTarget,\n      () => {\n        if (this._currentLoaderItem.loader === loader) {\n          this.onSegmentAnnouncement();\n        }\n      },\n    );\n    const loggerInfo = LoggerUtils.getStreamString(stream);\n    this.logger(`created new loader: ${loggerInfo}`);\n    return {\n      loader,\n      stream,\n      loggerInfo: LoggerUtils.getStreamString(stream),\n    };\n  }\n\n  private findOrCreateLoaderForStream(stream: StreamWithSegments) {\n    const loaderItem = this.loaders.get(stream.runtimeId);\n    if (loaderItem) {\n      clearTimeout(loaderItem.destroyTimeoutId);\n      loaderItem.destroyTimeoutId = undefined;\n      return loaderItem;\n    } else {\n      const loader = this.createLoader(stream);\n      this.loaders.set(stream.runtimeId, loader);\n      return loader;\n    }\n  }\n\n  changeCurrentLoader(stream: StreamWithSegments) {\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(\n      swarmId,\n      this._currentLoaderItem.stream,\n    );\n    const ids = this.segmentStorage.getStoredSegmentIds(swarmId, streamSwarmId);\n    if (!ids.length) this.destroyAndRemoveLoader(this._currentLoaderItem);\n    else this.setLoaderDestroyTimeout(this._currentLoaderItem);\n\n    this._currentLoaderItem = this.findOrCreateLoaderForStream(stream);\n\n    this.logger(\n      `change current p2p loader: ${LoggerUtils.getStreamString(stream)}`,\n    );\n  }\n\n  private setLoaderDestroyTimeout(item: P2PLoaderContainerItem) {\n    item.destroyTimeoutId = window.setTimeout(\n      () => this.destroyAndRemoveLoader(item),\n      this.config.p2pInactiveLoaderDestroyTimeoutMs,\n    );\n  }\n\n  private destroyAndRemoveLoader(item: P2PLoaderContainerItem) {\n    item.loader.destroy();\n    this.loaders.delete(item.stream.runtimeId);\n    this.logger(`destroy p2p loader: `, item.loggerInfo);\n  }\n\n  get currentLoader() {\n    return this._currentLoaderItem.loader;\n  }\n\n  destroy() {\n    for (const { loader, destroyTimeoutId } of this.loaders.values()) {\n      loader.destroy();\n      clearTimeout(destroyTimeoutId);\n    }\n    this.loaders.clear();\n  }\n}\n","import debug from \"debug\";\nimport { BandwidthCalculators, Playback } from \"../internal-types.js\";\nimport {\n  CoreEventMap,\n  RequestError,\n  RequestAbortErrorType,\n  SegmentWithStream,\n  Segment,\n} from \"../types.js\";\nimport * as StreamUtils from \"../utils/stream.js\";\nimport * as Utils from \"../utils/utils.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\n\nexport type LoadProgress = {\n  startTimestamp: number;\n  lastLoadedChunkTimestamp?: number;\n  startFromByte?: number;\n  loadedBytes: number;\n};\n\ntype HttpRequestAttempt = {\n  downloadSource: \"http\";\n  error?: RequestError;\n};\n\ntype P2PRequestAttempt = {\n  downloadSource: \"p2p\";\n  peerId: string;\n  error?: RequestError;\n};\n\nexport type RequestAttempt = HttpRequestAttempt | P2PRequestAttempt;\n\nexport type RequestControls = Readonly<{\n  firstBytesReceived: Request[\"firstBytesReceived\"];\n  addLoadedChunk: Request[\"addLoadedChunk\"];\n  completeOnSuccess: Request[\"completeOnSuccess\"];\n  abortOnError: Request[\"abortOnError\"];\n}>;\n\ntype OmitEncapsulated<T extends RequestAttempt> = Omit<\n  T,\n  \"error\" | \"errorTimestamp\"\n>;\ntype StartRequestParameters =\n  | OmitEncapsulated<HttpRequestAttempt>\n  | OmitEncapsulated<P2PRequestAttempt>;\n\nexport type RequestStatus =\n  | \"not-started\"\n  | \"loading\"\n  | \"succeed\"\n  | \"failed\"\n  | \"aborted\";\n\nfunction mapSegmentWithStreamToSegment(segment: SegmentWithStream): Segment {\n  return {\n    runtimeId: segment.runtimeId,\n    externalId: segment.externalId,\n    url: segment.url,\n    byteRange: segment.byteRange,\n    startTime: segment.startTime,\n    endTime: segment.endTime,\n  };\n}\n\nexport class Request {\n  private currentAttempt?: RequestAttempt;\n  private _failedAttempts = new FailedRequestAttempts();\n  private finalData?: ArrayBuffer;\n  private bytes: Uint8Array[] = [];\n  private _loadedBytes = 0;\n  private _totalBytes?: number;\n  private _status: RequestStatus = \"not-started\";\n  private progress?: LoadProgress;\n  private notReceivingBytesTimeout: Timeout;\n  private _abortRequestCallback?: (\n    error: RequestError<RequestAbortErrorType>,\n  ) => void;\n  private readonly _logger: debug.Debugger;\n  private _isHandledByProcessQueue = false;\n  private readonly onSegmentError: CoreEventMap[\"onSegmentError\"];\n  private readonly onSegmentAbort: CoreEventMap[\"onSegmentAbort\"];\n  private readonly onSegmentStart: CoreEventMap[\"onSegmentStart\"];\n  private readonly onSegmentLoaded: CoreEventMap[\"onSegmentLoaded\"];\n\n  constructor(\n    readonly segment: SegmentWithStream,\n    private readonly requestProcessQueueCallback: () => void,\n    private readonly bandwidthCalculators: BandwidthCalculators,\n    private readonly playback: Playback,\n    private readonly playbackConfig: StreamUtils.PlaybackTimeWindowsConfig,\n    eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    this.onSegmentError = eventTarget.getEventDispatcher(\"onSegmentError\");\n    this.onSegmentAbort = eventTarget.getEventDispatcher(\"onSegmentAbort\");\n    this.onSegmentStart = eventTarget.getEventDispatcher(\"onSegmentStart\");\n    this.onSegmentLoaded = eventTarget.getEventDispatcher(\"onSegmentLoaded\");\n\n    const { byteRange } = this.segment;\n    if (byteRange) {\n      const { end, start } = byteRange;\n      this._totalBytes = end - start + 1;\n    }\n    this.notReceivingBytesTimeout = new Timeout(this.abortOnTimeout);\n\n    const { type } = this.segment.stream;\n    this._logger = debug(`p2pml-core:request-${type}`);\n  }\n\n  clearLoadedBytes() {\n    this._loadedBytes = 0;\n    this.bytes = [];\n    this._totalBytes = undefined;\n    this.finalData = undefined;\n  }\n\n  get status() {\n    return this._status;\n  }\n\n  private setStatus(status: RequestStatus) {\n    this._status = status;\n    this._isHandledByProcessQueue = false;\n  }\n\n  get downloadSource() {\n    return this.currentAttempt?.downloadSource;\n  }\n\n  get loadedBytes() {\n    return this._loadedBytes;\n  }\n\n  get totalBytes(): number | undefined {\n    return this._totalBytes;\n  }\n\n  get data(): ArrayBuffer {\n    this.finalData ??= Utils.joinChunks(this.bytes).buffer;\n    return this.finalData;\n  }\n\n  get failedAttempts() {\n    return this._failedAttempts;\n  }\n\n  get isHandledByProcessQueue() {\n    return this._isHandledByProcessQueue;\n  }\n\n  markHandledByProcessQueue() {\n    this._isHandledByProcessQueue = true;\n  }\n\n  setTotalBytes(value: number) {\n    if (this._totalBytes !== undefined) {\n      throw new Error(\"Request total bytes value is already set\");\n    }\n    this._totalBytes = value;\n  }\n\n  start(\n    requestData: StartRequestParameters,\n    controls: {\n      notReceivingBytesTimeoutMs?: number;\n      abort: (errorType: RequestError<RequestAbortErrorType>) => void;\n    },\n  ): RequestControls {\n    if (this._status === \"succeed\") {\n      throw new Error(\n        `Request ${this.segment.externalId} has been already succeed.`,\n      );\n    }\n    if (this._status === \"loading\") {\n      throw new Error(\n        `Request ${this.segment.externalId} has been already started.`,\n      );\n    }\n\n    this.setStatus(\"loading\");\n    this.currentAttempt = { ...requestData };\n    this.progress = {\n      startFromByte: this._loadedBytes,\n      loadedBytes: 0,\n      startTimestamp: performance.now(),\n    };\n    this.manageBandwidthCalculatorsState(\"start\");\n\n    const { notReceivingBytesTimeoutMs, abort } = controls;\n    this._abortRequestCallback = abort;\n\n    if (notReceivingBytesTimeoutMs !== undefined) {\n      this.notReceivingBytesTimeout.start(notReceivingBytesTimeoutMs);\n    }\n\n    this.logger(\n      `${requestData.downloadSource} ${this.segment.externalId} started`,\n    );\n\n    this.onSegmentStart({\n      segment: mapSegmentWithStreamToSegment(this.segment),\n      downloadSource: requestData.downloadSource,\n      peerId:\n        requestData.downloadSource === \"p2p\" ? requestData.peerId : undefined,\n    });\n\n    return {\n      firstBytesReceived: this.firstBytesReceived,\n      addLoadedChunk: this.addLoadedChunk,\n      completeOnSuccess: this.completeOnSuccess,\n      abortOnError: this.abortOnError,\n    };\n  }\n\n  abortFromProcessQueue() {\n    this.throwErrorIfNotLoadingStatus();\n    this.setStatus(\"aborted\");\n    this.logger(\n      `${this.currentAttempt?.downloadSource} ${this.segment.externalId} aborted`,\n    );\n    this._abortRequestCallback?.(new RequestError(\"abort\"));\n    this.onSegmentAbort({\n      segment: mapSegmentWithStreamToSegment(this.segment),\n      downloadSource: this.currentAttempt?.downloadSource,\n      peerId:\n        this.currentAttempt?.downloadSource === \"p2p\"\n          ? this.currentAttempt.peerId\n          : undefined,\n      streamType: this.segment.stream.type,\n    });\n    this._abortRequestCallback = undefined;\n    this.manageBandwidthCalculatorsState(\"stop\");\n    this.notReceivingBytesTimeout.clear();\n  }\n\n  private abortOnTimeout = () => {\n    this.throwErrorIfNotLoadingStatus();\n    if (!this.currentAttempt) return;\n\n    this.setStatus(\"failed\");\n    const error = new RequestError(\"bytes-receiving-timeout\");\n    this._abortRequestCallback?.(error);\n    this.logger(\n      `${this.downloadSource} ${this.segment.externalId} failed ${error.type}`,\n    );\n    this._failedAttempts.add({\n      ...this.currentAttempt,\n      error,\n    });\n    this.onSegmentError({\n      segment: mapSegmentWithStreamToSegment(this.segment),\n      error,\n      downloadSource: this.currentAttempt.downloadSource,\n      peerId:\n        this.currentAttempt.downloadSource === \"p2p\"\n          ? this.currentAttempt.peerId\n          : undefined,\n      streamType: this.segment.stream.type,\n    });\n    this.notReceivingBytesTimeout.clear();\n    this.manageBandwidthCalculatorsState(\"stop\");\n    this.requestProcessQueueCallback();\n  };\n\n  private abortOnError = (error: RequestError) => {\n    this.throwErrorIfNotLoadingStatus();\n    if (!this.currentAttempt) return;\n\n    this.setStatus(\"failed\");\n    this.logger(\n      `${this.downloadSource} ${this.segment.externalId} failed ${error.type}`,\n    );\n    this._failedAttempts.add({\n      ...this.currentAttempt,\n      error,\n    });\n    this.onSegmentError({\n      segment: mapSegmentWithStreamToSegment(this.segment),\n      error,\n      downloadSource: this.currentAttempt.downloadSource,\n      peerId:\n        this.currentAttempt.downloadSource === \"p2p\"\n          ? this.currentAttempt.peerId\n          : undefined,\n      streamType: this.segment.stream.type,\n    });\n    this.notReceivingBytesTimeout.clear();\n    this.manageBandwidthCalculatorsState(\"stop\");\n    this.requestProcessQueueCallback();\n  };\n\n  private completeOnSuccess = () => {\n    this.throwErrorIfNotLoadingStatus();\n    if (!this.currentAttempt) return;\n\n    this.manageBandwidthCalculatorsState(\"stop\");\n    this.notReceivingBytesTimeout.clear();\n    this.setStatus(\"succeed\");\n    this._totalBytes = this._loadedBytes;\n    this.onSegmentLoaded({\n      segmentUrl: this.segment.url,\n      bytesLength: this.data.byteLength,\n      downloadSource: this.currentAttempt.downloadSource,\n      peerId:\n        this.currentAttempt.downloadSource === \"p2p\"\n          ? this.currentAttempt.peerId\n          : undefined,\n      streamType: this.segment.stream.type,\n    });\n\n    this.logger(\n      `${this.currentAttempt.downloadSource} ${this.segment.externalId} succeed`,\n    );\n    this.requestProcessQueueCallback();\n  };\n\n  private addLoadedChunk = (chunk: Uint8Array) => {\n    this.throwErrorIfNotLoadingStatus();\n    if (!this.currentAttempt || !this.progress) return;\n    this.notReceivingBytesTimeout.restart();\n\n    const { byteLength } = chunk;\n    const { all: allBC, http: httpBC } = this.bandwidthCalculators;\n    allBC.addBytes(byteLength);\n    if (this.currentAttempt.downloadSource === \"http\") {\n      httpBC.addBytes(byteLength);\n    }\n\n    this.bytes.push(chunk);\n    this.progress.lastLoadedChunkTimestamp = performance.now();\n    this.progress.loadedBytes += byteLength;\n    this._loadedBytes += byteLength;\n  };\n\n  private firstBytesReceived = () => {\n    this.throwErrorIfNotLoadingStatus();\n    this.notReceivingBytesTimeout.restart();\n  };\n\n  private throwErrorIfNotLoadingStatus() {\n    if (this._status !== \"loading\") {\n      throw new Error(`Request has been already ${this.status}.`);\n    }\n  }\n\n  private logger(message: string) {\n    this._logger.color =\n      this.currentAttempt?.downloadSource === \"http\" ? \"green\" : \"red\";\n    this._logger(message);\n    this._logger.color = \"\";\n  }\n\n  private manageBandwidthCalculatorsState(state: \"start\" | \"stop\") {\n    const { all, http } = this.bandwidthCalculators;\n    const method = state === \"start\" ? \"startLoading\" : \"stopLoading\";\n    if (this.currentAttempt?.downloadSource === \"http\") http[method]();\n    all[method]();\n  }\n}\n\nclass FailedRequestAttempts {\n  private attempts: Required<RequestAttempt>[] = [];\n\n  add(attempt: Required<RequestAttempt>) {\n    this.attempts.push(attempt);\n  }\n\n  get httpAttemptsCount() {\n    return this.attempts.reduce(\n      (sum, attempt) => (attempt.downloadSource === \"http\" ? sum + 1 : sum),\n      0,\n    );\n  }\n\n  get lastAttempt(): Readonly<Required<RequestAttempt>> | undefined {\n    return this.attempts[this.attempts.length - 1];\n  }\n\n  clear() {\n    this.attempts = [];\n  }\n}\n\nexport class Timeout {\n  private timeoutId?: number;\n  private ms?: number;\n\n  constructor(private readonly action: () => void) {}\n\n  start(ms: number) {\n    if (this.timeoutId) {\n      throw new Error(\"Timeout is already started.\");\n    }\n    this.ms = ms;\n    this.timeoutId = window.setTimeout(this.action, this.ms);\n  }\n\n  restart(ms?: number) {\n    if (this.timeoutId) clearTimeout(this.timeoutId);\n    if (ms) this.ms = ms;\n    if (!this.ms) return;\n    this.timeoutId = window.setTimeout(this.action, this.ms);\n  }\n\n  clear() {\n    clearTimeout(this.timeoutId);\n    this.timeoutId = undefined;\n  }\n}\n","import { Playback, BandwidthCalculators } from \"../internal-types.js\";\nimport { CoreEventMap, SegmentWithStream, StreamConfig } from \"../types.js\";\nimport { EventTarget } from \"../utils/event-target.js\";\nimport { Request } from \"./request.js\";\n\nexport class RequestsContainer {\n  private readonly requests = new Map<SegmentWithStream, Request>();\n\n  constructor(\n    private readonly requestProcessQueueCallback: () => void,\n    private readonly bandwidthCalculators: BandwidthCalculators,\n    private readonly playback: Playback,\n    private readonly config: StreamConfig,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n  ) {}\n\n  get executingHttpCount() {\n    let count = 0;\n    for (const request of this.httpRequests()) {\n      if (request.status === \"loading\") count++;\n    }\n    return count;\n  }\n\n  get executingP2PCount() {\n    let count = 0;\n    for (const request of this.p2pRequests()) {\n      if (request.status === \"loading\") count++;\n    }\n    return count;\n  }\n\n  get(segment: SegmentWithStream) {\n    return this.requests.get(segment);\n  }\n\n  getOrCreateRequest(segment: SegmentWithStream) {\n    let request = this.requests.get(segment);\n    if (!request) {\n      request = new Request(\n        segment,\n        this.requestProcessQueueCallback,\n        this.bandwidthCalculators,\n        this.playback,\n        this.config,\n        this.eventTarget,\n      );\n      this.requests.set(segment, request);\n    }\n    return request;\n  }\n\n  remove(request: Request) {\n    this.requests.delete(request.segment);\n  }\n\n  items() {\n    return this.requests.values();\n  }\n\n  *httpRequests(): Generator<Request, void> {\n    for (const request of this.requests.values()) {\n      if (request.downloadSource === \"http\") yield request;\n    }\n  }\n\n  *p2pRequests(): Generator<Request, void> {\n    for (const request of this.requests.values()) {\n      if (request.downloadSource === \"p2p\") yield request;\n    }\n  }\n\n  destroy() {\n    for (const request of this.requests.values()) {\n      if (request.status !== \"loading\") continue;\n      request.abortFromProcessQueue();\n    }\n    this.requests.clear();\n  }\n}\n","import {\n  CoreRequestError,\n  EngineCallbacks,\n  SegmentWithStream,\n} from \"../types.js\";\n\nexport class EngineRequest {\n  private _status: \"pending\" | \"succeed\" | \"failed\" | \"aborted\" = \"pending\";\n  private _shouldBeStartedImmediately = false;\n\n  constructor(\n    readonly segment: SegmentWithStream,\n    readonly engineCallbacks: EngineCallbacks,\n  ) {}\n\n  get status() {\n    return this._status;\n  }\n\n  get shouldBeStartedImmediately() {\n    return this._shouldBeStartedImmediately;\n  }\n\n  resolve(data: ArrayBuffer, bandwidth: number) {\n    if (this._status !== \"pending\") return;\n    this._status = \"succeed\";\n    this.engineCallbacks.onSuccess({ data, bandwidth });\n  }\n\n  reject() {\n    if (this._status !== \"pending\") return;\n    this._status = \"failed\";\n    this.engineCallbacks.onError(new CoreRequestError(\"failed\"));\n  }\n\n  abort() {\n    if (this._status !== \"pending\") return;\n    this._status = \"aborted\";\n    this.engineCallbacks.onError(new CoreRequestError(\"aborted\"));\n  }\n\n  markAsShouldBeStartedImmediately() {\n    this._shouldBeStartedImmediately = true;\n  }\n}\n","import { Playback } from \"../internal-types.js\";\nimport { P2PLoader } from \"../p2p/loader.js\";\nimport { SegmentWithStream } from \"../types.js\";\nimport {\n  getSegmentPlaybackStatuses,\n  SegmentPlaybackStatuses,\n  PlaybackTimeWindowsConfig,\n} from \"./stream.js\";\n\nexport type QueueItem = {\n  segment: SegmentWithStream;\n  statuses: SegmentPlaybackStatuses;\n};\n\nexport function* generateQueue(\n  lastRequestedSegment: Readonly<SegmentWithStream>,\n  playback: Readonly<Playback>,\n  playbackConfig: PlaybackTimeWindowsConfig,\n  currentP2PLoader: P2PLoader,\n  availablePercentMemory: number,\n): Generator<QueueItem, void> {\n  const { runtimeId, stream } = lastRequestedSegment;\n\n  const requestedSegment = stream.segments.get(runtimeId);\n  if (!requestedSegment) return;\n\n  const queueSegments = stream.segments.values();\n\n  let first: SegmentWithStream;\n\n  do {\n    const next = queueSegments.next();\n    if (next.done) return; // should never happen\n    first = next.value;\n  } while (first !== requestedSegment);\n\n  const firstStatuses = getSegmentPlaybackStatuses(\n    first,\n    playback,\n    playbackConfig,\n    currentP2PLoader,\n    availablePercentMemory,\n  );\n  if (isNotActualStatuses(firstStatuses)) {\n    const next = queueSegments.next();\n\n    // for cases when engine requests segment that is a little bit\n    // earlier than current playhead position\n    // it could happen when playhead position is significantly changed by user\n    if (next.done) return;\n\n    const second = next.value;\n\n    const secondStatuses = getSegmentPlaybackStatuses(\n      second,\n      playback,\n      playbackConfig,\n      currentP2PLoader,\n      availablePercentMemory,\n    );\n\n    if (isNotActualStatuses(secondStatuses)) return;\n    firstStatuses.isHighDemand = true;\n    yield { segment: first, statuses: firstStatuses };\n    yield { segment: second, statuses: secondStatuses };\n  } else {\n    yield { segment: first, statuses: firstStatuses };\n  }\n\n  for (const segment of queueSegments) {\n    const statuses = getSegmentPlaybackStatuses(\n      segment,\n      playback,\n      playbackConfig,\n      currentP2PLoader,\n      availablePercentMemory,\n    );\n    if (isNotActualStatuses(statuses)) break;\n    yield { segment, statuses };\n  }\n}\n\nfunction isNotActualStatuses(statuses: SegmentPlaybackStatuses) {\n  const {\n    isHighDemand = false,\n    isHttpDownloadable = false,\n    isP2PDownloadable = false,\n  } = statuses;\n  return !isHighDemand && !isHttpDownloadable && !isP2PDownloadable;\n}\n","import { HttpRequestExecutor } from \"./http-loader.js\";\nimport {\n  CoreEventMap,\n  EngineCallbacks,\n  SegmentWithStream,\n  StreamConfig,\n  StreamWithSegments,\n} from \"./types.js\";\nimport {\n  Playback,\n  BandwidthCalculators,\n  StreamDetails,\n} from \"./internal-types.js\";\nimport { P2PLoadersContainer } from \"./p2p/loaders-container.js\";\nimport { RequestsContainer } from \"./requests/request-container.js\";\nimport { EngineRequest } from \"./requests/engine-request.js\";\nimport * as QueueUtils from \"./utils/queue.js\";\nimport * as LoggerUtils from \"./utils/logger.js\";\nimport * as StreamUtils from \"./utils/stream.js\";\nimport * as Utils from \"./utils/utils.js\";\nimport debug from \"debug\";\nimport { QueueItem } from \"./utils/queue.js\";\nimport { EventTarget } from \"./utils/event-target.js\";\nimport { SegmentStorage } from \"./segment-storage/index.js\";\n\nconst FAILED_ATTEMPTS_CLEAR_INTERVAL = 60000;\nconst PEER_UPDATE_LATENCY = 1000;\n\nexport class HybridLoader {\n  private readonly requests: RequestsContainer;\n  private engineRequest?: EngineRequest;\n  private readonly p2pLoaders: P2PLoadersContainer;\n  private readonly playback: Playback;\n  private readonly segmentAvgDuration: number;\n  private readonly logger: debug.Debugger;\n  private storageCleanUpIntervalId?: number;\n  private levelChangedTimestamp?: number;\n  private lastQueueProcessingTimeStamp?: number;\n  private randomHttpDownloadInterval?: number;\n  private isProcessQueueMicrotaskCreated = false;\n\n  constructor(\n    private streamManifestUrl: string,\n    private lastRequestedSegment: Readonly<SegmentWithStream>,\n    private readonly streamDetails: Required<Readonly<StreamDetails>>,\n    private readonly config: StreamConfig,\n    private readonly bandwidthCalculators: BandwidthCalculators,\n    private readonly segmentStorage: SegmentStorage,\n    private readonly eventTarget: EventTarget<CoreEventMap>,\n  ) {\n    const activeStream = this.lastRequestedSegment.stream;\n    this.playback = { position: this.lastRequestedSegment.startTime, rate: 1 };\n    this.segmentAvgDuration = StreamUtils.getSegmentAvgDuration(activeStream);\n    this.requests = new RequestsContainer(\n      this.requestProcessQueueMicrotask,\n      this.bandwidthCalculators,\n      this.playback,\n      this.config,\n      this.eventTarget,\n    );\n\n    this.p2pLoaders = new P2PLoadersContainer(\n      this.streamManifestUrl,\n      this.lastRequestedSegment.stream,\n      this.requests,\n      this.segmentStorage,\n      this.config,\n      this.eventTarget,\n      this.requestProcessQueueMicrotask,\n    );\n\n    this.logger = debug(`p2pml-core:hybrid-loader-${activeStream.type}`);\n    this.logger.color = \"coral\";\n\n    this.setIntervalLoading();\n  }\n\n  private setIntervalLoading() {\n    const peersCount = this.p2pLoaders.currentLoader.connectedPeerCount;\n    const randomTimeout =\n      Math.random() * PEER_UPDATE_LATENCY * peersCount + PEER_UPDATE_LATENCY;\n    this.randomHttpDownloadInterval = window.setTimeout(() => {\n      this.loadRandomThroughHttp();\n      this.setIntervalLoading();\n    }, randomTimeout);\n  }\n\n  // api method for engines\n  async loadSegment(\n    segment: Readonly<SegmentWithStream>,\n    callbacks: EngineCallbacks,\n  ) {\n    this.logger(`requests: ${LoggerUtils.getSegmentString(segment)}`);\n    const { stream } = segment;\n    if (stream !== this.lastRequestedSegment.stream) {\n      this.logger(`stream changed to ${LoggerUtils.getStreamString(stream)}`);\n      this.p2pLoaders.changeCurrentLoader(stream);\n    }\n    this.lastRequestedSegment = segment;\n\n    const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n    const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, stream);\n\n    this.segmentStorage.onSegmentRequested(\n      swarmId,\n      streamSwarmId,\n      segment.externalId,\n      segment.startTime,\n      segment.endTime,\n      stream.type,\n      this.streamDetails.isLive,\n    );\n    const engineRequest = new EngineRequest(segment, callbacks);\n\n    try {\n      const hasSegment = this.segmentStorage.hasSegment(\n        swarmId,\n        streamSwarmId,\n        segment.externalId,\n      );\n\n      if (hasSegment) {\n        const data = await this.segmentStorage.getSegmentData(\n          swarmId,\n          streamSwarmId,\n          segment.externalId,\n        );\n        if (data) {\n          const { queueDownloadRatio } = this.generateQueue();\n          engineRequest.resolve(data, this.getBandwidth(queueDownloadRatio));\n          return;\n        }\n      }\n\n      this.engineRequest?.abort();\n      this.engineRequest = engineRequest;\n    } catch {\n      engineRequest.reject();\n    } finally {\n      this.requestProcessQueueMicrotask();\n    }\n  }\n\n  private requestProcessQueueMicrotask = (force = true) => {\n    const now = performance.now();\n    if (\n      (!force &&\n        this.lastQueueProcessingTimeStamp !== undefined &&\n        now - this.lastQueueProcessingTimeStamp <= 1000) ||\n      this.isProcessQueueMicrotaskCreated\n    ) {\n      return;\n    }\n\n    this.isProcessQueueMicrotaskCreated = true;\n    queueMicrotask(() => {\n      try {\n        this.processQueue();\n        this.lastQueueProcessingTimeStamp = now;\n      } finally {\n        this.isProcessQueueMicrotaskCreated = false;\n      }\n    });\n  };\n\n  private processRequests(\n    queueSegmentIds: Set<string>,\n    queueDownloadRatio: number,\n  ) {\n    const { stream } = this.lastRequestedSegment;\n    const { httpErrorRetries } = this.config;\n    const now = performance.now();\n    for (const request of this.requests.items()) {\n      const {\n        downloadSource: type,\n        status,\n        segment,\n        isHandledByProcessQueue,\n      } = request;\n      const engineRequest =\n        this.engineRequest?.segment === segment\n          ? this.engineRequest\n          : undefined;\n\n      switch (status) {\n        case \"loading\":\n          if (!queueSegmentIds.has(segment.runtimeId) && !engineRequest) {\n            request.abortFromProcessQueue();\n            this.requests.remove(request);\n          }\n          break;\n\n        case \"succeed\": {\n          if (!type) break;\n          if (type === \"http\") {\n            this.p2pLoaders.currentLoader.broadcastAnnouncement();\n          }\n          if (engineRequest) {\n            engineRequest.resolve(\n              request.data,\n              this.getBandwidth(queueDownloadRatio),\n            );\n            this.engineRequest = undefined;\n          }\n          this.requests.remove(request);\n\n          const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n          const streamSwarmId = StreamUtils.getStreamSwarmId(swarmId, stream);\n\n          void this.segmentStorage.storeSegment(\n            swarmId,\n            streamSwarmId,\n            segment.externalId,\n            request.data,\n            segment.startTime,\n            segment.endTime,\n            segment.stream.type,\n            this.streamDetails.isLive,\n          );\n          break;\n        }\n\n        case \"failed\":\n          if (type === \"http\" && !isHandledByProcessQueue) {\n            this.p2pLoaders.currentLoader.broadcastAnnouncement();\n          }\n          if (\n            !engineRequest &&\n            !stream.segments.has(request.segment.runtimeId)\n          ) {\n            this.requests.remove(request);\n          }\n          if (\n            request.failedAttempts.httpAttemptsCount >= httpErrorRetries &&\n            engineRequest\n          ) {\n            this.engineRequest = undefined;\n            engineRequest.reject();\n          }\n          break;\n\n        case \"not-started\":\n          this.requests.remove(request);\n          break;\n\n        case \"aborted\":\n          this.requests.remove(request);\n          break;\n      }\n\n      request.markHandledByProcessQueue();\n      const { lastAttempt } = request.failedAttempts;\n      if (\n        lastAttempt &&\n        now - lastAttempt.error.timestamp > FAILED_ATTEMPTS_CLEAR_INTERVAL\n      ) {\n        request.failedAttempts.clear();\n      }\n    }\n  }\n\n  private processQueue() {\n    const { queue, queueSegmentIds, queueDownloadRatio } = this.generateQueue();\n    this.processRequests(queueSegmentIds, queueDownloadRatio);\n\n    const {\n      simultaneousHttpDownloads,\n      simultaneousP2PDownloads,\n      httpErrorRetries,\n    } = this.config;\n\n    if (\n      this.engineRequest?.shouldBeStartedImmediately &&\n      this.engineRequest.status === \"pending\" &&\n      this.requests.executingHttpCount < simultaneousHttpDownloads\n    ) {\n      const { segment } = this.engineRequest;\n      const request = this.requests.get(segment);\n      if (\n        !request ||\n        request.status === \"not-started\" ||\n        (request.status === \"failed\" &&\n          request.failedAttempts.httpAttemptsCount <\n            this.config.httpErrorRetries)\n      ) {\n        this.loadThroughHttp(segment);\n      }\n    }\n\n    for (const item of queue) {\n      const { statuses, segment } = item;\n      const request = this.requests.get(segment);\n\n      if (statuses.isHighDemand) {\n        if (\n          request?.downloadSource === \"http\" &&\n          request.status === \"loading\"\n        ) {\n          continue;\n        }\n\n        if (\n          request?.downloadSource === \"http\" &&\n          request.status === \"failed\" &&\n          request.failedAttempts.httpAttemptsCount >= httpErrorRetries\n        ) {\n          continue;\n        }\n\n        const isP2PLoadingRequest =\n          request?.status === \"loading\" && request.downloadSource === \"p2p\";\n\n        if (this.requests.executingHttpCount < simultaneousHttpDownloads) {\n          if (isP2PLoadingRequest) request.abortFromProcessQueue();\n          this.loadThroughHttp(segment);\n          continue;\n        }\n\n        if (\n          this.abortLastHttpLoadingInQueueAfterItem(queue, segment) &&\n          this.requests.executingHttpCount < simultaneousHttpDownloads\n        ) {\n          if (isP2PLoadingRequest) request.abortFromProcessQueue();\n          this.loadThroughHttp(segment);\n          continue;\n        }\n\n        if (isP2PLoadingRequest) continue;\n\n        if (this.requests.executingP2PCount < simultaneousP2PDownloads) {\n          this.loadThroughP2P(segment);\n          continue;\n        }\n\n        if (\n          this.abortLastP2PLoadingInQueueAfterItem(queue, segment) &&\n          this.requests.executingP2PCount < simultaneousP2PDownloads\n        ) {\n          this.loadThroughP2P(segment);\n          continue;\n        }\n      } else if (statuses.isP2PDownloadable) {\n        if (request?.status === \"loading\") continue;\n\n        if (this.requests.executingP2PCount < simultaneousP2PDownloads) {\n          this.loadThroughP2P(segment);\n        } else if (\n          this.p2pLoaders.currentLoader.isSegmentLoadedBySomeone(segment)\n        ) {\n          if (\n            this.abortLastP2PLoadingInQueueAfterItem(queue, segment) &&\n            this.requests.executingP2PCount < simultaneousP2PDownloads\n          ) {\n            this.loadThroughP2P(segment);\n          }\n        }\n      }\n    }\n  }\n\n  // api method for engines\n  abortSegmentRequest(segmentRuntimeId: string) {\n    if (this.engineRequest?.segment.runtimeId !== segmentRuntimeId) return;\n    this.engineRequest.abort();\n    this.logger(\n      \"abort: \",\n      LoggerUtils.getSegmentString(this.engineRequest.segment),\n    );\n    this.engineRequest = undefined;\n    this.requestProcessQueueMicrotask();\n  }\n\n  private loadThroughHttp(segment: SegmentWithStream) {\n    const request = this.requests.getOrCreateRequest(segment);\n    new HttpRequestExecutor(request, this.config, this.eventTarget);\n    this.p2pLoaders.currentLoader.broadcastAnnouncement();\n  }\n\n  private loadThroughP2P(segment: SegmentWithStream) {\n    this.p2pLoaders.currentLoader.downloadSegment(segment);\n  }\n\n  private loadRandomThroughHttp() {\n    const availableStorageCapacityPercent =\n      this.getAvailableStorageCapacityPercent();\n    if (availableStorageCapacityPercent <= 10) return;\n\n    const { simultaneousHttpDownloads, httpErrorRetries } = this.config;\n    const p2pLoader = this.p2pLoaders.currentLoader;\n\n    if (\n      this.requests.executingHttpCount >= simultaneousHttpDownloads ||\n      !p2pLoader.connectedPeerCount\n    ) {\n      return;\n    }\n\n    const segmentsToLoad: SegmentWithStream[] = [];\n    for (const { segment, statuses } of QueueUtils.generateQueue(\n      this.lastRequestedSegment,\n      this.playback,\n      this.config,\n      this.p2pLoaders.currentLoader,\n      availableStorageCapacityPercent,\n    )) {\n      const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n      const streamSwarmId = StreamUtils.getStreamSwarmId(\n        swarmId,\n        segment.stream,\n      );\n\n      if (\n        !statuses.isHttpDownloadable ||\n        statuses.isP2PDownloadable ||\n        this.segmentStorage.hasSegment(\n          swarmId,\n          streamSwarmId,\n          segment.externalId,\n        )\n      ) {\n        continue;\n      }\n      const request = this.requests.get(segment);\n      if (\n        request &&\n        (request.status === \"loading\" ||\n          request.status === \"succeed\" ||\n          request.failedAttempts.httpAttemptsCount >= httpErrorRetries)\n      ) {\n        continue;\n      }\n      segmentsToLoad.push(segment);\n    }\n\n    if (!segmentsToLoad.length) return;\n\n    const availableHttpDownloads =\n      simultaneousHttpDownloads - this.requests.executingHttpCount;\n\n    if (availableHttpDownloads === 0) return;\n\n    const peersCount = p2pLoader.connectedPeerCount + 1;\n    const safeRandomSegmentsCount = Math.min(\n      segmentsToLoad.length,\n      simultaneousHttpDownloads * peersCount,\n    );\n\n    const randomIndices = Utils.shuffleArray(\n      Array.from({ length: safeRandomSegmentsCount }, (_, i) => i),\n    );\n\n    let probability = safeRandomSegmentsCount / peersCount;\n\n    for (const randomIndex of randomIndices) {\n      if (this.requests.executingHttpCount >= simultaneousHttpDownloads) {\n        break;\n      }\n\n      if (probability >= 1 || Math.random() <= probability) {\n        const segment = segmentsToLoad[randomIndex];\n        this.loadThroughHttp(segment);\n      }\n\n      probability--;\n      if (probability <= 0) break;\n    }\n  }\n\n  private abortLastHttpLoadingInQueueAfterItem(\n    queue: QueueUtils.QueueItem[],\n    segment: SegmentWithStream,\n  ): boolean {\n    for (const { segment: itemSegment } of Utils.arrayBackwards(queue)) {\n      if (itemSegment === segment) break;\n      const request = this.requests.get(itemSegment);\n      if (request?.downloadSource === \"http\" && request.status === \"loading\") {\n        request.abortFromProcessQueue();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private abortLastP2PLoadingInQueueAfterItem(\n    queue: QueueUtils.QueueItem[],\n    segment: SegmentWithStream,\n  ): boolean {\n    for (const { segment: itemSegment } of Utils.arrayBackwards(queue)) {\n      if (itemSegment === segment) break;\n      const request = this.requests.get(itemSegment);\n      if (request?.downloadSource === \"p2p\" && request.status === \"loading\") {\n        request.abortFromProcessQueue();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private getAvailableStorageCapacityPercent(): number {\n    const { totalCapacity, usedCapacity } = this.segmentStorage.getUsage();\n    return 100 - (usedCapacity / totalCapacity) * 100;\n  }\n\n  private generateQueue() {\n    const queue: QueueItem[] = [];\n    const queueSegmentIds = new Set<string>();\n    let maxPossibleLength = 0;\n    let alreadyLoadedCount = 0;\n\n    const availableStorageCapacityPercent =\n      this.getAvailableStorageCapacityPercent();\n    for (const item of QueueUtils.generateQueue(\n      this.lastRequestedSegment,\n      this.playback,\n      this.config,\n      this.p2pLoaders.currentLoader,\n      availableStorageCapacityPercent,\n    )) {\n      maxPossibleLength++;\n      const { segment } = item;\n\n      const swarmId = this.config.swarmId ?? this.streamManifestUrl;\n      const streamSwarmId = StreamUtils.getStreamSwarmId(\n        swarmId,\n        segment.stream,\n      );\n\n      if (\n        this.segmentStorage.hasSegment(\n          swarmId,\n          streamSwarmId,\n          segment.externalId,\n        ) ||\n        this.requests.get(segment)?.status === \"succeed\"\n      ) {\n        alreadyLoadedCount++;\n        continue;\n      }\n      queue.push(item);\n      queueSegmentIds.add(segment.runtimeId);\n    }\n\n    return {\n      queue,\n      queueSegmentIds,\n      maxPossibleLength,\n      alreadyLoadedCount,\n      queueDownloadRatio:\n        maxPossibleLength !== 0 ? alreadyLoadedCount / maxPossibleLength : 0,\n    };\n  }\n\n  private getBandwidth(queueDownloadRatio: number) {\n    const { http, all } = this.bandwidthCalculators;\n    const { activeLevelBitrate } = this.streamDetails;\n    if (this.streamDetails.activeLevelBitrate === 0) {\n      return all.getBandwidthLoadingOnly(3);\n    }\n\n    const bandwidth = Math.max(\n      all.getBandwidth(30, this.levelChangedTimestamp),\n      all.getBandwidth(60, this.levelChangedTimestamp),\n      all.getBandwidth(90, this.levelChangedTimestamp),\n    );\n\n    if (queueDownloadRatio >= 0.8 || bandwidth >= activeLevelBitrate * 0.9) {\n      return Math.max(\n        all.getBandwidthLoadingOnly(1),\n        all.getBandwidthLoadingOnly(3),\n        all.getBandwidthLoadingOnly(5),\n      );\n    }\n\n    const httpRealBandwidth = Math.max(\n      http.getBandwidthLoadingOnly(1),\n      http.getBandwidthLoadingOnly(3),\n      http.getBandwidthLoadingOnly(5),\n    );\n\n    return Math.max(bandwidth, httpRealBandwidth);\n  }\n\n  notifyLevelChanged() {\n    this.levelChangedTimestamp = performance.now();\n  }\n\n  sendBroadcastAnnouncement(sendEmptySegmentsAnnouncement = false) {\n    this.p2pLoaders.currentLoader.broadcastAnnouncement(\n      sendEmptySegmentsAnnouncement,\n    );\n  }\n\n  updatePlayback(position: number, rate: number) {\n    const isRateChanged = this.playback.rate !== rate;\n    const isPositionChanged = this.playback.position !== position;\n\n    if (!isRateChanged && !isPositionChanged) return;\n\n    const isPositionSignificantlyChanged =\n      Math.abs(position - this.playback.position) / this.segmentAvgDuration >\n      0.5;\n\n    if (isPositionChanged) this.playback.position = position;\n    if (isRateChanged && rate !== 0) this.playback.rate = rate;\n    if (isPositionSignificantlyChanged) {\n      this.logger(\"position significantly changed\");\n      this.engineRequest?.markAsShouldBeStartedImmediately();\n    }\n    this.segmentStorage.onPlaybackUpdated(position, rate);\n    this.requestProcessQueueMicrotask(isPositionSignificantlyChanged);\n  }\n\n  updateStream(stream: StreamWithSegments) {\n    if (stream !== this.lastRequestedSegment.stream) return;\n    this.logger(`update stream: ${LoggerUtils.getStreamString(stream)}`);\n    this.requestProcessQueueMicrotask();\n  }\n\n  destroy() {\n    clearInterval(this.storageCleanUpIntervalId);\n    clearInterval(this.randomHttpDownloadInterval);\n    this.storageCleanUpIntervalId = undefined;\n    this.engineRequest?.abort();\n    this.requests.destroy();\n    this.p2pLoaders.destroy();\n  }\n}\n","export class BandwidthCalculator {\n  private loadingsCount = 0;\n  private readonly bytes: number[] = [];\n  private readonly loadingOnlyTimestamps: number[] = [];\n  private readonly timestamps: number[] = [];\n  private noLoadingsTime = 0;\n  private loadingsStoppedAt = 0;\n\n  constructor(private readonly clearThresholdMs = 20000) {}\n\n  addBytes(bytesLength: number, now = performance.now()) {\n    this.bytes.push(bytesLength);\n    this.loadingOnlyTimestamps.push(now - this.noLoadingsTime);\n    this.timestamps.push(now);\n  }\n\n  startLoading(now = performance.now()) {\n    this.clearStale();\n    if (this.loadingsCount === 0 && this.loadingsStoppedAt !== 0) {\n      this.noLoadingsTime += now - this.loadingsStoppedAt;\n    }\n    this.loadingsCount++;\n  }\n\n  stopLoading(now = performance.now()) {\n    if (this.loadingsCount > 0) {\n      this.loadingsCount--;\n      if (this.loadingsCount === 0) this.loadingsStoppedAt = now;\n    }\n  }\n\n  getBandwidthLoadingOnly(\n    seconds: number,\n    ignoreThresholdTimestamp = Number.NEGATIVE_INFINITY,\n  ) {\n    if (!this.loadingOnlyTimestamps.length) return 0;\n    const milliseconds = seconds * 1000;\n    const lastItemTimestamp =\n      this.loadingOnlyTimestamps[this.loadingOnlyTimestamps.length - 1];\n    let lastCountedTimestamp = lastItemTimestamp;\n    const threshold = lastItemTimestamp - milliseconds;\n    let totalBytes = 0;\n\n    for (let i = this.bytes.length - 1; i >= 0; i--) {\n      const timestamp = this.loadingOnlyTimestamps[i];\n      if (\n        timestamp < threshold ||\n        this.timestamps[i] < ignoreThresholdTimestamp\n      ) {\n        break;\n      }\n      lastCountedTimestamp = timestamp;\n      totalBytes += this.bytes[i];\n    }\n\n    return (totalBytes * 8000) / (lastItemTimestamp - lastCountedTimestamp);\n  }\n\n  getBandwidth(\n    seconds: number,\n    ignoreThresholdTimestamp = Number.NEGATIVE_INFINITY,\n    now = performance.now(),\n  ) {\n    if (!this.timestamps.length) return 0;\n    const milliseconds = seconds * 1000;\n    const threshold = now - milliseconds;\n    let lastCountedTimestamp = now;\n    let totalBytes = 0;\n\n    for (let i = this.bytes.length - 1; i >= 0; i--) {\n      const timestamp = this.timestamps[i];\n      if (timestamp < threshold || timestamp < ignoreThresholdTimestamp) break;\n      lastCountedTimestamp = timestamp;\n      totalBytes += this.bytes[i];\n    }\n\n    return (totalBytes * 8000) / (now - lastCountedTimestamp);\n  }\n\n  clearStale() {\n    if (!this.loadingOnlyTimestamps.length) return;\n    const threshold =\n      this.loadingOnlyTimestamps[this.loadingOnlyTimestamps.length - 1] -\n      this.clearThresholdMs;\n\n    let samplesToRemove = 0;\n    for (const timestamp of this.loadingOnlyTimestamps) {\n      if (timestamp > threshold) break;\n      samplesToRemove++;\n    }\n\n    this.bytes.splice(0, samplesToRemove);\n    this.loadingOnlyTimestamps.splice(0, samplesToRemove);\n    this.timestamps.splice(0, samplesToRemove);\n  }\n}\n","export const getStorageItemId = (streamId: string, segmentId: number) =>\n  `${streamId}|${segmentId}`;\n\nexport const isAndroid = (userAgent: string) => /Android/i.test(userAgent);\n\nexport const isIPadOrIPhone = (userAgent: string) =>\n  /iPad|iPhone/i.test(userAgent);\n\nexport const isAndroidWebview = (userAgent: string) =>\n  /Android/i.test(userAgent) && !/Chrome|Firefox/i.test(userAgent);\n","import { CommonCoreConfig, StreamConfig, StreamType } from \"../types.js\";\nimport debug from \"debug\";\nimport { SegmentStorage } from \"./index.js\";\nimport {\n  isAndroid,\n  isIPadOrIPhone,\n  isAndroidWebview,\n  getStorageItemId,\n} from \"./utils.js\";\n\ntype SegmentDataItem = {\n  segmentId: number;\n  streamId: string;\n  data: ArrayBuffer;\n  startTime: number;\n  endTime: number;\n  streamType: StreamType;\n};\n\ntype Playback = {\n  position: number;\n  rate: number;\n};\n\ntype LastRequestedSegmentInfo = {\n  streamId: string;\n  segmentId: number;\n  startTime: number;\n  endTime: number;\n  swarmId: string;\n  streamType: StreamType;\n  isLiveStream: boolean;\n};\n\nconst BYTES_PER_MiB = 1048576;\n\nexport class SegmentMemoryStorage implements SegmentStorage {\n  private readonly userAgent = navigator.userAgent;\n  private segmentMemoryStorageLimit = 4 * 1024;\n  private currentStorageUsage = 0;\n\n  private cache = new Map<string, SegmentDataItem>();\n  private readonly logger: debug.Debugger;\n  private coreConfig?: CommonCoreConfig;\n  private mainStreamConfig?: StreamConfig;\n  private secondaryStreamConfig?: StreamConfig;\n  private currentPlayback?: Playback;\n  private lastRequestedSegment?: LastRequestedSegmentInfo;\n  private segmentChangeCallback?: (streamId: string) => void;\n\n  constructor() {\n    this.logger = debug(\"p2pml-core:segment-memory-storage\");\n    this.logger.color = \"RebeccaPurple\";\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async initialize(\n    coreConfig: CommonCoreConfig,\n    mainStreamConfig: StreamConfig,\n    secondaryStreamConfig: StreamConfig,\n  ) {\n    this.coreConfig = coreConfig;\n    this.mainStreamConfig = mainStreamConfig;\n    this.secondaryStreamConfig = secondaryStreamConfig;\n\n    this.setMemoryStorageLimit();\n    this.logger(\"initialized\");\n  }\n\n  onPlaybackUpdated(position: number, rate: number) {\n    this.currentPlayback = { position, rate };\n  }\n\n  onSegmentRequested(\n    swarmId: string,\n    streamId: string,\n    segmentId: number,\n    startTime: number,\n    endTime: number,\n    streamType: StreamType,\n    isLiveStream: boolean,\n  ): void {\n    this.lastRequestedSegment = {\n      streamId,\n      segmentId,\n      startTime,\n      endTime,\n      swarmId,\n      streamType,\n      isLiveStream,\n    };\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async storeSegment(\n    _swarmId: string,\n    streamId: string,\n    segmentId: number,\n    data: ArrayBuffer,\n    startTime: number,\n    endTime: number,\n    streamType: StreamType,\n    isLiveStream: boolean,\n  ) {\n    this.clear(isLiveStream, data.byteLength);\n\n    const storageId = getStorageItemId(streamId, segmentId);\n    this.cache.set(storageId, {\n      data,\n      segmentId,\n      streamId,\n      startTime,\n      endTime,\n      streamType,\n    });\n    this.increaseStorageUsage(data.byteLength);\n\n    this.logger(`add segment: ${segmentId} to ${streamId}`);\n\n    if (!this.segmentChangeCallback) {\n      throw new Error(\"dispatchStorageUpdatedEvent is not set\");\n    }\n\n    this.segmentChangeCallback(streamId);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/require-await\n  async getSegmentData(_swarmId: string, streamId: string, segmentId: number) {\n    const segmentStorageId = getStorageItemId(streamId, segmentId);\n    const dataItem = this.cache.get(segmentStorageId);\n\n    if (dataItem === undefined) return undefined;\n\n    return dataItem.data;\n  }\n\n  getUsage() {\n    if (!this.lastRequestedSegment || !this.currentPlayback) {\n      return {\n        totalCapacity: this.segmentMemoryStorageLimit,\n        usedCapacity: this.currentStorageUsage,\n      };\n    }\n    const playbackPosition = this.currentPlayback.position;\n\n    let calculatedUsedCapacity = 0;\n    for (const { endTime, data } of this.cache.values()) {\n      if (playbackPosition > endTime) continue;\n\n      calculatedUsedCapacity += data.byteLength;\n    }\n\n    return {\n      totalCapacity: this.segmentMemoryStorageLimit,\n      usedCapacity: calculatedUsedCapacity / BYTES_PER_MiB,\n    };\n  }\n\n  hasSegment(_swarmId: string, streamId: string, externalId: number) {\n    const segmentStorageId = getStorageItemId(streamId, externalId);\n    const segment = this.cache.get(segmentStorageId);\n\n    return segment !== undefined;\n  }\n\n  getStoredSegmentIds(_swarmId: string, streamId: string) {\n    const externalIds: number[] = [];\n\n    for (const { segmentId, streamId: streamCacheId } of this.cache.values()) {\n      if (streamCacheId !== streamId) continue;\n      externalIds.push(segmentId);\n    }\n\n    return externalIds;\n  }\n\n  private clear(isLiveStream: boolean, newSegmentSize: number) {\n    if (\n      !this.currentPlayback ||\n      !this.mainStreamConfig ||\n      !this.secondaryStreamConfig ||\n      !this.coreConfig\n    ) {\n      return;\n    }\n\n    const isMemoryLimitReached = this.isMemoryLimitReached(newSegmentSize);\n\n    if (!isMemoryLimitReached && !isLiveStream) return;\n\n    const affectedStreams = new Set<string>();\n    const sortedCache = Array.from(this.cache.values()).sort(\n      (a, b) => a.startTime - b.startTime,\n    );\n\n    for (const segmentData of sortedCache) {\n      const { streamId, segmentId, data } = segmentData;\n      const storageId = getStorageItemId(streamId, segmentId);\n\n      const shouldRemove = this.shouldRemoveSegment(\n        segmentData,\n        isLiveStream,\n        this.currentPlayback.position,\n      );\n\n      if (!shouldRemove) continue;\n\n      this.cache.delete(storageId);\n      affectedStreams.add(streamId);\n      this.decreaseStorageUsage(data.byteLength);\n\n      this.logger(`Removed segment ${segmentId} from stream ${streamId}`);\n\n      if (!this.isMemoryLimitReached(newSegmentSize) && !isLiveStream) break;\n    }\n\n    this.sendUpdatesToAffectedStreams(affectedStreams);\n  }\n\n  private isMemoryLimitReached(segmentByteLength: number) {\n    return (\n      this.currentStorageUsage + segmentByteLength / BYTES_PER_MiB >\n      this.segmentMemoryStorageLimit\n    );\n  }\n\n  setSegmentChangeCallback(callback: (streamId: string) => void) {\n    this.segmentChangeCallback = callback;\n  }\n\n  private sendUpdatesToAffectedStreams(affectedStreams: Set<string>) {\n    if (affectedStreams.size === 0) return;\n\n    affectedStreams.forEach((stream) => {\n      if (!this.segmentChangeCallback) {\n        throw new Error(\"dispatchStorageUpdatedEvent is not set\");\n      }\n\n      this.segmentChangeCallback(stream);\n    });\n  }\n\n  private shouldRemoveSegment(\n    segmentData: SegmentDataItem,\n    isLiveStream: boolean,\n    currentPlaybackPosition: number,\n  ): boolean {\n    const { endTime, streamType } = segmentData;\n    const highDemandTimeWindow = this.getStreamTimeWindow(\n      streamType,\n      \"highDemandTimeWindow\",\n    );\n\n    if (currentPlaybackPosition <= endTime) return false;\n\n    if (isLiveStream) {\n      return currentPlaybackPosition > highDemandTimeWindow + endTime;\n    }\n\n    return true;\n  }\n\n  private increaseStorageUsage(segmentByteLength: number) {\n    this.currentStorageUsage += segmentByteLength / BYTES_PER_MiB;\n  }\n\n  private decreaseStorageUsage(segmentByteLength: number) {\n    this.currentStorageUsage -= segmentByteLength / BYTES_PER_MiB;\n  }\n\n  private setMemoryStorageLimit() {\n    if (this.coreConfig?.segmentMemoryStorageLimit) {\n      this.segmentMemoryStorageLimit =\n        this.coreConfig.segmentMemoryStorageLimit;\n      return;\n    }\n\n    if (isAndroidWebview(this.userAgent) || isIPadOrIPhone(this.userAgent)) {\n      this.segmentMemoryStorageLimit = 1024;\n    } else if (isAndroid(this.userAgent)) {\n      this.segmentMemoryStorageLimit = 2 * 1024;\n    }\n  }\n\n  private getStreamTimeWindow(\n    streamType: string,\n    configKey: \"highDemandTimeWindow\" | \"httpDownloadTimeWindow\",\n  ): number {\n    const config =\n      streamType === \"main\"\n        ? this.mainStreamConfig\n        : this.secondaryStreamConfig;\n\n    return config?.[configKey] ?? 0;\n  }\n\n  public destroy() {\n    this.cache.clear();\n  }\n}\n","export class EventTarget<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  EventTypesMap extends Record<string, (...args: any[]) => unknown>,\n> {\n  private events = new Map<\n    keyof EventTypesMap,\n    EventTypesMap[keyof EventTypesMap][]\n  >();\n\n  public dispatchEvent<K extends keyof EventTypesMap>(\n    eventName: K,\n    ...args: Parameters<EventTypesMap[K]>\n  ) {\n    const listeners = this.events.get(eventName);\n    if (!listeners) return;\n    for (const listener of listeners) {\n      listener(...args);\n    }\n  }\n\n  public getEventDispatcher<K extends keyof EventTypesMap>(eventName: K) {\n    let listeners = this.events.get(eventName);\n    if (!listeners) {\n      listeners = [];\n      this.events.set(eventName, listeners);\n    }\n\n    const definedListeners = listeners;\n\n    return (...args: Parameters<EventTypesMap[K]>) => {\n      for (const listener of definedListeners) {\n        listener(...args);\n      }\n    };\n  }\n\n  public addEventListener<K extends keyof EventTypesMap>(\n    eventName: K,\n    listener: EventTypesMap[K],\n  ) {\n    const listeners = this.events.get(eventName);\n    if (!listeners) {\n      this.events.set(eventName, [listener]);\n    } else {\n      listeners.push(listener);\n    }\n  }\n\n  public removeEventListener<K extends keyof EventTypesMap>(\n    eventName: K,\n    listener: EventTypesMap[K],\n  ) {\n    const listeners = this.events.get(eventName);\n    if (listeners) {\n      const index = listeners.indexOf(listener);\n      if (index !== -1) {\n        listeners.splice(index, 1);\n      }\n    }\n  }\n}\n","import { HybridLoader } from \"./hybrid-loader.js\";\nimport {\n  Stream,\n  CoreConfig,\n  Segment,\n  CoreEventMap,\n  DynamicCoreConfig,\n  EngineCallbacks,\n  StreamWithSegments,\n  SegmentWithStream,\n  CommonCoreConfig,\n  StreamConfig,\n  DefinedCoreConfig,\n  StreamType,\n  DynamicStreamConfig,\n} from \"./types.js\";\nimport { BandwidthCalculators, StreamDetails } from \"./internal-types.js\";\nimport * as StreamUtils from \"./utils/stream.js\";\nimport { BandwidthCalculator } from \"./bandwidth-calculator.js\";\nimport { SegmentMemoryStorage } from \"./segment-storage/segment-memory-storage.js\";\nimport { EventTarget } from \"./utils/event-target.js\";\nimport {\n  overrideConfig,\n  mergeAndFilterConfig,\n  deepCopy,\n  filterUndefinedProps,\n} from \"./utils/utils.js\";\nimport { TRACKER_CLIENT_VERSION_PREFIX } from \"./utils/peer.js\";\nimport { SegmentStorage } from \"./segment-storage/index.js\";\nimport { P2PTrackerClient } from \"./p2p/tracker-client.js\";\n\n/** Core class for managing media streams loading via P2P. */\nexport class Core<TStream extends Stream = Stream> {\n  /** Default configuration for common core settings. */\n  static readonly DEFAULT_COMMON_CORE_CONFIG: CommonCoreConfig = {\n    segmentMemoryStorageLimit: undefined,\n    customSegmentStorageFactory: undefined,\n  };\n\n  /** Default configuration for stream settings. */\n  static readonly DEFAULT_STREAM_CONFIG: StreamConfig = {\n    isP2PUploadDisabled: false,\n    isP2PDisabled: false,\n    simultaneousHttpDownloads: 2,\n    simultaneousP2PDownloads: 3,\n    highDemandTimeWindow: 15,\n    httpDownloadTimeWindow: 3000,\n    p2pDownloadTimeWindow: 6000,\n    webRtcMaxMessageSize: 64 * 1024 - 1,\n    p2pNotReceivingBytesTimeoutMs: 2000,\n    p2pInactiveLoaderDestroyTimeoutMs: 30 * 1000,\n    httpNotReceivingBytesTimeoutMs: 3000,\n    httpErrorRetries: 3,\n    p2pErrorRetries: 3,\n    trackerClientVersionPrefix: TRACKER_CLIENT_VERSION_PREFIX,\n    announceTrackers: [\n      \"wss://tracker.novage.com.ua\",\n      \"wss://tracker.webtorrent.dev\",\n      \"wss://tracker.openwebtorrent.com\",\n    ],\n    rtcConfig: {\n      iceServers: [\n        { urls: \"stun:stun.l.google.com:19302\" },\n        { urls: \"stun:global.stun.twilio.com:3478\" },\n      ],\n    },\n    validateP2PSegment: undefined,\n    validateHTTPSegment: undefined,\n    httpRequestSetup: undefined,\n    swarmId: undefined,\n  };\n\n  private readonly eventTarget = new EventTarget<CoreEventMap>();\n  private manifestResponseUrl?: string;\n  private readonly streams = new Map<string, StreamWithSegments<TStream>>();\n  private mainStreamConfig: StreamConfig;\n  private secondaryStreamConfig: StreamConfig;\n  private commonCoreConfig: CommonCoreConfig;\n  private readonly bandwidthCalculators: BandwidthCalculators = {\n    all: new BandwidthCalculator(),\n    http: new BandwidthCalculator(),\n  };\n  private segmentStorage?: SegmentStorage;\n  private mainStreamLoader?: HybridLoader;\n  private secondaryStreamLoader?: HybridLoader;\n  private streamDetails: StreamDetails = {\n    isLive: false,\n    activeLevelBitrate: 0,\n  };\n\n  /**\n   * Constructs a new Core instance with optional initial configuration.\n   *\n   * @param config - Optional partial configuration to override default settings.\n   *\n   * @example\n   * // Create a Core instance with custom configuration for HTTP and P2P downloads.\n   * const core = new Core({\n   *   simultaneousHttpDownloads: 5,\n   *   simultaneousP2PDownloads: 5,\n   *   httpErrorRetries: 5,\n   *   p2pErrorRetries: 5\n   * });\n   *\n   * @example\n   * // Create a Core instance using the default configuration.\n   * const core = new Core();\n   */\n  constructor(config?: Partial<CoreConfig>) {\n    const filteredConfig = filterUndefinedProps(config ?? {});\n\n    this.commonCoreConfig = mergeAndFilterConfig<CommonCoreConfig>({\n      defaultConfig: Core.DEFAULT_COMMON_CORE_CONFIG,\n      baseConfig: filteredConfig,\n    });\n\n    this.mainStreamConfig = mergeAndFilterConfig<StreamConfig>({\n      defaultConfig: Core.DEFAULT_STREAM_CONFIG,\n      baseConfig: filteredConfig,\n      specificStreamConfig: filteredConfig.mainStream,\n    });\n\n    this.secondaryStreamConfig = mergeAndFilterConfig<StreamConfig>({\n      defaultConfig: Core.DEFAULT_STREAM_CONFIG,\n      baseConfig: filteredConfig,\n      specificStreamConfig: filteredConfig.secondaryStream,\n    });\n  }\n\n  /**\n   * Retrieves the current configuration for the core instance, ensuring immutability.\n   *\n   * @returns A deep readonly version of the core configuration.\n   */\n  getConfig(): DefinedCoreConfig {\n    return {\n      ...deepCopy(this.commonCoreConfig),\n      mainStream: deepCopy(this.mainStreamConfig),\n      secondaryStream: deepCopy(this.secondaryStreamConfig),\n    };\n  }\n\n  /**\n   * Applies a set of dynamic configuration updates to the core, merging with the existing configuration.\n   *\n   * @param dynamicConfig - A set of configuration changes to apply.\n   *\n   * @example\n   * // Example of dynamically updating the download time windows and timeout settings.\n   * const dynamicConfig = {\n   *   httpDownloadTimeWindow: 60,  // Set HTTP download time window to 60 seconds\n   *   p2pDownloadTimeWindow: 60,   // Set P2P download time window to 60 seconds\n   *   httpNotReceivingBytesTimeoutMs: 1500,  // Set HTTP timeout to 1500 milliseconds\n   *   p2pNotReceivingBytesTimeoutMs: 1500    // Set P2P timeout to 1500 milliseconds\n   * };\n   * core.applyDynamicConfig(dynamicConfig);\n   */\n  applyDynamicConfig(dynamicConfig: DynamicCoreConfig) {\n    const { mainStream, secondaryStream } = dynamicConfig;\n\n    const mainStreamConfigCopy = deepCopy(this.mainStreamConfig);\n    const secondaryStreamConfigCopy = deepCopy(this.secondaryStreamConfig);\n\n    this.overrideAllConfigs(dynamicConfig, mainStream, secondaryStream);\n\n    this.processSpecificDynamicConfigParams(\n      mainStreamConfigCopy,\n      dynamicConfig,\n      \"main\",\n    );\n    this.processSpecificDynamicConfigParams(\n      secondaryStreamConfigCopy,\n      dynamicConfig,\n      \"secondary\",\n    );\n  }\n\n  private processSpecificDynamicConfigParams(\n    prevConfig: StreamConfig,\n    updatedConfig: DynamicCoreConfig,\n    streamType: StreamType,\n  ) {\n    const isP2PDisabled = this.getUpdatedStreamProperty(\n      \"isP2PDisabled\",\n      updatedConfig,\n      streamType,\n    );\n\n    if (isP2PDisabled && prevConfig.isP2PDisabled !== isP2PDisabled) {\n      this.destroyStreamLoader(streamType);\n    }\n\n    const isP2PUploadDisabled = this.getUpdatedStreamProperty(\n      \"isP2PUploadDisabled\",\n      updatedConfig,\n      streamType,\n    );\n\n    if (\n      isP2PUploadDisabled !== undefined &&\n      prevConfig.isP2PUploadDisabled !== isP2PUploadDisabled\n    ) {\n      const streamLoader =\n        streamType === \"main\"\n          ? this.mainStreamLoader\n          : this.secondaryStreamLoader;\n\n      streamLoader?.sendBroadcastAnnouncement(isP2PUploadDisabled);\n    }\n  }\n\n  private getUpdatedStreamProperty<K extends keyof DynamicStreamConfig>(\n    propertyName: K,\n    updatedConfig: DynamicCoreConfig,\n    streamType: StreamType,\n  ): DynamicStreamConfig[K] | undefined {\n    const updatedStreamConfig =\n      streamType === \"main\"\n        ? updatedConfig.mainStream\n        : updatedConfig.secondaryStream;\n\n    return updatedStreamConfig?.[propertyName] ?? updatedConfig[propertyName];\n  }\n\n  /**\n   * Adds an event listener for the specified event type on the core event target.\n   *\n   * @param eventName - The name of the event to listen for.\n   * @param listener - The callback function to invoke when the event is fired.\n   */\n  addEventListener<K extends keyof CoreEventMap>(\n    eventName: K,\n    listener: CoreEventMap[K],\n  ) {\n    this.eventTarget.addEventListener(eventName, listener);\n  }\n\n  /**\n   * Removes an event listener for the specified event type on the core event target.\n   *\n   * @param eventName - The name of the event to listen for.\n   * @param listener - The callback function to be removed.\n   */\n  removeEventListener<K extends keyof CoreEventMap>(\n    eventName: K,\n    listener: CoreEventMap[K],\n  ) {\n    this.eventTarget.removeEventListener(eventName, listener);\n  }\n\n  /**\n   * Sets the response URL for the manifest, stripping any query parameters.\n   *\n   * @param url - The full URL to the manifest response.\n   */\n  setManifestResponseUrl(url: string): void {\n    this.manifestResponseUrl = url.split(\"?\")[0];\n  }\n\n  /**\n   * Checks if a segment is already stored within the core.\n   *\n   * @param segmentRuntimeId - The runtime identifier of the segment to check.\n   * @returns `true` if the segment is present, otherwise `false`.\n   */\n  hasSegment(segmentRuntimeId: string): boolean {\n    return !!StreamUtils.getSegmentFromStreamsMap(\n      this.streams,\n      segmentRuntimeId,\n    );\n  }\n\n  /**\n   * Retrieves a specific stream by its runtime identifier, if it exists.\n   *\n   * @param streamRuntimeId - The runtime identifier of the stream to retrieve.\n   * @returns The stream with its segments, or `undefined` if not found.\n   */\n  getStream(streamRuntimeId: string): StreamWithSegments<TStream> | undefined {\n    return this.streams.get(streamRuntimeId);\n  }\n\n  /**\n   * Ensures a stream exists in the map; adds it if it does not.\n   *\n   * @param stream - The stream to potentially add to the map.\n   */\n  addStreamIfNoneExists(stream: TStream): void {\n    if (this.streams.has(stream.runtimeId)) return;\n\n    this.streams.set(stream.runtimeId, {\n      ...stream,\n      segments: new Map<string, SegmentWithStream<TStream>>(),\n    });\n  }\n\n  /**\n   * Updates the segments associated with a specific stream.\n   *\n   * @param streamRuntimeId - The runtime identifier of the stream to update.\n   * @param addSegments - Optional segments to add to the stream.\n   * @param removeSegmentIds - Optional segment IDs to remove from the stream.\n   */\n  updateStream(\n    streamRuntimeId: string,\n    addSegments?: Iterable<Segment>,\n    removeSegmentIds?: Iterable<string>,\n  ): void {\n    const stream = this.streams.get(streamRuntimeId);\n    if (!stream) return;\n\n    if (addSegments) {\n      for (const segment of addSegments) {\n        if (stream.segments.has(segment.runtimeId)) continue; // should not happen\n        stream.segments.set(segment.runtimeId, { ...segment, stream });\n      }\n    }\n\n    if (removeSegmentIds) {\n      for (const id of removeSegmentIds) {\n        stream.segments.delete(id);\n      }\n    }\n\n    this.mainStreamLoader?.updateStream(stream);\n    this.secondaryStreamLoader?.updateStream(stream);\n  }\n\n  /**\n   * Loads a segment given its runtime identifier and invokes the provided callbacks during the process.\n   * Initializes segment storage if it has not been initialized yet.\n   *\n   * @param segmentRuntimeId - The runtime identifier of the segment to load.\n   * @param callbacks - The callbacks to be invoked during segment loading.\n   * @throws {Error} - Throws if the manifest response URL is not defined.\n   */\n  async loadSegment(segmentRuntimeId: string, callbacks: EngineCallbacks) {\n    if (!this.manifestResponseUrl) {\n      throw new Error(\"Manifest response url is not defined\");\n    }\n\n    await this.initializeSegmentStorage();\n\n    const segment = this.identifySegment(segmentRuntimeId);\n\n    const loader = this.getStreamHybridLoader(segment);\n    void loader.loadSegment(segment, callbacks);\n  }\n\n  /**\n   * Aborts the loading of a segment specified by its runtime identifier.\n   *\n   * @param segmentRuntimeId - The runtime identifier of the segment whose loading is to be aborted.\n   */\n  abortSegmentLoading(segmentRuntimeId: string): void {\n    this.mainStreamLoader?.abortSegmentRequest(segmentRuntimeId);\n    this.secondaryStreamLoader?.abortSegmentRequest(segmentRuntimeId);\n  }\n\n  /**\n   * Updates the playback parameters while play head moves, specifically position and playback rate, for stream loaders.\n   *\n   * @param position - The new position in the stream, in seconds.\n   * @param rate - The new playback rate.\n   */\n  updatePlayback(position: number, rate: number): void {\n    this.mainStreamLoader?.updatePlayback(position, rate);\n    this.secondaryStreamLoader?.updatePlayback(position, rate);\n  }\n\n  /**\n   * Sets the active level bitrate, used for adjusting quality levels in adaptive streaming.\n   * Notifies the stream loaders if a change occurs.\n   *\n   * @param bitrate - The new bitrate to set as active.\n   */\n  setActiveLevelBitrate(bitrate: number) {\n    if (bitrate !== this.streamDetails.activeLevelBitrate) {\n      this.streamDetails.activeLevelBitrate = bitrate;\n      this.mainStreamLoader?.notifyLevelChanged();\n      this.secondaryStreamLoader?.notifyLevelChanged();\n    }\n  }\n\n  /**\n   * Updates the 'isLive' status of the stream\n   *\n   * @param isLive - Boolean indicating whether the stream is live.\n   */\n  setIsLive(isLive: boolean) {\n    this.streamDetails.isLive = isLive;\n  }\n\n  /**\n   * Identify if a segment is loadable by the P2P core based on the segment's stream type and configuration.\n   * @param segmentRuntimeId Segment runtime identifier to check.\n   * @returns `true` if the segment is loadable by the P2P core, otherwise `false`.\n   */\n  isSegmentLoadable(segmentRuntimeId: string): boolean {\n    try {\n      const segment = this.identifySegment(segmentRuntimeId);\n\n      if (\n        segment.stream.type === \"main\" &&\n        this.mainStreamConfig.isP2PDisabled\n      ) {\n        return false;\n      }\n\n      if (\n        segment.stream.type === \"secondary\" &&\n        this.secondaryStreamConfig.isP2PDisabled\n      ) {\n        return false;\n      }\n\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Cleans up resources used by the Core instance, including destroying any active stream loaders\n   * and clearing stored segments.\n   */\n  destroy(): void {\n    this.streams.clear();\n    this.mainStreamLoader?.destroy();\n    this.secondaryStreamLoader?.destroy();\n    this.segmentStorage?.destroy();\n    this.mainStreamLoader = undefined;\n    this.secondaryStreamLoader = undefined;\n    this.segmentStorage = undefined;\n    this.manifestResponseUrl = undefined;\n    this.streamDetails = { isLive: false, activeLevelBitrate: 0 };\n    P2PTrackerClient.clearPeerIdCache();\n  }\n\n  private async initializeSegmentStorage() {\n    if (this.segmentStorage) return;\n\n    const { isLive } = this.streamDetails;\n    const createCustomStorage =\n      this.commonCoreConfig.customSegmentStorageFactory;\n\n    if (createCustomStorage && typeof createCustomStorage !== \"function\") {\n      throw new Error(\"Storage configuration is invalid\");\n    }\n\n    const segmentStorage = createCustomStorage\n      ? createCustomStorage(isLive)\n      : new SegmentMemoryStorage();\n\n    await segmentStorage.initialize(\n      this.commonCoreConfig,\n      this.mainStreamConfig,\n      this.secondaryStreamConfig,\n    );\n\n    this.segmentStorage = segmentStorage;\n  }\n\n  private identifySegment(segmentRuntimeId: string): SegmentWithStream {\n    if (!this.manifestResponseUrl) {\n      throw new Error(\"Manifest response url is undefined\");\n    }\n\n    const segment = StreamUtils.getSegmentFromStreamsMap(\n      this.streams,\n      segmentRuntimeId,\n    );\n    if (!segment) {\n      throw new Error(`Not found segment with id: ${segmentRuntimeId}`);\n    }\n\n    return segment;\n  }\n\n  private overrideAllConfigs(\n    dynamicConfig: DynamicCoreConfig,\n    mainStream?: Partial<StreamConfig>,\n    secondaryStream?: Partial<StreamConfig>,\n  ) {\n    overrideConfig(this.commonCoreConfig, dynamicConfig);\n    overrideConfig(this.mainStreamConfig, dynamicConfig);\n    overrideConfig(this.secondaryStreamConfig, dynamicConfig);\n\n    if (mainStream) {\n      overrideConfig(this.mainStreamConfig, mainStream);\n    }\n\n    if (secondaryStream) {\n      overrideConfig(this.secondaryStreamConfig, secondaryStream);\n    }\n  }\n\n  private destroyStreamLoader(streamType: StreamType) {\n    if (streamType === \"main\") {\n      this.mainStreamLoader?.destroy();\n      this.mainStreamLoader = undefined;\n    } else {\n      this.secondaryStreamLoader?.destroy();\n      this.secondaryStreamLoader = undefined;\n    }\n  }\n\n  private getStreamHybridLoader(segment: SegmentWithStream) {\n    if (segment.stream.type === \"main\") {\n      this.mainStreamLoader ??= this.createNewHybridLoader(segment);\n      return this.mainStreamLoader;\n    } else {\n      this.secondaryStreamLoader ??= this.createNewHybridLoader(segment);\n      return this.secondaryStreamLoader;\n    }\n  }\n\n  private createNewHybridLoader(segment: SegmentWithStream) {\n    if (!this.manifestResponseUrl) {\n      throw new Error(\"Manifest response url is not defined\");\n    }\n\n    if (!this.segmentStorage) {\n      throw new Error(\"Segment storage is not initialized\");\n    }\n\n    const streamConfig =\n      segment.stream.type === \"main\"\n        ? this.mainStreamConfig\n        : this.secondaryStreamConfig;\n\n    return new HybridLoader(\n      this.manifestResponseUrl,\n      segment,\n      this.streamDetails,\n      streamConfig,\n      this.bandwidthCalculators,\n      this.segmentStorage,\n      this.eventTarget,\n    );\n  }\n}\n"],"names":["RequestError","Error","type","message","super","this","timestamp","performance","now","CoreRequestError","HttpRequestExecutor","request","httpConfig","eventTarget","onChunkDownloaded","getEventDispatcher","byteRange","segment","requestByteRange","loadedBytes","start","totalBytes","expectedBytesLength","requestControls","downloadSource","abort","abortController","notReceivingBytesTimeoutMs","httpNotReceivingBytesTimeoutMs","fetch","AbortController","httpRequestSetup","url","signal","headers","Headers","Range","end","Request","aborted","DOMException","response","window","handleResponseHeaders","body","firstBytesReceived","reader","getReader","chunk","async","done","value","read","addLoadedChunk","byteLength","validateHTTPSegment","data","clearLoadedBytes","completeOnSuccess","error","handleError","ok","status","statusText","contentLengthHeader","get","contentRangeHeader","contentRange","headerValue","match","rangeHeaderRegex","exec","trim","from","to","total","parseInt","responseExpectedBytesLength","setTotalBytes","name","httpLoaderError","abortOnError","getDefaultExportFromCjs","x","__esModule","Object","prototype","hasOwnProperty","call","cachedSetTimeout","cachedClearTimeout","browser","exports","process","defaultSetTimout","defaultClearTimeout","runTimeout","fun","setTimeout","e","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","marker","Item","array","noop","nextTick","args","Array","arguments","i","push","apply","title","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","process$1","s","m","h","d","w","y","plural","ms","msAbs","n","isPlural","Math","round","val","options","str","String","parseFloat","toLowerCase","isFinite","long","abs","JSON","stringify","formatArgs","useColors","namespace","module","humanize","diff","c","color","splice","index","lastC","replace","save","namespaces","storage","setItem","removeItem","load","r","getItem","DEBUG","__nwjs","navigator","userAgent","document","documentElement","style","WebkitAppearance","console","firebug","exception","table","localStorage","localstorage","destroy","warned","warn","colors","log","debug","common","createDebug","prevTime","namespacesCache","enabledCache","enableOverride","enabled","self","curr","Number","Date","prev","coerce","unshift","format","formatter","formatters","selectColor","extend","defineProperty","enumerable","configurable","set","v","init","delimiter","newDebug","matchesTemplate","search","template","searchIndex","templateIndex","starIndex","matchIndex","default","stack","disable","names","skips","map","join","enable","split","filter","Boolean","ns","slice","skip","require$$0","keys","forEach","key","hash","charCodeAt","j","ReflectOwnKeys","R","Reflect","ReflectApply","target","receiver","Function","ownKeys","getOwnPropertySymbols","getOwnPropertyNames","NumberIsNaN","isNaN","EventEmitter","eventsModule","emitter","Promise","resolve","reject","errorListener","err","resolver","eventTargetAgnosticAddListener","handler","flags","_events","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","TypeError","_getMaxListeners","that","_addListener","prepend","events","existing","warning","create","newListener","count","onceWrapper","fired","wrapFn","_onceWrap","state","wrapped","bind","_listeners","unwrap","evlistener","arr","ret","arrayClone","listenerCount","copy","addEventListener","wrapListener","arg","removeEventListener","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","doError","er","context","list","position","originalListener","shift","pop","rawListeners","eventNames","wrappy","wrappy_1","fn","cb","k","wrapper","f","called","onceStrict","onceError","onceModule","strict","proto","promise","queueMicrotask_1","queueMicrotask","global","then","catch","runParallel_1","tasks","results","pending","isSync","isArray","each","result","task","scope","RTCPeerConnection","mozRTCPeerConnection","webkitRTCPeerConnection","RTCSessionDescription","mozRTCSessionDescription","webkitRTCSessionDescription","RTCIceCandidate","mozRTCIceCandidate","webkitRTCIceCandidate","FixedFIFO","fixedSize","hwm","buffer","mask","top","btm","next","fill","undefined","last","peek","isEmpty","fastFifo","head","tail","clear","browserDecoder","encoding","decoder","TextDecoder","remaining","decode","stream","Uint8Array","PassThroughDecoder","UTF8Decoder","require$$1","textDecoder","flush","_default","STREAM_DESTROYED","PREMATURE_CLOSE","FIFO","require$$2","qmt","MAX","NOT_OPENING","NOT_PREDESTROYING","READ_UPDATING","READ_PRIMARY","READ_QUEUED","READ_RESUMED","READ_ENDING","READ_EMIT_DATA","READ_EMIT_READABLE","READ_EMITTED_READABLE","READ_DONE","READ_NEXT_TICK","READ_READ_AHEAD","READ_RESUMED_READ_AHEAD","READ_NOT_ACTIVE","READ_PUSHED","READ_PIPE_NOT_DRAINED","READ_NOT_NEXT_TICK","READ_NO_READ_AHEAD","WRITE_ACTIVE","WRITE_UPDATING","WRITE_PRIMARY","WRITE_QUEUED","WRITE_UNDRAINED","WRITE_DONE","WRITE_EMIT_DRAIN","WRITE_NEXT_TICK","WRITE_WRITING","WRITE_FINISHING","WRITE_CORKED","WRITE_NON_PRIMARY","WRITE_NOT_NEXT_TICK","WRITE_NOT_CORKED","ACTIVE","READ_ACTIVE","NOT_ACTIVE","DONE","DESTROY_STATUS","DESTROYING","OPEN_STATUS","AUTO_DESTROY","ACTIVE_OR_TICKING","IS_OPENING","WRITE_QUEUED_AND_ACTIVE","WRITE_STATUS","asyncIterator","Symbol","WritableState","highWaterMark","mapWritable","byteLengthWritable","buffered","pipeline","drains","defaultByteLength","afterWrite","afterUpdateNextTick","updateWriteNT","ended","_duplexState","_writableState","_writev","update","_write","updateNonPrimary","continueUpdate","_final","afterFinal","_open","afterOpen","_destroy","afterDestroy","updateCallback","updateNextTick","ReadableState","mapReadable","byteLengthReadable","readAhead","pipeTo","afterRead","updateReadNT","Pipeline","isStreamx","finished","onerror","onclose","afterDrain","write","drain","_read","updateNextTickIfOpen","TransformState","afterTransform","src","dst","afterPipe","pipeToFinished","rs","_readableState","ws","writes","Stream","opts","open","predestroy","_predestroy","readable","writable","destroyed","destroying","Readable","OPENING","eagerOpen","setEncoding","dec","echo","dest","pipe","resume","pause","ite","return","_fromAsyncIterator","promiseResolve","promiseReject","ondata","throw","Writable","writev","final","cork","batch","autoBatch","Duplex","min","uncork","Transform","_transformState","transform","_transform","_flush","transformAfterFlush","streams","all","errorHandle","fin","autoDestroy","rd","wr","isStream","streamx","pipelinePromise","isEnded","isFinished","isDisturbed","getStreamError","PassThrough","assign","obj","props","errCode","code","_","ErrClass","alphabet","encodeLookup","decodeLookup","arr2hex","string","hex2arr","sizeof","chars","lookup","arr2text","enc","encoder","TextEncoder","text2arr","encode","bin2hex","res","hex2bin","hex","points","fromCharCode","subarray","crypto","msCrypto","subtle","webkitSubtle","randomBytes","size","view","getRandomValues","Debug","MAX_BUFFERED_AMOUNT","filterTrickle","sdp","Peer","_pc","allowHalfOpen","__objectMode","objectMode","_id","_debug","channelName","initiator","channelConfig","channelNegotiated","negotiated","config","offerOptions","answerOptions","sdpTransform","trickle","allowHalfTrickle","iceCompleteTimeout","_destroying","_connected","remoteAddress","remoteFamily","remotePort","localAddress","localFamily","localPort","_pcReady","_channelReady","_iceComplete","_iceCompleteTimer","_channel","_pendingCandidates","_isNegotiating","_firstNegotiation","_batchedNegotiation","_queuedNegotiation","_sendersAwaitingStable","_closingInterval","_remoteTracks","_remoteStreams","_chunk","_cb","_interval","__destroy","_isReactNativeWebrtc","_peerConnectionId","oniceconnectionstatechange","_onIceStateChange","onicegatheringstatechange","onconnectionstatechange","_onConnectionStateChange","onsignalingstatechange","_onSignalingStateChange","onicecandidate","event","_onIceCandidate","peerIdentity","_setupData","channel","createDataChannel","ondatachannel","_needsNegotiation","_onFinishBound","_onFinish","bufferedAmount","readyState","port","family","address","parse","renegotiate","transceiverRequest","addTransceiver","kind","candidate","remoteDescription","_addIceCandidate","setRemoteDescription","_createAnswer","iceCandidateObj","addIceCandidate","endsWith","send","negotiate","_createOffer","_senderMap","clearInterval","close","onmessage","onopen","ontrack","binaryType","bufferedAmountLowThreshold","label","_onChannelMessage","onbufferedamountlow","_onChannelBufferedAmountLow","_onChannelOpen","_onChannelClose","filename","lineno","colno","isClosing","setInterval","destroySoon","_startIceCompleteTimeout","createOffer","offer","sendOffer","localDescription","setLocalDescription","createAnswer","answer","sendAnswer","_requestMissingTransceivers","connectionState","iceConnectionState","iceGatheringState","_maybeReady","flattenValues","report","toString","values","getStats","reports","stat","id","_connecting","findCandidatePair","items","remoteCandidates","localCandidates","candidatePairs","foundSelectedCandidatePair","item","setSelectedCandidatePair","selectedCandidatePair","local","localCandidateId","ip","ipAddress","portNumber","googLocalAddress","includes","remote","remoteCandidateId","googRemoteAddress","selectedCandidatePairId","googActiveConnection","selected","_onInterval","unref","signalingState","sender","removeTrack","sdpMLineIndex","sdpMid","ArrayBuffer","WEBRTC_SUPPORT","iceServers","urls","sdpSemantics","UDPTracker","DEFAULT_ANNOUNCE_PEERS","MAX_ANNOUNCE_PEERS","parseUrl","URL","defineProperties","href","protocol","origin","_WebSocket","WebSocket","Socket","socket","connected","_ws","OPEN","_handleOpen","_handleMessage","_handleClose","_handleError","_handleFinishBound","_handleFinish","onClose","CLOSED","WEBSOCKET_SUPPORT","Tracker","client","announceUrl","interval","intervalMs","DEFAULT_ANNOUNCE_INTERVAL","announce","_defaultAnnounceOpts","socketPool","WebSocketTracker","peers","reconnecting","retries","reconnectTimer","expectingResponse","_openSocket","params","action","info_hash","_infoHashBinary","peer_id","_peerIdBinary","_trackerId","trackerid","_send","numwant","_generateOffers","offers","scrape","infoHash","peerId","peer","trackerTimeout","_onSocketConnectBound","_onSocketDataBound","_onSocketCloseBound","_onSocketErrorBound","consumers","destroyCleanup","DESTROY_TIMEOUT","_onSocketConnect","_onSocketError","_onSocketData","_onSocketClose","parsedUrl","agent","_proxyOpts","httpsAgent","httpAgent","socksProxy","_onAnnounceResponse","_onScrapeResponse","failure","trackerId","complete","_createPeer","to_peer_id","offer_id","offerId","files","_startReconnectTimer","floor","random","pow","generateOffer","checkDone","_rtcConfig","wrtc","_wrtc","onError","onConnect","_socketPool","Client","_peerIdBuffer","_infoHashBuffer","_port","_getAnnounceOpts","getAnnounceOpts","rtcConfig","_userAgent","proxyOpts","isView","substring","Set","webrtcSupport","nextTickWarn","_trackers","HTTPTracker","location","_announce","tracker","parallel","uploaded","downloaded","clientOpts","FF","a","b","GG","HH","II","byteToHex","byte","substr","bs","wordToBytes","word","utf8toBytes","utf8","unescape","encodeURIComponent","md5Module","utf8toMD5","toHex","bytesToMD5","fromBytes","bytes","words","bytes_count","bits_count","Uint32Array","AA","BB","CC","DD","hash_bytes","fromUtf8","b64","to64","u","charAt","b64_map","gen_salt","salt","crypt","setting","md","kl","TRACKER_CLIENT_VERSION_PREFIX","versionString","splittedVersion","padStart","HASH_SYMBOLS","getStreamString","getSegmentString","externalId","joinChunks","chunks","reduce","sum","offset","utf8ToUintArray","utf8String","encodeInto","arrayBackwards","isObject","deepCopy","element","overrideConfig","updates","defaults","keyStr","updateValue","defaultValue","mergeAndFilterConfig","defaultConfig","baseConfig","specificStreamConfig","mergedConfig","keysOfT","filteredConfig","PeerCommandType","SerializedItem","intToBytes","num","isNegative","bytesAmountNumber","binaryString","necessaryBits","ceil","bytesAmount","BigInt","bytesToInt","getNumberPart","number","serializeInt","numBytes","numberMetadata","deserializeInt","metadata","numberBytesLength","deserializeSimilarIntArray","codeByte","commonPartArraysAmount","originalIntArr","commonPartWithLength","arrayLength","commonPart","diffPart","numbers","deserializeString","lengthByte","stringBytes","ResizableUint8Array","_length","addBytes","bytesToAdd","getBytesChunks","getBuffer","commandFrameStart","stringToUtf8CodesBuffer","commandFrameEnd","commandDivFrameStart","commandDivFrameEnd","startFrames","endFrames","commandFramesLength","isCommandChunk","bufferEndingToCompare","some","frame","areBuffersEqual","BinaryCommandJoiningError","BinaryCommandChunksJoiner","onComplete","Serialization.ResizableUint8Array","isFirstChunk","unframeCommandChunk","BinaryCommandCreator","commandType","maxChunkLength","resultBuffers","Serialization.serializeInt","commonPartNumbersMap","Map","diffByte","binaryArray","unframedBuffer","frameBuffer","chunksCount","chunkLength","getResultBuffers","deserializeCommand","commandCode","deserializedCommand","getDataTypeFromByte","Serialization.SerializedItem","Int","Serialization.deserializeInt","SimilarIntArray","Serialization.deserializeSimilarIntArray","Serialization.deserializeString","typeCode","Min","Max","frameStart","frameEnd","buffer1","buffer2","serializePeerCommand","command","maxChunkSize","CancelSegmentRequest","SegmentAbsent","SegmentDataSendingCompleted","creator","addInteger","SegmentRequest","SegmentsAnnouncement","p","loadingByHttp","l","loaded","addSimilarIntArr","SegmentData","PeerProtocol","connection","peerConfig","eventHandlers","onChunkUploaded","onDataReceived","commandChunks","uploadingContext","Command.isCommandChunk","receivingCommandBytes","onSegmentChunkReceived","idUtf8","binaryCommandBuffers","Command.serializePeerCommand","webRtcMaxMessageSize","stopUploadingSegmentData","stopUploading","getUploadingRequestId","requestId","bytesLeft","bytesToSend","rej","Utils.getControlledPromise","isUploadingSegmentData","sendChunk","drained","Command.BinaryCommandChunksJoiner","commandBuffer","Command.deserializeCommand","onCommandReceived","addCommandChunk","Command.BinaryCommandJoiningError","Command","streamType","onPeerClosed","getPeerIdFromConnection","peerProtocol","onConnectionError","onPeerConnectionClosed","downloadingContext","loadedSegments","httpLoadingSegments","downloadingErrors","logger","downloadingSegment","has","onSegmentsAnnouncement","onSegmentRequested","isSegmentDataCommandReceived","controls","sendCancelSegmentRequestCommand","cancelSegmentDownloading","isValid","validateP2PSegment","delete","segmentRequest","p2pNotReceivingBytesTimeoutMs","p2pErrorRetries","sendCommand","splitSegmentDataToChunksAndUploadAsync","sendSegmentDataSendingCompletedCommand","loadedSegmentsIds","httpLoadingSegmentsIds","segmentExternalId","hexString","isSafariOrWkWebview","isSafari","test","isWkWebview","P2PTrackerClient","streamSwarmId","streamHash","streamId","binary15BytesHashString","md5","btoa","streamShortId","LoggerUtils.getStreamString","PEER_ID_BY_INFO_HASH","trackerClientVersionPrefix","trackerClientId","randomCharsCount","TrackerClient","announceTrackers","onReceivePeerConnection","onTrackerClientWarning","onTrackerClientError","static","_peers","potentialConnections","peerConnection","itemId","peerItem","add","onPeerConnected","clearPeerIdCache","getStreamSwarmId","swarmId","getSegmentFromStreamsMap","segmentRuntimeId","segments","getSegmentPlaybackStatuses","playback","timeWindowsConfig","currentP2PLoader","availableMemoryPercent","highDemandTimeWindow","httpDownloadTimeWindow","p2pDownloadTimeWindow","availableMemoryInPercent","isHighDemand","isSegmentInTimeWindow","isHttpDownloadable","isP2PDownloadable","isSegmentLoadingOrLoadedBySomeone","timeWindowLength","startTime","endTime","rate","P2PLoader","streamManifestUrl","requests","segmentStorage","onSegmentAnnouncement","StreamUtils.getStreamSwarmId","trackerClient","broadcastAnnouncement","setSegmentChangeCallback","dispatchEvent","isAnnounceMicrotaskCreated","peersWithSegment","getSegmentStatus","getOrCreateRequest","downloadSegment","iterator","getSegmentsAnnouncement","getStoredSegmentIds","httpLoading","httpRequests","runtimeId","isP2PUploadDisabled","sendSegmentsAnnouncementCommand","sendEmptyAnnouncement","sendSegmentsAnnouncement","byteFrom","sendSegmentAbsentCommand","segmentData","getSegmentData","uploadSegmentData","P2PLoadersContainer","_currentLoaderItem","findOrCreateLoaderForStream","loaders","loader","loggerInfo","loaderItem","destroyTimeoutId","createLoader","setLoaderDestroyTimeout","destroyAndRemoveLoader","p2pInactiveLoaderDestroyTimeoutMs","currentLoader","mapSegmentWithStreamToSegment","Request$1","requestProcessQueueCallback","bandwidthCalculators","playbackConfig","onSegmentError","onSegmentAbort","onSegmentStart","onSegmentLoaded","_totalBytes","notReceivingBytesTimeout","Timeout","abortOnTimeout","_logger","currentAttempt","_failedAttempts","FailedRequestAttempts","finalData","_loadedBytes","_status","progress","_abortRequestCallback","_isHandledByProcessQueue","Utils.joinChunks","isHandledByProcessQueue","markHandledByProcessQueue","requestData","setStatus","startFromByte","startTimestamp","manageBandwidthCalculatorsState","abortFromProcessQueue","throwErrorIfNotLoadingStatus","segmentUrl","bytesLength","restart","allBC","http","httpBC","lastLoadedChunkTimestamp","method","attempts","attempt","httpAttemptsCount","lastAttempt","timeoutId","RequestsContainer","executingHttpCount","executingP2PCount","p2pRequests","EngineRequest","engineCallbacks","_shouldBeStartedImmediately","bandwidth","onSuccess","markAsShouldBeStartedImmediately","generateQueue","lastRequestedSegment","availablePercentMemory","requestedSegment","queueSegments","first","firstStatuses","isNotActualStatuses","second","secondStatuses","statuses","HybridLoader","streamDetails","activeStream","segmentAvgDuration","sumDuration","requestProcessQueueMicrotask","p2pLoaders","setIntervalLoading","engineRequest","storageCleanUpIntervalId","levelChangedTimestamp","lastQueueProcessingTimeStamp","randomHttpDownloadInterval","isProcessQueueMicrotaskCreated","peersCount","connectedPeerCount","randomTimeout","loadRandomThroughHttp","callbacks","LoggerUtils.getSegmentString","changeCurrentLoader","isLive","hasSegment","queueDownloadRatio","getBandwidth","force","processQueue","queueSegmentIds","httpErrorRetries","remove","storeSegment","failedAttempts","processRequests","simultaneousHttpDownloads","simultaneousP2PDownloads","shouldBeStartedImmediately","loadThroughHttp","isP2PLoadingRequest","abortLastHttpLoadingInQueueAfterItem","loadThroughP2P","abortLastP2PLoadingInQueueAfterItem","isSegmentLoadedBySomeone","availableStorageCapacityPercent","getAvailableStorageCapacityPercent","p2pLoader","segmentsToLoad","QueueUtils.generateQueue","safeRandomSegmentsCount","randomIndices","probability","randomIndex","itemSegment","Utils.arrayBackwards","totalCapacity","usedCapacity","getUsage","maxPossibleLength","alreadyLoadedCount","activeLevelBitrate","getBandwidthLoadingOnly","max","httpRealBandwidth","notifyLevelChanged","sendEmptySegmentsAnnouncement","isRateChanged","isPositionChanged","isPositionSignificantlyChanged","onPlaybackUpdated","BandwidthCalculator","clearThresholdMs","loadingsCount","loadingOnlyTimestamps","timestamps","noLoadingsTime","loadingsStoppedAt","clearStale","seconds","ignoreThresholdTimestamp","NEGATIVE_INFINITY","milliseconds","lastItemTimestamp","lastCountedTimestamp","threshold","samplesToRemove","getStorageItemId","segmentId","BYTES_PER_MiB","SegmentMemoryStorage","segmentMemoryStorageLimit","currentStorageUsage","cache","coreConfig","mainStreamConfig","secondaryStreamConfig","currentPlayback","segmentChangeCallback","constructor","setMemoryStorageLimit","isLiveStream","_swarmId","storageId","increaseStorageUsage","segmentStorageId","dataItem","playbackPosition","calculatedUsedCapacity","externalIds","streamCacheId","newSegmentSize","isMemoryLimitReached","affectedStreams","sortedCache","sort","shouldRemoveSegment","decreaseStorageUsage","sendUpdatesToAffectedStreams","segmentByteLength","callback","currentPlaybackPosition","getStreamTimeWindow","configKey","EventTarget","eventName","definedListeners","indexOf","Core","customSegmentStorageFactory","isP2PDisabled","manifestResponseUrl","commonCoreConfig","mainStreamLoader","secondaryStreamLoader","DEFAULT_COMMON_CORE_CONFIG","DEFAULT_STREAM_CONFIG","mainStream","secondaryStream","getConfig","dynamicConfig","mainStreamConfigCopy","secondaryStreamConfigCopy","overrideAllConfigs","processSpecificDynamicConfigParams","prevConfig","updatedConfig","getUpdatedStreamProperty","destroyStreamLoader","sendBroadcastAnnouncement","propertyName","StreamUtils.getSegmentFromStreamsMap","streamRuntimeId","addSegments","removeSegmentIds","updateStream","initializeSegmentStorage","identifySegment","getStreamHybridLoader","loadSegment","abortSegmentRequest","updatePlayback","bitrate","createCustomStorage","initialize","createNewHybridLoader","streamConfig"],"mappings":"AAgqBO,MAAMA,UAEHC,MAAAA;AAAAA,EASR,YACWC,GACTC,GAAAA;AAEAC,UAAMD,CAAAA,GAHGE,KAAAH,OAAAA,GAITG,KAAKC,YAAYC,YAAYC;EAC/B;AAAA,EAbSF;AAAAA;AA0BJ,MAAMG,WAAyBR;EAKpC,YAAqBC,GAAAA;AACnBE,UAAAA,GADmBC,KAAAH,OAAAA;AAAAA,EAErB;AAAA;ACprBK,MAAMQ;EAOX,YACmBC,GACAC,GACjBC;AAFiBR,SAAAM,UAAAA,GACAN,KAAAO,aAAAA,GAGjBP,KAAKS,oBACHD,EAAYE,mBAAmB,mBAAA;AAEjC,UAAA,EAAMC,WAAEA,EAAAA,IAAcX,KAAKM,QAAQM;AAC/BD,UAAWX,KAAKa,mBAAmB,EAAA,GAAKF,EAAAA,IAExCL,EAAQQ,gBAAgB,MAC1Bd,KAAKa,mBAAmBb,KAAKa,oBAAoB,EAAEE,OAAO,EAAA,GAC1Df,KAAKa,iBAAiBE,QACpBf,KAAKa,iBAAiBE,QAAQT,EAAQQ,cAEtCd,KAAKM,QAAQU,eACfhB,KAAKiB,sBACHjB,KAAKM,QAAQU,aAAahB,KAAKM,QAAQQ,cAG3Cd,KAAKkB,kBAAkBlB,KAAKM,QAAQS,MAClC,EAAEI,gBAAgB,OAAA,GAClB,EACEC,OAAO,MAAMpB,KAAKqB,gBAAgBD,MAAM,OAAA,GACxCE,4BACEtB,KAAKO,WAAWgB,mCAGjBvB,KAAKwB,MAAAA;AAAAA,EACZ;AAAA,EApCiBN;AAAAA,EACAG,kBAAkB,IAAII;AAAAA,EACtBR;AAAAA,EACAJ;AAAAA,EACAJ;AAAAA,EAkCjB,MAAA,QAAce;AACZ,UAAA,EAAMZ,SAAEA,MAAYZ,KAAKM;AACzB,QAAA;AACE,UAAIA,UAAgBN,KAAKO,WAAWmB,mBAClCd,EAAQe,KACRf,EAAQD,WACRX,KAAKqB,gBAAgBO,QACrB5B,KAAKa,gBAAAA;AAGP,UAAA,CAAKP,GAAS;AACZ,cAAMuB,IAAU,IAAIC,QAClB9B,KAAKa,mBACD,EACEkB,OAAO,SAAS/B,KAAKa,iBAAiBE,KAAAA,IACpCf,KAAKa,iBAAiBmB,OAAO,EAAA,GAAA,IAAA,MAGjC;AAGN1B,QAAAA,IAAU,IAAI2B,QAAQrB,EAAQe,KAAK,EACjCE,SAAAA,GACAD,QAAQ5B,KAAKqB,gBAAgBO,OAAAA,CAAAA;AAAAA,MAEjC;AAEA,UAAI5B,KAAKqB,gBAAgBO,OAAOM,QAC9B,OAAM,IAAIC,aACR,wCACA,YAAA;AAIJ,YAAMC,IAAAA,MAAiBC,OAAOb,MAAMlB,CAAAA;AAIpC,UAFAN,KAAKsC,sBAAsBF,CAAAA,GAAAA,CAEtBA,EAASG,KAAM;AACpB,YAAA,EAAMrB,iBAAEA,EAAAA,IAAoBlB;AAC5BkB,MAAAA,EAAgBsB,mBAAAA;AAEhB,YAAMC,IAASL,EAASG,KAAKG,UAAAA;AAC7B,uBAAiBC,MA2GvBC,iBACEH,GAAAA;AAEA,mBAAa;AACX,kBAAMI,MAAEA,GAAAC,OAAMA,EAAAA,IAAAA,MAAgBL,EAAOM,KAAAA;AACrC,cAAIF,EAAM;AAAA,gBACJC;AAAAA,QACR;AAAA,MACF,GAnH2CL,CAAAA,EACnCzC,MAAKkB,gBAAgB8B,eAAeL,CAAAA,GACpC3C,KAAKS,kBAAkBkC,EAAMM,YAAY,MAAA;AAU3C,UAAA,EAAA,MANSjD,KAAKO,WAAW2C,sBACrBtC,EAAQe,KACRf,EAAQD,WACRX,KAAKM,QAAQ6C,IAAAA,KAAAA,IAKf,OADAnD,KAAKM,QAAQ8C,iBAAAA,GACP,IAAIzD,EACR,gCAAA;AAIJuB,MAAAA,EAAgBmC,kBAAAA;AAAAA,IAClB,SAASC,GAAAA;AACPtD,WAAKuD,YAAYD;IACnB;AAAA,EACF;AAAA,EAEQ,sBAAsBlB;AAC5B,QAAA,CAAKA,EAASoB,GACZ,OAAIpB,EAASqB,WAAW,OACtBzD,KAAKM,QAAQ8C,oBACP,IAAIzD,EACR,uBACAyC,EAASsB,eAGL,IAAI/D,EAA2B,cAAcyC,EAASsB;AAIhE,UAAA,EAAM7C,kBAAEA,EAAAA,IAAqBb;AAC7B,QAAIa,EACF,KAAIuB,EAASqB,WAAW,KAAK;AAC3B,UAAIzD,KAAKM,QAAQM,QAAQD,UACvB,OAAM,IAAIhB,EAAa;AAEvBK,WAAKM,QAAQ8C,iBAAAA;AAAAA,IAEjB,OAAO;AACL,UAAIhB,EAASqB,WAAW,IACtB,OAAM,IAAI9D,EACR,+BACAyC,EAASsB,UAAAA;AAGb,YAAMC,IAAsBvB,EAASP,QAAQ+B,IAAI,gBAAA;AACjD,UACED,KACA3D,KAAKiB,wBADL0C,UAEA3D,KAAKiB,wBAAAA,CAAyB0C,EAG9B,OADA3D,KAAKM,QAAQ8C,iBAAAA,GACP,IAAIzD,EAAa,uBAAuByC,EAASsB,UAAAA;AAGzD,YAAMG,IAAqBzB,EAASP,QAAQ+B,IAAI,kBAC1CE,IAAeD,KAuD7B,SAAiCE,GAAAA;AAC/B,cAAMC,IAAQC,GAAiBC,KAAKH,EAAYI;AAChD,YAAA,CAAKH,EAAO;AAEZ,cAAA,GAASI,GAAMC,GAAIC,CAAAA,IAASN;AAC5B,eAAO,EACLI,MAAMA,IAAOG,SAASH,aACtBC,IAAIA,IAAKE,SAASF,aAClBC,OAAOA,IAAQC,SAASD,YAAS;AAAA,MAErC,GAhEoCT,CAAAA,IAAAA;AAE5B,UAAIC,GAAc;AAChB,cAAA,EAAMM,MAAEA,GAAAC,IAAMA,EAAAA,IAAOP,GACfU,IACJH,gBAAoBD,MAApBC,SAAyCA,IAAKD,IAAO,IAAA;AAEvD,YACGI,MADH,UAEIxE,KAAKiB,wBAAwBuD,KAC9BJ,MAD8BI,UACR3D,EAAiBE,UAAUqD,KACjDC,MADiDD,UAEhDvD,EAAiBmB,QADlBqC,UAECxD,EAAiBmB,QAAQqC,EAG3B,OADArE,KAAKM,QAAQ8C,iBAAAA,GACP,IAAIzD,EAAa,uBAAuByC,EAASsB,UAAAA;AAAAA,MAE3D;AAAA,IACF;AAGF,QAAItB,EAASqB,WAAW,OAAOzD,KAAKM,QAAQU,eAA/ByC,QAAyD;AACpE,YAAME,IAAsBvB,EAASP,QAAQ+B,IAAI,gBAAA;AAC7CD,MAAAA,KAAqB3D,KAAKM,QAAQmE,cAAAA,CAAed,CAAAA;AAAAA,IACvD;AAAA,EACF;AAAA,EAEQ,YAAYL,GAAAA;AAClB,QAAIA,aAAiB1D,OAAO;AAC1B,UAAI0D,EAAMoB,SAAS,QAAS;AAE5B,YAAMC,IACJrB,aAAiB3D,IACZ2D,IACD,IAAI3D,EAAa,cAAc2D,EAAMxD,OAAAA;AAE3CE,WAAKkB,gBAAgB0D,aAAaD,CAAAA;AAAAA,IACpC;AAAA,EACF;AAAA;AAaF,MAAMV,KAAmB;ACxNzB,SAASY,GAAyBC,GAAAA;AACjC,SAAOA,KAAKA,EAAEC,cAAcC,OAAOC,UAAUC,eAAeC,KAAKL,GAAG,SAAA,IAAaA,EAAW,UAAIA;AACjG;AAEA,IAUIM,GACAC,GAXAC,KAAU,EAACC,SAAS,MAGpBC,IAAUF,GAAQC,UAAU,CAAA;AAUhC,SAASE,KAAAA;AACL,QAAM,IAAI7F,MAAM,iCAAA;AACpB;AACA,SAAS8F;AACL,QAAM,IAAI9F,MAAM,mCAAA;AACpB;AAqBA,SAAS+F,GAAWC,GAAAA;AAChB,MAAIR,MAAqBS,WAErB,QAAOA,WAAWD,GAAK;AAG3B,OAAKR,MAAqBK,MAAAA,CAAqBL,MAAqBS,WAEhE,QADAT,IAAmBS,YACZA,WAAWD,GAAK,CAAA;AAE3B,MAAA;AAEI,WAAOR,EAAiBQ,GAAK,CAAA;AAAA,EACjC,QAAQE;AACJ;AAEI,aAAOV,EAAiBD,KAAK,MAAMS,GAAK,CAAA;AAAA,IAC5C,QAAQE;AAEJ,aAAOV,EAAiBD,KAAKnF,MAAM4F,GAAK;IAC5C;AAAA,EACJ;AAGJ;AAAA,CA5CC,WAAA;AACG;AAEQR,IAAAA,IADsB,OAAfS,cAAe,aACHA,aAEAJ;AAAAA,EAE3B,QAASK;AACLV,IAAAA,IAAmBK;AAAAA,EACvB;AACA,MAAA;AAEQJ,IAAAA,IADwB,OAAjBU,gBAAiB,aACHA,eAEAL;AAAAA,EAE7B;AACIL,IAAAA,IAAqBK;AAAAA,EACzB;AACJ;AAqDA,IAEIM,IAFAC,IAAQ,CAAA,GACRC,SAEAC,KAAAA;AAEJ,SAASC;AACAF,EAAAA,MAAaF,OAGlBE,KAAAA,IACIF,GAAaK,SACbJ,IAAQD,GAAaM,OAAOL,KAE5BE,KAAAA,IAEAF,EAAMI,UACNE;AAER;AAEA,SAASA,KAAAA;AACL,MAAA,CAAIL,IAAJ;AAGA,QAAIM,IAAUb,GAAWS,EAAAA;AACzBF,IAAAA,KAAAA;AAGA,aADIO,IAAMR,EAAMI,QACVI,KAAK;AAGP,WAFAT,KAAeC,GACfA,IAAQ,MACCE,KAAaM,IACdT,CAAAA,MACAA,GAAaG,IAAYO,IAAAA;AAGjCP,MAAAA,KAAAA,IACAM,IAAMR,EAAMI;AAAAA,IAChB;AACAL,IAAAA,KAAe,MACfE,UAnEJ,SAAyBS,GAAAA;AACrB,UAAItB,MAAuBU,aAEvB,QAAOA,aAAaY,CAAAA;AAGxB,WAAKtB,MAAuBK,MAAAA,CAAwBL,MAAuBU,aAEvE,QADAV,IAAqBU,cACdA,aAAaY,CAAAA;AAExB;AAEI,eAAOtB,EAAmBsB,CAAAA;AAAAA,MAC9B,QAASb;AACL,YAAA;AAEI,iBAAOT,EAAmBF,KAAK,MAAMwB,CAAAA;AAAAA,QACzC;AAGI,iBAAOtB,EAAmBF,KAAKnF,MAAM2G;QACzC;AAAA,MACJ;AAAA,IAIJ,GA0CoBH;EAlBhB;AAmBJ;AAgBA,SAASI,GAAKhB,GAAKiB,GAAAA;AACf7G,OAAK4F,MAAMA,GACX5F,KAAK6G,QAAQA;AACjB;AAWA,SAASC;AAAQ;AA5BjBtB,EAAQuB,WAAW,SAAUnB;AACzB,MAAIoB,IAAO,IAAIC,MAAMC,UAAUb,SAAS,CAAA;AACxC,MAAIa,UAAUb,SAAS,EACnB,UAASc,IAAI,GAAGA,IAAID,UAAUb,QAAQc,IAClCH,GAAKG,IAAI,CAAA,IAAKD,UAAUC,CAAAA;AAGhClB,EAAAA,EAAMmB,KAAK,IAAIR,GAAKhB,GAAKoB,KACrBf,EAAMI,WAAW,KAAMH,MACvBP,GAAWY,EAAAA;AAEnB,GAOAK,GAAK3B,UAAUyB,MAAM,WAAA;AACjB1G,OAAK4F,IAAIyB,MAAM,MAAMrH,KAAK6G,KAAAA;AAC9B,GACArB,EAAQ8B,QAAQ,WAChB9B,EAAQF,UAAAA,IACRE,EAAQ+B,MAAM,CAAA,GACd/B,EAAQgC,OAAO,CAAA,GACfhC,EAAQiC,UAAU,IAClBjC,EAAQkC,WAAW,CAAA,GAInBlC,EAAQmC,KAAKb,GACbtB,EAAQoC,cAAcd,GACtBtB,EAAQqC,OAAOf,GACftB,EAAQsC,MAAMhB,GACdtB,EAAQuC,iBAAiBjB,GACzBtB,EAAQwC,qBAAqBlB,GAC7BtB,EAAQyC,OAAOnB,GACftB,EAAQ0C,kBAAkBpB,GAC1BtB,EAAQ2C,sBAAsBrB,GAE9BtB,EAAQ4C,YAAY,SAAU1D,GAAAA;AAAQ,SAAO,CAAA;AAAG,GAEhDc,EAAQ6C,UAAU,SAAU3D,GAAAA;AACxB,QAAM,IAAI9E,MAAM;AACpB,GAEA4F,EAAQ8C,MAAM,WAAA;AAAc,SAAO;AAAI,GACvC9C,EAAQ+C,QAAQ,SAAUC,GAAAA;AACtB,QAAM,IAAI5I,MAAM;AACpB,GACA4F,EAAQiD,QAAQ,WAAA;AAAa,SAAO;AAAG;AAGvC,MAAMC,KAAyB7D,GADVS,GAAQC,OAAAA;;;;;;;;;AC3L7B,MAAIoD,IAAI,KACJC,IAAQ,KAAJD,GACJE,IAAQ,KAAJD,GACJE,IAAQ,KAAJD,GACJE,IAAQ,IAAJD,GACJE,IAAQ,SAAJF;AAqJR,WAASG,EAAOC,GAAIC,GAAOC,GAAG1E,GAAAA;AAC5B,QAAI2E,IAAWF,KAAa,MAAJC;AACxB,WAAOE,KAAKC,MAAML,IAAKE,CAAAA,IAAK,MAAM1E,KAAQ2E,IAAW,MAAM;AAAA,EAC7D;SAxIAH,KAAiB,SAAUM,GAAKC,GAAAA;AAC9BA,IAAAA,IAAUA,KAAW,CAAA;AACrB,QAAI5J,WAAc2J;AAClB,QAAI3J,MAAS,YAAY2J,EAAInD,SAAS,EACpC,SAkBJ,SAAeqD;AAEb,UADAA,GAAAA,IAAMC,OAAOD,CAAAA,GACLrD,SAAS,MAGjB;AAAA,YAAIrC,IAAQ,mIAAmIE,KAC7IwF,CAAAA;AAEF,YAAK1F,GAGL;AAAA,cAAIoF,IAAIQ,WAAW5F,EAAM;AAEzB,mBADYA,EAAM,CAAA,KAAM,MAAM6F;YAE5B,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AACH,qBAAOT,IAAIJ;AAAAA,YACb,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AACH,qBAAOI,IAAIL;AAAAA,YACb,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AACH,qBAAOK,IAAIN;AAAAA,YACb,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AACH,qBAAOM,IAAIP;AAAAA,YACb,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AACH,qBAAOO,IAAIR;AAAAA,YACb,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AACH,qBAAOQ,IAAIT;AAAAA,YACb,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AACH,qBAAOS;AAAAA,YACT;AACE;AAAA,UAAA;AAAA;AAAA;AAAA,IAEN,GAzEiBI,CAAAA;AACR,QAAI3J,MAAS,YAAYiK,SAASN,CAAAA,EACvC,QAAOC,EAAQM,QA0GnB,SAAiBb,GAAAA;AACf,UAAIC,IAAQG,KAAKU,IAAId,CAAAA;AACrB,aAAIC,KAASL,IACJG,EAAOC,GAAIC,GAAOL,GAAG,KAAA,IAE1BK,KAASN,IACJI,EAAOC,GAAIC,GAAON,GAAG,UAE1BM,KAASP,IACJK,EAAOC,GAAIC,GAAOP,GAAG,QAAA,IAE1BO,KAASR,IACJM,EAAOC,GAAIC,GAAOR,GAAG,QAAA,IAEvBO,IAAK;AAAA,IACd,GAzHkCM,CAAAA,KAiFlC,SAAkBN,GAAAA;AAChB,UAAIC,IAAQG,KAAKU,IAAId,CAAAA;AACrB,aAAIC,KAASL,IACJQ,KAAKC,MAAML,IAAKJ,CAAAA,IAAK,MAE1BK,KAASN,IACJS,KAAKC,MAAML,IAAKL,CAAAA,IAAK,MAE1BM,KAASP,IACJU,KAAKC,MAAML,IAAKN,CAAAA,IAAK,MAE1BO,KAASR,IACJW,KAAKC,MAAML,IAAKP,CAAAA,IAAK,MAEvBO,IAAK;AAAA,IACd,GAhGkDM,CAAAA;AAEhD,UAAM,IAAI5J,MACR,0DACEqK,KAAKC,UAAUV;EAErB;;;AC/BAjE,IAAA4E,aA8IA,SAAoBnD,GAAAA;AAQnB,QAPAA,EAAK,CAAA,KAAMhH,KAAKoK,YAAY,OAAO,MAClCpK,KAAKqK,aACJrK,KAAKoK,YAAY,QAAQ,OAC1BpD,EAAK,CAAA,KACJhH,KAAKoK,YAAY,QAAQ,OAC1B,MAAME,EAAO/E,QAAQgF,SAASvK,KAAKwK,IAAAA,GAAAA,CAE/BxK,KAAKoK,UACT;AAGD,UAAMK,IAAI,YAAYzK,KAAK0K;AAC3B1D,IAAAA,EAAK2D,OAAO,GAAG,GAAGF,GAAG,gBAAA;AAKrB,QAAIG,IAAQ,GACRC,IAAQ;AACZ7D,IAAAA,EAAK,GAAG8D,QAAQ,eAAe9G,CAAAA,MAAAA;AAChB,MAAVA,MAAU,SAGd4G,KACI5G,MAAU,SAGb6G,IAAQD;AAAAA,IAAAA,CAAAA,GAIV5D,EAAK2D,OAAOE,GAAO,GAAGJ,CAAAA;AAAAA,EACvB,GA9KAlF,EAAAwF,OAgMA,SAAcC,GAAAA;AACb,QAAA;AACKA,MAAAA,IACHzF,EAAQ0F,QAAQC,QAAQ,SAASF,CAAAA,IAEjCzF,EAAQ0F,QAAQE,WAAW,OAAA;AAAA,IAE9B;IAGA;AAAA,EACA,GA1MA5F,EAAA6F,OAkNA;AACC,QAAIC;AACJ,QAAA;AACCA,MAAAA,IAAI9F,EAAQ0F,QAAQK,QAAQ,OAAA,KAAY/F,EAAQ0F,QAAQK,QAAQ,OAAA;AAAA,IAClE;IAGA;AAOC,WAAA,CAJKD,KAAY7F,OAAZ6F,UAAuC,SAAS7F,OACpD6F,IAAI7F,GAAQ+B,IAAIgE,QAGVF;AAAAA,EACR,GAhOA9F,EAAA6E,YAyGA,WAAA;AAIC,QAAsB,OAAX/H,SAAW,OAAeA,OAAOmD,YAAYnD,OAAOmD,QAAQ3F,SAAS,cAAcwC,OAAOmD,QAAQgG,QAC5G,QAAA;AAID,QAAyB,OAAdC,YAAc,OAAeA,UAAUC,aAAaD,UAAUC,UAAU7B,YAAAA,EAAc7F,MAAM,yBACtG,QAAA;AAGD,QAAI4E;AAKJ,WAA4B,OAAb+C,WAAa,OAAeA,SAASC,mBAAmBD,SAASC,gBAAgBC,SAASF,SAASC,gBAAgBC,MAAMC,oBAEpH,OAAXzJ,SAAW,OAAeA,OAAO0J,YAAY1J,OAAO0J,QAAQC,WAAY3J,OAAO0J,QAAQE,aAAa5J,OAAO0J,QAAQG,iBAGnHT,YAAc,OAAeA,UAAUC,cAAc9C,IAAI6C,UAAUC,UAAU7B,YAAAA,EAAc7F,MAAM,gBAAA,MAAsBO,SAASqE,EAAE,CAAA,GAAI,EAAA,KAAO,aAE7I6C,YAAc,OAAeA,UAAUC,aAAaD,UAAUC,UAAU7B,YAAAA,EAAc7F,MAAM,oBAAA;AAAA,EACtG,GAlIAuB,EAAA0F,WA4OA,WAAA;AACC,QAAA;AAGC,aAAOkB;AAAAA,IACT,QAAU7I;AAAAA,IAGV;AAAA,EACA,GArPkB8I,GAClB7G,EAAA8G,UAAkB,uBAAA;AACjB,QAAIC,IAAAA;AAEJ,WAAO,MAAA;AACDA,MAAAA,MACJA,IAAAA,IACAP,QAAQQ,KAAK;;EAGf,GATiB,GAelBhH,EAAAiH,SAAiB,CAChB,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,WACA,SAAA,GAyFDjH,EAAAkH,MAAcV,QAAQW,SAASX,QAAQU,QAAG,MAAA;AAAA,EAAa,IAkEvDnC,EAAA/E,0BCkCAoH,KA7RA,SAAepF,GAAAA;AAqDd,aAASqF,EAAYvC;AACpB,UAAIwC,GAEAC,GACAC,GAFAC,IAAiB;AAIrB,eAASN,KAAS1F,GAAAA;AAEjB,aAAK0F,EAAMO,QACV;AAGD,cAAMC,IAAOR,GAGPS,IAAOC,OAAO,oBAAIC,SAClBnE,IAAKiE,KAAQN,KAAYM;AAC/BD,QAAAA,EAAK1C,OAAOtB,GACZgE,EAAKI,OAAOT,GACZK,EAAKC,OAAOA,GACZN,IAAWM,GAEXnG,EAAK,CAAA,IAAK4F,EAAYW,OAAOvG,EAAK,CAAA,CAAA,GAEX,OAAZA,EAAK,CAAA,KAAO,YAEtBA,EAAKwG,QAAQ,IAAA;AAId,YAAI5C,IAAQ;AACZ5D,QAAAA,EAAK,CAAA,IAAKA,EAAK,CAAA,EAAG8D,QAAQ,iBAAiB,CAAC9G,GAAOyJ,MAAAA;AAElD,cAAIzJ,MAAU,KACb,QAAO;AAER4G,UAAAA;AACA,gBAAM8C,IAAYd,EAAYe,WAAWF;AACzC,cAAyB,OAAdC,KAAc,YAAY;AACpC,kBAAMlE,IAAMxC,EAAK4D,CAAAA;AACjB5G,YAAAA,IAAQ0J,EAAUvI,KAAK+H,GAAM1D,CAAAA,GAG7BxC,EAAK2D,OAAOC,GAAO,CAAA,GACnBA;AAAAA,UACL;AACI,iBAAO5G;AAAAA,QAAAA,CAAAA,GAIR4I,EAAYzC,WAAWhF,KAAK+H,GAAMlG,CAAAA,IAEpBkG,EAAKT,OAAOG,EAAYH,KAChCpF,MAAM6F,GAAMlG,CAAAA;AAAAA,MACrB;AAgCE,aA9BA0F,EAAMrC,YAAYA,GAClBqC,EAAMtC,YAAYwC,EAAYxC,UAAAA,GAC9BsC,EAAMhC,QAAQkC,EAAYgB,YAAYvD,CAAAA,GACtCqC,EAAMmB,SAASA,GACfnB,EAAML,UAAUO,EAAYP,SAE5BrH,OAAO8I,eAAepB,GAAO,WAAW,EACvCqB,gBACAC,cAAAA,IACApK,KAAK,MACAoJ,MAAmB,OACfA,KAEJF,MAAoBF,EAAY5B,eACnC8B,IAAkBF,EAAY5B,YAC9B+B,IAAeH,EAAYK,QAAQ5C,CAAAA,IAG7B0C,IAERkB,KAAKC,CAAAA,MAAAA;AACJlB,QAAAA,IAAiBkB;AAAAA,MAAAA,EAAAA,CAAAA,GAKa,OAArBtB,EAAYuB,QAAS,cAC/BvB,EAAYuB,KAAKzB,CAAAA,GAGXA;AAAAA,IACT;AAEC,aAASmB,EAAOxD,GAAW+D;AAC1B,YAAMC,IAAWzB,EAAY5M,KAAKqK,aAAoB+D,eAA4B,MAAMA,KAAa/D;AAErG,aADAgE,EAAS5B,MAAMzM,KAAKyM,KACb4B;AAAAA,IACT;AAuCC,aAASC,EAAgBC,GAAQC,GAAAA;AAChC,UAAIC,IAAc,GACdC,IAAgB,GAChBC,IAAAA,IACAC,IAAa;AAEjB,aAAOH,IAAcF,EAAOlI,SAC3B,KAAIqI,IAAgBF,EAASnI,WAAWmI,EAASE,OAAmBH,EAAOE,CAAAA,KAAgBD,EAASE,OAAmB,KAEtF,CAA5BF,EAASE,CAAAA,MAAmB,OAC/BC,IAAYD,GACZE,IAAaH,GACbC,QAEAD,KACAC;AAAAA,WAEK;AAAA,YAAIC,MAAJ,GAMN,QAAA;AAJAD,QAAAA,IAAgBC,IAAY,GAC5BC,KACAH,IAAcG;AAAAA,MAGlB;AAIE,aAAOF,IAAgBF,EAASnI,UAAUmI,EAASE,CAAAA,MAAmB,MACrEA,CAAAA;AAGD,aAAOA,MAAkBF,EAASnI;AAAAA,IACpC;AAgEC,WAzRAuG,EAAYF,QAAQE,GACpBA,EAAYiC,UAAUjC,GACtBA,EAAYW,SAsQZ,SAAgB/D,GAAAA;AACf,aAAIA,aAAe5J,QACX4J,EAAIsF,SAAStF,EAAI1J,UAElB0J;AAAAA,IACT,GA1QCoD,EAAYmC,UA8NZ,WAAA;AACC,YAAM/D,IAAa,CAAA,GACf4B,EAAYoC,OAAAA,GACZpC,EAAYqC,MAAMC,IAAI7E,CAAAA,MAAa,MAAMA,CAAAA,CAAAA,EAC3C8E,KAAK,GAAA;AAEP,aADAvC,EAAYwC,OAAO,KACZpE;AAAAA,IACT,GApOC4B,EAAYwC,SAsJZ,SAAgBpE,GAAAA;AACf4B,MAAAA,EAAY7B,KAAKC,CAAAA,GACjB4B,EAAY5B,aAAaA,GAEzB4B,EAAYoC,QAAQ,IACpBpC,EAAYqC,QAAQ,CAAA;AAEpB,YAAMI,KAA+B,OAAfrE,KAAe,WAAWA,IAAa,IAC3D7G,OACA2G,QAAQ,QAAQ,GAAA,EAChBuE,MAAM,KACNC,OAAOC,OAAAA;AAET,iBAAWC,KAAMH,EACF,CAAVG,EAAG,CAAA,MAAO,MACb5C,EAAYqC,MAAM7H,KAAKoI,EAAGC,MAAM,MAEhC7C,EAAYoC,MAAM5H,KAAKoI,CAAAA;AAAAA,IAG3B,GAzKC5C,EAAYK,UA4OZ,SAAiBvI,GAAAA;AAChB,iBAAWgL,KAAQ9C,EAAYqC,MAC9B,KAAIX,EAAgB5J,GAAMgL,CAAAA,EACzB,QAAA;AAIF,iBAAWF,KAAM5C,EAAYoC,MAC5B,KAAIV,EAAgB5J,GAAM8K,CAAAA,EACzB;AAIF,aAAA;AAAA,IACF,GAzPC5C,EAAYrC,WAAWoF,GAAAA,GACvB/C,EAAYP,UA4QZ,WAAA;AACCN,cAAQQ,KAAK,uIAAA;AAAA,IACf,GA5QCvH,OAAO4K,KAAKrI,CAAAA,EAAKsI,QAAQC,CAAAA;AACxBlD,MAAAA,EAAYkD,CAAAA,IAAOvI,EAAIuI,CAAAA;AAAAA,IAAAA,CAAAA,GAOxBlD,EAAYoC,QAAQ,CAAA,GACpBpC,EAAYqC,QAAQ,IAOpBrC,EAAYe,aAAa,CAAA,GAkBzBf,EAAYgB,cAVZ,SAAqBvD,GAAAA;AACpB,UAAI0F,IAAO;AAEX,eAAS5I,IAAI,GAAGA,IAAIkD,EAAUhE,QAAQc,IACrC4I,CAAAA,KAASA,KAAQ,KAAKA,IAAQ1F,EAAU2F,WAAW7I,CAAAA,GACnD4I,KAAQ;AAGT,aAAOnD,EAAYJ,OAAOlD,KAAKU,IAAI+F,CAAAA,IAAQnD,EAAYJ,OAAOnG,MAAAA;AAAAA,IAChE,GA6OCuG,EAAYwC,OAAOxC,EAAYxB,KAAAA,CAAAA,GAExBwB;AAAAA,EACR,QDhCqCrH,CAAAA;AAErC,QAAA,EAAMoI,YAACA,EAAAA,IAAcrD,EAAO/E;AAM5BoI,EAAAA,EAAWsC,IAAI,SAAU/B;AACxB,QAAA;AACC,aAAOjE,KAAKC,UAAUgE;IACxB,SAAU5K,GAAAA;AACR,aAAO,iCAAiCA,EAAMxD;AAAAA,IAChD;AAAA,EACA;;;;;;;AExPA,MAOIoQ,GAPAC,WAAWC,WAAY,WAAWA,UAAU,MAC5CC,IAAeF,KAAwB,OAAZA,EAAE9I,SAAU,aACvC8I,EAAE9I,QACF,SAAsBiJ,GAAQC,GAAUvJ,GAAAA;AACxC,WAAOwJ,SAASvL,UAAUoC,MAAMlC,KAAKmL,GAAQC,GAAUvJ,CAAAA;AAAAA,EAC3D;AAIEkJ,EAAAA,IADEC,KAA0B,OAAdA,EAAEM,WAAY,aACXN,EAAEM,UACVzL,OAAO0L,wBACC,SAAwBJ,GAAAA;AACvC,WAAOtL,OAAO2L,oBAAoBL,CAAAA,EAC/BhK,OAAOtB,OAAO0L,sBAAsBJ,CAAAA,CAAAA;AAAAA,EAC3C,IAEmB,SAAwBA;AACvC,WAAOtL,OAAO2L,oBAAoBL,CAAAA;AAAAA,EACtC;AAOA,MAAIM,IAAcxD,OAAOyD,SAAS,SAAqB/N,GAAAA;AACrD,WAAOA,KAAUA;AAAAA,EACnB;AAEA,WAASgO,IAAAA;AACPA,IAAAA,EAAa3C,KAAKhJ,KAAKnF,IAAAA;AAAAA,EACzB;AACA+Q,EAAAA,GAAAxL,UAAiBuL,GACjBC,GAAAxL,QAAAsC,OAwYA,SAAcmJ,GAAStM,GAAAA;AACrB,WAAO,IAAIuM,QAAQ,SAAUC,GAASC,GAAAA;AACpC,eAASC,EAAcC;AACrBL,QAAAA,EAAQjJ,eAAerD,GAAM4M,CAAAA,GAC7BH,EAAOE,CAAAA;AAAAA,MACb;AAEI,eAASC,IAAAA;AAC+B,eAA3BN,EAAQjJ,kBAAmB,cACpCiJ,EAAQjJ,eAAe,SAASqJ,CAAAA,GAElCF,EAAQ,CAAA,EAAGzB,MAAMtK,KAAK+B,SAAAA,CAAAA;AAAAA,MAC5B;AAEIqK,MAAAA,EAA+BP,GAAStM,GAAM4M,GAAU,EAAEzJ,MAAAA,GAAM,CAAA,GAC5DnD,MAAS,YAMjB,SAAuCsM,GAASQ,GAASC;AAC7B,QAAA,OAAfT,EAAQrJ,MAAO,cACxB4J,EAA+BP,GAAS,SAASQ,GAASC,CAAAA;AAAAA,MAE9D,GAToCT,GAASI,GAAe,EAAEvJ,MAAAA;IAE9D,CAAA;AAAA,EACA,GAxZAiJ,EAAaA,eAAeA,GAE5BA,EAAa7L,UAAUyM,UAAAA,QACvBZ,EAAa7L,UAAU0M,eAAe,GACtCb,EAAa7L,UAAU2M,gBAAAA;AAIvB,MAAIC,IAAsB;AAE1B,WAASC,EAAcC,GAAAA;AACrB,eAAWA,KAAa,WACtB,OAAM,IAAIC,UAAU,4EAA4ED,CAAAA;AAAAA,EAEpG;AAoCA,WAASE,EAAiBC;AACxB,WAAIA,EAAKN,kBAAT,SACSd,EAAae,sBACfK,EAAKN;AAAAA,EACd;AAkDA,WAASO,EAAa7B,GAAQzQ,GAAMkS,GAAUK;AAC5C,QAAIxJ,GACAyJ,GACAC,GA1HsBC;AAgJ1B,QApBAT,EAAcC,CAAAA,IAEdM,IAAS/B,EAAOoB,aAFFK,UAIZM,IAAS/B,EAAOoB,UAAU1M,uBAAOwN,OAAO,IAAA,GACxClC,EAAOqB,eAAe,MAIlBU,EAAOI,gBAJW,WAKpBnC,EAAOrI,KAAK,eAAepI,GACfkS,EAASA,WAAWA,EAASA,WAAWA,CAAAA,GAIpDM,IAAS/B,EAAOoB,UAElBY,IAAWD,EAAOxS,CAAAA,IAGhByS,MAHgBzS,OAKlByS,CAAAA,IAAWD,EAAOxS,CAAAA,IAAQkS,KACxBzB,EAAOqB;AAAAA,aAEe,OAAbW,KAAa,aAEtBA,IAAWD,EAAOxS,CAAAA,IAChBuS,IAAU,CAACL,GAAUO,CAAAA,IAAY,CAACA,GAAUP,KAErCK,IACTE,EAAS9E,QAAQuE,CAAAA,IAEjBO,EAASlL,KAAK2K,CAAAA,IAIhBnJ,IAAIqJ,EAAiB3B,MACb,KAAKgC,EAASjM,SAASuC,KAAAA,CAAM0J,EAAShG,QAAQ;AACpDgG,MAAAA,EAAShG,SAAAA;AAGT,UAAIvD,IAAI,IAAInJ,MAAM,iDACE0S,EAASjM,SAAS,MAAMsD,OAAO9J,KADjC,mEAAA;AAIlBkJ,MAAAA,EAAErE,OAAO,+BACTqE,EAAEiI,UAAUV,GACZvH,EAAElJ,OAAOA,GACTkJ,EAAE2J,QAAQJ,EAASjM,QA7KGkM,IA8KHxJ,GA7KnBgD,WAAWA,QAAQQ,QAAMR,QAAQQ,KAAKgG,CAAAA;AAAAA,IA8K5C;AAGE,WAAOjC;AAAAA,EACT;AAaA,WAASqC,IAAAA;AACP,QAAA,CAAK3S,KAAK4S,MAGR,QAFA5S,KAAKsQ,OAAOvI,eAAe/H,KAAKH,MAAMG,KAAK6S,MAAAA,GAC3C7S,KAAK4S,QAAAA,IACD1L,UAAUb,WAAW,IAChBrG,KAAK+R,SAAS5M,KAAKnF,KAAKsQ,UAC1BtQ,KAAK+R,SAAS1K,MAAMrH,KAAKsQ,QAAQpJ,SAAAA;AAAAA,EAE5C;AAEA,WAAS4L,EAAUxC,GAAQzQ,GAAMkS,GAAAA;AAC/B,QAAIgB,IAAQ,EAAEH,OAAAA,IAAcC,QAAAA,QAAmBvC,QAAQA,GAAQzQ,MAAMA,GAAMkS,UAAUA,KACjFiB,IAAUL,EAAYM,KAAKF,CAAAA;AAG/B,WAFAC,EAAQjB,WAAWA,GACnBgB,EAAMF,SAASG,GACRA;AAAAA,EACT;AAyHA,WAASE,EAAW5C,GAAQzQ,GAAMsT,GAAAA;AAChC,QAAId,IAAS/B,EAAOoB;AAEpB,QAAIW,MAAJ,OACE,QAAO,CAAA;AAET,QAAIe,IAAaf,EAAOxS,CAAAA;AACxB,WAAIuT,MAAJ,SACS,KAEiB,OAAfA,KAAe,aACjBD,IAAS,CAACC,EAAWrB,YAAYqB,CAAAA,IAAc,CAACA,CAAAA,IAElDD,KAsDT,SAAyBE,GAAAA;AAEvB,eADIC,IAAM,IAAIrM,MAAMoM,EAAIhN,MAAAA,GACfc,IAAI,GAAGA,IAAImM,EAAIjN,QAAAA,EAAUc,EAChCmM,CAAAA,EAAInM,CAAAA,IAAKkM,EAAIlM,CAAAA,EAAG4K,YAAYsB,EAAIlM,CAAAA;AAElC,aAAOmM;AAAAA,IACT,GA3DoBF,CAAAA,IAAcG,EAAWH,GAAYA,EAAW/M,MAAAA;AAAAA,EACpE;AAmBA,WAASmN,EAAc3T;AACrB,QAAIwS,IAASrS,KAAK0R;AAElB,QAAIW,cAAsB;AACxB,UAAIe,IAAaf,EAAOxS,CAAAA;AAExB,UAA0B,OAAfuT,KAAe,WACxB,QAAO;AACF,UAAIA,MAAJ,OACL,QAAOA,EAAW/M;AAAAA,IAExB;AAEE,WAAO;AAAA,EACT;AAMA,WAASkN,EAAWF,GAAKjK,GAAAA;AAEvB,aADIqK,IAAO,IAAIxM,MAAMmC,CAAAA,GACZjC,IAAI,GAAGA,IAAIiC,GAAAA,EAAKjC,EACvBsM,CAAAA,EAAKtM,CAAAA,IAAKkM,EAAIlM,CAAAA;AAChB,WAAOsM;AAAAA,EACT;AA2CA,WAASlC,EAA+BP,GAAStM,GAAMqN,GAAUN;AAC/D,QAA0B,OAAfT,EAAQrJ,MAAO,WACpB8J,CAAAA,EAAM5J,OACRmJ,EAAQnJ,KAAKnD,GAAMqN,KAEnBf,EAAQrJ,GAAGjD,GAAMqN,CAAAA;AAAAA,SAEd;UAAwC,OAA7Bf,EAAQ0C,oBAAqB,WAY7C,OAAM,IAAI1B,UAAU,wEAAA,OAA+EhB,CAAAA;AATnGA,MAAAA,EAAQ0C,iBAAiBhP,GAAM,SAASiP,EAAaC,GAAAA;AAG/CnC,QAAAA,EAAM5J,QACRmJ,EAAQ6C,oBAAoBnP,GAAMiP,CAAAA,GAEpC5B,EAAS6B,CAAAA;AAAAA,MACf,CAAA;AAAA,IAGA;AAAA,EACA;SAraA5O,OAAO8I,eAAegD,GAAc,uBAAuB,EACzD/C,YAAAA,IACAnK,KAAK,WAAA;AACH,WAAOiO;AAAAA,EACX,GACE5D,KAAK,SAAS2F,GAAAA;AACZ,QAAmB,OAARA,KAAQ,YAAYA,IAAM,KAAKhD,EAAYgD,CAAAA,EACpD,OAAM,IAAIE,WAAW,oGAAoGF,IAAM;AAEjI/B,IAAAA,IAAsB+B;AAAAA,EAC1B,EAAA,CAAA,GAGA9C,EAAa3C,OAAO,WAAA;AAAA,IAEdnO,KAAK0R,YAFS,UAGd1R,KAAK0R,YAAY1M,OAAO+O,eAAe/T,IAAAA,EAAM0R,YAC/C1R,KAAK0R,UAAU1M,uBAAOwN,OAAO,OAC7BxS,KAAK2R,eAAe,IAGtB3R,KAAK4R,gBAAgB5R,KAAK4R,iBAAAA;AAAAA,EAC5B,GAIAd,EAAa7L,UAAU+O,kBAAkB,SAAyB5K,GAAAA;AAChE,QAAiB,OAANA,KAAM,YAAYA,IAAI,KAAKwH,EAAYxH,CAAAA,EAChD,OAAM,IAAI0K,WAAW,kFAAkF1K,IAAI,GAAA;AAG7G,WADApJ,KAAK4R,gBAAgBxI,GACdpJ;AAAAA,EACT,GAQA8Q,EAAa7L,UAAUgP,kBAAkB,WAAA;AACvC,WAAOhC,EAAiBjS;EAC1B,GAEA8Q,EAAa7L,UAAUgD,OAAO,SAAcpI,GAAAA;AAE1C,aADImH,IAAO,IACFG,IAAI,GAAGA,IAAID,UAAUb,QAAQc,IAAKH,CAAAA,EAAKI,KAAKF,UAAUC;AAC/D,QAAI+M,IAAWrU,MAAS,SAEpBwS,IAASrS,KAAK0R;AAClB,QAAIW,MAAJ,OACE6B,CAAAA,IAAWA,KAAW7B,EAAO/O,UAAlB4Q;AAAAA,aACR,CAAKA,EACR,QAAA;AAGF,QAAIA,GAAS;AACX,UAAIC;AAGJ,UAFInN,EAAKX,SAAS,MAChB8N,IAAKnN,EAAK,CAAA,IACRmN,aAAcvU,MAGhB,OAAMuU;AAGR,UAAI9C,IAAM,IAAIzR,MAAM,sBAAsBuU,IAAK,OAAOA,EAAGrU,UAAU,MAAM,GAAA;AAEzE,YADAuR,EAAI+C,UAAUD,GACR9C;AAAAA,IACV;AAEE,QAAIG,IAAUa,EAAOxS,CAAAA;AAErB,QAAI2R,MAAJ,OACE;AAEF,QAAuB,OAAZA,KAAY,WACrBnB,CAAAA,EAAamB,GAASxR,MAAMgH,CAAAA;AAAAA,SAE5B;AAAA,UAAIP,IAAM+K,EAAQnL,QACd+B,KAAYmL,EAAW/B,GAAS/K,CAAAA;AACpC,WAASU,IAAI,GAAGA,IAAIV,GAAAA,EAAOU,EACzBkJ,CAAAA,EAAajI,GAAUjB,IAAInH,MAAMgH,CAAAA;AAAAA,IAHX;AAM1B,WAAA;AAAA,EACF,GAgEA8J,EAAa7L,UAAU2C,cAAc,SAAqB/H,GAAMkS,GAAAA;AAC9D,WAAOI,EAAanS,MAAMH,GAAMkS,GAAAA,EAAU;AAAA,EAC5C,GAEAjB,EAAa7L,UAAU0C,KAAKmJ,EAAa7L,UAAU2C,aAEnDkJ,EAAa7L,UAAUiD,kBACnB,SAAyBrI,GAAMkS,GAAAA;AAC7B,WAAOI,EAAanS,MAAMH,GAAMkS,GAAAA,EAAU;AAAA,EAChD,GAoBAjB,EAAa7L,UAAU4C,OAAO,SAAchI,GAAMkS,GAAAA;AAGhD,WAFAD,EAAcC,CAAAA,GACd/R,KAAK2H,GAAG9H,GAAMiT,EAAU9S,MAAMH,GAAMkS,CAAAA,CAAAA,GAC7B/R;AAAAA,EACT,GAEA8Q,EAAa7L,UAAUkD,sBACnB,SAA6BtI,GAAMkS,GAAAA;AAGjC,WAFAD,EAAcC,IACd/R,KAAKkI,gBAAgBrI,GAAMiT,EAAU9S,MAAMH,GAAMkS,CAAAA,CAAAA,GAC1C/R;AAAAA,EACb,GAGA8Q,EAAa7L,UAAU8C,iBACnB,SAAwBlI,GAAMkS;AAC5B,QAAIsC,GAAMhC,GAAQiC,GAAUnN,GAAGoN;AAK/B,QAHAzC,EAAcC,CAAAA,IAEdM,IAASrS,KAAK0R,aAFAK,OAIZ,QAAO/R;AAGT,SADAqU,IAAOhC,EAAOxS,QACd,OACE,QAAOG;AAET,QAAIqU,MAAStC,KAAYsC,EAAKtC,aAAaA,EACb,CAAA,EAAtB/R,KAAK2R,iBAAiB,IAC1B3R,KAAK0R,UAAU1M,uBAAOwN,OAAO,IAAA,KAAA,OAEtBH,EAAOxS,CAAAA,GACVwS,EAAOtK,kBACT/H,KAAKiI,KAAK,kBAAkBpI,GAAMwU,EAAKtC,YAAYA,CAAAA;AAAAA,oBAEvCsC,KAAS,YAAY;AAGrC,WAFAC,IAAAA,IAEKnN,IAAIkN,EAAKhO,SAAS,GAAGc,KAAK,GAAGA,IAChC,KAAIkN,EAAKlN,OAAO4K,KAAYsC,EAAKlN,CAAAA,EAAG4K,aAAaA,GAAU;AACzDwC,QAAAA,IAAmBF,EAAKlN,CAAAA,EAAG4K,UAC3BuC,IAAWnN;AACX;AAAA,MACZ;AAGQ,UAAImN,IAAW,EACb,QAAOtU;AAEQ,MAAbsU,MAAa,IACfD,EAAKG,MAAAA,KAiIf,SAAmBH,GAAMzJ,GAAAA;AACvB,eAAOA,IAAQ,IAAIyJ,EAAKhO,QAAQuE,IAC9ByJ,CAAAA,EAAKzJ,CAAAA,IAASyJ,EAAKzJ,IAAQ,CAAA;AAC7ByJ,QAAAA,EAAKI,IAAAA;AAAAA,MACP,GAnIoBJ,GAAMC,CAAAA,GAGdD,EAAKhO,WAAW,MAClBgM,EAAOxS,CAAAA,IAAQwU,EAAK,KAElBhC,EAAOtK,6BACT/H,KAAKiI,KAAK,kBAAkBpI,GAAM0U,KAAoBxC,CAAAA;AAAAA,IAChE;AAEM,WAAO/R;AAAAA,EACb,GAEA8Q,EAAa7L,UAAU6C,MAAMgJ,EAAa7L,UAAU8C,gBAEpD+I,EAAa7L,UAAU+C,qBACnB,SAA4BnI,GAAAA;AAC1B,QAAIuI,GAAWiK,GAAQlL;AAGvB,SADAkL,IAASrS,KAAK0R,aACd,OACE,QAAO1R;AAGT,QAAIqS,EAAOtK,mBAAX,OAUE,QATIb,UAAUb,WAAW,KACvBrG,KAAK0R,UAAU1M,uBAAOwN,OAAO,IAAA,GAC7BxS,KAAK2R,eAAe,KACXU,EAAOxS,CAAAA,MADI,aAEdG,KAAK2R,iBAAiB,IAC1B3R,KAAK0R,UAAU1M,uBAAOwN,OAAO,IAAA,IAAA,OAEtBH,EAAOxS,CAAAA,IAEXG;AAIT,QAAIkH,UAAUb,WAAW,GAAG;AAC1B,UACIyJ,GADAF,IAAO5K,OAAO4K,KAAKyC,CAAAA;AAEvB,WAAKlL,IAAI,GAAGA,IAAIyI,EAAKvJ,QAAAA,EAAUc,EAEjB,EADZ2I,IAAMF,EAAKzI,CAAAA,OACC,oBACZnH,KAAKgI,mBAAmB8H;AAK1B,aAHA9P,KAAKgI,mBAAmB,gBAAA,GACxBhI,KAAK0R,UAAU1M,uBAAOwN,OAAO,IAAA,GAC7BxS,KAAK2R,eAAe,GACb3R;AAAAA,IACf;AAIM,QAAyB,QAFzBoI,IAAYiK,EAAOxS,CAAAA,MAEM,WACvBG,MAAK+H,eAAelI,GAAMuI,CAAAA;AAAAA,aACjBA,MAAJ,OAEL,MAAKjB,IAAIiB,EAAU/B,SAAS,GAAGc,KAAK,GAAGA,IACrCnH,MAAK+H,eAAelI,GAAMuI,EAAUjB,CAAAA,CAAAA;AAIxC,WAAOnH;AAAAA,EACb,GAmBA8Q,EAAa7L,UAAUmD,YAAY,SAAmBvI,GAAAA;AACpD,WAAOqT,EAAWlT,MAAMH,GAAAA,EAAM;AAAA,EAChC,GAEAiR,EAAa7L,UAAUyP,eAAe,SAAsB7U,GAAAA;AAC1D,WAAOqT,EAAWlT,MAAMH,GAAAA,EAAM;AAAA,EAChC,GAEAiR,EAAa0C,gBAAgB,SAASxC,GAASnR,GAAAA;AAC7C,WAAqC,OAA1BmR,EAAQwC,iBAAkB,aAC5BxC,EAAQwC,cAAc3T,CAAAA,IAEtB2T,EAAcrO,KAAK6L,GAASnR;EAEvC,GAEAiR,EAAa7L,UAAUuO,gBAAgBA,GAiBvC1C,EAAa7L,UAAU0P,aAAa,WAAA;AAClC,WAAO3U,KAAK2R,eAAe,IAAIzB,EAAelQ,KAAK0R,OAAAA,IAAW,CAAA;AAAA,EAChE;;;;;;ACzaA,MAAIkD,oBCKJC,KACA,SAASD,EAAQE,GAAIC,GAAAA;AACnB,QAAID,KAAMC,EAAI,QAAOH,EAAOE,GAAIC,CAAAA;AAEhC,QAAkB,OAAPD,KAAO,WAChB,OAAM,IAAI9C,UAAU,uBAAA;AAMtB,WAJAhN,OAAO4K,KAAKkF,CAAAA,EAAIjF,QAAQ,SAAUmF,GAAAA;AAChCC,MAAAA,EAAQD,CAAAA,IAAKF,EAAGE,CAAAA;AAAAA,IACpB,CAAA,GAESC;AAEP,aAASA;AAEP,eADIjO,IAAO,IAAIC,MAAMC,UAAUb,MAAAA,GACtBc,IAAI,GAAGA,IAAIH,EAAKX,QAAQc,IAC/BH,CAAAA,EAAKG,KAAKD,UAAUC,CAAAA;AAEtB,UAAImM,IAAMwB,EAAGzN,MAAMrH,MAAMgH,CAAAA,GACrB+N,IAAK/N,EAAKA,EAAKX,SAAO,CAAA;AAM1B,oBALWiN,KAAQ,cAAcA,MAAQyB,KACvC/P,OAAO4K,KAAKmF,CAAAA,EAAIlF,QAAQ,SAAUmF,GAAAA;AAChC1B,QAAAA,EAAI0B,CAAAA,IAAKD,EAAGC,CAAAA;AAAAA,MACpB,CAAA,GAEW1B;AAAAA,IACX;AAAA,EACA;ADZA,WAASzL,EAAMiN,GAAAA;AACb,QAAII,IAAI,WAAA;AACN,aAAIA,EAAEC,SAAeD,EAAEpS,SACvBoS,EAAEC,SAAAA,IACKD,EAAEpS,QAAQgS,EAAGzN,MAAMrH,MAAMkH,SAAAA;AAAAA,IACpC;AAEE,WADAgO,EAAEC,SAAAA,IACKD;AAAAA,EACT;AAEA,WAASE,EAAYN,GAAAA;AACnB,QAAII,IAAI,WAAA;AACN,UAAIA,EAAEC,OACJ,OAAM,IAAIvV,MAAMsV,EAAEG,SAAAA;AAEpB,aADAH,EAAEC,SAAAA,IACKD,EAAEpS,QAAQgS,EAAGzN,MAAMrH,MAAMkH,SAAAA;AAAAA,IACpC,GACMxC,IAAOoQ,EAAGpQ,QAAQ;AAGtB,WAFAwQ,EAAEG,YAAY3Q,IAAO,uCACrBwQ,EAAEC,SAAAA,IACKD;AAAAA,EACT;SAxCAI,GAAA/P,UAAiBqP,EAAO/M,CAAAA,GACxByN,GAAA/P,QAAAgQ,SAAwBX,EAAOQ,CAAAA,GAE/BvN,EAAK2N,QAAQ3N,EAAK,WAAA;AAChB7C,WAAO8I,eAAe0C,SAASvL,WAAW,QAAQ,EAChDnC,OAAO,WAAA;AACL,aAAO+E,EAAK7H,IAAAA;AAAAA,IAClB,GACIgO,cAAAA,GAAc,CAAA,GAGhBhJ,OAAO8I,eAAe0C,SAASvL,WAAW,cAAc,EACtDnC,OAAO;AACL,aAAOsS,EAAWpV,IAAAA;AAAAA,IACxB,GACIgO,iBAAc,CAAA;AAAA,EAElB,CAAA;;;;;;AEjBA,MAAIyH;iBAEJC,KAA2C,OAAnBC,kBAAmB,aACvCA,eAAe1C,KAAuB,OAAX5Q,SAAW,MAAcA,SAASuT,MAE7Db,QAAOU,MAAYA,IAAUxE,QAAQC,YACpC2E,KAAKd,CAAAA,EACLe,MAAMzE,OAAOxL,WAAW,MAAA;AAAQ,UAAMwL;AAAAA,EAAAA,GAAO,CAAA,CAAA;;;;UCPlD0E,KAIA,SAAsBC,GAAOjB,GAAAA;AAC3B,QAAIkB,GAASC,GAAStG,GAClBuG,IAAAA;AAEAlP,UAAMmP,QAAQJ,CAAAA,KAChBC,IAAU,CAAA,GACVC,IAAUF,EAAM3P,WAEhBuJ,IAAO5K,OAAO4K,KAAKoG,CAAAA,GACnBC,IAAU,CAAA,GACVC,IAAUtG,EAAKvJ;AAGjB,aAASxD,EAAMwO;AACb,eAASrP,IAAAA;AACH+S,QAAAA,KAAIA,EAAG1D,GAAK4E,CAAAA,GAChBlB,IAAK;AAAA,MACX;AACQoB,MAAAA,IAAQR,EAAe3T,CAAAA,IACtBA,EAAAA;AAAAA,IACT;AAEE,aAASqU,EAAMlP,GAAGkK,GAAKiF,GAAAA;AACrBL,MAAAA,EAAQ9O,CAAAA,IAAKmP,IACK,EAAZJ,MAAY,KAAK7E,MACrBxO,EAAKwO,CAAAA;AAAAA,IAEX;AAEO6E,IAAAA,IAGMtG,IAETA,EAAKC,QAAQ,SAAUC,GAAAA;AACrBkG,QAAMlG,CAAAA,EAAK,SAAUuB,GAAKiF,GAAAA;AAAUD,QAAAA,EAAKvG,GAAKuB,GAAKiF,CAAAA;AAAAA,MAAO,CAAA;AAAA,IAChE,KAGIN,EAAMnG,QAAQ,SAAU0G,GAAMpP;AAC5BoP,MAAAA,EAAK,SAAUlF,GAAKiF,GAAAA;AAAUD,QAAAA,EAAKlP,GAAGkK,GAAKiF,CAAAA;AAAAA,MAAO,CAAA;AAAA,IACxD,KAVIzT,EAAK,IAAA,GAaPsT,IAAAA;AAAAA,EACF;AA/CA,QAAMR,IAAiBhG,GAAAA;;;mBCHjB6G,IAA0B,OAAXnU,SAAW,MAAcA,SAAS6K,MAG1CuJ,KAAoBD,EAAMC,qBAAqBD,EAAME,wBAAwBF,EAAMG,yBAEnFC,KAAwBJ,EAAMI,yBAAyBJ,EAAMK,4BAA4BL,EAAMM,6BAE/FC,KAAkBP,EAAMO,mBAAmBP,EAAMQ,sBAAsBR,EAAMS;;;;;ACP1F,QAAMC,uBCANC,KAAiB,MAAA;AAAA,IACf,YAAaC,GAAAA;AACX,YAAMA,IAAM,MAAQA,IAAM,IAAKA,EAAY,OAAM,IAAIxX,MAAM,mDAAA;AAC3DI,WAAKqX,SAAS,IAAIpQ,MAAMmQ,CAAAA,GACxBpX,KAAKsX,OAAOF,IAAM,GAClBpX,KAAKuX,MAAM,GACXvX,KAAKwX,MAAM,GACXxX,KAAKyX,OAAO;AAAA,IAChB;AAAA,IAEE;AACEzX,WAAKuX,MAAMvX,KAAKwX,MAAM,GACtBxX,KAAKyX,OAAO,MACZzX,KAAKqX,OAAOK,KAAAA,MAAKC;AAAAA,IACrB;AAAA,IAEE,KAAMxU,GAAAA;AACJ,aAAInD,KAAKqX,OAAOrX,KAAKuX,GAAAA,MAArB,WACAvX,KAAKqX,OAAOrX,KAAKuX,GAAAA,IAAOpU,GACxBnD,KAAKuX,MAAOvX,KAAKuX,MAAM,IAAKvX,KAAKsX,MAAAA;AAAAA,IAErC;AAAA,IAEE,QAAA9C;AACE,YAAMoD,IAAO5X,KAAKqX,OAAOrX,KAAKwX,GAAAA;AAC9B,UAAII,aAGJ,QAFA5X,KAAKqX,OAAOrX,KAAKwX,GAAAA,IAAAA,QACjBxX,KAAKwX,MAAOxX,KAAKwX,MAAM,IAAKxX,KAAKsX,MAC1BM;AAAAA,IACX;AAAA,IAEE,OAAAC;AACE,aAAO7X,KAAKqX,OAAOrX,KAAKwX,GAAAA;AAAAA,IAC5B;AAAA,IAEE,UAAAM;AACE,aAAO9X,KAAKqX,OAAOrX,KAAKwX,GAAAA,MAAxB;AAAA,IACJ;AAAA,EAAA;SDnCAO,KAAiB,MAAA;AAAA,IACf,YAAaX;AACXpX,WAAKoX,MAAMA,KAAO,IAClBpX,KAAKgY,OAAO,IAAId,EAAUlX,KAAKoX,MAC/BpX,KAAKiY,OAAOjY,KAAKgY,MACjBhY,KAAKqG,SAAS;AAAA,IAClB;AAAA,IAEE;AACErG,WAAKgY,OAAOhY,KAAKiY,MACjBjY,KAAKgY,KAAKE,MAAAA,GACVlY,KAAKqG,SAAS;AAAA,IAClB;AAAA,IAEE,KAAMmD,GAAAA;AAEJ,UADAxJ,KAAKqG,UAAAA,CACArG,KAAKgY,KAAK5Q,KAAKoC,CAAAA,GAAM;AACxB,cAAM8D,IAAOtN,KAAKgY;AAClBhY,aAAKgY,OAAO1K,EAAKmK,OAAO,IAAIP,EAAU,IAAIlX,KAAKgY,KAAKX,OAAOhR,MAAAA,GAC3DrG,KAAKgY,KAAK5Q,KAAKoC,CAAAA;AAAAA,MACrB;AAAA,IACA;AAAA,IAEE;AACsB,MAAhBxJ,KAAKqG,WAAW,KAAGrG,KAAKqG;AAC5B,YAAMmD,IAAMxJ,KAAKiY,KAAKzD;AACtB,UAAIhL,MAAJ,UAAyBxJ,KAAKiY,KAAKR,MAAM;AACvC,cAAMA,IAAOzX,KAAKiY,KAAKR;AAGvB,eAFAzX,KAAKiY,KAAKR,OAAO,MACjBzX,KAAKiY,OAAOR,GACLzX,KAAKiY,KAAKzD,MAAAA;AAAAA,MACvB;AAEI,aAAOhL;AAAAA,IACX;AAAA,IAEE,OAAAqO;AACE,YAAMrO,IAAMxJ,KAAKiY,KAAKJ,KAAAA;AACtB,aAAIrO,gBAAqBxJ,KAAKiY,KAAKR,OAAazX,KAAKiY,KAAKR,KAAKI,KAAAA,IACxDrO;AAAAA,IACX;AAAA,IAEE,UAAAsO;AACE,aAAO9X,KAAKqG,WAAW;AAAA,IAC3B;AAAA,EAAA;;;4BE9CA8R,KAAiB,MAAA;AAAA,IACf,YAAaC,GAAAA;AACXpY,WAAKqY,UAAU,IAAIC,YAAYF,MAAa,YAAY,aAAaA;IACzE;AAAA,IAEE,IAAA,YAAIG;AACF,aAAA;AAAA,IACJ;AAAA,IAEE,OAAQpV,GAAAA;AACN,aAAOnD,KAAKqY,QAAQG,OAAOrV,GAAM,EAAEsV,QAAAA,GAAQ,CAAA;AAAA,IAC/C;AAAA,IAEE;AACE,aAAOzY,KAAKqY,QAAQG,OAAO,IAAIE,WAAW,CAAA,CAAA;AAAA,IAC9C;AAAA,EAAA;;;;;ACfA,QAAMC,IAAqBhJ,MACrBiJ,IAAcC,GAAAA;SAEpBC,KAAiB;IACf,YAAaV,IAAW,QAAA;AAGtB,cAFApY,KAAKoY,YAoCT,SAA4BA,GAAAA;AAG1B,gBAFAA,IAAWA,EAASvO,YAAAA,GAAAA;AAAAA,UAGlB,KAAK;AAAA,UACL,KAAK;AACH,mBAAO;AAAA,UACT,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AACH,mBAAO;AAAA,UACT,KAAK;AAAA,UACL,KAAK;AACH,mBAAO;AAAA,UACT,KAAK;AAAA,UACL,KAAK;AAAA,UACL,KAAK;AACH,mBAAOuO;AAAAA,UACT;AACE,kBAAM,IAAIxY,MAAM,uBAAuBwY,CAAAA;AAAAA,QAAAA;AAAAA,MAE7C,GA1DsCA,CAAAA,GAE1BpY,KAAKoY,UAAAA;AAAAA,QACX,KAAK;AACHpY,eAAKqY,UAAU,IAAIO;AACnB;AAAA,QACF,KAAK;AAAA,QACL,KAAK;AACH,gBAAM,IAAIhZ,MAAM,2BAA2BI,KAAKoY,QAAAA;AAAAA,QAClD;AACEpY,eAAKqY,UAAU,IAAIM,EAAmB3Y,KAAKoY,QAAAA;AAAAA,MAAAA;AAAAA,IAEnD;AAAA,IAEE,gBAAIG;AACF,aAAOvY,KAAKqY,QAAQE;AAAAA,IACxB;AAAA,IAEE,KAAMpV,GAAAA;AACJ,aAAoB,OAATA,KAAS,WAAiBA,IAC9BnD,KAAKqY,QAAQG,OAAOrV,CAAAA;AAAAA,IAC/B;AAAA,IAGE,MAAOA,GAAAA;AACL,aAAOnD,KAAKoH,KAAKjE;IACrB;AAAA,IAEE,IAAKA,GAAAA;AACH,UAAImT,IAAS;AAGb,aAFInT,MAAMmT,IAAStW,KAAKoH,KAAKjE,CAAAA,IAC7BmT,KAAUtW,KAAKqY,QAAQU,MAAAA,GAChBzC;AAAAA,IACX;AAAA,EAAA;;;;;ACtCA,QAAA,EAAMxF,cAAEA,EAAAA,uBCARkI,KAAiBrJ,ODCXsJ,IAAmB,IAAIrZ,MAAM,sBAAA,GAC7BsZ,IAAkB,IAAItZ,MAAM,iBAAA,GAE5BuZ,IAAON,MACPP,IAAcc,GAAAA,GAGdC,IAAgC,OAAnB1D,iBAAmB,MAAcb,CAAAA,MAAMc,GAAOpQ,QAAQuB,SAAS+N,KAAMa,gBAKlF2D,IAAG,WAQHC,IALgB,IAKFD,GACdE,IALgB,IAKIF,GAIpBG,IAAwB,IACxBC,IAAwB,IACxBC,IAAwB,KACxBC,IAAwB,KAExBC,IAAwB,MACxBC,IAAwB,MACxBC,IAAwB,MACxBC,IAAwB,MACxBC,IAAwB,OACxBC,IAAwB,OAExBC,IAAwB,QAOxBC,IAA0BR,QAE1BS,IAtBwB,KAsBMf,GAG9BgB,IAA8BhB,WAI9BiB,IAbeX,MAaeN,GAC9BkB,KAA8BlB,WAE9BmB,KAA8BnB,WAI9BoB,KAAmB,KAAiB,IACpCC,IAAmB,KAAiB,IACpCC,IAAmB,KAAiB,IACpCC,IAAmB,KAAiB,IACpCC,KAAmB,MAAiB,IACpCC,IAAmB,MAAiB,IACpCC,IAAmB,MAAiB,IACpCC,KAAmB,OAAiB,IACpCC,KAAmB,OAAiB,IACpCC,KAAmB,OAAiB,IACpCC,KAAmB,QAAiB,IAGpCC,KAAsB/B,WAItBgC,KAAsBhC,WAEtBiC,KAAsBjC,WAGtBkC,KAASC,QACTC,KAAapC,WACbqC,KAAO1B,SACP2B,KAAiBC,IACjBC,KAAcF,IACdG,KAAeH,SAEfI,KAAoBf,UAEpBgB,KAAaH,UAebI,KAA0BrB,SAE1BsB,KAAeL,WAQfM,KAAgBC,OAAOD,iBAAiBC,OAAO,eAAA;AAAA,EAErD,MAAMC,GAAAA;AAAAA,IACJ,YAAa7D,GAAAA,EAAQ8D,eAAEA,IAAgB,OAAKrN,KAAEA,IAAM,MAAIsN,aAAEA,GAAWvZ,YAAEA,GAAUwZ,oBAAEA,EAAAA,IAAuB,CAAA,GAAA;AACxGzc,WAAKyY,SAASA,GACdzY,KAAKiG,QAAQ,IAAIkT,KACjBnZ,KAAKuc,gBAAgBA,GACrBvc,KAAK0c,WAAW,GAChB1c,KAAKsD,QAAQ,MACbtD,KAAK2c,WAAW,MAChB3c,KAAK4c,SAAS,MACd5c,KAAKiD,aAAawZ,KAAsBxZ,KAAc4Z,IACtD7c,KAAKkP,MAAMsN,KAAetN,GAC1BlP,KAAK8c,aAAaA,GAAW7J,KAAKjT,IAAAA,GAClCA,KAAK+c,sBAAsBC,GAAc/J,KAAKjT,IAAAA;AAAAA,IAClD;AAAA,IAEE,IAAA,QAAIid;AACF,cAAQjd,KAAKyY,OAAOyE,eAAenC,OAAgB;AAAA,IACvD;AAAA,IAEE,KAAM5X,GAAAA;AACJ,aAAA,EAxBoBgY,YAwBfnb,KAAKyY,OAAOyE,kBACbld,KAAKkP,QAAQ,SAAM/L,IAAOnD,KAAKkP,IAAI/L,CAAAA,IAEvCnD,KAAK0c,YAAY1c,KAAKiD,WAAWE,CAAAA,GACjCnD,KAAKiG,MAAMmB,KAAKjE,CAAAA,GAEZnD,KAAK0c,WAAW1c,KAAKuc,iBACvBvc,KAAKyY,OAAOyE,gBAAgBrC,GAAAA,OAI9B7a,KAAKyY,OAAOyE,gBA5CmBrC,SAAAA;AAAAA,IA8CnC;AAAA,IAEE;AACE,YAAM1X,IAAOnD,KAAKiG,MAAMuO;AAKxB,aAHAxU,KAAK0c,YAAY1c,KAAKiD,WAAWE,CAAAA,GAC7BnD,KAAK0c,aAAa,MAAG1c,KAAKyY,OAAOyE,gBAjFb5D,YAmFjBnW;AAAAA,IACX;AAAA,IAEE,IAAKA,GAAAA;AACiB,MAAA,OAATA,KAAS,aAAYnD,KAAKyY,OAAO5Q,KAAK,UAAU1E,KAClDA,KAAAA,QAAqCnD,KAAKoH,KAAKjE,CAAAA,GACxDnD,KAAKyY,OAAOyE,gBAAgBld,KAAKyY,OAAOyE,eAAe/B,MAAmBE;AAAAA,IAC9E;AAAA,IAEE,UAAWlY,GAAM4R,GAAAA;AACf,YAAMsC,IAAS,IACToB,IAASzY,KAAKyY;AAGpB,WADApB,EAAOjQ,KAAKjE,CAAAA,IACJsV,EAAOyE,eAAef,QAAkBD,KAC9C7E,CAAAA,EAAOjQ,KAAKqR,EAAO0E,eAAe3I,MAAAA,CAAAA;AAGpC,WAAKiE,EAAOyE,eAAepB,QAAiB,EAAG,QAAO/G,EAAG,IAAA;AACzD0D,MAAAA,EAAO2E,QAAQ/F,GAAQtC,CAAAA;AAAAA,IAC3B;AAAA,IAEE,SAAAsI;AACE,YAAM5E,IAASzY,KAAKyY;AAEpBA,MAAAA,EAAOyE,gBAAgBvC;AAEvB,SAAG;AACD,gBAAQlC,EAAOyE,eAAef,QAAkBtB,KAAc;AAC5D,gBAAM1X,IAAOnD,KAAKwU;AAClBiE,UAAAA,EAAOyE,gBA/EkBxC,UAgFzBjC,EAAO6E,OAAOna,GAAMnD,KAAK8c,UAAAA;AAAAA,QACjC;AAlFiClC,kBAoFtBnC,EAAOyE,gBAAgDld,KAAKud,iBAAAA;AAAAA,MACvE,SAAavd,KAAKwd,eAAAA;AAEd/E,MAAAA,EAAOyE,gBAtHiB5D;AAAAA,IAuH5B;AAAA,IAEE,mBAAAiE;AACE,YAAM9E,IAASzY,KAAKyY;AAEpB,WA3F2BqD,YA2FtBrD,EAAOyE,kBAA2C/B,GAGrD,QAFA1C,EAAOyE,eAAezE,EAAOyE,eAAexC,IAAAA,KAC5CjC,EAAOgF,OAAOC,GAAWzK,KAAKjT,IAAAA,CAAAA;AA3Ld,OA+LbyY,EAAOyE,eAAetB,QA/LT,KAuMbnD,EAAOyE,eAAejB,QAzMT,MA0MhBxD,EAAOyE,gBAAgBzE,EAAOyE,eAAe1B,MAAUjC,GACvDd,EAAOkF,MAAMC,GAAU3K,KAAKjT,IAAAA,CAAAA,MATvByY,EAAOyE,eAAelB,QAAuB,MAChDvD,EAAOyE,gBAAgB1B,IACvB/C,EAAOoF,SAASC,GAAa7K,KAAKjT;IAS1C;AAAA,IAEE,iBAAAwd;AACE,cAAKxd,KAAKyY,OAAOyE,eAAejC,QAAqB,MACrDjb,KAAKyY,OAAOyE,gBAAgB5B,IAAAA;AAAAA,IAEhC;AAAA,IAEE,iBAAAyC;AAAAA,OAnH+BpD,WAoHxB3a,KAAKyY,OAAOyE,kBAA6CtC,IAAe5a,KAAKqd,WAC7Erd,KAAKge,eAAAA;AAAAA,IACd;AAAA,IAEE;AACuD,OAAhDhe,KAAKyY,OAAOyE,eAAejC,QAAqB,MACrDjb,KAAKyY,OAAOyE,gBAAgBjC,KACvBjb,KAAKyY,OAAOyE,eAAevC,OAAoB,KAAGtB,EAAIrZ,KAAK+c,mBAAAA;AAAAA,IACpE;AAAA,EAAA;AAAA,EAGA,MAAMkB;IACJ,YAAaxF,GAAAA,EAAQ8D,eAAEA,IAAgB,OAAKrN,KAAEA,IAAM,MAAIgP,aAAEA,GAAWjb,YAAEA,GAAUkb,oBAAEA,MAAuB,CAAA,GAAA;AACxGne,WAAKyY,SAASA,GACdzY,KAAKiG,QAAQ,IAAIkT,KACjBnZ,KAAKuc,gBAAgBA,MAAkB,IAAI,IAAIA,GAC/Cvc,KAAK0c,WAAW,GAChB1c,KAAKoe,YAAY7B,IAAgB,GACjCvc,KAAKsD,QAAQ,MACbtD,KAAK2c,WAAW,MAChB3c,KAAKiD,aAAakb,KAAsBlb,KAAc4Z,IACtD7c,KAAKkP,MAAMgP,KAAehP,GAC1BlP,KAAKqe,SAAS,MACdre,KAAKse,YAAYA,GAAUrL,KAAKjT,OAChCA,KAAK+c,sBAAsBwB,GAAatL,KAAKjT;IACjD;AAAA,IAEE,IAAA,QAAIid;AACF,cAAQjd,KAAKyY,OAAOyE,eAAejD,OAAe;AAAA,IACtD;AAAA,IAEE,KAAMoE,GAAQtJ,GAAAA;AACZ,UAAI/U,KAAKqe,WAAW,KAAM,OAAM,IAAIze,MAAM,kCAAA;AAS1C,UARkB,OAAPmV,KAAO,eAAYA,IAAK,OAEnC/U,KAAKyY,OAAOyE,gBA3Oc,KA4O1Bld,KAAKqe,SAASA,GACdre,KAAK2c,WAAW,IAAI6B,GAASxe,KAAKyY,QAAQ4F,GAAQtJ,CAAAA,GAE9CA,KAAI/U,KAAKyY,OAAO9Q,GAAG,SAASb,EAAAA,GAE5B2X,GAAUJ,GACZA,CAAAA,EAAOlB,eAAeR,WAAW3c,KAAK2c,UAClC5H,KAAIsJ,EAAO1W,GAAG,SAASb,KAC3BuX,EAAO1W,GAAG,UAAU3H,KAAK2c,SAAS+B,SAASzL,KAAKjT,KAAK2c,QAAAA,CAAAA;AAAAA,WAChD;AACL,cAAMgC,IAAU3e,KAAK2c,SAAS9Z,KAAKoQ,KAAKjT,KAAK2c,UAAU0B,CAAAA,GACjDO,IAAU5e,KAAK2c,SAAS9Z,KAAKoQ,KAAKjT,KAAK2c,UAAU0B,GAAQ,IAAA;AAC/DA,QAAAA,EAAO1W,GAAG,SAASgX,CAAAA,GACnBN,EAAO1W,GAAG,SAASiX,CAAAA,GACnBP,EAAO1W,GAAG,UAAU3H,KAAK2c,SAAS+B,SAASzL,KAAKjT,KAAK2c;MAC3D;AAEI0B,MAAAA,EAAO1W,GAAG,SAASkX,GAAW5L,KAAKjT,IAAAA,CAAAA,GACnCA,KAAKyY,OAAOxQ,KAAK,UAAUoW,CAAAA,GAC3BA,EAAOpW,KAAK,QAAQjI,KAAKyY,MAAAA;AAAAA,IAC7B;AAAA,IAEE,KAAMtV,GAAAA;AACJ,YAAMsV,IAASzY,KAAKyY;AAEpB,aAAItV,MAAS,QACXnD,KAAKuc,gBAAgB,GACrB9D,EAAOyE,eApPuB5D,YAoPPb,EAAOyE,eAAerD,MAAAA,MAI3C7Z,KAAKkP,QAAQ,SACf/L,IAAOnD,KAAKkP,IAAI/L,CAAAA,OACH,QACXsV,EAAOyE,gBAAgB5C,GAChBta,KAAK0c,WAAW1c,KAAKuc,kBAIhCvc,KAAK0c,YAAY1c,KAAKiD,WAAWE,CAAAA,GACjCnD,KAAKiG,MAAMmB,KAAKjE,CAAAA,GAEhBsV,EAAOyE,gBAAgBzE,EAAOyE,eAAevD,KAAeW,GAErDta,KAAK0c,WAAW1c,KAAKuc;AAAAA,IAChC;AAAA,IAEE;AACE,YAAMpZ,IAAOnD,KAAKiG,MAAMuO;AAIxB,aAFAxU,KAAK0c,YAAY1c,KAAKiD,WAAWE,CAAAA,GAC7BnD,KAAK0c,aAAa,MAAG1c,KAAKyY,OAAOyE,gBAzQL5D,YA0QzBnW;AAAAA,IACX;AAAA,IAEE,QAASA,GAAAA;AACP,YAAM+S,IAAU,CAAClW,KAAKkP,QAAQ,OAAOlP,KAAKkP,IAAI/L,CAAAA,IAAQA,CAAAA;AACtD,aAAOnD,KAAK0c,WAAW,IAAGxG,CAAAA,EAAQ9O,KAAKpH,KAAKwU,MAAAA,CAAAA;AAE5C,eAASrN,IAAI,GAAGA,IAAI+O,EAAQ7P,SAAS,GAAGc,KAAK;AAC3C,cAAMhE,IAAO+S,EAAQ/O;AACrBnH,aAAK0c,YAAY1c,KAAKiD,WAAWE,IACjCnD,KAAKiG,MAAMmB,KAAKjE,CAAAA;AAAAA,MACtB;AAEInD,WAAKoH,KAAK8O,EAAQA,EAAQ7P,SAAS,CAAA,CAAA;AAAA,IACvC;AAAA,IAEE,OAAAtD;AACE,YAAM0V,IAASzY,KAAKyY;AAEpB,WAjPgBqD,QAiPXrD,EAAOyE,kBAAgCvD,GAAa;AACvD,cAAMxW,IAAOnD,KAAKwU,MAAAA;AAGlB,eAFIxU,KAAKqe,WAAW,QAAQre,KAAKqe,OAAOS,MAAM3b,CAAAA,MAArCkb,OAAsD5F,EAAOyE,gBAAgB3C,KACjF9B,EAAOyE,eAAepD,OAAoB,KAAGrB,EAAOxQ,KAAK,QAAQ9E,CAAAA,GAC/DA;AAAAA,MACb;AAOI,aALInD,KAAKoe,cAKT,OAJE3F,EAAOyE,gBAAgB/C,GACvBna,KAAKge,eAAAA,IAGA;AAAA,IACX;AAAA,IAEE,QAAAe;AACE,YAAMtG,IAASzY,KAAKyY;AAEpB,cAnQgBqD,QAmQRrD,EAAOyE,kBAAgCvD,KA1T9BC,MA0T8CnB,EAAOyE,gBAAoC;AACxG,cAAM/Z,IAAOnD,KAAKwU;AACE,QAAhBxU,KAAKqe,WAAW,QAAQre,KAAKqe,OAAOS,MAAM3b,CAAAA,MAArCkb,OAAsD5F,EAAOyE,gBAAgB3C,KACjF9B,EAAOyE,eAAepD,OAAoB,KAAGrB,EAAOxQ,KAAK,QAAQ9E,CAAAA;AAAAA,MAC5E;AAAA,IACA;AAAA,IAEE,SAAAka;AACE,YAAM5E,IAASzY,KAAKyY;AAEpBA,MAAAA,EAAOyE,gBAAgBzD;AAEvB,SAAG;AAGD,aAFAzZ,KAAK+e,SAEE/e,KAAK0c,WAAW1c,KAAKuc,kBA/QVT,SA+Q4BrD,EAAOyE,kBAAoC/C,IACvF1B,CAAAA,EAAOyE,gBAzUoBzB,OA0U3BhD,EAAOuG,MAAMhf,KAAKse,YAClBte,KAAK+e,MAAAA;AAzUyBhF,SAsDT+B,QAsRlBrD,EAAOyE,iBA5UoBnD,SA6U9BtB,EAAOyE,gBAAgBlD,GACvBvB,EAAOxQ,KAAK,UAAA,IA/UYyR,KAkVrBjB,EAAOyE,gBAA+Cld,KAAKud,iBAAAA;AAAAA,MACtE,SAAavd,KAAKwd,eAAAA,MAAlB;AAEI/E,MAAAA,EAAOyE,gBAxUyB5D;AAAAA,IAyUpC;AAAA,IAEE,mBAAAiE;AACE,YAAM9E,IAASzY,KAAKyY;AAAAA,OAnSGqD,OAqSlBrD,EAAOyE,kBAAuCrD,MACjDpB,EAAOyE,eAlVuB5D,YAkVPb,EAAOyE,eAAejD,OAC7CxB,EAAOxQ,KAAK,KAAA,IACPwQ,EAAOyE,eAAenB,QAAkBJ,OAAMlD,EAAOyE,gBAvX1C,IAwXZld,KAAKqe,WAAW,QAAMre,KAAKqe,OAAOrc,IAAAA,KAGnCyW,EAAOyE,eAAetB,QA3XT,KAmYbnD,EAAOyE,eAAejB,QArYT,MAsYhBxD,EAAOyE,gBAAgBzE,EAAOyE,eAAe1B,MAAUjC,GACvDd,EAAOkF,MAAMC,GAAU3K,KAAKjT,IAAAA,CAAAA,MATvByY,EAAOyE,eAAelB,QAAuB,MAChDvD,EAAOyE,gBAAgB1B,IACvB/C,EAAOoF,SAASC,GAAa7K,KAAKjT,IAAAA,CAAAA;AAAAA,IAS1C;AAAA,IAEE,iBAAAwd;AACE,cAAKxd,KAAKyY,OAAOyE,eAAehD,OAAoB,MACpDla,KAAKyY,OAAOyE,gBAAgB1C,IAAAA;AAAAA,IAEhC;AAAA,IAEE;OA5T8Bf,QA6TvBzZ,KAAKyY,OAAOyE,kBAA4CxD,IAAc1Z,KAAKqd,OAAAA,IAC3Erd,KAAKge,eAAAA;AAAAA,IACd;AAAA,IAEE,uBAAAiB;AAhUgC/E,cAiUzBla,KAAKyY,OAAOyE,iBACjBld,KAAKyY,OAAOyE,gBAAgBhD,IACvBla,KAAKyY,OAAOyE,eAAezD,OAAmB,KAAGJ,EAAIrZ,KAAK+c,mBAAAA;AAAAA,IACnE;AAAA,IAEE,iBAAAiB;AACsD,OAA/Che,KAAKyY,OAAOyE,eAAehD,OAAoB,MACpDla,KAAKyY,OAAOyE,gBAAgBhD,IACvBla,KAAKyY,OAAOyE,eAAezD,OAAmB,KAAGJ,EAAIrZ,KAAK+c,mBAAAA;AAAAA,IACnE;AAAA,EAAA;AAAA,EAGA,MAAMmC,GAAAA;AAAAA,IACJ,YAAazG,GAAAA;AACXzY,WAAKmD,OAAO,MACZnD,KAAKmf,iBAAiBA,GAAelM,KAAKwF,CAAAA,GAC1CzY,KAAK0d,aAAa;AAAA,IACtB;AAAA,EAAA;AAAA,EAGA,MAAMc,GAAAA;AAAAA,IACJ,YAAaY,GAAKC,GAAKtK,GAAAA;AACrB/U,WAAKoE,OAAOgb,GACZpf,KAAKqE,KAAKgb,GACVrf,KAAKsf,YAAYvK,GACjB/U,KAAKsD,QAAQ,MACbtD,KAAKuf,iBAAAA;AAAAA,IACT;AAAA,IAEE,WAAAb;AACE1e,WAAKuf,iBAAAA;AAAAA,IACT;AAAA,IAEE,KAAM9G,GAAQpH;AACRA,MAAAA,MAAKrR,KAAKsD,QAAQ+N,IAElBoH,MAAWzY,KAAKqE,OAClBrE,KAAKqE,KAAK,MAENrE,KAAKoE,SAAS,QAQhBqU,MAAWzY,KAAKoE,SAClBpE,KAAKoE,OAAO,MAERpE,KAAKqE,OAAO,SAQdrE,KAAKsf,cAAc,QAAMtf,KAAKsf,UAAUtf,KAAKsD,KAAAA,GACjDtD,KAAKqE,KAAKrE,KAAKoE,OAAOpE,KAAKsf,YAAY,SAR9B7G,EAAOyE,eAAejD,OAAe,KACxCja,KAAKqE,GAAGgI,QAAQrM,KAAKsD,SAAS,IAAI1D,MAAM,sCAAA,CAAA,KAZrCI,KAAKoE,KAAK8Y,eAAejD,OAAe,KAAMja,KAAKuf,kBACtDvf,KAAKoE,KAAKiI,QAAQrM,KAAKsD,SAAS,IAAI1D,MAAM,oCAAA,CAAA;AAAA,IAmBpD;AAAA,EAAA;AAGA,WAASif,KAAAA;AACP7e,SAAKyY,OAAOyE,gBAzcgB,KA0c5Bld,KAAK+d,eAAAA;AAAAA,EACP;AAEA,WAASL,GAAYrM,GAAAA;AACnB,UAAMoH,IAASzY,KAAKyY;AAChBpH,IAAAA,KAAKoH,EAAOpM,QAAQgF,CAAAA,IACnBoH,EAAOyE,eAAetB,QAAoB,MAC7CnD,EAAOyE,gBAAgBnC,GACvBtC,EAAOxQ,KAAK,QAAA,KAETwQ,EAAOyE,eAAenB,QAAkBJ,OAC3ClD,EAAOyE,gBAjeW,IAoepBzE,EAAOyE,gBA3amB5D,YA8arBb,EAAOyE,eAAevC,OAAoB,IAAG3a,KAAKqd,WAClDrd,KAAKge,eAAAA;AAAAA,EACZ;AAEA,WAASF,GAAczM,GAAAA;AACrB,UAAMoH,IAASzY,KAAKyY;AAEfpH,IAAAA,KAAOrR,KAAKsD,UAAU2V,MAAkB5H,IAAMrR,KAAKsD,QACpD+N,KAAKoH,EAAOxQ,KAAK,SAASoJ,CAAAA,GAC9BoH,EAAOyE,gBA/ea,GAgfpBzE,EAAOxQ,KAAK,OAAA;AAEZ,UAAMuX,IAAK/G,EAAOgH,gBACZC,IAAKjH,EAAO0E;AAIlB,QAFIqC,MAAO,QAAQA,EAAG7C,aAAa,QAAM6C,EAAG7C,SAAS9Z,KAAK4V,GAAQpH,CAAAA,GAE9DqO,MAAO,MAAM;AACf,aAAOA,EAAG9C,WAAW,QAAQ8C,EAAG9C,OAAOvW,SAAS,IAAGqZ,CAAAA,EAAG9C,OAAOpI,QAAQtD,QAAAA,EAAQ;AACzD,MAAhBwO,EAAG/C,aAAa,QAAM+C,EAAG/C,SAAS9Z,KAAK4V,GAAQpH;IACvD;AAAA,EACA;AAEA,WAASyL,GAAYzL;AACnB,UAAMoH,IAASzY,KAAKyY;AAEhBpH,IAAAA,KAAKoH,EAAOpM,QAAQgF,CAAAA,GACxBoH,EAAOyE,gBA3cmB5D,WA6ctBtZ,KAAK4c,WAAW,SAiCtB,SAAqBA,GAAAA;AACnB,eAASzV,IAAI,GAAGA,IAAIyV,EAAOvW,QAAQc,IAEN,GAArByV,EAAOzV,CAAAA,EAAGwY,WAAW,MACzB/C,EAAOpI,QAAQtD,QAAAA,EAAQ,GACvB/J;AAAAA,IAGN,GAzCuCnH,KAAK4c,MAAAA,IA1ajB/B,UA4apBpC,EAAOyE,kBAAuCpC,OACjDrC,EAAOyE,gBA7ciB5D,YA8cnBb,EAAOyE,eAAelC,OAAsBA,KAC/CvC,EAAOxQ,KAAK,OAAA,IAIhBjI,KAAK+d,eAAAA;AAAAA,EACP;AAEA,WAASO,GAAWjN,GAAAA;AACdA,IAAAA,KAAKrR,KAAKyY,OAAOpM,QAAQgF,CAAAA,GAC7BrR,KAAKyY,OAAOyE,gBAAgB7C,GACxBra,KAAKoe,cADmB/D,OACKra,KAAKyY,OAAOyE,eAAetD,OAAkB,MAAG5Z,KAAKyY,OAAOyE,gBAAgBzC,KAC7Gza,KAAK+d;EACP;AAEA,WAASQ,KAAAA;AAC4C,KAA9Cve,KAAKyY,OAAOyE,eAAezD,OAAmB,MACjDzZ,KAAKyY,OAAOyE,gBAAgB1C,IAC5Bxa,KAAKqd,OAAAA;AAAAA,EAET;AAEA,WAASL,KAAAA;AAC6C,KAA/Chd,KAAKyY,OAAOyE,eAAevC,OAAoB,MAClD3a,KAAKyY,OAAOyE,gBAAgB5B,IAC5Btb,KAAKqd,OAAAA;AAAAA,EAET;AAYA,WAASO,GAAWvM,GAAAA;AAClB,UAAMoH,IAASzY,KAAKyY;AAEhBpH,IAAAA,KAAKoH,EAAOpM,QAAQgF,CAAAA,GAljBJ,IAojBfoH,EAAOyE,iBAvecpB,QAwenBrD,EAAOyE,iBAA2CzE,EAAOyE,gBAAgBxD,IA9drDoC,YA+dpBrD,EAAOyE,iBAA4CzE,EAAOyE,gBAAgBtC,IAC/EnC,EAAOxQ,KAAK,MAAA,IAGdwQ,EAAOyE,gBAAgBxB,IAEnBjD,EAAO0E,mBAAmB,QAC5B1E,EAAO0E,eAAeY,eAAAA,GAGpBtF,EAAOgH,mBAAmB,QAC5BhH,EAAOgH,eAAe1B,eAAAA;AAAAA,EAE1B;AAEA,WAASoB,GAAgB9N,GAAKlO,GAAAA;AACxBA,SAAAA,QAAqCnD,KAAKoH,KAAKjE,CAAAA,GACnDnD,KAAKmd,eAAeL,WAAWzL,CAAAA;AAAAA,EACjC;AAEA,WAASoB,GAAa/N,GAAAA;AACQ,IAAxB1E,KAAKyf,mBAAmB,SACtB/a,MAAS,WACX1E,KAAKkd,gBAAY,QACjBld,KAAKyf,eAAezB,eAAAA,IAElBtZ,MAAS,eACX1E,KAAKkd,gBAAgBnD,GACrB/Z,KAAKyf,eAAezB,oBAIpBhe,KAAKmd,mBAAmB,QACtBzY,MAAS,YACX1E,KAAKkd,gBAAgBlC,GACrBhb,KAAKmd,eAAea,eAAAA;AAAAA,EAG1B;AAAA,EAEA,MAAM4B,WAAe9O;IACnB,YAAa+O,GAAAA;AACX9f,YAAAA,GAEAC,KAAKkd,eAAe,GACpBld,KAAKyf,iBAAiB,MACtBzf,KAAKmd,iBAAiB,MAElB0C,MACEA,EAAKC,SAAM9f,KAAK2d,QAAQkC,EAAKC,OAC7BD,EAAKxT,YAASrM,KAAK6d,WAAWgC,EAAKxT,UACnCwT,EAAKE,eAAY/f,KAAKggB,cAAcH,EAAKE,aACzCF,EAAKje,UACPie,EAAKje,OAAO8R,iBAAiB,SAAStS,GAAM6R,KAAKjT,IAAAA,CAAAA,IAIrDA,KAAK2H,GAAG,eAAe8K;IAC3B;AAAA,IAEE,MAAOsC,GAAAA;AACLA,MAAAA,EAAG,IAAA;AAAA,IACP;AAAA,IAEE,SAAUA;AACRA,MAAAA,EAAG,IAAA;AAAA,IACP;AAAA,IAEE;IAEF;AAAA,IAEE,IAAA,WAAIkL;AACF,aAAOjgB,KAAKyf,mBAAmB,QAAnBA;AAAAA,IAChB;AAAA,IAEE,eAAIS;AACF,aAAOlgB,KAAKmd,mBAAmB;IACnC;AAAA,IAEE,IAAA,YAAIgD;AACF,gBAtoBkB,IAsoBVngB,KAAKkd;AAAAA,IACjB;AAAA,IAEE,iBAAIkD;AACF,cAAQpgB,KAAKkd,eAAetB,QAAoB;AAAA,IACpD;AAAA,IAEE,QAASvK;AACsC,OAAxCrR,KAAKkd,eAAetB,QAAoB,MACtCvK,MAAKA,IAAM4H,IAChBjZ,KAAKkd,eA1kBS7B,YA0kBOrb,KAAKkd,eAjpBV,GAmpBZld,KAAKyf,mBAAmB,SAC1Bzf,KAAKyf,eAAelD,gBAAgB,GACpCvc,KAAKyf,eAAenc,QAAQ+N,IAE1BrR,KAAKmd,mBAAmB,SAC1Bnd,KAAKmd,eAAeZ,gBAAgB,GACpCvc,KAAKmd,eAAe7Z,QAAQ+N,IAG9BrR,KAAKkd,gBA7pBW,GA8pBhBld,KAAKggB,eACLhgB,KAAKkd,gBAAgB1D,GAEjBxZ,KAAKyf,mBAAmB,QAAMzf,KAAKyf,eAAezB,eAAAA,GAClDhe,KAAKmd,mBAAmB,QAAMnd,KAAKmd,eAAea;IAE5D;AAAA,EAAA;AAAA,EAGA,MAAMqC,WAAiBT,GAAAA;AAAAA,IACrB,YAAaC,GAAAA;AACX9f,YAAM8f,CAAAA,GAEN7f,KAAKkd,gBAAgBoD,SACrBtgB,KAAKyf,iBAAiB,IAAIxB,GAAcje,MAAM6f,CAAAA,GAE1CA,MACE7f,KAAKyf,eAAerB,cADtByB,OAC2C7f,KAAKkd,gBAAgBzC,KAC9DoF,EAAK9c,SAAM/C,KAAKgf,QAAQa,EAAK9c,OAC7B8c,EAAKU,aAAWvgB,KAAKyf,eAAezB,eAAAA,GACpC6B,EAAKzH,YAAUpY,KAAKwgB,YAAYX,EAAKzH,QAAAA;AAAAA,IAE/C;AAAA,IAEE,YAAaA,GAAAA;AACX,YAAMqI,IAAM,IAAInI,EAAYF,CAAAA,GACtBlJ,IAAMlP,KAAKyf,eAAevQ,OAAOwR;AAEvC,aADA1gB,KAAKyf,eAAevQ,MAGpB,SAAoB/L,GAAAA;AAClB,cAAMsU,IAAOgJ,EAAIrZ,KAAKjE,CAAAA;AACtB,eAAOsU,MAAS,OAAOtU,EAAKF,eAAe,KAAKwd,EAAIlI,YAAY,KAAK,OAAOrJ,EAAIuI,CAAAA;AAAAA,MACtF,GALWzX;AAAAA,IAMX;AAAA,IAEE,MAAO+U,GAAAA;AACLA,MAAAA,EAAG,IAAA;AAAA,IACP;AAAA,IAEE,KAAM4L,GAAM5L,GAAAA;AAGV,aAFA/U,KAAKyf,eAAezB,eAAAA,GACpBhe,KAAKyf,eAAemB,KAAKD,GAAM5L,CAAAA,GACxB4L;AAAAA,IACX;AAAA,IAEE,OAAA5d;AAEE,aADA/C,KAAKyf,eAAezB,eAAAA,GACbhe,KAAKyf,eAAe1c,KAAAA;AAAAA,IAC/B;AAAA,IAEE,KAAMI,GAAAA;AAEJ,aADAnD,KAAKyf,eAAeR,qBAAAA,GACbjf,KAAKyf,eAAerY,KAAKjE,CAAAA;AAAAA,IACpC;AAAA,IAEE,QAASA;AAEP,aADAnD,KAAKyf,eAAeR,qBAAAA,GACbjf,KAAKyf,eAAejS,QAAQrK,CAAAA;AAAAA,IACvC;AAAA,IAEE,SAAA0d;AAGE,aAFA7gB,KAAKkd,gBAAgB9C,GACrBpa,KAAKyf,eAAezB,eAAAA,GACbhe;AAAAA,IACX;AAAA,IAEE,QAAA8gB;AAEE,aADA9gB,KAAKkd,gBAAiBld,KAAKyf,eAAerB,mBAzrBV9E,YAPAA,WAisBzBtZ;AAAAA,IACX;AAAA,IAEE,OAAA,mBAA2B+gB,GAAKlB,GAAAA;AAC9B,UAAIxT;AAEJ,YAAMmT,IAAK,IAAIa,GAAS,EAAA,GACnBR,GACH,KAAM9K,GAAAA;AACJgM,QAAAA,EAAItJ,OAAO5B,KAAKzO,CAAAA,EAAMyO,KAAKd,EAAG9B,KAAK,MAAM,IAAA,CAAA,EAAO6C,MAAMf,CAAAA;AAAAA,MAC9D,GACM,aAAAgL;AACE1T,QAAAA,IAAU0U,EAAIC;MACtB,GACM,QAASjM,GAAAA;AACP,aAAK1I,EAAS,QAAO0I,EAAG,IAAA;AACxB1I,QAAAA,EAAQwJ,KAAKd,EAAG9B,KAAK,MAAM,OAAO6C,MAAMf,CAAAA;AAAAA,MAChD,EAAA,CAAA;AAGI,aAAOyK;AAEP,eAASpY,EAAMjE,GAAAA;AACTA,QAAAA,EAAKN,OAAM2c,EAAGpY,KAAK,IAAA,IAClBoY,EAAGpY,KAAKjE,EAAKL,KAAAA;AAAAA,MACxB;AAAA,IACA;AAAA,IAEE,YAAaK,GAAM0c,GAAAA;AACjB,UAqWKpB,GADehG,IApWFtV,CAAAA,KAqWQsV,EAAOwH,SArWR,QAAO9c;AAoWpC,UAAwBsV;AAnWpB,UAAItV,EAAKiZ,EAAAA,EAAgB,QAAOpc,KAAKihB,mBAAmB9d,EAAKiZ,EAAAA,EAAAA,GAAkByD,CAAAA;AAC1E5Y,YAAMmP,QAAQjT,OAAOA,IAAOA,MAAPA,SAA4B,CAAA,IAAK,CAACA,CAAAA;AAE5D,UAAIgE,IAAI;AACR,aAAO,IAAIkZ,GAAS,EAAA,GACfR,GACH,KAAM9K,GAAAA;AACJ/U,aAAKoH,KAAKD,MAAMhE,EAAKkD,SAAS,OAAOlD,EAAKgE,OAC1C4N,EAAG,IAAA;AAAA,MACX,EAAA,CAAA;AAAA,IAEA;AAAA,IAEE,uBAAwByK,GAAAA;AACtB,aAAA,CAAA,EA5rB6B5D,QA4rBrB4D,EAAGtC,iBAAkDsC,EAAGC,eAAe/C,YAAY8C,EAAGC,eAAelD;AAAAA,IACjH;AAAA,IAEE,OAAA,SAAiBiD,GAAAA;AACf,cAAQA,EAAGtC,eAAetD,OAAkB;AAAA,IAChD;AAAA,IAEE,CAACwC,EAAAA,IAAAA;AACC,YAAM3D,IAASzY;AAEf,UAAIsD,IAAQ,MACR4d,IAAiB,MACjBC,IAAgB;AAMpB,aAJAnhB,KAAK2H,GAAG,SAAU0J,CAAAA,MAAAA;AAAU/N,QAAAA,IAAQ+N;AAAAA,MAAAA,CAAAA,GACpCrR,KAAK2H,GAAG,YAwBR;AACyB,QAAnBuZ,MAAmB,QAAME,EAAO3I,EAAO1V;MACjD,CAAA,GAzBI/C,KAAK2H,GAAG,SA2BR;AACyB,QAAnBuZ,MAAmB,QAAME,EAAO,IAAA;AAAA,MAC1C,IA3BW,EACL,CAAChF,EAAAA,IAAAA;AACC,eAAOpc;AAAAA,MACf,GACMyX,MAAK,MACI,IAAIxG,QAAQ,SAAUC,GAASC,IAAAA;AACpC+P,QAAAA,IAAiBhQ,GACjBiQ,IAAgBhQ;AAChB,cAAMhO,IAAOsV,EAAO1V,KAAAA;AACP,QAATI,MAAS,OAAMie,EAAOje,KAxyBd,IAyyBFsV,EAAOyE,gBAAiCkE,EAAO;MACnE,CAAA,GAEMJ,QAAO,MACE3U,EAAQ,OAEjBgV,OAAOhQ,CAAAA,MACEhF,EAAQgF,CAAAA,EAAAA;AAYnB,eAAS+P,EAAQje,GAAAA;AACO,QAAlBge,MAAkB,SAClB7d,IAAO6d,EAAc7d,CAAAA,IAChBH,MAAS,SAASsV,EAAOyE,eAAejD,OAAe,IAAGkH,EAAclI,KAC5EiI,EAAe,EAAEpe,OAAOK,GAAMN,MAAMM,MAAS,KAATA,CAAAA,GACzCge,IAAgBD,IAAiB;AAAA,MACvC;AAEI,eAAS7U,EAASgF,GAAAA;AAEhB,eADAoH,EAAOpM,QAAQgF,CAAAA,GACR,IAAIJ,QAAQ,CAACC,IAASC,MAAAA;AAC3B,cAv0Bc,IAu0BVsH,EAAOyE,aAA0B,QAAOhM,GAAQ,EAAEpO,OAAAA,QAAkBD,MAAAA,GAAM,CAAA;AAC9E4V,UAAAA,EAAO5Q,KAAK,SAAS,WAAA;AACfwJ,YAAAA,IAAKF,EAAOE,CAAAA,IACXH,GAAQ,EAAEpO,OAAAA,QAAkBD,MAAAA,GAAM,CAAA;AAAA,UACjD,CAAA;AAAA,QAAA,CAAA;AAAA,MAEA;AAAA,IACA;AAAA;EAGA,MAAMye,WAAiB1B,GAAAA;AAAAA,IACrB,YAAaC,GAAAA;AACX9f,YAAM8f,CAAAA,GAEN7f,KAAKkd,gBAAgBoD,OACrBtgB,KAAKmd,iBAAiB,IAAIb,GAActc,MAAM6f,CAAAA,GAE1CA,MACEA,EAAK0B,WAAQvhB,KAAKod,UAAUyC,EAAK0B,SACjC1B,EAAKf,UAAO9e,KAAKsd,SAASuC,EAAKf,QAC/Be,EAAK2B,UAAOxhB,KAAKyd,SAASoC,EAAK2B,QAC/B3B,EAAKU,aAAWvgB,KAAKmd,eAAea,eAAAA;AAAAA,IAE9C;AAAA,IAEE,OAAAyD;AACEzhB,WAAKkd,gBAAgB9B;AAAAA,IACzB;AAAA,IAEE;AACEpb,WAAKkd,gBAAgB3B,IACrBvb,KAAKmd,eAAea,eAAAA;AAAAA,IACxB;AAAA,IAEE,QAAS0D,GAAO3M,GAAAA;AACdA,MAAAA,EAAG,IAAA;AAAA,IACP;AAAA,IAEE,OAAQ5R,GAAM4R,GAAAA;AACZ/U,WAAKmd,eAAewE,UAAUxe,GAAM4R,CAAAA;AAAAA,IACxC;AAAA,IAEE,OAAQA,GAAAA;AACNA,MAAAA,EAAG,IAAA;AAAA,IACP;AAAA,IAEE,OAAA,gBAAwB2K,GAAAA;AACtB,aAAA,CAAA,EAxxB8B5E,YAwxBtB4E,EAAGxC;AAAAA,IACf;AAAA,IAEE,OAAA,QAAgBwC,GAAAA;AACd,UAAIA,EAAGS,UAAW,QAAOlP,QAAQC,QAAAA,EAAQ;AACzC,YAAM6B,IAAQ2M,EAAGvC;AA6PrB,UAAmBxU;AA3Pf,YAAMgX,MA2PShX,IA5PW+W,GA6PnBtC,YAAYkE,GAASrc,UAAUmY,WAAWzU,EAAEyU,YAAYwE,GAAO3c,UAAUmY,UA7PhD9T,KAAKuY,IAAI,GAAG9O,EAAM9M,MAAMI,MAAAA,IAAU0M,EAAM9M,MAAMI,WACnDqZ,EAAGxC,eAAehC,KAAiB,IAAI;AAClE,aAAIyE,MAAW,IAAU1O,QAAQC,QAAAA,EAAQ,KACrC6B,EAAM6J,WAAW,SAAM7J,EAAM6J,SAAS,CAAA,IACnC,IAAI3L,QAASC,CAAAA,MAAAA;AAClB6B,QAAAA,EAAM6J,OAAOxV,KAAK,EAAEuY,QAAAA,GAAQzO,SAAAA,EAAAA,CAAAA;AAAAA,MAAAA,CAAAA;AAAAA,IAElC;AAAA,IAEE,MAAO/N,GAAAA;AAEL,aADAnD,KAAKmd,eAAea,kBACbhe,KAAKmd,eAAe/V,KAAKjE,CAAAA;AAAAA,IACpC;AAAA,IAEE,IAAKA,GAAAA;AAGH,aAFAnD,KAAKmd,eAAea,eAAAA,GACpBhe,KAAKmd,eAAenb,IAAImB,CAAAA,GACjBnD;AAAAA,IACX;AAAA,EAAA;AAAA,EAGA,MAAM4hB,WAAevB,GAAAA;AAAAA,IACnB,YAAaR,GAAAA;AACX9f,YAAM8f,CAAAA,GAEN7f,KAAKkd,eAx5Ba,IAw5Bald,KAAKkd,eAAe/C,GACnDna,KAAKmd,iBAAiB,IAAIb,GAActc,MAAM6f,CAAAA,GAE1CA,MACEA,EAAK0B,WAAQvhB,KAAKod,UAAUyC,EAAK0B,SACjC1B,EAAKf,UAAO9e,KAAKsd,SAASuC,EAAKf,QAC/Be,EAAK2B,UAAOxhB,KAAKyd,SAASoC,EAAK2B;AAAAA,IAEzC;AAAA,IAEE;AACExhB,WAAKkd,gBAAgB9B;AAAAA,IACzB;AAAA,IAEE,SAAA0G;AACE9hB,WAAKkd,gBAAgB3B,IACrBvb,KAAKmd,eAAea,eAAAA;AAAAA,IACxB;AAAA,IAEE,QAAS0D,GAAO3M,GAAAA;AACdA,MAAAA,EAAG,IAAA;AAAA,IACP;AAAA,IAEE,OAAQ5R,GAAM4R,GAAAA;AACZ/U,WAAKmd,eAAewE,UAAUxe,GAAM4R,CAAAA;AAAAA,IACxC;AAAA,IAEE,OAAQA,GAAAA;AACNA,MAAAA,EAAG;IACP;AAAA,IAEE,MAAO5R,GAAAA;AAEL,aADAnD,KAAKmd,eAAea,eAAAA,GACbhe,KAAKmd,eAAe/V,KAAKjE,CAAAA;AAAAA,IACpC;AAAA,IAEE,IAAKA,GAAAA;AAGH,aAFAnD,KAAKmd,eAAea,eAAAA,GACpBhe,KAAKmd,eAAenb,IAAImB,IACjBnD;AAAAA,IACX;AAAA,EAAA;AAAA,EAGA,MAAM+hB,WAAkBH;IACtB,YAAa/B,GAAAA;AACX9f,YAAM8f,IACN7f,KAAKgiB,kBAAkB,IAAI9C,GAAelf,OAEtC6f,MACEA,EAAKoC,cAAWjiB,KAAKkiB,aAAarC,EAAKoC,YACvCpC,EAAK9G,UAAO/Y,KAAKmiB,SAAStC,EAAK9G;AAAAA,IAEzC;AAAA,IAEE,OAAQ5V,GAAM4R,GAAAA;AACR/U,WAAKyf,eAAe/C,YAAY1c,KAAKyf,eAAelD,gBACtDvc,KAAKgiB,gBAAgB7e,OAAOA,IAE5BnD,KAAKkiB,WAAW/e,GAAMnD,KAAKgiB,gBAAgB7C,cAAAA;AAAAA,IAEjD;AAAA,IAEE,MAAOpK,GAAAA;AACL,UAAI/U,KAAKgiB,gBAAgB7e,SAAS,MAAM;AACtC,cAAMA,IAAOnD,KAAKgiB,gBAAgB7e;AAClCnD,aAAKgiB,gBAAgB7e,OAAO,MAC5B4R,EAAG,OACH/U,KAAKkiB,WAAW/e,GAAMnD,KAAKgiB,gBAAgB7C,cAAAA;AAAAA,MACjD,MACMpK,CAAAA,EAAG,IAAA;AAAA,IAET;AAAA,IAEE,QAAS1D,GAAAA;AACPtR,YAAMsM,QAAQgF,CAAAA,GACVrR,KAAKgiB,gBAAgB7e,SAAS,SAChCnD,KAAKgiB,gBAAgB7e,OAAO,MAC5BnD,KAAKgiB,gBAAgB7C,eAAAA;AAAAA,IAE3B;AAAA,IAEE,WAAYhc,GAAM4R,GAAAA;AAChBA,MAAAA,EAAG,MAAM5R;IACb;AAAA,IAEE,OAAQ4R,GAAAA;AACNA,MAAAA,EAAG,IAAA;AAAA,IACP;AAAA,IAEE,OAAQA;AACN/U,WAAKgiB,gBAAgBtE,aAAa3I,GAClC/U,KAAKmiB,OAAOC,GAAoBnP,KAAKjT,IAAAA,CAAAA;AAAAA,IACzC;AAAA;AAKA,WAASoiB,GAAqB/Q,GAAKlO,GAAAA;AACjC,UAAM4R,IAAK/U,KAAKgiB,gBAAgBtE;AAChC,QAAIrM,EAAK,QAAO0D,EAAG1D,CAAAA;AACflO,SAAAA,QAAqCnD,KAAKoH,KAAKjE,CAAAA,GACnDnD,KAAKoH,KAAK,IAAA,GACV2N,EAAG,IAAA;AAAA,EACL;AAWA,WAAS4H,GAAUlE,MAAW4J,GAAAA;AAC5B,UAAMC,IAAMrb,MAAMmP,QAAQqC,CAAAA,IAAU,CAAA,GAAIA,MAAW4J,CAAAA,IAAW,CAAC5J,GAAAA,GAAW4J,CAAAA,GACpExf,IAAQyf,EAAIjc,UAAyC,OAAxBic,EAAIA,EAAIjc,SAAS,CAAA,KAAO,aAAcic,EAAI7N,IAAAA,IAAQ;AAErF,QAAI6N,EAAIjc,SAAS,EAAG,OAAM,IAAIzG,MAAM,sCAAA;AAEpC,QAAIwf,IAAMkD,EAAI,CAAA,GACV3B,IAAO,MACPrd,IAAQ;AAEZ,aAAS6D,IAAI,GAAGA,IAAImb,EAAIjc,QAAQc,IAC9BwZ,CAAAA,IAAO2B,EAAInb,CAAAA,GAEPsX,GAAUW,CAAAA,IACZA,EAAIwB,KAAKD,GAAMhC,EAAAA,KAEf4D,EAAYnD,OAAWjY,IAAI,GAAGwX,EAAAA,GAC9BS,EAAIwB,KAAKD,CAAAA,IAGXvB,IAAMuB;AAGR,QAAI9d,GAAM;AACR,UAAI2f,IAAAA;AAEJ,YAAMC,KAAchE,GAAUkC,CAAAA,KAAAA,EAAAA,CAAYA,EAAKxD,kBAAAA,CAAkBwD,EAAKxD,eAAesF;AAErF9B,MAAAA,EAAKhZ,GAAG,SAAU0J,CAAAA,OAAAA;AACF,QAAV/N,MAAU,SAAMA,IAAQ+N;AAAAA,MAAAA,CAAAA,GAG9BsP,EAAKhZ,GAAG,UAAU,MAAA;AAChB6a,QAAAA,IAAAA,IACKC,MAAa5f,EAAKS,CAAAA;AAAAA,MAAAA,CAAAA,GAGrBmf,MACF9B,EAAKhZ,GAAG,SAAS,MAAM9E,EAAKS,MAAUkf,IAAM,OAAOtJ,EAAAA,CAAAA;AAAAA,IAEzD;AAEE,WAAOyH;AAEP,aAAS4B,EAAa5Z,GAAG+Z,IAAIC,IAAIhE;AAC/BhW,MAAAA,EAAEhB,GAAG,SAASgX,EAAAA,GACdhW,EAAEhB,GAAG,SAEL,WAAA;AAEE,YADUgB,EAAE8W,kBAAAA,CAAmB9W,EAAE8W,eAAexC,SAC5C0F,MAAMha,EAAEwU,kBAAAA,CAAmBxU,EAAEwU,eAAeF,MAAO,QAAO0B,GAAQzF,CAAAA;AAAAA,MAC5E,CAAA;AAAA,IACA;AAEE,aAASyF,GAAStN,GAAAA;AAChB,UAAKA,KAAAA,CAAO/N,GAAZ;AACAA,QAAAA,IAAQ+N;AAER,mBAAW1I,MAAK2Z,EACd3Z,CAAAA,GAAE0D,QAAQgF;MAJO;AAAA,IAMvB;AAAA,EACA;AAEA,WAASqP,GAAM/X,GAAAA;AACb,WAAOA;AAAAA,EACT;AAEA,WAASia,GAAUnK,GAAAA;AACjB,WAAA,CAAA,CAASA,EAAOgH,oBAAoBhH,EAAO0E;AAAAA,EAC7C;AAEA,WAASsB,GAAWhG,GAAAA;AAClB,WAAsC,OAAxBA,EAAOyE,gBAAiB,YAAY0F,GAASnK,CAAAA;AAAAA,EAC7D;AA6BA,WAASoE,GAAmB1Z,GAAAA;AAC1B,YALF,SAAuBA,GAAAA;AACrB,aAAuB,OAATA,KAAS,YAAYA,MAAS,eAAeA,EAAKF,cAAe;AAAA,IACjF,GAGsBE,KAAQA,EAAKF,aAAa;AAAA,EAChD;AAEA,WAAS6D,KAAAA;AAAAA,EAAQ;AAEjB,WAAS1F,KAAAA;AACPpB,SAAKqM,QAAQ,IAAIzM,MAAM,iBAAA,CAAA;AAAA,EACzB;SAMAijB,KAAiB,EACflG,UAAAA,IACAmG,iBAhIF,YAA6BT,GAAAA;AAC3B,WAAO,IAAIpR,QAAQ,CAACC,GAASC,MACpBwL,GAAAA,GAAY0F,GAAUhR,CAAAA,MAAAA;AAC3B,UAAIA,EAAK,QAAOF,EAAOE,CAAAA;AACvBH,MAAAA,EAAAA;AAAAA,IAAAA,CAAAA,CAAAA;AAAAA,EAGN,GA0HE0R,UAAAA,IACAnE,eACAsE,SA9CF,SAAkBtK,GAAAA;AAChB,WAAA,CAAA,CAASA,EAAOgH,kBAAkBhH,EAAOgH,eAAexC;AAAAA,EAC1D,GA6CE+F,YA3CF,SAAqBvK,GAAAA;AACnB,WAAA,CAAA,CAASA,EAAO0E,kBAAkB1E,EAAO0E,eAAeF;AAAAA,EAC1D,GA0CEgG,aA7BF,SAAsBxK,GAAAA;AACpB,WAAA,CAAA,EA1mCoB,KA0mCZA,EAAOyE,kBAAwCzE,EAAOyE,eAAelB,QAAuB;AAAA,EACtG,GA4BEkH,gBAzCF,SAAyBzK,GAAQoH,IAAO;AACtC,UAAMxO,IAAOoH,EAAOgH,kBAAkBhH,EAAOgH,eAAenc,SAAWmV,EAAO0E,kBAAkB1E,EAAO0E,eAAe7Z;AAGtH,WAASuc,EAAKyC,OAAOjR,MAAQ4H,IAA2B5H,IAAP;AAAA,EACnD,GAqCEuO,QAAAA,IACA0B,cACAjB,UAAAA,IACAuB,QAAAA,IACAG,WAAAA,IAEAoB,aAvJF,cAA0BpB,GAAAA;AAAAA,EAAAA,EAAAA;;;;AEz/B1B,WAASqB,EAAOC,GAAKC;AACjB,eAAWxT,KAAOwT,EACdte,QAAO8I,eAAeuV,GAAKvT,GAAK,EAC5BhN,OAAOwgB,EAAMxT,CAAAA,GACb/B,YAAAA,IACAC,iBAAc,CAAA;AAItB,WAAOqV;AAAAA,EACX;iBA4CAE,KAnCA,SAAqBlS,GAAKmS,GAAMF,GAAAA;AAC5B,QAAA,CAAKjS,YAAcA,KAAQ,SACvB,OAAM,IAAIW,UAAU;AAGnBsR,IAAAA,MACDA,IAAQ,CAAA,WAGDE,KAAS,aAChBF,IAAQE,GACRA,IAAO,KAGPA,MACAF,EAAME,OAAOA;AAGjB;AACI,aAAOJ,EAAO/R,GAAKiS,CAAAA;AAAAA,IAC3B,QAAaG;AACLH,MAAAA,EAAMxjB,UAAUuR,EAAIvR,SACpBwjB,EAAMxU,QAAQuC,EAAIvC;AAElB,YAAM4U,IAAW,WAAA;AAAA,MAAY;AAE7BA,aAAAA,EAASze,YAAYD,OAAOwN,OAAOxN,OAAO+O,eAAe1C,CAAAA,CAAAA,GAG1C+R,EAAO,IAAIM,KAAYJ,CAAAA;AAAAA,IAG9C;AAAA,EACA;OC7DaK,KAAW,oBAClBC,KAAe,CAAA,GACfC,KAAe,CAAA;AAErB,SAAS1c,IAAI,GAAGA,IAAI,KAAKA,IACvByc,CAAAA,GAAazc,KAAKwc,GAASxc,KAAK,IAAI,EAAA,IAAOwc,GAAa,KAAJxc,CAAAA,GAChDA,IAAI,OACFA,IAAI,KACN0c,GAAa,KAAO1c,CAAAA,IAAKA,IAEzB0c,GAAa,KAAY1c,CAAAA,IAAKA;AAK7B,MAAM2c,KAAU3gB,CAAAA,MAAAA;AACrB,QAAMkD,IAASlD,EAAKkD;AACpB,MAAI0d,IAAS,IACT5c,IAAI;AACR,SAAOA,IAAId,IACT0d,CAAAA,KAAUH,GAAazgB,EAAKgE,GAAAA,CAAAA;AAE9B,SAAO4c;AAAAA,GAGIC,KAAUta,CAAAA,MAAAA;AACrB,QAAMua,IAASva,EAAIrD,UAAU,GACvBA,IAAS4d,KAAU,GACnBpd,IAAQ,IAAI6R,WAAWuL;AAC7B,MAAI7a,IAAI,GACJjC,IAAI;AACR,SAAOA,IAAId,IACTQ,CAAAA,EAAMuC,OAAOya,GAAana,EAAIsG,WAAW7I,GAAAA,CAAAA,KAAS,IAAI0c,GAAana,EAAIsG,WAAW7I,GAAAA,CAAAA;AAEpF,SAAON;AAAAA;AC/BT,SAHIqd,KAAQ,oEAERC,KAA+B,OAAfzL,aAAe,MAAc,CAAA,IAAK,IAAIA,WAAW,GAAA,GAC5DvR,KAAI,GAAGA,KAAI+c,IAAc/c,KAC9Bgd,CAAAA,GAAOD,GAAMlU,WAAW7I,EAAAA,CAAAA,IAAMA;ACNlC,MAAMkR,KAAU,IAAIC,eAEP8L,KAAW,CAACjhB,GAAMkhB,MACZhM,GAAQG,OAAOrV,CAAAA,GAM5BmhB,KAAU,IAAIC,eACPC,KAAW9a,CAAAA,MAAO4a,GAAQG,OAAO/a,CAAAA,GAMjCgb,KAAUhb,CAAAA,MAAAA;AACrB,MACIe,GADAka,IAAM,IAENxd,IAAI;AACR,QAAMV,IAAMiD,EAAIrD;AAEhB,SAAOc,IAAIV,IACTgE,KAAIf,EAAIsG,WAAW7I,MACnBwd,KAAOhB,GAASlZ,KAAK,CAAA,IAAKkZ,GAAa,KAAJlZ,CAAAA;AAGrC,SAAOka;AAAAA,GAIIC,KAAUC,CAAAA,MAAAA;AACrB,QAAMC,IAASd,GAAQa;AACvB,MAAIC,EAAOze,UAHgB,MAGgB,QAAOsD,OAAOob,aAAAA,GAAgBD,CAAAA;AAEzE,MAAIH,IAAM,IACNxd,IAAI;AACR,SAAOA,IAAI2d,EAAOze,SAChBse,CAAAA,KAAOhb,OAAOob,gBAAgBD,EAAOE,SAAS7d,GAAGA,KARxB;AAU3B,SAAOwd;AAAAA,GAGHnO,KAA0B,OAAXnU,SAAW,MAAcA,SAAS6K,MACjD+X,KAASzO,GAAMyO,UAAUzO,GAAM0O,YAAY,CAAA;AAClCD,GAAOE,UAAUF,GAAOG;AAchC,MAAMC,KAAcC,CAAAA,MAAAA;AACzB,QAAMC,IAAO,IAAI7M,WAAW4M,CAAAA;AAC5B,SAAOL,GAAOO,gBAAgBD;GCzD1BE,KAAQ/Y,EAAM,aAAA,GAEdgZ,KAAsB;AAK5B,SAASC,GAAeC,GAAAA;AACtB,SAAOA,EAAI9a,QAAQ,8BAA8B,EAAA;AACnD;SAWA,MAAM+a,WAAajE,GAAAA;EAEjBkE;AAAAA,EACA,YAAajG,GAAAA;AAqCX,QAhCA9f,MAJA8f,IAAO7a,OAAOoe,OAAO,EACnB2C,eAAAA,GAAe,GACdlG,CAAAA,CAAAA,GAIH7f,KAAKgmB,iBAAiBnG,EAAKoG,YAE3BjmB,KAAKkmB,MAAMpC,GAAQuB,GAAY,CAAA,CAAA,EAAI5V,MAAM,GAAG,IAC5CzP,KAAKmmB,OAAO,eAAetG,CAAAA,GAE3B7f,KAAKomB,cAAcvG,EAAKwG,YACpBxG,EAAKuG,eAAetC,GAAQuB,GAAY,EAAA,CAAA,IACxC,MAEJrlB,KAAKqmB,YAAYxG,EAAKwG,aAAAA,IACtBrmB,KAAKsmB,gBAAgBzG,EAAKyG,iBAAiBT,GAAKS,eAChDtmB,KAAKumB,oBAAoBvmB,KAAKsmB,cAAcE,YAC5CxmB,KAAKymB,SAASzhB,OAAOoe,OAAO,CAAA,GAAIyC,GAAKY,QAAQ5G,EAAK4G,SAClDzmB,KAAK0mB,eAAe7G,EAAK6G,gBAAgB,CAAA,GACzC1mB,KAAK2mB,gBAAgB9G,EAAK8G,iBAAiB,CAAA,GAC3C3mB,KAAK4mB,eAAe/G,EAAK+G,iBAAiBhB,OAAOA,IACjD5lB,KAAK6mB,UAAUhH,EAAKgH,YAAfA,UAAuChH,EAAKgH,SACjD7mB,KAAK8mB,mBAAmBjH,EAAKiH,qBAAxBA,UAAyDjH,EAAKiH,kBACnE9mB,KAAK+mB,qBAAqBlH,EAAKkH,sBA7CP,KA+CxB/mB,KAAKgnB,kBACLhnB,KAAKinB,aAAAA,IAELjnB,KAAKknB,gBAAAA,QACLlnB,KAAKmnB,eAAAA,QACLnnB,KAAKonB,aAAAA,QACLpnB,KAAKqnB,uBACLrnB,KAAKsnB,cAAAA,QACLtnB,KAAKunB,YAAAA,QAAY5P,CAEZlB,GACH,OACQ8M,SADGlhB,SAAW,MACN,IAAIzC,MAAM,uEAEV,IAAIA,MAAM,+CAFsE,oBAAA;AAMlGI,SAAKwnB,WAAAA,IACLxnB,KAAKynB,gBAAAA,IACLznB,KAAK0nB,eAAAA,IACL1nB,KAAK2nB,oBAAoB,MACzB3nB,KAAK4nB,WAAW,MAChB5nB,KAAK6nB,qBAAqB,CAAA,GAE1B7nB,KAAK8nB,iBAAAA,IACL9nB,KAAK+nB,oBAAAA,IACL/nB,KAAKgoB,sBAAAA,IACLhoB,KAAKioB,yBACLjoB,KAAKkoB,yBAAyB,CAAA,GAC9BloB,KAAKmoB,mBAAmB,MAExBnoB,KAAKooB,gBAAgB,IACrBpoB,KAAKqoB,iBAAiB,CAAA,GAEtBroB,KAAKsoB,SAAS,MACdtoB,KAAKuoB,MAAM,MACXvoB,KAAKwoB,YAAY;AAEjB,QAAA;AACExoB,WAAK8lB,MAAM,IAAIrP,GAAkBzW,KAAKymB,MAAAA;AAAAA,IACxC,SAASpV,GAAAA;AAEP,aAAA,KADArR,KAAKyoB,UAAUlF,EAAQlS,GAAK,oBAAA,CAAA;AAAA,IAE9B;AAIArR,SAAK0oB,uBAA6D,OAA/B1oB,KAAK8lB,IAAI6C,qBAAsB,UAElE3oB,KAAK8lB,IAAI8C,6BAA6B,MAAA;AACpC5oB,WAAK6oB,kBAAAA;AAAAA,IAAAA,GAEP7oB,KAAK8lB,IAAIgD,4BAA4B;AACnC9oB,WAAK6oB,kBAAAA;AAAAA,IAAAA,GAEP7oB,KAAK8lB,IAAIiD,0BAA0B,MAAA;AACjC/oB,WAAKgpB,yBAAAA;AAAAA,IAAAA,GAEPhpB,KAAK8lB,IAAImD,yBAAyB,MAAA;AAChCjpB,WAAKkpB,wBAAAA;AAAAA,IAAAA,GAEPlpB,KAAK8lB,IAAIqD,iBAAiBC,OAAAA;AACxBppB,WAAKqpB,gBAAgBD,CAAAA;AAAAA,IAAAA,GAIc,OAA1BppB,KAAK8lB,IAAIwD,gBAAiB,YACnCtpB,KAAK8lB,IAAIwD,aAAaxT,MAAMzE;AAC1BrR,WAAKyoB,UAAUlF,EAAQlS,GAAK;QAU5BrR,KAAKqmB,aAAarmB,KAAKumB,oBACzBvmB,KAAKupB,WAAW,EACdC,SAASxpB,KAAK8lB,IAAI2D,kBAAkBzpB,KAAKomB,aAAapmB,KAAKsmB,oBAG7DtmB,KAAK8lB,IAAI4D,gBAAgBN,OAAAA;AACvBppB,WAAKupB,WAAWH,CAAAA;AAAAA,IAAAA,GAIpBppB,KAAKmmB,OAAO,wBACZnmB,KAAK2pB,kBAAAA,GAEL3pB,KAAK4pB,iBAAiB;AACpB5pB,WAAK6pB,UAAAA;AAAAA,IAAAA,GAEP7pB,KAAK6H,KAAK,UAAU7H,KAAK4pB,cAAAA;AAAAA,EAC3B;AAAA,EAEA,IAAA;AACE,WAAQ5pB,KAAK4nB,YAAY5nB,KAAK4nB,SAASkC,kBAAmB;AAAA,EAC5D;AAAA,EAIA,IAAA;AACE,WAAQ9pB,KAAKinB,cAAcjnB,KAAK4nB,SAASmC,eAAe;AAAA,EAC1D;AAAA,EAEA;AACE,WAAO,EAAEC,MAAMhqB,KAAKunB,WAAW0C,QAAQjqB,KAAKsnB,aAAa4C,SAASlqB,KAAKqnB,aAAAA;AAAAA,EACzE;AAAA,EAEA,OAAQlkB;AACN,QAAA,CAAInD,KAAKgnB,aAAT;AACA,UAAIhnB,KAAKmgB,UAAW,OAAMoD,EAAQ,IAAI3jB,MAAM,uCAAA,GAA0C,eAAA;AACtF,iBAAWuD,KAAS,SAClB,KAAA;AACEA,QAAAA,IAAO8G,KAAKkgB,MAAMhnB,CAAAA;AAAAA,MACpB,QAASkO;AACPlO,QAAAA,IAAO,CAAA;AAAA,MACT;AAEFnD,WAAKmmB,OAAO,UAAA,GAERhjB,EAAKinB,eAAepqB,KAAKqmB,cAC3BrmB,KAAKmmB,OAAO,4BAAA,GACZnmB,KAAK2pB,sBAEHxmB,EAAKknB,sBAAsBrqB,KAAKqmB,cAClCrmB,KAAKmmB,OAAO,6BAAA,GACZnmB,KAAKsqB,eAAennB,EAAKknB,mBAAmBE,MAAMpnB,EAAKknB,mBAAmBlc,QAExEhL,EAAKqnB,cACHxqB,KAAK8lB,IAAI2E,qBAAqBzqB,KAAK8lB,IAAI2E,kBAAkB5qB,OAC3DG,KAAK0qB,iBAAiBvnB,EAAKqnB,SAAAA,IAE3BxqB,KAAK6nB,mBAAmBzgB,KAAKjE,EAAKqnB,SAAAA,IAGlCrnB,EAAKyiB,OACP5lB,KAAK8lB,IAAI6E,qBAAqB,IAAI/T,GAAsBzT,CAAAA,CAAAA,EACrD0S,KAAK,MAAA;AACA7V,aAAKmgB,cAETngB,KAAK6nB,mBAAmBhY,QAAQ2a,OAAAA;AAC9BxqB,eAAK0qB,iBAAiBF,CAAAA;AAAAA,QAAAA,CAAAA,GAExBxqB,KAAK6nB,qBAAqB,IAEtB7nB,KAAK8lB,IAAI2E,kBAAkB5qB,SAAS,WAASG,KAAK4qB,cAAAA;AAAAA,MAAAA,CAAAA,EAEvD9U,MAAMzE,OAAAA;AACLrR,aAAKyoB,UAAUlF,EAAQlS,GAAK,4BAAA,CAAA;AAAA,MAAA,CAAA,GAG7BlO,EAAKyiB,OAAQziB,EAAKqnB,aAAcrnB,EAAKinB,eAAgBjnB,EAAKknB,sBAC7DrqB,KAAKyoB,UAAUlF,EAAQ,IAAI3jB,MAAM,0CAAA,GAA6C;IA3C1D;AAAA,EA6CxB;AAAA,EAEA,iBAAkB4qB;AAChB,UAAMK,IAAkB,IAAI9T,GAAgByT;AAC5CxqB,SAAK8lB,IAAIgF,gBAAgBD,CAAAA,EACtB/U,MAAMzE,CAAAA,MAAAA;AA1Mb,UAAevR;AAAAA,OA2MF+qB,EAAgBX,WAAWW,EAAgBX,QAAQa,SAAS,QAAA,KA3M1DjrB,IA4MA,uCA3MbiM,QAAQQ,KAAKzM,CAAAA,KA6MLE,KAAKyoB,UAAUlF,EAAQlS,GAAK,uBAAA,CAAA;AAAA,IAAA,CAAA;AAAA,EAGpC;AAAA,EAMA,KAAM1O,GAAAA;AACJ,QAAA,CAAI3C,KAAKgnB,aAAT;AACA,UAAIhnB,KAAKmgB,UAAW,OAAMoD,EAAQ,IAAI3jB,MAAM,wCAAwC,eAAA;AACpFI,WAAK4nB,SAASoD,KAAKroB;IAFG;AAAA,EAGxB;AAAA,EAEA,oBAAAgnB;AACE3pB,SAAKmmB,OAAO,mBAAA,GACRnmB,KAAKgoB,wBACThoB,KAAKgoB,sBAAAA,IACLrS,eAAe,MAAA;AACb3V,WAAKgoB,sBAAAA,IACDhoB,KAAKqmB,aAAAA,CAAcrmB,KAAK+nB,qBAC1B/nB,KAAKmmB,OAAO,8BAAA,GACZnmB,KAAKirB,UAAAA,KAELjrB,KAAKmmB,OAAO,qDAAA,GAEdnmB,KAAK+nB,oBAAAA;AAAAA,IAAoB,CAAA;AAAA,EAE7B;AAAA,EAEA;AACE,QAAA,CAAI/nB,KAAKgnB,aAAT;AACA,UAAIhnB,KAAKmgB,UAAW,OAAMoD,EAAQ,IAAI3jB,MAAM,0CAAA,GAA6C,eAAA;AAErFI,WAAKqmB,YACHrmB,KAAK8nB,kBACP9nB,KAAKioB,qBAAAA,IACLjoB,KAAKmmB,OAAO,+BAAA,MAEZnmB,KAAKmmB,OAAO,mBAAA,GACZtgB,WAAW,MAAA;AACT7F,aAAKkrB;SACJ,CAAA,KAGDlrB,KAAK8nB,kBACP9nB,KAAKioB,yBACLjoB,KAAKmmB,OAAO,+BAAA,MAEZnmB,KAAKmmB,OAAO,uCAAA,GACZnmB,KAAKiI,KAAK,UAAU,EAClBpI,MAAM,eACNuqB,aAAAA,QAINpqB,KAAK8nB,iBAAAA;AAAAA,IAzBiB;AAAA,EA0BxB;AAAA,EAEA,OAAQ/S,GAAAA;AACD/U,SAAKyf,eAAexC,SAAOjd,KAAKoH,KAAK,IAAA,GAC1C2N,EAAG,IAAA;AAAA,EACL;AAAA,EAEA,UAAW1D;AACTrR,SAAKgC,IAAAA,GACLhC,KAAK6d,SAAS;OAAUxM,CAAAA;AAAAA,EAC1B;AAAA,EAEA,SAAU0D,GAAI1D,GAAAA;AACRrR,SAAKmgB,aAAangB,KAAKgnB,gBAC3BhnB,KAAKgnB,cAAAA,IAELhnB,KAAKmmB,OAAO,0BAA0B9U,MAAQA,EAAIvR,WAAWuR,KAE7DxL,WAAW,MAAA;AAoBT,UAnBI7F,KAAKinB,cAAYjnB,KAAKiI,KAAK,YAAA,GAC/BjI,KAAKinB,iBACLjnB,KAAKwnB,WAAAA,IACLxnB,KAAKynB,gBAAAA,IACLznB,KAAKooB,gBAAgB,MACrBpoB,KAAKqoB,iBAAiB,MACtBroB,KAAKmrB,aAAa,MAElBC,cAAcprB,KAAKmoB,gBAAAA,GACnBnoB,KAAKmoB,mBAAmB,MAExBiD,cAAcprB,KAAKwoB,YACnBxoB,KAAKwoB,YAAY,MACjBxoB,KAAKsoB,SAAS,MACdtoB,KAAKuoB,MAAM,MAEPvoB,KAAK4pB,kBAAgB5pB,KAAK+H,eAAe,UAAU/H,KAAK4pB,cAAAA,GAC5D5pB,KAAK4pB,iBAAiB,MAElB5pB,KAAK4nB,UAAU;AACjB,YAAA;AACE5nB,eAAK4nB,SAASyD,MAAAA;AAAAA,QAChB,QAASha;AAAAA,QAAM;AAGfrR,aAAK4nB,SAAS0D,YAAY,MAC1BtrB,KAAK4nB,SAAS2D,SAAS,MACvBvrB,KAAK4nB,SAAShJ,UAAU,MACxB5e,KAAK4nB,SAASjJ,UAAU;AAAA,MAC1B;AACA,UAAI3e,KAAK8lB,KAAK;AACZ,YAAA;AACE9lB,eAAK8lB,IAAIuF;QACX,QAASha;AAAAA,QAAM;AAGfrR,aAAK8lB,IAAI8C,6BAA6B,MACtC5oB,KAAK8lB,IAAIgD,4BAA4B,MACrC9oB,KAAK8lB,IAAImD,yBAAyB,MAClCjpB,KAAK8lB,IAAIqD,iBAAiB,MAC1BnpB,KAAK8lB,IAAI0F,UAAU,MACnBxrB,KAAK8lB,IAAI4D,gBAAgB;AAAA,MAC3B;AACA1pB,WAAK8lB,MAAM,MACX9lB,KAAK4nB,WAAW,MACZvW,KAAKrR,KAAKiI,KAAK,SAASoJ,IAC5B0D,EAAAA;AAAAA,IAAAA,GACC,CAAA;AAAA,EACL;AAAA,EAEA,WAAYqU,GAAAA;AACV,QAAA,CAAKA,EAAMI,QAIT,QAAOxpB,KAAKyoB,UAAUlF,EAAQ,IAAI3jB,MAAM,kDAAA,GAAqD,kBAAA,CAAA;AAG/FI,SAAK4nB,WAAWwB,EAAMI,SACtBxpB,KAAK4nB,SAAS6D,aAAa,eAE6B,OAA7CzrB,KAAK4nB,SAAS8D,8BAA+B,aACtD1rB,KAAK4nB,SAAS8D,6BAA6BhG,KAG7C1lB,KAAKomB,cAAcpmB,KAAK4nB,SAAS+D,OAEjC3rB,KAAK4nB,SAAS0D,YAAYlC,CAAAA,MAAAA;AACxBppB,WAAK4rB,kBAAkBxC;OAEzBppB,KAAK4nB,SAASiE,sBAAsB,MAAA;AAClC7rB,WAAK8rB,4BAAAA;AAAAA,IAAAA,GAEP9rB,KAAK4nB,SAAS2D,SAAS;AACrBvrB,WAAK+rB,eAAAA;AAAAA,IAAAA,GAEP/rB,KAAK4nB,SAAShJ,UAAU,MAAA;AACtB5e,WAAKgsB,gBAAAA;AAAAA,IAAAA,GAEPhsB,KAAK4nB,SAASjJ,UAAUyK,CAAAA,MAAAA;AACtB,YAAM/X,IAAM+X,EAAM9lB,iBAAiB1D,QAC/BwpB,EAAM9lB,QACN,IAAI1D,MAAM,sBAAsBwpB,EAAMtpB,OAAAA,IAAWspB,EAAM6C,QAAAA,IAAY7C,EAAM8C,MAAAA,IAAU9C,EAAM+C;AAC7FnsB,WAAKyoB,UAAUlF,EAAQlS,GAAK;;AAK9B,QAAI+a,IAAAA;AACJpsB,SAAKmoB,mBAAmBkE,YAAY,MAAA;AAC9BrsB,WAAK4nB,YAAY5nB,KAAK4nB,SAASmC,eAAe,aAC5CqC,KAAWpsB,KAAKgsB,gBAAAA,GACpBI,IAAAA,MAEAA,IAAAA;AAAAA,OAhYwB,GAAA;AAAA,EAmY9B;AAAA,EAEA,OAAQzpB,GAAOoS,GAAAA;AACb,QAAI/U,KAAKmgB,UAAW,QAAOpL,EAAGwO,EAAQ,IAAI3jB,MAAM,yCAAyC,kBAAA,CAAA;AAEzF,QAAII,KAAKinB,YAAY;AACnB,UAAA;AACEjnB,aAAKgrB,KAAKroB,CAAAA;AAAAA,MACZ,SAAS0O,GAAAA;AACP,eAAOrR,KAAKyoB,UAAUlF,EAAQlS,GAAK,kBAAA,CAAA;AAAA,MACrC;AACIrR,WAAK4nB,SAASkC,iBAAiBpE,MACjC1lB,KAAKmmB,OAAO,yCAAyCnmB,KAAK4nB,SAASkC,cAAAA,GACnE9pB,KAAKuoB,MAAMxT,KAEXA,EAAG,IAAA;AAAA,IAEP,MACE/U,MAAKmmB,OAAO,sBAAA,GACZnmB,KAAKsoB,SAAS3lB,GACd3C,KAAKuoB,MAAMxT;AAAAA,EAEf;AAAA,EAIA,YAAA8U;AACE,QAAI7pB,KAAKmgB,UAAW;AAIpB,UAAMmM,IAAc,MAAA;AAClBzmB,iBAAW,MAAM7F,KAAKyoB,UAAAA,GAAa,GAAA;AAAA,IAAA;AAGjCzoB,SAAKinB,aACPqF,EAAAA,IAEAtsB,KAAK6H,KAAK,WAAWykB,CAAAA;AAAAA,EAEzB;AAAA,EAEA,2BAAAC;AACMvsB,SAAKmgB,aACLngB,KAAK2nB,sBACT3nB,KAAKmmB,OAAO,6BAAA,GACZnmB,KAAK2nB,oBAAoB9hB,WAAW;AAC7B7F,WAAK0nB,iBACR1nB,KAAK0nB,eAAAA,IACL1nB,KAAKmmB,OAAO,+BAAA,GACZnmB,KAAKiI,KAAK,YAAA,GACVjI,KAAKiI,KAAK,cAAA;AAAA,IAAA,GAEXjI,KAAK+mB,kBAAAA;AAAAA,EACV;AAAA,EAEA,eAAAmE;AACMlrB,SAAKmgB,aAETngB,KAAK8lB,IAAI0G,YAAYxsB,KAAK0mB,YAAAA,EACvB7Q,KAAK4W,CAAAA,MAAAA;AACJ,UAAIzsB,KAAKmgB,UAAW;AACfngB,WAAK6mB,WAAY7mB,KAAK8mB,qBAAkB2F,EAAM7G,MAAMD,GAAc8G,EAAM7G,GAAAA,IAC7E6G,EAAM7G,MAAM5lB,KAAK4mB,aAAa6F,EAAM7G,GAAAA;AAEpC,YAAM8G,IAAY;AAChB,YAAI1sB,KAAKmgB,UAAW;AACpB,cAAMve,IAAS5B,KAAK8lB,IAAI6G,oBAAoBF;AAC5CzsB,aAAKmmB,OAAO,QAAA,GACZnmB,KAAKiI,KAAK,UAAU,EAClBpI,MAAM+B,EAAO/B,MACb+lB,KAAKhkB,EAAOgkB,IAAAA,CAAAA;AAAAA,MAAAA;AAehB5lB,WAAK8lB,IAAI8G,oBAAoBH,CAAAA,EAC1B5W,KAZe,MAAA;AAChB7V,aAAKmmB,OAAO,qBAAA,GACRnmB,KAAKmgB,cACLngB,KAAK6mB,WAAW7mB,KAAK0nB,eAAcgF,EAAAA,IAClC1sB,KAAK6H,KAAK,gBAAgB6kB,CAAAA;AAAAA,MAAAA,CAAAA,EAS9B5W,MANazE,CAAAA;AACdrR,aAAKyoB,UAAUlF,EAAQlS,GAAK;;OAO/ByE,MAAMzE,CAAAA,MAAAA;AACLrR,WAAKyoB,UAAUlF,EAAQlS,GAAK,kBAAA,CAAA;AAAA,IAAA,CAAA;AAAA,EAElC;AAAA,EAEA;AACMrR,SAAKmgB,aAETngB,KAAK8lB,IAAI+G,aAAa7sB,KAAK2mB,aAAAA,EACxB9Q,KAAKiX,CAAAA;AACJ,UAAI9sB,KAAKmgB,UAAW;AACfngB,WAAK6mB,WAAY7mB,KAAK8mB,qBAAkBgG,EAAOlH,MAAMD,GAAcmH,EAAOlH,GAAAA,IAC/EkH,EAAOlH,MAAM5lB,KAAK4mB,aAAakG,EAAOlH,GAAAA;AAEtC,YAAMmH,IAAa,MAAA;AACjB,YAAI/sB,KAAKmgB,UAAW;AACpB,cAAMve,IAAS5B,KAAK8lB,IAAI6G,oBAAoBG;AAC5C9sB,aAAKmmB,OAAO,WACZnmB,KAAKiI,KAAK,UAAU,EAClBpI,MAAM+B,EAAO/B,MACb+lB,KAAKhkB,EAAOgkB,QAET5lB,KAAKqmB,aAAWrmB,KAAKgtB,8BAAAA;AAAAA,MAAAA;AAa5BhtB,WAAK8lB,IAAI8G,oBAAoBE,CAAAA,EAC1BjX,KAXe;AACZ7V,aAAKmgB,cACLngB,KAAK6mB,WAAW7mB,KAAK0nB,eAAcqF,EAAAA,IAClC/sB,KAAK6H,KAAK,gBAAgBklB,CAAAA;AAAAA,MAAAA,CAAAA,EAS9BjX,MANazE,CAAAA,MAAAA;AACdrR,aAAKyoB,UAAUlF,EAAQlS,GAAK,2BAAA,CAAA;AAAA,MAAA,CAAA;AAAA,IAAA,CAAA,EAO/ByE,MAAMzE,CAAAA;AACLrR,WAAKyoB,UAAUlF,EAAQlS,GAAK;;EAElC;AAAA,EAEA,2BAAA2X;AACMhpB,SAAKmgB,aAAangB,KAAKgnB,eACvBhnB,KAAK8lB,IAAImH,oBAAoB,YAC/BjtB,KAAKyoB,UAAUlF,EAAQ,IAAI3jB,MAAM,oBAAA,GAAuB,wBAAA,CAAA;AAAA,EAE5D;AAAA,EAEA,oBAAAipB;AACE,QAAI7oB,KAAKmgB,UAAW;AACpB,UAAM+M,IAAqBltB,KAAK8lB,IAAIoH,oBAC9BC,IAAoBntB,KAAK8lB,IAAIqH;AAEnCntB,SAAKmmB,OACH,mDACA+G,GACAC,CAAAA,GAEFntB,KAAKiI,KAAK,kBAAkBilB,GAAoBC,CAAAA,GAE5CD,MAAuB,eAAeA,MAAuB,gBAC/DltB,KAAKwnB,eACLxnB,KAAKotB,YAAAA,IAEHF,MAAuB,YACzBltB,KAAKyoB,UAAUlF,EAAQ,IAAI3jB,MAAM,wBAAA,GAA2B,4BAAA,CAAA,GAE1DstB,MAAuB,YACzBltB,KAAKyoB,UAAUlF,EAAQ,IAAI3jB,MAAM,2BAA2B,2BAAA,CAAA;AAAA,EAEhE;AAAA,EAEA,SAAUmV;AAER,UAAMsY,IAAgBC,CAAAA,OAChBtoB,OAAOC,UAAUsoB,SAASpoB,KAAKmoB,EAAOE,YAAY,oBACpDF,EAAOE,OAAO3d,QAAQ/M,CAAAA,MAAAA;AACpBkC,aAAOoe,OAAOkK,GAAQxqB,CAAAA;AAAAA,IAAAA,CAAAA,GAGnBwqB;AAIwB,IAA7BttB,KAAK8lB,IAAI2H,SAASpnB,WAAW,KAAKrG,KAAK0oB,uBACzC1oB,KAAK8lB,IAAI2H,SAAAA,EACN5X,KAAK8O,OAAAA;AACJ,YAAM+I,IAAU,CAAA;AAChB/I,QAAI9U,QAAQyd,CAAAA,MAAAA;AACVI,UAAQtmB,KAAKimB,EAAcC,CAAAA,CAAAA;AAAAA,MAAAA,CAAAA,GAE7BvY,EAAG,MAAM2Y,CAAAA;AAAAA,IAAAA,GACRrc,CAAAA,MAAO0D,EAAG1D,CAAAA,CAAAA,IAGNrR,KAAK8lB,IAAI2H,SAASpnB,SAAS,IACpCrG,KAAK8lB,IAAI2H,SAAS9I,OAAAA;AAEhB,UAAI3kB,KAAKmgB,UAAW;AAEpB,YAAMuN,IAAU,CAAA;AAChB/I,QAAIrO,SAASzG,QAAQyG,CAAAA,MAAAA;AACnB,cAAMgX,IAAS,CAAA;AACfhX,QAAAA,EAAOtH,MAAAA,EAAQa,QAAQnL,CAAAA;AACrB4oB,UAAAA,EAAO5oB,CAAAA,IAAQ4R,EAAOqX,KAAKjpB;YAE7B4oB,EAAOM,KAAKtX,EAAOsX,IACnBN,EAAOztB,OAAOyW,EAAOzW,MACrBytB,EAAOrtB,YAAYqW,EAAOrW,WAC1BytB,EAAQtmB,KAAKimB,EAAcC,CAAAA,CAAAA;AAAAA,MAAAA,CAAAA,GAE7BvY,EAAG,MAAM2Y,CAAAA;AAAAA,IAAAA,GACRrc,CAAAA,MAAO0D,EAAG1D,CAAAA,CAAAA,IAKb0D,EAAG,MAAM;EAEb;AAAA,EAEA,cAAAqY;AAEE,QADAptB,KAAKmmB,OAAO,+BAA+BnmB,KAAKwnB,UAAUxnB,KAAKynB,aAAAA,GAC3DznB,KAAKinB,cAAcjnB,KAAK6tB,gBAAgB7tB,KAAKwnB,YAAAA,CAAaxnB,KAAKynB,cAAe;AAElFznB,SAAK6tB,cAAAA;AAGL,UAAMC,IAAoB,MAAA;AACpB9tB,WAAKmgB,aAAangB,KAAKgnB,eAE3BhnB,KAAKytB,SAAS,CAACpc,GAAK0c;AAClB,YAAI/tB,KAAKmgB,aAAangB,KAAKgnB,YAAa;AAGpC3V,QAAAA,MAAK0c,IAAQ,CAAA;AAEjB,cAAMC,IAAmB,CAAA,GACnBC,IAAkB,CAAA,GAClBC,IAAiB,CAAA;AACvB,YAAIC,IAAAA;AAEJJ,UAAMle,QAAQue,CAAAA;AAGM,UAAdA,EAAKvuB,SAAS,qBAAqBuuB,EAAKvuB,SAAS,uBACnDmuB,EAAiBI,EAAKR,EAAAA,IAAMQ,IAE1BA,EAAKvuB,SAAS,oBAAoBuuB,EAAKvuB,SAAS,sBAClDouB,EAAgBG,EAAKR,EAAAA,IAAMQ,IAEzBA,EAAKvuB,SAAS,mBAAmBuuB,EAAKvuB,SAAS,qBACjDquB,EAAeE,EAAKR,EAAAA,IAAMQ;AAAAA;AAI9B,cAAMC,IAA2BC,CAAAA,MAAAA;AAC/BH,UAAAA,IAAAA;AAEA,cAAII,IAAQN,EAAgBK,EAAsBE;AAE9CD,UAAAA,MAAUA,EAAME,MAAMF,EAAMrE,YAE9BlqB,KAAKqnB,eAAekH,EAAME,MAAMF,EAAMrE,SACtClqB,KAAKunB,YAAYna,OAAOmhB,EAAMvE,IAAAA,KACrBuE,KAASA,EAAMG,aAExB1uB,KAAKqnB,eAAekH,EAAMG,WAC1B1uB,KAAKunB,YAAYna,OAAOmhB,EAAMI,UAAAA,KAC6B,OAA3CL,EAAsBM,oBAAqB,aAE3DL,IAAQD,EAAsBM,iBAAiBvf,MAAM,GAAA,GACrDrP,KAAKqnB,eAAekH,EAAM,IAC1BvuB,KAAKunB,YAAYna,OAAOmhB,EAAM,MAE5BvuB,KAAKqnB,iBACPrnB,KAAKsnB,cAActnB,KAAKqnB,aAAawH,SAAS,GAAA,IAAO,SAAS;AAGhE,cAAIC,IAASd,EAAiBM,EAAsBS;AAEhDD,UAAAA,MAAWA,EAAOL,MAAMK,EAAO5E,YAEjClqB,KAAKknB,gBAAgB4H,EAAOL,MAAMK,EAAO5E,SACzClqB,KAAKonB,aAAaha,OAAO0hB,EAAO9E,IAAAA,KACvB8E,KAAUA,EAAOJ,aAE1B1uB,KAAKknB,gBAAgB4H,EAAOJ,WAC5B1uB,KAAKonB,aAAaha,OAAO0hB,EAAOH,UAAAA,KAC4B,OAA5CL,EAAsBU,qBAAsB,aAE5DF,IAASR,EAAsBU,kBAAkB3f,MAAM,GAAA,GACvDrP,KAAKknB,gBAAgB4H,EAAO,IAC5B9uB,KAAKonB,aAAaha,OAAO0hB,EAAO,MAE9B9uB,KAAKknB,kBACPlnB,KAAKmnB,eAAennB,KAAKknB,cAAc2H,SAAS,GAAA,IAAO,SAAS,SAGlE7uB,KAAKmmB,OACH,sCACAnmB,KAAKqnB,cACLrnB,KAAKunB,WACLvnB,KAAKknB,eACLlnB,KAAKonB,UAAAA;AAAAA,QAAAA;AAqBT,YAjBA2G,EAAMle,QAAQue,CAAAA;AAEM,UAAdA,EAAKvuB,SAAS,eAAeuuB,EAAKa,2BACpCZ,EAAyBH,EAAeE,EAAKa,uBAAAA,CAAAA,IAK5Cb,EAAKvuB,SAAS,uBAAuBuuB,EAAKc,yBAAyB,WAClEd,EAAKvuB,SAAS,mBAAmBuuB,EAAKvuB,SAAS,qBAAqBuuB,EAAKe,aAE3Ed,EAAyBD;YAMxBD,KAAgCnpB,OAAO4K,KAAKse,CAAAA,EAAgB7nB,WAAUrB,OAAO4K,KAAKqe,CAAAA,EAAiB5nB,QAAxG;AASA,cALErG,KAAK6tB,cAAAA,IACL7tB,KAAKinB,aAAAA,IACLjnB,KAAKiI,KAAK,YAGRjI,KAAKsoB,QAAQ;AACf,gBAAA;AACEtoB,mBAAKgrB,KAAKhrB,KAAKsoB,MAAAA;AAAAA,YACjB,SAASjX,GAAAA;AACP,qBAAOrR,KAAKyoB,UAAUlF,EAAQlS,GAAK,kBAAA,CAAA;AAAA,YACrC;AACArR,iBAAKsoB,SAAS,MACdtoB,KAAKmmB,OAAO,wCAAA;AAEZ,kBAAMpR,IAAK/U,KAAKuoB;AAChBvoB,iBAAKuoB,MAAM,MACXxT,EAAG,IAAA;AAAA,UACL;AAIwD,iBAA7C/U,KAAK4nB,SAAS8D,8BAA+B,aACtD1rB,KAAKwoB,YAAY6D,YAAY,MAAMrsB,KAAKovB,YAAAA,GAAe,MACnDpvB,KAAKwoB,UAAU6G,SAAOrvB,KAAKwoB,UAAU6G,MAAAA,IAG3CrvB,KAAKmmB,OAAO,SAAA,GACZnmB,KAAKiI,KAAK,SAAA;AAAA,QAxBV,MANEpC,YAAWioB,GAAmB,GAAA;AAAA,MAAA,CAAA;AAAA,IAAA;AAiCpCA,IAAAA,EAAAA;AAAAA,EACF;AAAA,EAEA;KACO9tB,KAAKuoB,OAAAA,CAAQvoB,KAAK4nB,YAAY5nB,KAAK4nB,SAASkC,iBAAiBpE,MAGlE1lB,KAAK8rB;EACP;AAAA,EAEA,0BAAA5C;AACMlpB,SAAKmgB,cAELngB,KAAK8lB,IAAIwJ,mBAAmB,aAC9BtvB,KAAK8nB,iBAAAA,IAGL9nB,KAAKmmB,OAAO,yBAAyBnmB,KAAKkoB,sBAAAA,GAC1CloB,KAAKkoB,uBAAuBrY,QAAQ0f,CAAAA,MAAAA;AAClCvvB,WAAK8lB,IAAI0J,YAAYD,CAAAA,GACrBvvB,KAAKioB,qBAAAA;AAAAA,IAAqB,CAAA,GAE5BjoB,KAAKkoB,yBAAyB,CAAA,GAE1BloB,KAAKioB,sBACPjoB,KAAKmmB,OAAO,4BAAA,GACZnmB,KAAKioB,qBAAAA,IACLjoB,KAAK2pB,kBAAAA,MAEL3pB,KAAKmmB,OAAO,eACZnmB,KAAKiI,KAAK,YAAA,KAIdjI,KAAKmmB,OAAO,2BAA2BnmB,KAAK8lB,IAAIwJ,cAAAA,GAChDtvB,KAAKiI,KAAK,wBAAwBjI,KAAK8lB,IAAIwJ;EAC7C;AAAA,EAEA,gBAAiBlG,GAAAA;AACXppB,SAAKmgB,cACLiJ,EAAMoB,aAAaxqB,KAAK6mB,UAC1B7mB,KAAKiI,KAAK,UAAU,EAClBpI,MAAM,aACN2qB,WAAW,EACTA,WAAWpB,EAAMoB,UAAUA,WAC3BiF,eAAerG,EAAMoB,UAAUiF,eAC/BC,QAAQtG,EAAMoB,UAAUkF,cAGlBtG,EAAMoB,aAAcxqB,KAAK0nB,iBACnC1nB,KAAK0nB,eAAAA,IACL1nB,KAAKiI,KAAK,kBAGRmhB,EAAMoB,aACRxqB,KAAKusB,yBAAAA;AAAAA,EAET;AAAA,EAEA,kBAAmBnD,GAAAA;AACjB,QAAIppB,KAAKmgB,UAAW;AACpB,QAAIhd,IAAOimB,EAAMjmB;AACbA,IAAAA,aAAgBwsB,cAClBxsB,IAAO,IAAIuV,WAAWvV,CAAAA,IACbnD,KAAKgmB,iBADQ7iB,OAEtBA,IAAOqhB,GAASrhB,CAAAA,IAElBnD,KAAKoH,KAAKjE,CAAAA;AAAAA,EACZ;AAAA,EAEA,8BAAA2oB;AACE,QAAI9rB,KAAKmgB,aAAAA,CAAcngB,KAAKuoB,IAAK;AACjCvoB,SAAKmmB,OAAO,0CAA0CnmB,KAAK4nB,SAASkC,cAAAA;AACpE,UAAM/U,IAAK/U,KAAKuoB;AAChBvoB,SAAKuoB,MAAM,MACXxT,EAAG;EACL;AAAA,EAEA,iBAAAgX;AACM/rB,SAAKinB,cAAcjnB,KAAKmgB,cAC5BngB,KAAKmmB,OAAO,oBACZnmB,KAAKynB,gBAAAA,IACLznB,KAAKotB;EACP;AAAA,EAEA,kBAAApB;AACMhsB,SAAKmgB,cACTngB,KAAKmmB,OAAO,kBAAA,GACZnmB,KAAKyoB;EACP;AAAA,EAEA,SAAAtC;AACE,UAAMnf,IAAO,CAAA,EAAGyI,MAAMtK,KAAK+B,SAAAA;AAC3BF,IAAAA,EAAK,CAAA,IAAK,MAAMhH,KAAKkmB,MAAM,OAAOlf,EAAK,CAAA,GACvCye,GAAMpe,MAAM,MAAML,CAAAA;AAAAA,EACpB;AAAA;AAGF6e,GAAK+J,iBAAAA,CAAAA,CAAmBnZ,IAOxBoP,GAAKY,SAAS,EACZoJ,YAAY,CACV,EACEC,MAAM,CACJ,gCACA,wCAINC,cAAc,eAAA,GAGhBlK,GAAKS,gBAAgB,CAAA;qBCn2BrB0J,IAAe,CAAA,GCmCfrjB,KAAe,EACbsjB,wBA9BoC,IA+BpCC,oBA9BgC,IA+BhCC,UAjBsBzmB,CAAAA,MAAAA;AACtB,QAAM/H,IAAM,IAAIyuB,IAAI1mB,EAAIoB,QAAQ,SAAS,OAAA,CAAA;AAUzC,SARIpB,EAAI1F,MAAM,OAAA,KACZgB,OAAOqrB,iBAAiB1uB,GAAK,EAC3B2uB,MAAM,EAAExtB,OAAOnB,EAAI2uB,KAAKxlB,QAAQ,SAAS,UACzCylB,UAAU,EAAEztB,OAAOnB,EAAI4uB,SAASzlB,QAAQ,SAAS,KAAA,EAAA,GACjD0lB,QAAQ,EAAE1tB,OAAOnB,EAAI6uB,OAAO1lB,QAAQ,SAAS,KAAA,EAAA,EAAA,CAAA,GAI1CnJ;AAAAA,GAAAA,qHCvBH+K,KAAQ+Y,EAAM,kBAAA,GAEdgL,KAA2B,OAAP/Q,KAAO,aAAagR,YAAYhR;AAU3C,MAAMiR,WAAe/O,GAAAA,OAAAA;AAAAA,EAClC,YAAa/B,IAAO;AAelB,eAbWA,KAAS,aAClBA,IAAO,EAAEle,KAAKke,MAOhB9f,MAJA8f,IAAO7a,OAAOoe,OAAO,EACnB2C,eAAAA,GAAe,GACdlG,CAAAA,CAAAA,GAIH7f,KAAKgmB,iBAAiBnG,EAAKoG,YACvBpG,EAAKoG,cAAc,eAAapG,EAAKoG,YAErCpG,EAAKle,OAAO,QAAQke,EAAK+Q,UAAU,KACrC,OAAM,IAAIhxB,MAAM,2CAAA;AAElB,QAAIigB,EAAKle,OAAO,QAAQke,EAAK+Q,UAAU,KACrC,OAAM,IAAIhxB,MAAM,wDAAA;AAYlB,QATAI,KAAKkmB,MAAMpC,GAAQuB,GAAY,CAAA,CAAA,EAAI5V,MAAM,GAAG,CAAA,GAC5CzP,KAAKmmB,OAAO,qBAAqBtG,CAAAA,GAEjC7f,KAAK6wB,YAAAA,IAEL7wB,KAAKsoB,SAAS,MACdtoB,KAAKuoB,MAAM,MACXvoB,KAAKwoB,YAAY,MAEb3I,EAAK+Q,OACP5wB,MAAK2B,MAAMke,EAAK+Q,OAAOjvB,KACvB3B,KAAK8wB,MAAMjR,EAAK+Q,QAChB5wB,KAAK6wB,YAAYhR,EAAK+Q,OAAO7G,eAAe0G,GAAWM;AAAAA,SAClD;AACL/wB,WAAK2B,MAAMke,EAAKle;AAChB,UAAA;AAGI3B,aAAK8wB,aAFIpR,KAAO,aAEL,IAAI+Q,GAAW5Q,EAAKle,KAAK,EAAA,GAC/Bke,GACHzH,UAAAA,OAAUT,CAAAA,IAGD,IAAI8Y,GAAW5Q,EAAKle,GAAAA;AAAAA,MAEnC,SAAS0P,GAAAA;AAEP,eAAA,KADAsE,GAAe,MAAM3V,KAAKqM,QAAQgF,CAAAA,CAAAA;AAAAA,MAEpC;AAAA,IACF;AAEArR,SAAK8wB,IAAIrF,aAAa,eAElB5L,EAAK+Q,UAAU5wB,KAAK6wB,YACtBlb,GAAe,MAAM3V,KAAKgxB,YAAAA,CAAAA,IAE1BhxB,KAAK8wB,IAAIvF,SAAS,MAAMvrB,KAAKgxB,YAAAA,GAG/BhxB,KAAK8wB,IAAIxF,YAAYlC,OAASppB,KAAKixB,eAAe7H,CAAAA,GAClDppB,KAAK8wB,IAAIlS,UAAU,MAAM5e,KAAKkxB,gBAC9BlxB,KAAK8wB,IAAInS,UAAUtN,OAAOrR,KAAKmxB,aAAa9f,CAAAA,GAE5CrR,KAAKoxB,qBAAqB,MAAMpxB,KAAKqxB,cAAAA,GACrCrxB,KAAK6H,KAAK,UAAU7H,KAAKoxB,kBAAAA;AAAAA,EAC3B;AAAA,EAMA,KAAMzuB,GAAAA;AACJ3C,SAAK8wB,IAAI9F,KAAKroB;EAChB;AAAA,EAEA,OAAQoS,GAAAA;AACD/U,SAAKyf,eAAexC,SAAOjd,KAAKoH,KAAK,OAC1C2N,EAAG,IAAA;AAAA,EACL;AAAA,EAEA,SAAUA,GAAAA;AACR,QAAA,CAAI/U,KAAKmgB,WAAT;AAeA,UAdKngB,KAAKmd,eAAeF,SAAOjd,KAAKgC,IAAAA,GAErChC,KAAK6wB,YAAAA,IAELzF,cAAcprB,KAAKwoB,SAAAA,GACnBxoB,KAAKwoB,YAAY,MACjBxoB,KAAKsoB,SAAS,MACdtoB,KAAKuoB,MAAM,MAEPvoB,KAAKoxB,sBACPpxB,KAAK+H,eAAe,UAAU/H,KAAKoxB,kBAAAA,GAErCpxB,KAAKoxB,qBAAqB,MAEtBpxB,KAAK8wB,KAAK;AACZ,cAAMpR,IAAK1f,KAAK8wB,KACVQ,IAAU;AACd5R,YAAGd,UAAU;AAAA,QAAA;AAEf,YAAIc,EAAGqK,eAAe0G,GAAWc,OAC/BD,CAAAA,EAAAA;AAAAA,YAEA;AACE5R,YAAGd,UAAU0S,GACb5R,EAAG2L;QACL,QAASha;AACPigB,UAAAA,EAAAA;AAAAA,QACF;AAGF5R,UAAG6L,SAAS,MACZ7L,EAAG4L,YAAY,MACf5L,EAAGf,UAAU,MAAA;AAAA,QAAA;AAAA,MACf;AACA3e,WAAK8wB,MAAM,MAEX/b,EAAAA;AAAAA,IArCoB;AAAA,EAsCtB;AAAA,EAEA,OAAQpS,GAAOoS;AACb,QAAI/U,KAAKmgB,UAAW,QAAOpL,EAAG,IAAInV,MAAM,wCAAA,CAAA;AAExC,QAAII,KAAK6wB,WAAW;AAClB,UAAA;AACE7wB,aAAKgrB,KAAKroB,CAAAA;AAAAA,MACZ,SAAS0O,GAAAA;AACP,eAAOrR,KAAKqM,QAAQgF,CAAAA;AAAAA,MACtB;AACkB,aAAPqO,KAAO,cAAc1f,KAAK8wB,IAAIhH,iBA7InB,SA8IpB9pB,KAAKmmB,OAAO,yCAAyCnmB,KAAK8wB,IAAIhH,cAAAA,GAC9D9pB,KAAKuoB,MAAMxT,KAEXA,EAAG,IAAA;AAAA,IAEP,MACE/U,MAAKmmB,OAAO,yBACZnmB,KAAKsoB,SAAS3lB,GACd3C,KAAKuoB,MAAMxT;AAAAA,EAEf;AAAA,EAEA,cAAAic;AACE,SAAIhxB,KAAK6wB,aAAAA,CAAa7wB,KAAKmgB,WAA3B;AAGA,UAFAngB,KAAK6wB,YAAAA,IAED7wB,KAAKsoB,QAAQ;AACf,YAAA;AACEtoB,eAAKgrB,KAAKhrB,KAAKsoB,MAAAA;AAAAA,QACjB,SAASjX;AACP,iBAAOrR,KAAKqM,QAAQgF,CAAAA;AAAAA,QACtB;AACArR,aAAKsoB,SAAS,MACdtoB,KAAKmmB,OAAO,wCAAA;AAEZ,cAAMpR,IAAK/U,KAAKuoB;AAChBvoB,aAAKuoB,MAAM,MACXxT,EAAG,IAAA;AAAA,MACL;AAIkB,MAAA,OAAP2K,KAAO,eAChB1f,KAAKwoB,YAAY6D,YAAY,MAAMrsB,KAAKovB,eAAe,GAAA,GACnDpvB,KAAKwoB,UAAU6G,SAAOrvB,KAAKwoB,UAAU6G,MAAAA,IAG3CrvB,KAAKmmB,OAAO,YACZnmB,KAAKiI,KAAK,SAAA;AAAA,IAzB4B;AAAA,EA0BxC;AAAA,EAEA,eAAgBmhB,GAAAA;AACd,QAAIppB,KAAKmgB,UAAW;AACpB,QAAIhd,IAAOimB,EAAMjmB;AACbA,IAAAA,aAAgBwsB,gBAAaxsB,IAAO,IAAIuV,WAAWvV,CAAAA,IACnDnD,KAAKgmB,iBAD8C7iB,OACtBA,IAAOqhB,GAASrhB,CAAAA,IACjDnD,KAAKoH,KAAKjE,CAAAA;AAAAA,EACZ;AAAA,EAEA,eAAA+tB;AACMlxB,SAAKmgB,cACTngB,KAAKmmB,OAAO,UAAA,GACZnmB,KAAKqM,QAAAA;AAAAA,EACP;AAAA,EAEA,aAAcoX;AACZzjB,SAAKqM,QAAQ,IAAIzM,MAAM,uBAAuBI,KAAK2B,GAAAA,EAAAA,CAAAA;AAAAA,EACrD;AAAA,EAIA;AACE,QAAI3B,KAAKmgB,UAAW;AAIpB,UAAMmM,IAAc,MAAA;AAClBzmB,iBAAW,MAAM7F,KAAKqM,QAAAA,GAAW,GAAA;AAAA,IAAA;AAG/BrM,SAAK6wB,YACPvE,MAEAtsB,KAAK6H,KAAK,WAAWykB,CAAAA;AAAAA,EAEzB;AAAA,EAEA,cAAA8C;AACE,QAAA,CAAKpvB,KAAKuoB,QAAQvoB,KAAK8wB,OAAO9wB,KAAK8wB,IAAIhH,iBA5Nf,MA6NtB;AAEF9pB,SAAKmmB,OAAO,0CAA0CnmB,KAAK8wB,IAAIhH,cAAAA;AAC/D,UAAM/U,IAAK/U,KAAKuoB;AAChBvoB,SAAKuoB,MAAM,MACXxT,EAAG,IAAA;AAAA,EACL;AAAA,EAEA;AACE,UAAM/N,IAAO,CAAA,EAAGyI,MAAMtK,KAAK+B,SAAAA;AAC3BF,IAAAA,EAAK,CAAA,IAAK,MAAMhH,KAAKkmB,MAAM,OAAOlf,EAAK,CAAA,GACvC0F,GAAMrF,MAAM,MAAML,CAAAA;AAAAA,EACpB;AAAA;AAGF2pB,GAAOa,oBAAAA,CAAAA,CAAsBf;ACvP7B,MAAMgB,WAAgB3gB;EACpB,YAAa4gB,GAAQC,GAAAA;AACnB5xB,aAEAC,KAAK0xB,SAASA,GACd1xB,KAAK2xB,cAAcA,GAEnB3xB,KAAK4xB,WAAW,MAChB5xB,KAAKmgB,YAAAA;AAAAA,EACP;AAAA,EAEA,YAAa0R,GAAAA;AACO,IAAdA,KAAc,SAAMA,IAAa7xB,KAAK8xB,4BAE1C1G,cAAcprB,KAAK4xB,QAAAA,GAEfC,MACF7xB,KAAK4xB,WAAWvF,YAAY,MAAA;AAC1BrsB,WAAK+xB,SAAS/xB,KAAK0xB,OAAOM,qBAAAA,CAAAA;AAAAA,IAAAA,GACzBH,IACC7xB,KAAK4xB,SAASvC,SAAOrvB,KAAK4xB,SAASvC,MAAAA;AAAAA,EAE3C;AAAA;AChBF,MAAM3iB,IAAQ+Y,EAAM,sCAAA,GAKdwM,IAAa,CAAA;AAOnB,MAAMC,WAAyBT,GAAAA;AAAAA,EAC7B,YAAaC,GAAQC,GAAAA;AACnB5xB,UAAM2xB,GAAQC,CAAAA,GACdjlB,EAAM,4BAA4BilB,CAAAA,GAElC3xB,KAAKmyB,QAAQ,CAAA,GACbnyB,KAAK4wB,SAAS,MAEd5wB,KAAKoyB,eAAAA,IACLpyB,KAAKqyB,UAAU,GACfryB,KAAKsyB,iBAAiB,MAItBtyB,KAAKuyB,wBAELvyB,KAAKwyB,YAAAA;AAAAA,EACP;AAAA,EAEA,SAAU3S,GAAAA;AACR,QAAI7f,KAAKmgB,aAAangB,KAAKoyB,aAAc;AACzC,QAAA,CAAKpyB,KAAK4wB,OAAOC,UAIf,QAAA,KAHA7wB,KAAK4wB,OAAO/oB,KAAK,WAAW,MAAA;AAC1B7H,WAAK+xB,SAASlS,CAAAA;AAAAA,IAAAA,CAAAA;AAKlB,UAAM4S,IAASztB,OAAOoe,OAAO,CAAA,GAAIvD,GAAM,EACrC6S,QAAQ,YACRC,WAAW3yB,KAAK0xB,OAAOkB,iBACvBC,SAAS7yB,KAAK0xB,OAAOoB,cAAAA,CAAAA;AAIvB,QAFI9yB,KAAK+yB,eAAYN,EAAOO,YAAYhzB,KAAK+yB,aAEzClT,EAAKuJ,UAAU,aAAavJ,EAAKuJ,UAAU,YAE7CppB,MAAKizB,MAAMR;SACN;AAEL,YAAMS,IAAU5pB,KAAKuY,IAAIhC,EAAKqT,SAAS,EAAA;AAEvClzB,WAAKmzB,gBAAgBD,GAASE,CAAAA,MAAAA;AAC5BX,QAAAA,EAAOS,UAAUA,GACjBT,EAAOW,SAASA,GAChBpzB,KAAKizB,MAAMR,CAAAA;AAAAA,MAAAA,CAAAA;AAAAA,IAEf;AAAA,EACF;AAAA,EAEA,OAAQ5S,GAAAA;AACN,QAAI7f,KAAKmgB,aAAangB,KAAKoyB,aAAc;AACzC,QAAA,CAAKpyB,KAAK4wB,OAAOC,UAIf,QAAA,KAHA7wB,KAAK4wB,OAAO/oB,KAAK,WAAW,MAAA;AAC1B7H,WAAKqzB,OAAOxT;;AAKhB,UAGM4S,IAAS,EACbC,QAAQ,UACRC,WALkB1rB,MAAMmP,QAAQyJ,EAAKyT,aAAazT,EAAKyT,SAASjtB,SAAS,IACvEwZ,EAAKyT,SAASpkB,IAAIokB,CAAAA,MAAY1O,GAAQ0O,MACrCzT,EAAKyT,YAAY1O,GAAQ/E,EAAKyT,aAActzB,KAAK0xB,OAAOkB,gBAAAA;AAM7D5yB,SAAKizB,MAAMR,CAAAA;AAAAA,EACb;AAAA,EAEA,QAAS1d,IAAKjO,IAAAA;AACZ,QAAI9G,KAAKmgB,UAAW,QAAOpL,EAAG,IAAA;AAE9B/U,SAAKmgB,YAAAA,IAELiL,cAAcprB,KAAK4xB,QAAAA,GACnB7rB,aAAa/F,KAAKsyB,cAAAA;AAGlB,eAAWiB,KAAUvzB,KAAKmyB,OAAO;AAC/B,YAAMqB,IAAOxzB,KAAKmyB,MAAMoB,CAAAA;AACxBxtB,mBAAaytB,EAAKC,iBAClBD,EAAKnnB,QAAAA;AAAAA,IACP;AAqBA,QApBArM,KAAKmyB,QAAQ,MAETnyB,KAAK4wB,WACP5wB,KAAK4wB,OAAO7oB,eAAe,WAAW/H,KAAK0zB,wBAC3C1zB,KAAK4wB,OAAO7oB,eAAe,QAAQ/H,KAAK2zB,kBAAAA,GACxC3zB,KAAK4wB,OAAO7oB,eAAe,SAAS/H,KAAK4zB,mBAAAA,GACzC5zB,KAAK4wB,OAAO7oB,eAAe,SAAS/H,KAAK6zB,mBAAAA,GACzC7zB,KAAK4wB,SAAS,OAGhB5wB,KAAK0zB,wBAAwB,MAC7B1zB,KAAK6zB,sBAAsB,MAC3B7zB,KAAK2zB,qBAAqB,MAC1B3zB,KAAK4zB,sBAAsB,MAEvB3B,EAAWjyB,KAAK2xB,WAAAA,MAClBM,EAAWjyB,KAAK2xB,WAAAA,EAAamC,aAAa,IAIxC7B,EAAWjyB,KAAK2xB,WAAAA,EAAamC,YAAY,EAAG,QAAO/e,EAAAA;AAEvD,QAKIvO,GALAoqB,IAASqB,EAAWjyB,KAAK2xB,WAAAA;AAQ7B,eAPOM,EAAWjyB,KAAK2xB,WAAAA,GACvBf,EAAOjpB,GAAG,SAASb,EAAAA,GACnB8pB,EAAO/oB,KAAK,SAASkN,CAAAA,GAAAA,CAKhB/U,KAAKuyB,kBAAmB,QAAOwB;AAUpC,aAASA,IAAAA;AACHvtB,MAAAA,MACFT,aAAaS,IACbA,IAAU,OAEZoqB,EAAO7oB,eAAe,QAAQgsB,CAAAA,GAC9BnD,EAAOvkB,QAAAA,GACPukB,IAAS;AAAA,IACX;AAdApqB,IAAAA,IAAUX,WAAWkuB,GAAgBpnB,GAAOqnB,eAAAA,GAI5CpD,EAAO/oB,KAAK,QAAQksB;EAWtB;AAAA,EAEA,cAAAvB;AAmBE,QAlBAxyB,KAAKmgB,YAAAA,IAEAngB,KAAKmyB,UAAOnyB,KAAKmyB,QAAQ,CAAA,IAE9BnyB,KAAK0zB,wBAAwB,MAAA;AAC3B1zB,WAAKi0B,iBAAAA;AAAAA,IAAAA,GAEPj0B,KAAK6zB,sBAAsBxiB,CAAAA,MAAAA;AACzBrR,WAAKk0B,eAAe7iB,CAAAA;AAAAA,IAAAA,GAEtBrR,KAAK2zB,qBAAqBxwB,CAAAA,MAAAA;AACxBnD,WAAKm0B,cAAchxB;OAErBnD,KAAK4zB,sBAAsB,MAAA;AACzB5zB,WAAKo0B;OAGPp0B,KAAK4wB,SAASqB,EAAWjyB,KAAK2xB,cAC1B3xB,KAAK4wB,OACPqB,CAAAA,EAAWjyB,KAAK2xB,aAAamC,aAAa,GACtC9zB,KAAK4wB,OAAOC,aACd7wB,KAAK0zB,sBAAAA;AAAAA,SAEF;AACL,YAAMW,IAAY,IAAIjE,IAAIpwB,KAAK2xB,WAAAA;AAC/B,UAAI2C;AACAt0B,WAAK0xB,OAAO6C,eACdD,IAAQD,EAAU9D,aAAa,SAASvwB,KAAK0xB,OAAO6C,WAAWC,aAAax0B,KAAK0xB,OAAO6C,WAAWE,WAAAA,CAC9FH,KAASt0B,KAAK0xB,OAAO6C,WAAWG,eACnCJ,IAAQt0B,KAAK0xB,OAAO6C,WAAWG,cAGnC10B,KAAK4wB,SAASqB,EAAWjyB,KAAK2xB,WAAAA,IAAe,IAAIhB,GAAO,EAAEhvB,KAAK3B,KAAK2xB,aAAa2C,OAAAA,EAAAA,CAAAA,GACjFt0B,KAAK4wB,OAAOkD,YAAY,GACxB9zB,KAAK4wB,OAAO/oB,KAAK,WAAW7H,KAAK0zB,qBAAAA;AAAAA,IACnC;AAEA1zB,SAAK4wB,OAAOjpB,GAAG,QAAQ3H,KAAK2zB,kBAAAA,GAC5B3zB,KAAK4wB,OAAO/oB,KAAK,SAAS7H,KAAK4zB,mBAAAA,GAC/B5zB,KAAK4wB,OAAO/oB,KAAK,SAAS7H,KAAK6zB,mBAAAA;AAAAA,EACjC;AAAA,EAEA,mBAAAI;AACMj0B,SAAKmgB,aAELngB,KAAKoyB,iBACPpyB,KAAKoyB,eAAAA,IACLpyB,KAAKqyB,UAAU,GACfryB,KAAK+xB,SAAS/xB,KAAK0xB,OAAOM,qBAAAA,CAAAA;AAAAA,EAE9B;AAAA,EAEA,cAAe7uB;AACb,QAAA,CAAInD,KAAKmgB,WAAT;AAEAngB,WAAKuyB,oBAAAA;AAEL,UAAA;AACEpvB,QAAAA,IAAO8G,KAAKkgB,MAAM/F,GAASjhB,CAAAA,CAAAA;AAAAA,MAC7B,QAASkO;AAEP,eAAA,KADArR,KAAK0xB,OAAOzpB,KAAK,WAAW,IAAIrI,MAAM,0BAAA,CAAA;AAAA,MAExC;AAEoB,MAAhBuD,EAAKuvB,WAAW,aAClB1yB,KAAK20B,oBAAoBxxB,CAAAA,IAChBA,EAAKuvB,WAAW,WACzB1yB,KAAK40B,kBAAkBzxB,CAAAA,IAEvBnD,KAAKk0B,eAAe,IAAIt0B,MAAM,kCAAkCuD,EAAKuvB,MAAAA,EAAAA,CAAAA;AAAAA,IAhBnD;AAAA,EAkBtB;AAAA,EAEA,oBAAqBvvB,GAAAA;AACnB,QAAIA,EAAKwvB,cAAc3yB,KAAK0xB,OAAOkB,gBAKjC,QAAA,KAJAlmB,EACE,0EACA1M,KAAK2xB,aAAajN,GAAQvhB,EAAKwvB,SAAAA,GAAY3yB,KAAK0xB,OAAO4B,QAAAA;AAK3D,QAAInwB,EAAK0vB,WAAW1vB,EAAK0vB,YAAY7yB,KAAK0xB,OAAOoB,cAE/C;AAGFpmB,IAAAA,EACE,8BACAzC,KAAKC,UAAU/G,IAAOnD,KAAK2xB,aAAa3xB,KAAK0xB,OAAO4B;AAGtD,UAAMuB,IAAU1xB,EAAK,gBAAA;AACrB,QAAI0xB,EAAS,QAAO70B,KAAK0xB,OAAOzpB,KAAK,WAAW,IAAIrI,MAAMi1B,CAAAA,CAAAA;AAE1D,UAAMtiB,IAAUpP,EAAK,iBAAA;AACjBoP,SAASvS,KAAK0xB,OAAOzpB,KAAK,WAAW,IAAIrI,MAAM2S,CAAAA,CAAAA;AAEnD,UAAMqf,IAAWzuB,EAAKyuB,YAAYzuB,EAAK,cAAA;AACnCyuB,SAAU5xB,KAAKqsB,YAAuB,MAAXuF,CAAAA;AAE/B,UAAMkD,IAAY3xB,EAAK,YAAA;AAMvB,QALI2xB,MAEF90B,KAAK+yB,aAAa+B,IAGhB3xB,EAAK4xB,YAAY,MAAM;AACzB,YAAM3yB,IAAW4C,OAAOoe,OAAO,CAAA,GAAIjgB,GAAM,EACvC4uB,UAAU/xB,KAAK2xB,aACf2B,UAAU5O,GAAQvhB,EAAKwvB;AAEzB3yB,WAAK0xB,OAAOzpB,KAAK,UAAU7F;IAC7B;AAEA,QAAIoxB;AAqBJ,QApBIrwB,EAAKspB,SAAStpB,EAAK0vB,YACrBnmB,EAAM,sCACN8mB,IAAOxzB,KAAKg1B,YAAAA,GACZxB,EAAK5F,KAAKlJ,GAAQvhB,EAAK0vB,OAAAA,GACvBW,EAAK3rB,KAAK,UAAUilB,CAAAA,MAAAA;AAClB,YAAM2F,IAAS,EACbC,QAAQ,YACRC,WAAW3yB,KAAK0xB,OAAOkB,iBACvBC,SAAS7yB,KAAK0xB,OAAOoB,eACrBmC,YAAY9xB,EAAK0vB,SACjB/F,QAAAA,GACAoI,UAAU/xB,EAAK+xB,SAAAA;AAEbl1B,WAAK+yB,eAAYN,EAAOO,YAAYhzB,KAAK+yB,aAC7C/yB,KAAKizB,MAAMR,CAAAA;AAAAA,IAAAA,CAAAA,GAEbzyB,KAAK0xB,OAAOzpB,KAAK,QAAQurB,CAAAA,GACzBA,EAAK5xB,OAAOuB,EAAKspB,SAGftpB,EAAK2pB,UAAU3pB,EAAK0vB,SAAS;AAC/B,YAAMsC,IAAUzQ,GAAQvhB,EAAK+xB;AAC7B1B,MAAAA,IAAOxzB,KAAKmyB,MAAMgD,CAAAA,GACd3B,KACFA,EAAK5F,KAAKlJ,GAAQvhB,EAAK0vB,UACvB7yB,KAAK0xB,OAAOzpB,KAAK,QAAQurB,IACzBA,EAAK5xB,OAAOuB,EAAK2pB,MAAAA,GAEjB/mB,aAAaytB,EAAKC,cAAAA,GAClBD,EAAKC,iBAAiB,aACfzzB,KAAKmyB,MAAMgD,CAAAA,KAElBzoB,EAAM,0BAA0BzC,KAAKC,UAAU/G,EAAK2pB,MAAAA,CAAAA,EAAAA;AAAAA,IAExD;AAAA,EACF;AAAA,EAEA,kBAAmB3pB,GAAAA;AACjBA,IAAAA,IAAOA,EAAKiyB,SAAS,CAAA;AAErB,UAAMxlB,IAAO5K,OAAO4K,KAAKzM,CAAAA;AACL,IAAhByM,EAAKvJ,WAAW,IAKpBuJ,EAAKC,QAAQyjB,CAAAA,MAAAA;AAGX,YAAMlxB,IAAW4C,OAAOoe,OAAOjgB,EAAKmwB,CAAAA,GAAW,EAC7CvB,UAAU/xB,KAAK2xB,aACf2B,UAAU5O,GAAQ4O,CAAAA,EAAAA,CAAAA;AAEpBtzB,WAAK0xB,OAAOzpB,KAAK,UAAU7F,CAAAA;AAAAA,IAAAA,CAAAA,IAX3BpC,KAAK0xB,OAAOzpB,KAAK,WAAW,IAAIrI,MAAM,yBAAA,CAAA;AAAA,EAa1C;AAAA,EAEA,iBAAAw0B;AACMp0B,SAAKmgB,cACTngB,KAAKqM,QAAAA,GACLrM,KAAKq1B;EACP;AAAA,EAEA,eAAgBhkB,GAAAA;AACVrR,SAAKmgB,cACTngB,KAAKqM,QAAAA,GAELrM,KAAK0xB,OAAOzpB,KAAK,WAAWoJ,CAAAA,GAC5BrR,KAAKq1B;EACP;AAAA,EAEA,uBAAAA;AACE,UAAMnsB,IAAKI,KAAKgsB,MAvUO,MAuUDhsB,KAAKisB,YAAiCjsB,KAAKuY,IAzU3C,MAyU+CvY,KAAKksB,IAAI,GAAGx1B,KAAKqyB,OAAAA,GAxUhE,IAAA;AA0UtBryB,SAAKoyB,eAAAA,IACLrsB,aAAa/F,KAAKsyB,iBAClBtyB,KAAKsyB,iBAAiBzsB,WAAW,MAAA;AAC/B7F,WAAKqyB,WACLryB,KAAKwyB,YAAAA;AAAAA,IAAAA,GACJtpB,CAAAA,GACClJ,KAAKsyB,eAAejD,SAAOrvB,KAAKsyB,eAAejD,SAEnD3iB,EAAM,gCAAgCxD,CAAAA;AAAAA,EACxC;AAAA,EAEA,MAAOupB,GAAAA;AACL,QAAIzyB,KAAKmgB,UAAW;AACpBngB,SAAKuyB,oBAAAA;AACL,UAAMzyB,IAAUmK,KAAKC,UAAUuoB,CAAAA;AAC/B/lB,IAAAA,EAAM,WAAW5M,CAAAA,GACjBE,KAAK4wB,OAAO5F,KAAKlrB,CAAAA;AAAAA,EACnB;AAAA,EAEA,gBAAiBozB,GAASne,GAAAA;AACxB,UAAM7H,IAAOlN,MACPozB,IAAS,CAAA;AACf1mB,IAAAA,EAAM,wBAAwBwmB,CAAAA;AAE9B,aAAS/rB,IAAI,GAAGA,IAAI+rB,KAAW/rB,EAC7BsuB,CAAAA,EAAAA;AAIF,aAASA,IAAAA;AACP,YAAMN,IAAUrR,GAAQuB,GAAY,EAAA,CAAA;AACpC3Y,MAAAA,EAAM,sCAAA;AACN,YAAM8mB,IAAOtmB,EAAKilB,MAAMgD,CAAAA,IAAWjoB,EAAK8nB,YAAY,EAAE3O,cAAW,CAAA;AACjEmN,MAAAA,EAAK3rB,KAAK,UAAU4kB,CAAAA;AAClB2G,UAAOhsB,KAAK,EACVqlB,OAAAA,GACAyI,UAAUtQ,GAAQuQ,CAAAA,EAAAA,CAAAA,GAEpBO,EAAAA;AAAAA,MAAAA,CAAAA,GAEFlC,EAAKC,iBAAiB5tB,WAAW,MAAA;AAC/B6G,QAAAA,EAAM,kCAAA,GACN8mB,EAAKC,iBAAiB,MAAA,OACfvmB,EAAKilB,MAAMgD,IAClB3B,EAAKnnB,QAAAA;AAAAA,MAAAA,GApXS,GAAA,GAsXZmnB,EAAKC,eAAepE,SAAOmE,EAAKC,eAAepE,MAAAA;AAAAA,IACrD;AAEA,aAASqG,IAAAA;AACHtC,QAAO/sB,WAAW6sB,MACpBxmB,EAAM,uBAAuBwmB,CAAAA,GAC7Bne,EAAGqe;IAEP;AA3BAsC,IAAAA,EAAAA;AAAAA,EA4BF;AAAA,EAEA,YAAa7V,GAAAA;AACX,UAAM3S,IAAOlN;AAEb6f,IAAAA,IAAO7a,OAAOoe,OAAO,EACnByD,SAAAA,IACAJ,QAAQvZ,EAAKwkB,OAAOiE,YACpBC,MAAM1oB,EAAKwkB,OAAOmE,MAAAA,GACjBhW,CAAAA;AAEH,UAAM2T,IAAO,IAAI3N,GAAKhG,CAAAA;AAKtB,WAHA2T,EAAK3rB,KAAK,SAASiuB,CAAAA,GACnBtC,EAAK3rB,KAAK,WAaV,SAASkuB,IAAAA;AACPvC,QAAKzrB,eAAe,SAAS+tB,CAAAA,GAC7BtC,EAAKzrB,eAAe,WAAWguB,CAAAA;AAAAA,IACjC,CAAA,GAdOvC;AAIP,aAASsC,EAASzkB,GAAAA;AAChBnE,MAAAA,EAAKwkB,OAAOzpB,KAAK,WAAW,IAAIrI,MAAM,qBAAqByR,EAAIvR,OAAAA,EAAAA,CAAAA,GAC/D0zB,EAAKnnB,QAAAA;AAAAA,IACP;AAAA,EAQF;;AAOF,SAASvF,KAAAA;AAAS;AAJlBorB,GAAiBjtB,UAAU6sB,4BAA4B,KAEvDI,GAAiB8D,cAAc/D;ACxa/B,MAAMvlB,IAAQ+Y,EAAM,2BAAA;AAkBpB,MAAMwQ,WAAenlB,GAAAA;AAAAA,EACnB,YAAa+O,IAAO;AAGlB,QAFA9f,MAAAA,GAAAA,CAEK8f,EAAK0T,OAAQ,OAAM,IAAI3zB,MAAM;AAClC,QAAA,CAAKigB,EAAKyT,SAAU,OAAM,IAAI1zB,MAAM,+BAAA;AACpC,QAAA,CAAKigB,EAAKkS,SAAU,OAAM,IAAInyB,MAAM,+BAAA;AACpC,SAAK4F,GAAQF,WAAAA,CAAYua,EAAKmK,KAAM,OAAM,IAAIpqB,MAAM,2BAAA;AAEpDI,SAAKuzB,SAAgC,OAAhB1T,EAAK0T,UAAW,WACjC1T,EAAK0T,SACLzP,GAAQjE,EAAK0T,MAAAA,GACjBvzB,KAAKk2B,gBAAgBlS,GAAQhkB,KAAKuzB,MAAAA,GAClCvzB,KAAK8yB,gBAAgBlO,GAAQ5kB,KAAKuzB,MAAAA,GAElCvzB,KAAKszB,WAAoC,OAAlBzT,EAAKyT,YAAa,WACrCzT,EAAKyT,SAASzpB,YAAAA,IACdia,GAAQjE,EAAKyT,WACjBtzB,KAAKm2B,kBAAkBnS,GAAQhkB,KAAKszB,WACpCtzB,KAAK4yB,kBAAkBhO,GAAQ5kB,KAAKszB,WAEpC5mB,EAAM,iBAAiB1M,KAAKszB,QAAAA,GAE5BtzB,KAAKmgB,YAAAA,IAELngB,KAAKo2B,QAAQvW,EAAKmK,MAClBhqB,KAAKq2B,mBAAmBxW,EAAKyW,iBAC7Bt2B,KAAK21B,aAAa9V,EAAK0W,WACvBv2B,KAAKw2B,aAAa3W,EAAKnU,WACvB1L,KAAKu0B,aAAa1U,EAAK4W,WAIvBz2B,KAAK61B,eAAehW,EAAK+V,QAAS,aAAa/V,EAAK+V,KAAAA,IAAS/V,EAAK+V;AAElE,QAAI7D,IAAoC,OAAlBlS,EAAKkS,YAAa,WACpC,CAAClS,EAAKkS,QAAAA,IACNlS,EAAKkS,YAAY,OAAO,CAAA,IAAKlS,EAAKkS;AAGtCA,IAAAA,IAAWA,EAAS7iB,IAAIyiB,CAAAA,OAClBhC,YAAY+G,OAAO/E,CAAAA,MAAcA,IAAcvN,GAASuN,KACxDA,EAAYA,EAAYtrB,SAAS,OAAO,QAC1CsrB,IAAcA,EAAYgF,UAAU,GAAGhF,EAAYtrB,SAAS,CAAA,IAEvDsrB,EAAAA,GAGTI,IAAW9qB,MAAM7C,KAAK,IAAIwyB,IAAI7E,CAAAA,CAAAA;AAE9B,UAAM8E,IAAgB72B,KAAK61B,UAArBgB,OAAqBhB,CAAAA,CAAsB71B,KAAK61B,SAAShQ,GAAK+J,iBAE9DkH,IAAezlB,CAAAA;AACnBsE,MAAAA,GAAe,MAAA;AACb3V,aAAKiI,KAAK,WAAWoJ,CAAAA;AAAAA,MAAAA,CAAAA;AAAAA,IAAAA;AAIzBrR,SAAK+2B,YAAYhF,EACd7iB,IAAIyiB,CAAAA,MAAAA;AACH,UAAI0C;AACJ,UAAA;AACEA,QAAAA,IAAY1nB,GAAOwjB,SAASwB,CAAAA;AAAAA,MAC9B,QAAStgB;AAEP,eADAylB,EAAa,IAAIl3B,MAAM,wBAAwB+xB,CAAAA,EAAAA,CAAAA,GACxC;AAAA,MACT;AAEA,YAAM3H,IAAOqK,EAAUrK;AACvB,UAAIA,IAAO,KAAKA,IAAO,MAErB,QADA8M,EAAa,IAAIl3B,MAAM,yBAAyB+xB,CAAAA,EAAAA,CAAAA,GACzC;AAGT,YAAMpB,IAAW8D,EAAU9D;AAC3B,aAAKA,MAAa,WAAWA,MAAa,mBAC/ByG,KAAgB,aAEhBzG,MAAa,UAAgC,OAAfP,KAAe,aAC/C,IAAIA,EAAWhwB,MAAM2xB,CAAAA,IAClBpB,MAAa,SAASA,MAAa,UAAbA,CAAwBsG,KAEpDtG,MAAa,SAA2B,OAAXluB,SAAW,OACxCA,OAAO40B,SAAS1G,aAAa,YAMjCuG,EAAa,IAAIl3B,MAAM,iCAAiC+xB,CAAAA,EAAAA,CAAAA,GACjD,QAHA,IAAIO,GAAiBlyB,MAAM2xB,CAAAA,IAV3B,IAAIqF,EAAYh3B,MAAM2xB,CAAAA;AAAAA,IAAAA,CAAAA,EAgBhCriB,OAAOC,OAAAA;AAAAA,EACZ;AAAA,EASA,MAAOsQ,GAAAA;AAAAA,KACLA,IAAO7f,KAAKgyB,qBAAqBnS,CAAAA,GAC5BuJ,QAAQ,WACb1c,EAAM,mBAAmBmT,CAAAA,GACzB7f,KAAKk3B,UAAUrX,CAAAA,GAGf7f,KAAK+2B,UAAUlnB,QAAQsnB,OAAAA;AACrBA,QAAQ9K;;EAEZ;AAAA,EAUA,KAAMxM,GAAAA;AAAAA,KACJA,IAAO7f,KAAKgyB,qBAAqBnS,CAAAA,GAC5BuJ,QAAQ,WACb1c,EAAM,kBAAkBmT,CAAAA,GACxB7f,KAAKk3B,UAAUrX,CAAAA;AAAAA,EACjB;AAAA,EAUA,SAAUA;AACHA,IAAAA,MAAMA,IAAO,CAAA,KAClBA,IAAO7f,KAAKgyB,qBAAqBnS,CAAAA,GAC5BuJ,QAAQ,aACb1c,EAAM,sBAAsBmT,CAAAA,GAC5B7f,KAAKk3B,UAAUrX,CAAAA;AAAAA,EACjB;AAAA,EAUA,OAAQA;KACNA,IAAO7f,KAAKgyB,qBAAqBnS,CAAAA,GACxBuJ,gBAAcvJ,EAAKuJ,OAC5B1c,EAAM,oBAAoBmT,IAC1B7f,KAAKk3B,UAAUrX,CAAAA;AAAAA,EACjB;AAAA,EAEA,UAAWA,GAAAA;AACT7f,SAAK+2B,UAAUlnB,QAAQsnB,CAAAA,MAAAA;AAErBA,MAAAA,EAAQpF,SAASlS,CAAAA;AAAAA,IAAAA,CAAAA;AAAAA,EAErB;AAAA,EAMA,OAAQA,GAAAA;AACNnT,IAAAA,EAAM,kBACDmT,MAAMA,IAAO,CAAA,IAClB7f,KAAK+2B,UAAUlnB,QAAQsnB,CAAAA,MAAAA;AAErBA,MAAAA,EAAQ9D,OAAOxT,CAAAA;AAAAA,IAAAA,CAAAA;AAAAA,EAEnB;AAAA,EAEA,YAAagS;AACXnlB,IAAAA,EAAM,kBAAkBmlB,CAAAA,GACxB7xB,KAAK+2B,UAAUlnB,QAAQsnB,CAAAA,MAAAA;AACrBA,MAAAA,EAAQ9K,YAAYwF;;EAExB;AAAA,EAEA,QAAS9c,GAAAA;AACP,QAAI/U,KAAKmgB,UAAW;AACpBngB,SAAKmgB,gBACLzT,EAAM,SAAA;AAEN,UAAMsJ,IAAQhW,KAAK+2B,UAAU7nB,IAAIioB,CAAAA,MAAWpiB,CAAAA;AAC1CoiB,MAAAA,EAAQ9qB,QAAQ0I,CAAAA;AAAAA,IAAAA,CAAAA;AAGlBqiB,IAAAA,GAASphB,GAAOjB,CAAAA,GAEhB/U,KAAK+2B,YAAY,CAAA,GACjB/2B,KAAKq2B,mBAAmB;AAAA,EAC1B;AAAA,EAEA,qBAAsBxW,IAAO;AAQ3B,WAPIA,EAAKqT,WAAW,SAAMrT,EAAKqT,UAAUvmB,GAAOsjB,yBAE5CpQ,EAAKwX,YAAY,SAAMxX,EAAKwX,WAAW,IACvCxX,EAAKyX,cAAc,SAAMzX,EAAKyX,aAAa,IAE3Ct3B,KAAKq2B,qBAAkBxW,IAAO7a,OAAOoe,OAAO,IAAIvD,GAAM7f,KAAKq2B,iBAAAA,CAAAA,IAExDxW;AAAAA,EACT;;AAYFoW,GAAO5C,SAAS,CAACxT,GAAM9K;AAGrB,MAFAA,IAAKlN,GAAKkN,CAAAA,GAAAA,CAEL8K,EAAKyT,SAAU,OAAM,IAAI1zB,MAAM;AACpC,MAAA,CAAKigB,EAAKkS,SAAU,OAAM,IAAInyB,MAAM,+BAAA;AAEpC,QAAM23B,IAAavyB,OAAOoe,OAAO,CAAA,GAAIvD,GAAM,EACzCyT,UAAUrsB,MAAMmP,QAAQyJ,EAAKyT,YAAYzT,EAAKyT,SAAS,CAAA,IAAKzT,EAAKyT,UACjEC,QAAQ/O,GAAS,sBAAA,GACjBwF,MAAM,SAGF0H,IAAS,IAAIuE,GAAOsB,CAAAA;AAC1B7F,EAAAA,EAAO7pB,KAAK,SAASkN,CAAAA,GACrB2c,EAAO7pB,KAAK,WAAWkN,CAAAA;AAEvB,MAAItO,IAAMQ,MAAMmP,QAAQyJ,EAAKyT,QAAAA,IAAYzT,EAAKyT,SAASjtB,SAAS;AAChE,QAAM4P,IAAU,CAAA;AAgBhB,SAfAyb,EAAO/pB,GAAG,UAAUxE,CAAAA,MAAAA;AAGlB,QAFAsD,KAAO,GACPwP,EAAQ9S,EAAKmwB,QAAAA,IAAYnwB,GACrBsD,MAAQ,GAAG;AACbirB,MAAAA,EAAOrlB,QAAAA;AACP,YAAMuD,IAAO5K,OAAO4K,KAAKqG,CAAAA;AACL,MAAhBrG,EAAKvJ,WAAW,IAClB0O,EAAG,MAAMkB,EAAQrG,EAAK,CAAA,CAAA,CAAA,IAEtBmF,EAAG,MAAMkB,CAAAA;AAAAA,IAEb;AAAA,MAGFyb,EAAO2B,OAAO,EAAEC,UAAUzT,EAAKyT,SAAAA,CAAAA,GACxB5B;AAAAA;;;AChST,WAAS8F,EAAGC,GAAGC,GAAGjtB,GAAG3B,GAAGF,GAAGD,GAAGqM,GAAAA;AAC7B,QAAI5L,IAAIquB,KAAKC,IAAIjtB,IAAAA,CAAKitB,IAAI5uB,MAAMF,MAAM,KAAKoM;AAC3C,YAAS5L,KAAKT,IAAMS,MAAO,KAAKT,KAAO+uB;AAAAA,EACxC;AAEA,WAASC,EAAGF,GAAGC,GAAGjtB,GAAG3B,GAAGF,GAAGD,GAAGqM,GAAAA;AAC7B,QAAI5L,IAAIquB,KAAKC,IAAI5uB,IAAI2B,IAAAA,CAAK3B,MAAMF,MAAM,KAAKoM;AAC3C,YAAS5L,KAAKT,IAAMS,MAAO,KAAKT,KAAO+uB;AAAAA,EACxC;AAEA,WAASE,EAAGH,GAAGC,GAAGjtB,GAAG3B,GAAGF,GAAGD,GAAGqM;AAC7B,QAAI5L,IAAIquB,KAAKC,IAAIjtB,IAAI3B,MAAMF,MAAM,KAAKoM;AACtC,YAAS5L,KAAKT,IAAMS,MAAO,KAAKT,KAAO+uB;AAAAA,EACxC;AAEA,WAASG,EAAGJ,GAAGC,GAAGjtB,GAAG3B,GAAGF,GAAGD,GAAGqM,GAAAA;AAC7B,QAAI5L,IAAIquB,KAAKhtB,KAAKitB,IAAAA,CAAK5uB,OAAOF,MAAM,KAAKoM;AACzC,YAAS5L,KAAKT,IAAMS,MAAO,KAAKT,KAAO+uB;AAAAA,EACxC;AAGA,WAASI,EAAUC,GAAAA;AAClB,YAAQ,OAAU,MAALA,IAAWxK,SAAS,EAAA,EAAIyK,OAAAA;EACtC;AAGA,WAASC,EAAGF,GAAAA;AACX,WAAOpuB,OAAOob,aAAoB,MAAPgT,CAAAA;AAAAA,EAC5B;AAEA,WAASG,EAAYC,GAAAA;AACpB,WAAOF,EAAGE,CAAAA,IAAQF,EAAGE,MAAS,CAAA,IAAKF,EAAGE,MAAS,EAAA,IAAMF,EAAGE,MAAS;EAClE;;AAIA,MAAIC,IAAc,SAAUC,GAAAA;AAC3B,WAAOC,SAASC,mBAAmBF,CAAAA,CAAAA;AAAAA,EACpC,GAgBI9yB,IAAUizB,GAAAjzB,UAAiB,SAAa8yB,GAAAA;AAC3C,WAAOI,EAAUJ,GAAMK,MAAAA;AAAAA,EACxB,GAEIC,IAAapzB,EAAQqzB,YAAY,SAAUC,GAAAA;AAW9C,aAVIC,KAjBL,SAAsBD,GAAAA;AAIrB,eAHIE,IAAcF,EAAMxyB,QACpB2yB,KAAaD,KAAe,GAC5BD,IAAQ,IAAIG,YAAaF,IAAc,OAAQ,KAAK,CAAA,GAC/C5xB,IAAI,GAAGiC,KAAIyvB,EAAMxyB,QAAQc,IAAIiC,IAAAA,EAAKjC,EAC1C2xB,CAAAA,EAAM3xB,MAAM,CAAA,KAAM0xB,EAAM7oB,WAAW7I,CAAAA,OAAY,IAAJA,MAAU;AAGtD,aAFA2xB,EAAMC,KAAe,CAAA,KAAM,QAAsB,KAAbC,KACpCF,EAAMA,EAAMzyB,SAAS,KAAK2yB,IACnBF;AAAAA,IACR,GAQ0BD,IACrBpB,IAAI,YACJC,IAAI,YACJjtB,IAAI,YACJ3B,IAAI,WAMC3B,IAAI,GAAGuY,IAAKoZ,EAAMzyB,QAAQc,IAAIuY,GAAIvY,KAAK,IAAI;AACnD,UAAI+xB,IAAKzB,GAAG0B,KAAKzB,GAAG0B,KAAK3uB,GAAG4uB,KAAKvwB;AACjC2uB,MAAAA,IAAID,EAAGC,GAAGC,GAAGjtB,GAAG3B,GAAGgwB,EAAM3xB,IAAE,CAAA,GAPlB,GAO2B,UAAA,GACpC2B,IAAI0uB,EAAG1uB,GAAG2uB,GAAGC,GAAGjtB,GAAGquB,EAAM3xB,IAAE,CAAA,GART,IAQkB,UAAA,GACpCsD,IAAI+sB,EAAG/sB,GAAG3B,GAAG2uB,GAAGC,GAAGoB,EAAM3xB,IAAE,CAAA,GATC,IASQ,YACpCuwB,IAAIF,EAAGE,GAAGjtB,GAAG3B,GAAG2uB,GAAGqB,EAAM3xB,IAAE,CAAA,GAVW,IAUF,UAAA,GACpCswB,IAAID,EAAGC,GAAGC,GAAGjtB,GAAG3B,GAAGgwB,EAAM3xB,IAAE,IAXlB,GAW2B,UAAA,GACpC2B,IAAI0uB,EAAG1uB,GAAG2uB,GAAGC,GAAGjtB,GAAGquB,EAAM3xB,IAAE,CAAA,GAZT,IAYkB,UAAA,GACpCsD,IAAI+sB,EAAG/sB,GAAG3B,GAAG2uB,GAAGC,GAAGoB,EAAM3xB,IAAE,CAAA,GAbC,IAaQ,UAAA,GACpCuwB,IAAIF,EAAGE,GAAGjtB,GAAG3B,GAAG2uB,GAAGqB,EAAM3xB,IAAE,CAAA,GAdW,IAcF,aACpCswB,IAAID,EAAGC,GAAGC,GAAGjtB,GAAG3B,GAAGgwB,EAAM3xB,IAAE,CAAA,GAflB,GAe2B,UAAA,GACpC2B,IAAI0uB,EAAG1uB,GAAG2uB,GAAGC,GAAGjtB,GAAGquB,EAAM3xB,IAAE,IAhBT,IAgBkB,UAAA,GACpCsD,IAAI+sB,EAAG/sB,GAAG3B,GAAG2uB,GAAGC,GAAGoB,EAAM3xB,IAAE,EAAA,GAjBC,IAiBQ,UAAA,GACpCuwB,IAAIF,EAAGE,GAAGjtB,GAAG3B,GAAG2uB,GAAGqB,EAAM3xB,IAAE,EAAA,GAlBW,IAkBF,UAAA,GACpCswB,IAAID,EAAGC,GAAGC,GAAGjtB,GAAG3B,GAAGgwB,EAAM3xB,IAAE,EAAA,GAnBlB,GAmB2B,aACpC2B,IAAI0uB,EAAG1uB,GAAG2uB,GAAGC,GAAGjtB,GAAGquB,EAAM3xB,IAAE,EAAA,GApBT,IAoBkB,UAAA,GACpCsD,IAAI+sB,EAAG/sB,GAAG3B,GAAG2uB,GAAGC,GAAGoB,EAAM3xB,IAAE,KArBC,IAqBQ,UAAA,GAEpCswB,IAAIE,EAAGF,GADPC,IAAIF,EAAGE,GAAGjtB,GAAG3B,GAAG2uB,GAAGqB,EAAM3xB,IAAE,EAAA,GAtBW,IAsBF,UAAA,GACvBsD,GAAG3B,GAAGgwB,EAAM3xB,IAAE,CAAA,GAtBlB,GAsB2B,UAAA,GACpC2B,IAAI6uB,EAAG7uB,GAAG2uB,GAAGC,GAAGjtB,GAAGquB,EAAM3xB,IAAE,CAAA,GAvBT,GAuBkB,UAAA,GACpCsD,IAAIktB,EAAGltB,GAAG3B,GAAG2uB,GAAGC,GAAGoB,EAAM3xB,IAAE,EAAA,GAxBC,IAwBQ,YACpCuwB,IAAIC,EAAGD,GAAGjtB,GAAG3B,GAAG2uB,GAAGqB,EAAM3xB,IAAE,CAAA,GAzBW,IAyBF,UAAA,GACpCswB,IAAIE,EAAGF,GAAGC,GAAGjtB,GAAG3B,GAAGgwB,EAAM3xB,IAAE,IA1BlB,GA0B2B,UAAA,GACpC2B,IAAI6uB,EAAG7uB,GAAG2uB,GAAGC,GAAGjtB,GAAGquB,EAAM3xB,IAAE,EAAA,GA3BT,GA2BkB,QAAA,GACpCsD,IAAIktB,EAAGltB,GAAG3B,GAAG2uB,GAAGC,GAAGoB,EAAM3xB,IAAE,EAAA,GA5BC,IA4BQ,UAAA,GACpCuwB,IAAIC,EAAGD,GAAGjtB,GAAG3B,GAAG2uB,GAAGqB,EAAM3xB,IAAE,CAAA,GA7BW,IA6BF,aACpCswB,IAAIE,EAAGF,GAAGC,GAAGjtB,GAAG3B,GAAGgwB,EAAM3xB,IAAE,CAAA,GA9BlB,GA8B2B,SAAA,GACpC2B,IAAI6uB,EAAG7uB,GAAG2uB,GAAGC,GAAGjtB,GAAGquB,EAAM3xB,IAAE,KA/BT,GA+BkB,UAAA,GACpCsD,IAAIktB,EAAGltB,GAAG3B,GAAG2uB,GAAGC,GAAGoB,EAAM3xB,IAAE,CAAA,GAhCC,IAgCQ,UAAA,GACpCuwB,IAAIC,EAAGD,GAAGjtB,GAAG3B,GAAG2uB,GAAGqB,EAAM3xB,IAAE,CAAA,GAjCW,IAiCF,UAAA,GACpCswB,IAAIE,EAAGF,GAAGC,GAAGjtB,GAAG3B,GAAGgwB,EAAM3xB,IAAE,EAAA,GAlClB,GAkC2B,aACpC2B,IAAI6uB,EAAG7uB,GAAG2uB,GAAGC,GAAGjtB,GAAGquB,EAAM3xB,IAAE,CAAA,GAnCT,GAmCkB,UAAA,GACpCsD,IAAIktB,EAAGltB,GAAG3B,GAAG2uB,GAAGC,GAAGoB,EAAM3xB,IAAE,IApCC,IAoCQ,UAAA,GAEpCswB,IAAIG,EAAGH,GADPC,IAAIC,EAAGD,GAAGjtB,GAAG3B,GAAG2uB,GAAGqB,EAAM3xB,IAAE,EAAA,GArCW,IAqCF,UAAA,GACvBsD,GAAG3B,GAAGgwB,EAAM3xB,IAAE,CAAA,GArClB,GAqC2B,UAAA,GACpC2B,IAAI8uB,EAAG9uB,GAAG2uB,GAAGC,GAAGjtB,GAAGquB,EAAM3xB,IAAE,CAAA,GAtCT,IAsCkB,UAAA,GACpCsD,IAAImtB,EAAGntB,GAAG3B,GAAG2uB,GAAGC,GAAGoB,EAAM3xB,IAAE,EAAA,GAvCC,IAuCQ,aACpCuwB,IAAIE,EAAGF,GAAGjtB,GAAG3B,GAAG2uB,GAAGqB,EAAM3xB,IAAE,EAAA,GAxCW,IAwCF,UAAA,GACpCswB,IAAIG,EAAGH,GAAGC,GAAGjtB,GAAG3B,GAAGgwB,EAAM3xB,IAAE,IAzClB,GAyC2B,UAAA,GACpC2B,IAAI8uB,EAAG9uB,GAAG2uB,GAAGC,GAAGjtB,GAAGquB,EAAM3xB,IAAE,CAAA,GA1CT,IA0CkB,UAAA,GACpCsD,IAAImtB,EAAGntB,GAAG3B,GAAG2uB,GAAGC,GAAGoB,EAAM3xB,IAAE,CAAA,GA3CC,IA2CQ,UAAA,GACpCuwB,IAAIE,EAAGF,GAAGjtB,GAAG3B,GAAG2uB,GAAGqB,EAAM3xB,IAAE,EAAA,GA5CW,IA4CF,aACpCswB,IAAIG,EAAGH,GAAGC,GAAGjtB,GAAG3B,GAAGgwB,EAAM3xB,IAAE,EAAA,GA7ClB,GA6C2B,SAAA,GACpC2B,IAAI8uB,EAAG9uB,GAAG2uB,GAAGC,GAAGjtB,GAAGquB,EAAM3xB,IAAE,IA9CT,IA8CkB,UAAA,GACpCsD,IAAImtB,EAAGntB,GAAG3B,GAAG2uB,GAAGC,GAAGoB,EAAM3xB,IAAE,CAAA,GA/CC,IA+CQ,UAAA,GACpCuwB,IAAIE,EAAGF,GAAGjtB,GAAG3B,GAAG2uB,GAAGqB,EAAM3xB,IAAE,CAAA,GAhDW,IAgDF,QAAA,GACpCswB,IAAIG,EAAGH,GAAGC,GAAGjtB,GAAG3B,GAAGgwB,EAAM3xB,IAAE,CAAA,GAjDlB,GAiD2B,UAAA,GACpC2B,IAAI8uB,EAAG9uB,GAAG2uB,GAAGC,GAAGjtB,GAAGquB,EAAM3xB,IAAE,KAlDT,IAkDkB,UAAA,GACpCsD,IAAImtB,EAAGntB,GAAG3B,GAAG2uB,GAAGC,GAAGoB,EAAM3xB,IAAE,EAAA,GAnDC,IAmDQ,SAAA,GAEpCswB,IAAII,EAAGJ,GADPC,IAAIE,EAAGF,GAAGjtB,GAAG3B,GAAG2uB,GAAGqB,EAAM3xB,IAAE,IApDW,IAoDF,UAAA,GACvBsD,GAAG3B,GAAGgwB,EAAM3xB,IAAE,CAAA,GApDlB,GAoD2B,UAAA,GACpC2B,IAAI+uB,EAAG/uB,GAAG2uB,GAAGC,GAAGjtB,GAAGquB,EAAM3xB,IAAE,CAAA,GArDT,IAqDkB,aACpCsD,IAAIotB,EAAGptB,GAAG3B,GAAG2uB,GAAGC,GAAGoB,EAAM3xB,IAAE,EAAA,GAtDC,IAsDQ,UAAA,GACpCuwB,IAAIG,EAAGH,GAAGjtB,GAAG3B,GAAG2uB,GAAGqB,EAAM3xB,IAAE,IAvDW,IAuDF,UAAA,GACpCswB,IAAII,EAAGJ,GAAGC,GAAGjtB,GAAG3B,GAAGgwB,EAAM3xB,IAAE,EAAA,GAxDlB,GAwD2B,UAAA,GACpC2B,IAAI+uB,EAAG/uB,GAAG2uB,GAAGC,GAAGjtB,GAAGquB,EAAM3xB,IAAE,CAAA,GAzDT,IAyDkB,UAAA,GACpCsD,IAAIotB,EAAGptB,GAAG3B,GAAG2uB,GAAGC,GAAGoB,EAAM3xB,IAAE,EAAA,GA1DC,IA0DQ,aACpCuwB,IAAIG,EAAGH,GAAGjtB,GAAG3B,GAAG2uB,GAAGqB,EAAM3xB,IAAE,CAAA,GA3DW,IA2DF,UAAA,GACpCswB,IAAII,EAAGJ,GAAGC,GAAGjtB,GAAG3B,GAAGgwB,EAAM3xB,IAAE,IA5DlB,GA4D2B,UAAA,GACpC2B,IAAI+uB,EAAG/uB,GAAG2uB,GAAGC,GAAGjtB,GAAGquB,EAAM3xB,IAAE,EAAA,GA7DT,IA6DkB,UAAA,GACpCsD,IAAIotB,EAAGptB,GAAG3B,GAAG2uB,GAAGC,GAAGoB,EAAM3xB,IAAE,CAAA,GA9DC,IA8DQ,UAAA,GACpCuwB,IAAIG,EAAGH,GAAGjtB,GAAG3B,GAAG2uB,GAAGqB,EAAM3xB,IAAE,EAAA,GA/DW,IA+DF,aACpCswB,IAAII,EAAGJ,GAAGC,GAAGjtB,GAAG3B,GAAGgwB,EAAM3xB,IAAE,CAAA,GAhElB,GAgE2B,UAAA,GACpC2B,IAAI+uB,EAAG/uB,GAAG2uB,GAAGC,GAAGjtB,GAAGquB,EAAM3xB,IAAE,KAjET,IAiEkB,UAAA,GACpCsD,IAAIotB,EAAGptB,GAAG3B,GAAG2uB,GAAGC,GAAGoB,EAAM3xB,IAAE,CAAA,GAlEC,IAkEQ,SAAA,GACpCuwB,IAAIG,EAAGH,GAAGjtB,GAAG3B,GAAG2uB,GAAGqB,EAAM3xB,IAAE,CAAA,GAnEW,IAmEF,UAAA,GACpCswB,IAAKA,IAAIyB,MAAQ,GACjBxB,IAAKA,IAAIyB,OAAQ,GACjB1uB,IAAKA,IAAI2uB,OAAQ,GACjBtwB,IAAKA,IAAIuwB,OAAQ;AAAA,IACnB;AAEC,QAAIC,IAAa,IAAI3vB,OAAOuuB,EAAYT,CAAAA,IAAKS,EAAYR,CAAAA,IAAKQ,EAAYztB,CAAAA,IAAKytB,EAAYpvB,CAAAA,CAAAA;AAO3F,WANAwwB,EAAWZ,QAAQ,WAAA;AAElB,eADI7T,IAAM,IACD1d,IAAI,GAAGiC,KAAIkwB,EAAWjzB,QAAQc,IAAIiC,IAAAA,EAAKjC,EAC/C0d,CAAAA,KAAOiT,EAAUwB,EAAWtpB,WAAW7I,CAAAA,CAAAA;AACxC,aAAO0d;AAAAA,IACT,GACQyU;AAAAA,EACR,GAGIb,IAAYlzB,EAAQg0B,WAAW,SAAUlB,GAAAA;AAC5C,WAAOM,EAAWP,EAAYC,CAAAA,CAAAA;AAAAA,EAC/B,GAIImB,IAAM;AAEV,WAASC,EAAKC,GAAGtwB;AAChB,aAAST,IAAI,IAAA,EAAMS,KAAK,GAAGswB,OAAO,EACjC/wB,CAAAA,KAAK6wB,EAAIG,OAAW,KAAJD,CAAAA;AACjB,WAAO/wB;AAAAA,EACR;AAGA,MACIixB,IAAU,CAAE,GAAE,GAAE,IAAI,GAAE,GAAE,IAAI,GAAE,GAAE,IAAI,GAAE,GAAE,IAAI,GAAE,IAAG,GAAG,KAGpDC,IAAWt0B,EAAQu0B,OAAO,SAAU1wB;AACvC,QAAIT,IAAI;AACHS,IAAAA,MACJA,IAAI;AACL;AACCT,MAAAA,KAAK6wB,EAAIG,OAAQ,KAAGrwB,KAAKisB,OAAAA,MAAa,CAAA;AAAA,WAAA,EAC5BnsB;AACX,WAAOT;AAAAA,EACR;SAGApD,EAAQw0B,QAAQ,SAAUjqB,GAAKkqB,GAAAA;AAE9B,QAAIlqB,EAAIzJ,SAjBY,GAkBnB,OAAMzG,MAAM,cAAA;AAERo6B,IAAAA,MACJA,IAAU,QAAMH,MAEjB/pB,IAAMsoB,EAAYtoB,CAAAA;AAMlB,aAJIgqB,IAAO1B,EAAY4B,EAAQlvB,QAAQ,2BAA2B,IAAA,CAAA,GAC9DmvB,IAAKtB,EAAW7oB,IAAMgqB,IAAOhqB,CAAAA,GAC7BnH,IAAImH,IAAM,QAAQgqB,GAEbI,IAAKpqB,EAAIzJ,QAAQ6zB,IAAK,IAAIA,KAAM,GACxCvxB,CAAAA,KAAKsxB;AAIN,SAFAtxB,KAAKsxB,EAAGxqB,MAAM,GAAGyqB,CAAAA,GAERA,IAAKpqB,EAAIzJ,QAAQ6zB,GAAIA,MAAO,EACpCvxB,CAAAA,KAAU,IAALuxB,IAAS,OAAOpqB,EAAI6pB,OAAO,CAAA;AAEjCM,IAAAA,IAAKtB,EAAWhwB,CAAAA;AAEhB,aAASxB,IAAI,GAAGA,IAAI,KAAA,EAAQA,EAC3B8yB,CAAAA,IAAKtB,GAAgB,IAAJxxB,IAAQ2I,IAAMmqB,MAAO9yB,IAAI,IAAI2yB,IAAO,OAAO3yB,IAAI,IAAI2I,IAAM,OAAW,IAAJ3I,IAAQ8yB,IAAKnqB,EAAAA;AAE/F,QAAIjH,IAAI,QAAMixB,IAAK;AAEnB,SAAS3yB,IAAI,GAAGA,IAAI,IAAIA,KAAK,EAC5B0B,CAAAA,KAAK4wB,EACJQ,EAAGjqB,WAAW4pB,EAAQzyB,IAAE,OAAO,KAC/B8yB,EAAGjqB,WAAW4pB,EAAQzyB,IAAE,CAAA,CAAA,KAAO,IAC/B8yB,EAAGjqB,WAAW4pB,EAAQzyB,IAAE,CAAA,CAAA,GAAK,CAAA;AAE/B,WAAO0B,IAAI4wB,EAAKQ,EAAGjqB,WAAW4pB,EAAQ,MAAM,CAAA;AAAA,EAC7C;;mBCvNaO,KAAgC,OA0B7C,SAAuBC,GAAAA;AACrB,QAAMC,IAAkBD,EAAc/qB,MAAM,GAAA;AAE5C,SAAO,GAAGgrB,EAAgB,CAAA,EAAGC,SAAS,GAAG,GAAA,CAAA,GAAOD,EAAgB,CAAA,EAAGC,SAAS,GAAG,GAAA,CAAA;AACjF,GCjC+B,OAAA,CAAA,KDKzBC,KACJ;AEHK,SAASC,GAAgB/hB,GAAAA;AAC9B,SAAO,GAAGA,EAAO5Y,IAAAA,IAAQ4Y,EAAO7N;AAClC;AAEO,SAAS6vB,GAAiB75B,GAAAA;AAC/B,UAAM85B,YAAEA,EAAAA,IAAe95B;AACvB,SAAO,IAAI45B,GAAgB55B,EAAQ6X,MAAAA,CAAAA,MAAaiiB,CAAAA;AAClD;ACSO,SAASC,GAAWC,GAAsB55B,GAAAA;AAC/CA,QAAe45B,EAAOC,OAAO,CAACC,GAAKn4B,MAAUm4B,IAAMn4B,EAAMM,YAAY,CAAA;AAErE,QAAMoU,IAAS,IAAIqB,WAAW1X,CAAAA;AAC9B,MAAI+5B,IAAS;AACb,aAAWp4B,KAASi4B,EAClBvjB,CAAAA,EAAOpJ,IAAItL,GAAOo4B,IAClBA,KAAUp4B,EAAMM;AAGlB,SAAOoU;AACT;AAUO,SAAS2jB,GAAgBC,GAAAA;AAC9B,QAAM3W,IAAU,IAAIC,eACdsU,IAAQ,IAAIngB,WAAWuiB,EAAW50B,MAAAA;AAExC,SADAie,EAAQ4W,WAAWD,GAAYpC,CAAAA,GACxBA;AACT;AAYO,UAAUsC,GAAkB9nB,GAAAA;AACjC,WAASlM,IAAIkM,EAAIhN,SAAS,GAAGc,KAAK,GAAGA,IAAAA,OAC7BkM,EAAIlM,CAAAA;AAEd;AAEA,SAASi0B,GAAShN,GAAAA;AAChB,SAAA,CAAA,CAASA,KAAwB,OAATA,KAAS,YAATA,CAAsBnnB,MAAMmP,QAAQgY;AAC9D;AA2BO,SAASiN,GAAYjN,GAAAA;AAC1B,OA1BF,SAAiBA,GAAAA;AACf,WAAOnnB,MAAMmP,QAAQgY,CAAAA;AAAAA,EACvB,GAwBcA,CAAAA,EACV,QAAOA,EAAKlf,IAAKosB,CAAAA,MAAYD,GAASC;AACxC,MAAWF,GAAShN,CAAAA,GAAO;AACzB,UAAM3a,IAAO,CAAA;AACb,eAAW3D,KAAO9K,OAAO4K,KAAKwe,GAC5B3a,GAAK3D,CAAAA,IAAOurB,GAASjN,EAAKte;AAE5B,WAAO2D;AAAAA,EACT;AACE,SAAO2a;AAEX;AAcO,SAASmN,GACdjrB,GACAkrB,GACAC,IAAgC,CAAA,GAAA;AAEhC,gBACSnrB,KAAW,YAClBA,MAAW,QACQ,OAAZkrB,KAAY,YACnBA,MAAY,QAKbx2B,OAAO4K,KAAK4rB,GAAyB3rB,QAASC,CAAAA,MAAAA;AAC7C,UAAM4rB,WAAgB5rB,KAAQ,WAAWA,EAAIyd,SAAAA,IAAa5jB,OAAOmG;AACjE,QAAIA,MAAQ,eAAeA,MAAQ,iBAAiBA,MAAQ,YAC1D,OAAM,IAAIlQ,MAAM,0CAA0C87B,CAAAA,GAAAA;AAG5D,UAAMC,IAAcH,EAAQ1rB,CAAAA,GACtB8rB,IAAeH,EAAS3rB,CAAAA;AAE1BA,IAAAA,KAAOQ,MAEPA,EAAOR,CAAAA,IADL6rB,MACK7rB,SACL8rB,eAAAA,SAEKA,IAEOD;AAAAA,MAnBXrrB;AAyBX;AASO,SAASurB,GAAwBpyB;AACtC,QAAA,EAAMqyB,eAAEA,eAAeC,IAAa,CAAA,yBAAIC,IAAuB,CAAA,EAAA,IAAOvyB,GAEhEwyB,IAAeZ,GAAS,KACzBS,GAAAA,GACAC,GAAAA,GACAC,EAAAA,CAAAA,GAGCE,IAAUl3B,OAAO4K,KAAKksB,CAAAA,GACtBK,IAA6B,CAAA;AAUnC,SARAD,EAAQrsB,QAASC,CAAAA,MAAAA;AACXA,IAAAA,KAAOmsB,MACTE,EAAersB,CAAAA,IAAOmsB,EACpBnsB;MAKCqsB;AACT;ACpLO,IAAWC,KAAAA,CAAAA,OAChBA,EAAAA,EAAA,uBAAA,KAAA,wBACAA,EAAAA,EAAA,iBAAA,KAAA,kBACAA,EAAAA,EAAA,cAAA,KAAA,eACAA,EAAAA,EAAA,8BAAA,KAAA,+BACAA,EAAAA,EAAA,gBAAA,KAAA,iBACAA,EAAAA,EAAA,uBAAA,KAAA,wBANgBA,IAAAA,KAAA,CAAA,CAAA,GCDAC,MAAAA,CAAAA,OAChBA,EAAAA,UAAM,IAAN,OACAA,EAAAA,EAAA,MAAA,CAAA,IAAA,OACAA,EAAAA,EAAA,kBAAA,CAAA,IAAA,mBACAA,EAAAA,EAAA,SAAA,CAAA,IAAA,UACAA,EAAAA,EAAA,MAAA,CAAA,IAAA,OALgBA,IAAAA,MAAA,CAAA,CAAA;AAkBlB,SAASC,GAAWC,GAAAA;AAClB,QAAMC,IAAaD,IAAM,GACnBE,KARR,SAAgCF,GAAAA;AAC9B,UAAMG,IAAeH,EAAIhP,SAAS,CAAA,GAC5BoP,IAAgBJ,IAAM,IAAIG,EAAar2B,SAASq2B,EAAar2B,SAAS;AAC5E,WAAOiD,KAAKszB,KAAKD,IAAgB,CAAA;AAAA,EACnC,GAImDJ,IAC3C1D,IAAQ,IAAIngB,WAAW+jB,CAAAA,GACvBI,IAAcC,OAAOL,CAAAA;AAE3BF,EAAAA,KAhBF,SAAaA;AACX,WAAOA,IAAM,IAAA,CAAKA,IAAMA;AAAAA,EAC1B,GAcYA,CAAAA;AACV,WAASp1B,IAAI,GAAGA,IAAIs1B,GAAmBt1B,KAAK;AAC1C,UACM4wB,IAAQwE,KADA,MAAMM,IAAc,KAAKC,OAAO31B,CAAAA,KAChB;AAC9B0xB,IAAAA,EAAM1xB,CAAAA,IAAKiG,OAAO2qB,CAAAA;AAAAA,EACpB;AAGA,SADIyE,MAAY3D,EAAM,CAAA,IAAgB,MAAXA,EAAM,CAAA,IAC1BA;AACT;AAEA,SAASkE,GAAWlE,GAAAA;AAClB,QAAM51B,IAAa65B,OAAOjE,EAAMxyB,MAAAA,GAC1B22B,IAAgB,CAACjF,GAAc5wB,MAAAA;AACnC,UAAMqN,IAAQ,MAAMvR,IAAa,KAAK65B,OAAO31B,CAAAA;AAC7C,WAAO21B,OAAO/E,CAAAA,KAASvjB;AAAAA,EAAAA;AAIzB,MAAIyoB,IAASD,EAAyB,MAAXnE,EAAM,CAAA,GAAiB,CAAA;AAClD,WAAS1xB,IAAI,GAAGA,IAAIlE,GAAYkE,IAC9B81B,CAAAA,IAASD,EAAcnE,EAAM1xB,IAAIA,CAAAA,IAAK81B;AAIxC,UAFgB,MAAXpE,EAAM,CAAA,MAAoB,WAAmBoE,IAE3CA;AACT;AAEO,SAASC,GAAaX;AAC3B,QAAMY,IAAWb,GAAWC,CAAAA,GACtBa,IAAkB,IAA2BD,EAAS92B;AAC5D,SAAO,IAAIqS,WAAW,CAAC0kB,GAAAA,GAAmBD,CAAAA,CAAAA;AAC5C;AAEO,SAASE,GAAexE,GAAAA;AAC7B,QAAMyE,IAAWzE,EAAM,CAAA;AAEvB,MAD6ByE,KAAY,MAC5B,EACX,OAAM,IAAI19B,MACR;AAGJ,QAAM29B,IAA+B,KAAXD,GAEpBt7B,IADQ,IACMu7B;AACpB,SAAO,EACLN,QAAQF,GAAWlE,EAAMppB,MAHb,GAG0BzN,KACtCiB,YAAYs6B,IAAoB,EAAA;AAEpC;AA0BO,SAASC,GAA2B3E,GAAAA;AACzC,QAAA,CAAO4E,GAAUC,KAA0B7E;AAE3C,MAD6B4E,KAAY,MAC5B,EACX,OAAM,IAAI79B,MACR,2EAAA;AAIJ,MAAIm7B,IAAS;AACb,QAAM4C,IAA2B;AACjC,WAASx2B,IAAI,GAAGA,IAAIu2B,GAAwBv2B,KAAK;AAC/C,UAAA,EAAQ81B,QAAQW,GAAA36B,YAAsBA,EAAAA,IAAeo6B,GACnDxE,EAAMppB,MAAMsrB,CAAAA,CAAAA;AAEdA,IAAAA,KAAU93B;AACV,UAAM46B,IAAqC,QAAvBD,GACdE,IAAoC,QAAvBF;AAEnB,aAAS3tB,IAAI,GAAGA,IAAI4tB,GAAa5tB,KAAK;AACpC,YAAM8tB,IAAWjB,OAAOjE,EAAMkC,CAAAA,CAAAA;AAC9B4C,MAAAA,EAAev2B,KAAK02B,IAAaC,CAAAA,GACjChD;AAAAA,IACF;AAAA,EACF;AAEA,SAAO,EAAEiD,SAASL,GAAgB16B,YAAY83B,EAAAA;AAChD;AAaO,SAASkD,GAAkBpF,GAAAA;AAChC,QAAA,CAAO4E,GAAUS,CAAAA,IAAcrF;AAE/B,MAD6B4E,KAAY,MAC5B,EACX,OAAM,IAAI79B,MACR,wEAAA;AAGJ,QAAMyG,KAAsB,KAAXo3B,MAAoB,IAAKS,GACpCC,IAActF,EAAMppB,MAAM,GAAGpJ,IAAS;AAE5C,SAAO,EAAE0d,QADM,IAAIzL,YAAY,MAAA,EAAQE,OAAO2lB,CAAAA,GAC7Bl7B,YAAYoD,IAAS,EAAA;AACxC;AAEO,MAAM+3B,GAAAA;AAAAA,EACHvF,QAAsB,CAAA;AAAA,EACtBwF,UAAU;AAAA,EAElB,KAAKxF,GAAAA;AACH74B,SAAKs+B,SAASzF,GAAO;EACvB;AAAA,EAEA,QAAQA,GAAAA;AACN74B,SAAKs+B,SAASzF,GAAO,OAAA;AAAA,EACvB;AAAA,EAEQ,SACNA,GACAvkB,GAAAA;AAEA,QAAIiqB;AAEFA,QADE1F,aAAiBngB,aACNmgB,IACJ5xB,MAAMmP,QAAQyiB,CAAAA,IACV,IAAIngB,WAAWmgB,KAEf,IAAIngB,WAAW,CAACmgB,CAAAA,CAAAA,GAE/B74B,KAAKq+B,WAAWE,EAAWl4B,QAC3BrG,KAAK64B,MAAMvkB,MAAa,UAAU,YAAY,MAAA,EAAQiqB;EACxD;AAAA,EAEA,iBAAAC;AACE,WAAOx+B,KAAK64B;AAAAA,EACd;AAAA,EAEA,YAAA4F;AACE,WAAO9D,GAAW36B,KAAK64B,OAAO74B,KAAKq+B;EACrC;AAAA,EAEA,IAAA,SAAIh4B;AACF,WAAOrG,KAAKq+B;AAAAA,EACd;AAAA;AC/LF,MACMK,KAAoBC,GAAwB,QADxB,CAAA,GAEpBC,KAAkBD,GAAwB,QAFtB,CAAA,GAGpBE,KAAuBF,GAAwB,QAH3B,IAIpBG,KAAqBH,GAAwB,QAJzB,CAAA,GAKpBI,KAAc,CAACL,IAAmBG,EAAAA,GAClCG,KAAY,CAACJ,IAAiBE,EAAAA,GAC9BG,KAAsBP,GAAkBr4B,SAASu4B,GAAgBv4B;AAEhE,SAAS64B,GAAe7nB;AAC7B,QAAA,EAAMhR,QAAEA,EAAAA,IAAWq4B,IACbS,IAAwB9nB,EAAO5H,MAAAA,CAAOpJ,CAAAA;AAC5C,SACE04B,GAAYK,KAAMC,CAAAA,MAChBC,GAAgBjoB,GAAQgoB,GAdJ,CAAA,CAAA,KAgBtBL,GAAUI,KAAMC,CAAAA,MACdC,GAAgBH,GAAuBE,GAjBnB,CAAA,CAAA;AAoB1B;AAcO,MAAME,WAAkC3/B,MAAAA;AAAAA,EAC7C,YAAqBC;AACnBE,UAAAA,GADmBC,KAAAH,OAAAA;AAAAA,EAErB;;AAGK,MAAM2/B,GAAAA;AAAAA,EAIX,YACmBC;AAAAz/B,SAAAy/B,aAAAA;AAAAA,EAChB;AAAA,EALc7E,SAAS,IAAI8E;AAAAA,EACtBj8B,SAAkC;AAAA,EAM1C,gBAAgBd,GAAAA;AACd,QAAI3C,KAAKyD,WAAW,YAAa;AAEjC,UAAMk8B,IA5BDL,GA4BoC38B,GA5BZ+7B,IAvBP,CAAA;AAoDtB,SAAK1+B,KAAK46B,OAAOv0B,UAAAA,CAAWs5B,EAC1B,OAAM,IAAIJ,GAA0B,gBAAA;AAEtC,QAAIv/B,KAAK46B,OAAOv0B,UAAUs5B,EACxB,OAAM,IAAIJ,GAA0B,oBAAA;AAEtCv/B,SAAK46B,OAAOxzB,KAAKpH,KAAK4/B,oBAAoBj9B,CAAAA,CAAAA,IAhC9C,SAA4B0U;AAC1B,aAAOioB,GACLjoB,EAAO5H,MAAAA,KACPmvB,IA7BsB,CAAA;AAAA,IAgC1B,GA4B4Bj8B,OACxB3C,KAAKyD,SAAS,aACdzD,KAAKy/B,WAAWz/B,KAAK46B,OAAO6D,UAAAA,CAAAA;AAAAA,EAC9B;AAAA,EAEQ,oBAAoB97B,GAAAA;AAC1B,WAAOA,EAAM8M,MAlES,GAkEgB9M,EAAM0D,SAlEtB,CAAA;AAAA,EAmExB;;AAGK,MAAMw5B,GAAAA;AAAAA,EAKX,YACEC,GACiBC,GAAAA;AAAA//B,SAAA+/B,iBAAAA,GAEjB//B,KAAK64B,MAAMzxB,KAAK04B,CAAAA;AAAAA,EAClB;AAAA,EATiBjH,QAAQ,IAAI6G;AAAAA,EACrBM,gBAA8B,CAAA;AAAA,EAC9Bv8B,SAAmC;AAAA,EAS3C,WAAWiB,GAAc5B;AACvB9C,SAAK64B,MAAMzxB,KAAK1C,EAAKsL,WAAW,CAAA,CAAA;AAChC,UAAM6oB,IAAQoH,GAA2BnD,OAAOh6B,CAAAA,CAAAA;AAChD9C,SAAK64B,MAAMzxB,KAAKyxB;EAClB;AAAA,EAEA,iBAAiBn0B,GAAc2O;AAC7BrT,SAAK64B,MAAMzxB,KAAK1C,EAAKsL,WAAW,CAAA,CAAA;AAChC,UAAM6oB,KDfH,SAAkCmF;AACvC,YAAMkC,wBAA2BC;AAEjC,iBAAWlD,KAAUe,GAAS;AAC5B,cAAMrxB,IAAkB,CAAA,OAATswB,GACTmD,IAAoB,QAATnD,GACXpE,IAAQqH,EAAqBt8B,IAAI+I,MAAW,IAAIyxB;AACjDvF,QAAAA,EAAMxyB,UAAQ65B,EAAqBjyB,IAAItB,GAAQksB,CAAAA,GACpDA,EAAMzxB,KAAKgG,OAAOgzB,CAAAA,CAAAA;AAAAA,MACpB;AAEA,YAAM9pB,IAAS,IAAI8nB;AACnB9nB,MAAAA,EAAOlP,KAAK,CAAC,IAAqC84B,EAAqB5a,IAAAA,CAAAA;AAEvE,kBAAYwY,GAAYuC,CAAAA,KAAgBH,GAAsB;AAC5D,gBAAM75B,QAAEA,EAAAA,IAAWg6B,EAAY7B,eAAAA,GACzBZ,IAAuBE,IAA+B,QAAjBhB,OAAOz2B,CAAAA;AAClDg6B,QAAAA,EAAY7yB,QAAQ0vB,GAAaU,CAAAA,CAAAA,GACjCtnB,EAAOlP,KAAKi5B,EAAY5B,UAAAA,CAAAA;AAAAA,MAC1B;AAEA,aAAOnoB,EAAOmoB,UAAAA;AAAAA,IAChB,GCNMprB,EAAInE,IAAKqtB,CAAAA,MAAQO,OAAOP,CAAAA,CAAAA,CAAAA;AAE1Bv8B,SAAK64B,MAAMzxB,KAAKyxB,CAAAA;AAAAA,EAClB;AAAA,EAEA,UAAUn0B,GAAcqf,GAAAA;AACtB/jB,SAAK64B,MAAMzxB,KAAK1C,EAAKsL,WAAW,CAAA,CAAA;AAChC,UAAM6oB,KD8BH,SAAyB9U,GAAAA;AAC9B,YAAA,EAAM1d,QAAEA,MAAW0d,GACb8U,IAAQ,IAAIuF;AAMlB,aALAvF,EAAMzxB,KAAK,CACR,KAAgCf,KAAU,IAAK,IACvC,MAATA,CAAAA,CAAAA,GAEFwyB,EAAMzxB,KAAK,IAAImd,cAAcE,OAAOV,KAC7B8U,EAAM4F,UAAAA;AAAAA,IACf,GCvCgD1a;AAC5C/jB,SAAK64B,MAAMzxB,KAAKyxB,CAAAA;AAAAA,EAClB;AAAA,EAEA,WAAA9D;AACE,QAAA,CAAK/0B,KAAK64B,MAAMxyB,OAAQ,OAAM,IAAIzG,MAAM;AACxC,QAAII,KAAKyD,WAAW,YAAa;AACjCzD,SAAKyD,SAAS;AAEd,UAAM68B,IAAiBtgC,KAAK64B,MAAM4F,UAAAA;AAClC,QAAI6B,EAAej6B,SAAS44B,MAAuBj/B,KAAK+/B,eAItD,aAHA//B,KAAKggC,cAAc54B,KACjBm5B,GAAYD,GAAgB5B,IAAmBE,EAAAA,CAAAA;AAKnD,QAAI4B,IAAcl3B,KAAKszB,KAAK0D,EAAej6B,SAASrG,KAAK+/B;AAEvDz2B,SAAKszB,KAAK0D,EAAej6B,SAASm6B,KAAevB,KACjDj/B,KAAK+/B,kBAELS;AAGF,eAAA,CAAYr5B,GAAGxE,CAAAA,MA6FnB,WACE0U,GACAmpB,GAAAA;AAEA,YAAMC,IAAcn3B,KAAKszB,KAAKvlB,EAAOhR,SAASm6B,CAAAA;AAC9C,eAASr5B,IAAI,GAAGA,IAAIq5B,GAAar5B,WACzB,CAACA,GAAGkQ,EAAO5H,MAAMtI,IAAIs5B,IAAct5B,IAAI,KAAKs5B,CAAAA,CAAAA;AAAAA,IAEtD,GApGMH,GACAE,CAAAA,EAEU,CAANr5B,MAAM,IACRnH,KAAKggC,cAAc54B,KACjBm5B,GAAY59B,GAAO+7B,IAAmBI,EAAAA,CAAAA,IAE/B33B,MAAMq5B,IAAc,IAC7BxgC,KAAKggC,cAAc54B,KACjBm5B,GAAY59B,GAAOk8B,IAAsBD,EAAAA,CAAAA,IAG3C5+B,KAAKggC,cAAc54B,KACjBm5B,GAAY59B,GAAOk8B,IAAsBC,EAAAA,CAAAA;AAAAA,EAIjD;AAAA,EAEA,mBAAA4B;AACE,QAAI1gC,KAAKyD,WAAW,cAAXA,CAA0BzD,KAAKggC,cAAc35B,OACpD,OAAM,IAAIzG,MAAM,0BAAA;AAElB,WAAOI,KAAKggC;AAAAA,EACd;AAAA;AAGK,SAASW,GAAmB9H;AACjC,QAAA,CAAO+H,CAAAA,IAAe/H,GAChBgI,IAA+C,EACnDp2B,GAAGm2B,EAAAA;AAGL,MAAI7F,IAAS;AACb,SAAOA,IAASlC,EAAMxyB,UAAQ;AAC5B,UAAM3B,IAAOiF,OAAOob,aAAa8T,EAAMkC,CAAAA,CAAAA;AAIvC,YAHAA,KACiB+F,GAAoBjI,EAAMkC,CAAAA,CAAAA,GAAAA;AAAAA,MAGzC,KAAKgG,GAA6BC;AAChC;AACE,gBAAA,EAAM/D,QAAEA,GAAAh6B,YAAQA,MAAeg+B,GAC7BpI,EAAMppB,MAAMsrB,CAAAA,CAAAA;AAEd8F,UAAAA,EAAoBn8B,CAAAA,IAAQ0I,OAAO6vB,CAAAA,GACnClC,KAAU93B;AAAAA,QACZ;AACA;AAAA,MACF,KAAK89B,GAA6BG;AAChC;AACE,gBAAA,EAAMlD,SAAEA,eAAS/6B,EAAAA,IACfk+B,GAAyCtI,EAAMppB,MAAMsrB;AACvD8F,UAAAA,EAAoBn8B,CAAAA,IAAQs5B,EAAQ9uB,IAAK9F,CAAAA,MAAMgE,OAAOhE,CAAAA,CAAAA,GACtD2xB,KAAU93B;AAAAA,QACZ;AACA;AAAA,MACF,KAAK89B,GAA6Bp3B,QAChC;AACE,cAAA,EAAMoa,QAAEA,GAAA9gB,YAAQA,MAAem+B,GAC7BvI,EAAMppB,MAAMsrB,CAAAA,CAAAA;AAEd8F,QAAAA,EAAoBn8B,CAAAA,IAAQqf,GAC5BgX,KAAU93B;AAAAA,MACZ;AAAA;EAGN;AACA,SAAO49B;AACT;AAEA,SAASC,GAAoB/I,GAAAA;AAC3B,QAAMsJ,IAAyCtJ,KAAQ;AACvD,MACEsJ,KAAYN,GAA6BO,OACzCD,KAAYN,GAA6BQ,IAEzC,OAAM,IAAI3hC,MAAM,mBAAA;AAGlB,SAAOyhC;AACT;AAEA,SAAS1C,GAAwB5a,GAAgB1d,GAAAA;AAC/C,MAAc0d,EAAO1d,WAAWA,EAC9B,OAAM,IAAIzG,MAAM,qBAAA;AAElB,QAAMyX,IAAS,IAAIqB,WAAWrS,CAAAA;AAC9B,WAASc,IAAI,GAAGA,IAAI4c,EAAO1d,QAAQc,IAAKkQ,CAAAA,EAAOlQ,CAAAA,IAAK4c,EAAO/T,WAAW7I;AACtE,SAAOkQ;AACT;AAYA,SAASkpB,GACPlpB,GACAmqB,GACAC,GAAAA;AAEA,QAAMnrB,IAAS,IAAIoC,WACjBrB,EAAOhR,SAASm7B,EAAWn7B,SAASo7B,EAASp7B,MAAAA;AAM/C,SAJAiQ,EAAOrI,IAAIuzB,CAAAA,GACXlrB,EAAOrI,IAAIoJ,GAAQmqB,EAAWn7B,MAAAA,GAC9BiQ,EAAOrI,IAAIwzB,GAAUD,EAAWn7B,SAASgR,EAAOhR,MAAAA,GAEzCiQ;AACT;AAEA,SAASgpB,GACPoC,GACAC,GACAt7B,GAAAA;AAEA,WAASc,IAAI,GAAGA,IAAId,GAAQc,IAC1B,KAAIu6B,EAAQv6B,CAAAA,MAAOw6B,EAAQx6B,CAAAA,EAAI,QAAA;AAEjC,SAAA;AACF;AClMO,SAASy6B,GACdC,GACAC,GAAAA;AAEA,UAAQD,EAAQp3B;IACd,KAAK2xB,EAAgB2F;AAAAA,IACrB,KAAK3F,EAAgB4F;AAAAA,IACrB,KAAK5F,EAAgB6F;AACnB,cA3CN,SACEJ,GACAC,GAAAA;AAEA,cAAMI,IAAU,IAAIrC,GAAqBgC,EAAQp3B,GAAGq3B;AAIpD,eAHAI,EAAQC,WAAW,KAAKN,EAAQ16B,CAAAA,GAChC+6B,EAAQC,WAAW,KAAKN,EAAQx2B,CAAAA,GAChC62B,EAAQnN,SAAAA,GACDmN,EAAQxB,iBAAAA;AAAAA,MACjB,GAkCyCmB,GAASC;IAC9C,KAAK1F,EAAgBgG;AACnB,cAtBN,SACEP,GACAC,GAAAA;AAEA,cAAMI,IAAU,IAAIrC,GAAqBgC,EAAQp3B,GAAGq3B,CAAAA;AAKpD,eAJAI,EAAQC,WAAW,KAAKN,EAAQ16B,IAChC+6B,EAAQC,WAAW,KAAKN,EAAQx2B,IAC5Bw2B,EAAQnK,KAAGwK,EAAQC,WAAW,KAAKN,EAAQnK,CAAAA,GAC/CwK,EAAQnN,SAAAA,GACDmN,EAAQxB,iBAAAA;AAAAA,MACjB,GAYgDmB,GAASC;IACrD,KAAK1F,EAAgBiG;AACnB,cA7DN,SACER,GACAC,GAAAA;AAEA,cAAA,EAAQr3B,GAAGm2B,GAAa0B,GAAGC,GAAeC,GAAGC,EAAAA,IAAWZ,GAClDK,IAAU,IAAIrC,GAAqBe,GAAakB;AAMtD,eALIW,GAAQp8B,UAAQ67B,EAAQQ,iBAAiB,KAAKD,CAAAA,GAC9CF,GAAel8B,UACjB67B,EAAQQ,iBAAiB,KAAKH,CAAAA,GAEhCL,EAAQnN,YACDmN,EAAQxB,iBAAAA;AAAAA,MACjB,GAiDiDmB,GAASC,CAAAA;AAAAA,IACtD,KAAK1F,EAAgBuG;AACnB,cAtCN,SACEd,GACAC,GAAAA;AAEA,cAAMI,IAAU,IAAIrC,GAAqBgC,EAAQp3B,GAAGq3B;AAKpD,eAJAI,EAAQC,WAAW,KAAKN,EAAQ16B,CAAAA,GAChC+6B,EAAQC,WAAW,KAAKN,EAAQl5B,CAAAA,GAChCu5B,EAAQC,WAAW,KAAKN,EAAQx2B,CAAAA,GAChC62B,EAAQnN,SAAAA,GACDmN,EAAQxB;MACjB,GA4B6CmB,GAASC,CAAAA;AAAAA,EAAAA;AAEtD;;AC7DO,MAAMc,GAAAA;AAAAA,EAMX,YACmBC,GACAC,GACAC,GAIjBviC,GAAAA;AANiBR,SAAA6iC,aAAAA,GACA7iC,KAAA8iC,aAAAA,GACA9iC,KAAA+iC,gBAAAA,GAMjB/iC,KAAKS,oBACHD,EAAYE,mBAAmB,mBAAA,GACjCV,KAAKgjC,kBAAkBxiC,EAAYE,mBAAmB,iBAAA,GACtDmiC,EAAWl7B,GAAG,QAAQ3H,KAAKijC,cAAAA;AAAAA,EAC7B;AAAA,EAlBQC;AAAAA,EACAC;AAAAA,EACS1iC;AAAAA,EACAuiC;AAAAA,EAiBTC,iBAAkB9/B,CAAAA;AACpBigC,IAAAA,GAAuBjgC,CAAAA,IACzBnD,KAAKqjC,sBAAsBlgC,MAE3BnD,KAAK+iC,cAAcO,uBAAuBngC,CAAAA,GAE1CnD,KAAKS,kBAAkB0C,EAAKF,YAAY,OAAOjD,KAAK6iC,WAAWU,MAAAA;AAAAA,EAAAA;AAAAA,EAInE,YAAY1B;AACV,UAAM2B,IAAuBC,GAC3B5B,GACA7hC,KAAK8iC,WAAWY,oBAAAA;AAElB,eAAWrsB,KAAUmsB,EACnBxjC,MAAK6iC,WAAW/jB,MAAMzH;EAE1B;AAAA,EAEA,2BAAAssB;AACE3jC,SAAKmjC,kBAAkBS,cAAAA,GACvB5jC,KAAKmjC,mBAAAA;AAAAA,EACP;AAAA,EAEA,wBAAAU;AACE,WAAO7jC,KAAKmjC,kBAAkBW;AAAAA,EAChC;AAAA,EAEA,MAAA,uCACE3gC,GACA2gC,GAAAA;AAEA,QAAI9jC,KAAKmjC,iBACP,OAAM,IAAIvjC,MAAM,yCAAA;AAElB,UAAMg7B,KAiEV,WACEz3B,GACA2+B,GAAAA;AAEA,UAAIiC,IAAY5gC,EAAKF;AACrB,aAAO8gC,IAAY,KAAG;AACpB,cAAMC,IAAcD,KAAajC,IAAeA,IAAeiC,GACzD3/B,IAAOjB,EAAKF,aAAa8gC,GACzB1sB,IAASlU,EAAKsM,MAAMrL,GAAMA,IAAO4/B,CAAAA;AACvCD,QAAAA,KAAaC,GAAAA,MACP3sB;AAAAA,MACR;AAAA,IACF,GA7EmClU,GAAMnD,KAAK8iC,WAAWY,oBAAAA,GAAAA,EAC/CjuB,SAAEA,GAAAvE,SAASA,GAAAC,QAASA,EAAAA,KLtEvB,WAAA;AACL,UAAID,GACAC;AAMJ,aAAO,EACLsE,SANc,IAAIxE,QAAW,CAAC0T,GAAKsf;AACnC/yB,QAAAA,IAAUyT,GACVxT,IAAS8yB;AAAAA,MAAAA,CAAAA,GAMT/yB,YAEAC,QAAAA,EAAAA;AAAAA,IAEJ,GKuDyC+yB;AAErC,QAAIC;AAEJ,UAAMhB,IAAmB,EACvBS,eAAe,MAAA;AACbO,MAAAA,IAAAA;AAAAA,IAAyB,GAE3BL,WAAAA,EAAAA;AAGF9jC,SAAKmjC,mBAAmBA;AAExB,UAAMiB,IAAY;AAChB,UAAKD,EAKL,YAAa;AACX,cAAMxhC,IAAQi4B,EAAOnjB,KAAAA,EAAO3U;AAE5B,aAAKH,GAAO;AACVuO,UAAAA,EAAAA;AACA;AAAA,QACF;AAEA,cAAMmzB,IAAUrkC,KAAK6iC,WAAW/jB,MAAMnc,CAAAA;AAEtC,YADA3C,KAAKgjC,gBAAgBrgC,EAAMM,YAAYjD,KAAK6iC,WAAWU,MAAAA,GAAAA,CAClDc,EAAS;AAAA,MAChB;AAAA,UAfElzB,CAAAA,EAAAA;AAAAA,IAAAA;AAkBJ,QAAA;AACEnR,WAAK6iC,WAAWl7B,GAAG,SAASy8B,CAAAA,GAC5BD,QACAC,EAAAA,GAAAA,MACM3uB;AAAAA,IACR,UAAA;AACEzV,WAAK6iC,WAAW/6B,IAAI,SAASs8B,IAEzBpkC,KAAKmjC,qBAAqBA,MAC5BnjC,KAAKmjC;IAET;AAAA,EACF;AAAA,EAEQ,sBAAsB9rB,GAAAA;AAC5BrX,SAAKkjC,kBAAkB,IAAIoB,GACxBC,OAAAA;AACCvkC,WAAKkjC,gBAAAA;AACL,YAAMrB,IAAU2C,GAA2BD,CAAAA;AAC3CvkC,WAAK+iC,cAAc0B,kBAAkB5C,CAAAA;AAAAA,IAAAA,CAAAA;AAGzC,QAAA;AACE7hC,WAAKkjC,cAAcwB,gBAAgBrtB,CAAAA;AAAAA,IACrC,SAAShG;AACP,UAAA,EAAMA,aAAeszB,IAAoC;AACzD3kC,WAAKkjC,gBAAAA;AAAAA,IACP;AAAA,EACF;AAAA;ACrHF,QAAM9G,iBAAEA,EAAAA,IAAoBwI;AAYrB,MAAM/e;EAiBX,YACmBgd,GACAE,GACAD,GACA+B,GACArkC,GAAAA;AAJAR,SAAA6iC,aAAAA,GACA7iC,KAAA+iC,gBAAAA,GACA/iC,KAAA8iC,aAAAA,GACA9iC,KAAA6kC,aAAAA,GACA7kC,KAAAQ,cAAAA,GAEjBR,KAAK8kC,eAAetkC,EAAYE,mBAAmB,aAAA,GAEnDV,KAAK4tB,KAAK/H,GAAKkf,wBAAwBlC,CAAAA,GACvC7iC,KAAKglC,eAAe,IAAIpC,GACtBC,GACAC,GACA,EACEQ,wBAAwBtjC,KAAKsjC,wBAE7BmB,mBAAmBzkC,KAAKykC,qBAE1BjkC,CAAAA,GAEFA,EAAYE,mBAAmB,eAAA,EAAiB,EAC9C6yB,QAAQvzB,KAAK4tB,IACbiX,kBAGFhC,EAAWl7B,GAAG,SAAS3H,KAAKilC,oBAC5BpC,EAAWl7B,GAAG,SAAS3H,KAAKklC,yBAC5BrC,EAAWl7B,GAAG,OAAO3H,KAAKklC,yBAC1BrC,EAAWl7B,GAAG,UAAU3H,KAAKklC;EAC/B;AAAA,EA7CStX;AAAAA,EACQoX;AAAAA,EACTG;AAAAA,EAMAC,qCAAqBxO;AAAAA,EACrByO,0CAA0BzO;AAAAA,EAC1B0O,oBAEF,CAAA;AAAA,EACEC,SAAS74B,EAAM;EACNo4B;AAAAA,EAiCjB,IAAA,qBAAIU;AACF,WAAOxlC,KAAKmlC,oBAAoB7kC,QAAQM;AAAAA,EAC1C;AAAA,EAEA,iBACEA,GAAAA;AAEA,UAAA,EAAM85B,YAAEA,MAAe95B;AACvB,WAAIZ,KAAKolC,eAAeK,IAAI/K,CAAAA,IAAoB,WAC5C16B,KAAKqlC,oBAAoBI,IAAI/K,CAAAA,IAAoB,iBAAA;AAAA,EACvD;AAAA,EAEQ+J,oBAAoB7hC,OAAOi/B,MAAAA;AACjC,YAAQA,EAAQp3B;MACd,KAAK2xB,EAAgBiG;AACnBriC,aAAKolC,iBAAiB,IAAIxO,IAAIiL,EAAQW,CAAAA,GACtCxiC,KAAKqlC,sBAAsB,IAAIzO,IAAIiL,EAAQS,IAC3CtiC,KAAK+iC,cAAc2C,uBAAAA;AACnB;AAAA,MAEF,KAAKtJ,EAAgBgG;AACnBpiC,aAAKglC,aAAarB,4BAClB3jC,KAAK+iC,cAAc4C,mBACjB3lC,MACA6hC,EAAQ16B,GACR06B,EAAQx2B,GACRw2B,EAAQnK;AAEV;AAAA,MAEF,KAAK0E,EAAgBuG;AACnB;AAEE,cADA,CAAK3iC,KAAKmlC,sBACNnlC,KAAKmlC,mBAAmBS,6BAA8B;AAE1D,kBAAMtlC,SAAEA,GAAAulC,UAASA,GAAA/B,WAAUA,EAAAA,IAAc9jC,KAAKmlC;AAC9C,cACE7kC,EAAQM,QAAQ85B,eAAemH,EAAQ16B,KACvC28B,MAAcjC,EAAQx2B,EAEtB;AAGFrL,eAAKmlC,mBAAmBS,+BAAAA,IACxBC,EAASrjC,mBAAAA,GAELlC,EAAQU,eAFHwB,SAGPlC,EAAQmE,cAAco9B,EAAQl5B,CAAAA,IACrBrI,EAAQU,aAAaV,EAAQQ,gBAAgB+gC,EAAQl5B,MAC9DrI,EAAQ8C,oBACRpD,KAAK8lC,gCAAgCxlC,EAAQM,SAASkjC,IACtD9jC,KAAK+lC,yBACH,qCAAA,GAEF/lC,KAAKqM;QAET;AACA;AAAA,MAEF,KAAK+vB,EAAgB6F,6BAA6B;AAChD,cAAA,EAAMkD,oBAAEA,EAAAA,IAAuBnlC;AAE/B,YAAA,CAAKmlC,GAAoBS,6BAA8B;AAEvD,gBAAMtlC,SAAEA,GAAAulC,UAASA,EAAAA,IAAaV;AAM9B,YAHEA,EAAmB7kC,QAAQM,QAAQ85B,eAAemH,EAAQ16B,KAC1Dg+B,EAAmBrB,cAAcjC,EAAQx2B,EAMzC,QAHA/K,EAAQ8C,iBAAAA,GACRpD,KAAK+lC,yBAAyB,yBAAA,GAAA,KAC9B/lC,KAAKqM,QAAAA;AAMP,YAFqB/L,EAAQQ,gBAAgBR,EAAQU,WAMnD,QAHAV,EAAQ8C,iBAAAA,GACRpD,KAAK+lC,yBAAyB,6CAC9B/lC,KAAKqM,QAAAA;AAIP,cAAM25B,IAAAA,MACGhmC,KAAK8iC,WAAWmD,qBACrB3lC,EAAQM,QAAQe,KAChBrB,EAAQM,QAAQD,WAChBL,EAAQ6C;AAGZ,YAAInD,KAAKmlC,uBAAuBA,EAAoB;AAEpD,YAAA,CAAKa,EAIH,QAHA1lC,EAAQ8C,iBAAAA,GACRpD,KAAK+lC,yBAAyB,+BAAA,GAAA,KAC9B/lC,KAAKqM,QAAAA;AAIPrM,aAAKslC,oBAAoB,CAAA,GACzBO,EAASxiC,kBAAAA,GACTrD,KAAKmlC,qBAAAA;AACL;AAAA,MACF;AAAA,MAEA,KAAK/I,EAAgB4F;AAEjBhiC,aAAKmlC,oBAAoB7kC,QAAQM,QAAQ85B,eAAemH,EAAQ16B,KAChEnH,KAAKmlC,mBAAmBrB,cAAcjC,EAAQx2B,MAE9CrL,KAAK+lC,yBAAyB,qBAAA,GAC9B/lC,KAAKolC,eAAec,OAAOrE,EAAQ16B,CAAAA;AAErC;AAAA,MAEF,KAAKi1B,EAAgB2F;AAGnB,YAF2B/hC,KAAKglC,aAAanB,sBAAAA,MAElBhC,EAAQx2B,EAAG;AAEtCrL,aAAKglC,aAAarB,yBAAAA;AAClB;AAAA,IAAA;AAAA,EAAA;AAAA,EAKIL,yBAA0B3gC,CAAAA,MAAAA;AAClC,QAAA,CAAK3C,KAAKmlC,oBAAoBS,6BAA8B;AAE5D,UAAA,EAAMtlC,SAAEA,GAAAulC,UAASA,EAAAA,IAAa7lC,KAAKmlC;AAMnC,QAHE7kC,EAAQU,eAGV,UAFEV,EAAQQ,cAAc6B,EAAMM,aAAa3C,EAAQU,WAMjD,QAHAV,EAAQ8C,iBAAAA,GACRpD,KAAK+lC,yBAAyB,qCAAA,GAAA,KAC9B/lC,KAAKqM,QAAAA;AAIPw5B,MAAS7iC,eAAeL,CAAAA;AAAAA,EAAAA;AAAAA,EAG1B,gBAAgBwjC,GAAAA;AACd,QAAInmC,KAAKmlC,mBACP,OAAM,IAAIvlC,MAAM,qCAAA;AAElBI,SAAKmlC,qBAAqB,EACxB7kC,SAAS6lC,GACTrC,WAAWx6B,KAAKgsB,MAAsB,MAAhBhsB,KAAKisB,WAC3BqQ,8BAAAA,IACAC,UAAUM,EAAeplC,MACvB,EAAEI,gBAAgB,OAAOoyB,QAAQvzB,KAAK4tB,GAAAA,GACtC,EACEtsB,4BACEtB,KAAK8iC,WAAWsD,+BAClBhlC,OAAQkC,CAAAA,MAAAA;AACN,UAAA,CAAKtD,KAAKmlC,mBAAoB;AAC9B,YAAA,EAAM7kC,SAAEA,GAAAwjC,WAASA,EAAAA,IAAc9jC,KAAKmlC;AACpCnlC,WAAK8lC,gCAAgCxlC,EAAQM,SAASkjC,CAAAA,GACtD9jC,KAAKslC,kBAAkBl+B,KAAK9D,CAAAA,GAC5BtD,KAAKmlC,6BAEiBnlC,KAAKslC,kBAAkBh2B,OAC1ChM,CAAAA,MAAUA,EAAMzD,SAAS,yBAATA,EAGDwG,UAAUrG,KAAK8iC,WAAWuD,mBAC1CrmC,KAAKqM,QAAAA;AAAAA,IAAAA,EAAAA,CAAAA,EAAAA;AAMf,UAAMw1B,IAA6C,EACjDp3B,GAAG2xB,EAAgBgG,gBACnB/2B,GAAGrL,KAAKmlC,mBAAmBrB,WAC3B38B,GAAGg/B,EAAevlC,QAAQ85B,WAAAA;AAExByL,IAAAA,EAAerlC,gBAAa+gC,EAAQnK,IAAIyO,EAAerlC,cAC3Dd,KAAKglC,aAAasB,YAAYzE,CAAAA;AAAAA,EAChC;AAAA,EAEA,wBACEjhC,GACAkjC,GACA3gC,GAAAA;AAEA,YAAMu3B,YAAEA,EAAAA,IAAe95B;AACvBZ,SAAKulC,OAAO,gBAAgB3kC,EAAQ85B,UAAAA,OAAiB16B,KAAK4tB;AAC1D,UAAMiU,IAA0C,EAC9Cp3B,GAAG2xB,EAAgBuG,aACnBx7B,GAAGuzB,GACHrvB,GAAGy4B,GACHn7B,GAAGxF,EAAKF,WAAAA;AAEVjD,SAAKglC,aAAasB,YAAYzE,CAAAA;AAC9B,QAAA;AAAA,YACQ7hC,KAAKglC,aAAauB,uCACtBpjC,GACA2gC,CAAAA,GAEF9jC,KAAKwmC,uCAAuC5lC,GAASkjC,CAAAA,GACrD9jC,KAAKulC,OAAO,WAAW7K,CAAAA,qBAA+B16B,KAAK4tB,EAAAA,EAAAA;AAAAA,IAC7D;AACE5tB,WAAKulC,OAAO,4BAA4B7K,CAAAA,EAAAA;AAAAA,IAC1C;AAAA,EACF;AAAA,EAEQ,yBAAyB76B,GAAAA;AAC/B,SAAKG,KAAKmlC,mBAAoB;AAC9B,UAAA,EAAM7kC,SAAEA,GAAAulC,UAASA,EAAAA,IAAa7lC,KAAKmlC,sBAC7BvkC,SAAEA,EAAAA,IAAYN;AACpBN,SAAKulC,OAAO,0BAA0B3kC,EAAQ85B,UAAAA,KAAe76B,CAAAA,GAAAA;AAC7D,UAAMyD,IAAQ,IAAI3D,EAAaE,CAAAA;AAC/BgmC,IAAAA,EAASjhC,aAAatB,CAAAA,GACtBtD,KAAKmlC,qBAAAA,QACLnlC,KAAKslC,kBAAkBl+B,KAAK9D,CAAAA;AAAAA,EAC9B;AAAA,EAEA,gCACEmjC,GACAC,GAAAA;AAEA,UAAM7E,IAAkD,EACtDp3B,GAAG2xB,EAAgBiG,sBACnBC,GAAGoE,GACHlE,GAAGiE,EAAAA;AAELzmC,SAAKglC,aAAasB,YAAYzE,CAAAA;AAAAA,EAChC;AAAA,EAEA,yBAAyB8E,GAA2B7C,GAAAA;AAClD9jC,SAAKglC,aAAasB,YAAY,EAC5B77B,GAAG2xB,EAAgB4F,eACnB76B,GAAGw/B,GACHt7B,GAAGy4B,EAAAA,CAAAA;AAAAA,EAEP;AAAA,EAEQ,gCACNljC,GACAkjC,GAAAA;AAEA9jC,SAAKglC,aAAasB,YAAY,EAC5B77B,GAAG2xB,EAAgB2F,sBACnB56B,GAAGvG,EAAQ85B,YACXrvB,GAAGy4B,EAAAA,CAAAA;AAAAA,EAEP;AAAA,EAEQ,uCACNljC,GACAkjC,GAAAA;AAEA9jC,SAAKglC,aAAasB,YAAY,EAC5B77B,GAAG2xB,EAAgB6F,6BACnB52B,GAAGy4B,GACH38B,GAAGvG,EAAQ85B,WAAAA,CAAAA;AAAAA,EAEf;AAAA,EAEQwK,yBAAyB,MAAA;AAC/BllC,SAAKqM,QAAAA;AAAAA,EAAAA;AAAAA,EAGC44B,oBAAqB3hC,CAAAA;AAC3BtD,SAAKulC,OAAO,yBAAyBvlC,KAAK4tB,SAAStqB,CAAAA,GACnDtD,KAAKQ,YAAYE,mBAAmB,eAAe,EACjD6yB,QAAQvzB,KAAK4tB,IACbiX,YAAY7kC,KAAK6kC,YACjBvhC,OAAAA,EAAAA,CAAAA;AAGF,YAAMkgB,MAAEA,EAAAA,IAASlgB;AAAAA,KAEbkgB,MAAS,sBAEFA,MAAS,6BADlBxjB,KAAKqM,QAAAA;AAAAA,EAAAA;AAAAA,EAMTA,UAAU,MAAA;AACRrM,SAAK+lC,yBAAyB,aAAA,GAC9B/lC,KAAK6iC,WAAWx2B,QAAAA,GAChBrM,KAAK+iC,cAAc+B,aAAa9kC,IAAAA,GAChCA,KAAK8kC,aAAa,EAChBvR,QAAQvzB,KAAK4tB,IACbiX,YAAY7kC,KAAK6kC,eAEnB7kC,KAAKulC,OAAO,eAAevlC,KAAK4tB;;EAGlC,OAAA,wBAA+BiV,GAAAA;AAC7B,YNzUG,SAAmB+D,GAAAA;AACxB,YAAM/N,IAAQ,IAAIngB,WAAWkuB,EAAUvgC,SAAS,CAAA;AAEhD,eAASc,IAAI,GAAGA,IAAIy/B,EAAUvgC,QAAQc,KAAK,EACzC0xB,CAAAA,EAAM1xB,IAAI,KAAK5C,SAASqiC,EAAUn3B,MAAMtI,GAAGA,IAAI,CAAA,GAAI,EAAA;AAGrD,aADgB,IAAImR,cACLE,OAAOqgB,CAAAA;AAAAA,IACxB,GMiU2BgK,EAAWjV,EAAAA;AAAAA,EACpC;AAAA;AC7VF,SAASiZ,KAAAA;AACP,QAAMC,IAAW,iCAAiCC,KAAKt7B,UAAUC,YAC3Ds7B,IACJ,sDAAsDD,KACpDt7B,UAAUC;AAGd,SAAOo7B,KAAYE;AACrB;AAEO,MAAMC,GAAAA;AAAAA,EAQX,YACEC,GACiBzuB,GACAsqB,GACAtc,GACAjmB,GAAAA;AAHAR,SAAAyY,SAAAA,GACAzY,KAAA+iC,gBAAAA,GACA/iC,KAAAymB,SAAAA,GACAzmB,KAAAQ,cAAAA;AAEjB,UAAM2mC,KV5CH,SAAuBC,GAAAA;AAE5B,YAAMC,IAA0BC,GAAI/N,SAAS6N,CAAAA,EAAU33B,MAAM,CAAA;AAE7D,aADgC83B,KAAKF,CAAAA;AAAAA,IAEvC,GUuC8CH,CAAAA;AAC1ClnC,SAAKwnC,gBAAgBC,GAA4BhvB,CAAAA;AAEjD,QAAI8a,IAAS0T,GAAiBS,qBAAqB9jC,IAAIujC,CAAAA;AAClD5T,IAAAA,MACHA,KV1CC,SAAwBoU,GAAAA;AAC7B,YAAMC,IAAkB,CAACD,IACnBE,IAXe,KAWqBF,EAA2BthC;AAErE,eAASc,IAAI,GAAGA,IAAI0gC,GAAkB1gC,IACpCygC,CAAAA,EAAgBxgC,KACdmzB,GAAajxB,KAAKgsB,MAAsBiF,KAAhBjxB,KAAKisB,OAAAA,CAAAA,CAAAA,CAAAA;AAIjC,aAAOqS,EAAgBz4B,KAAK,EAAA;AAAA,IAC9B,GU+BuCsX,EAAOkhB,0BAAAA,GACxCV,GAAiBS,qBAAqBz5B,IAAIk5B,GAAY5T,CAAAA,IAGxDvzB,KAAK0xB,SAAS,IAAIoW,GAAc,EAC9BxU,UAAU0H,GAAgBmM,CAAAA,GAC1B5T,QAAQyH,GAAgBzH,CAAAA,GACxBxB,UAAU8U,GAAAA,IACNpgB,EAAOshB,iBAAiBt4B,MAAM,GAAG,CAAA,IACjCgX,EAAOshB,kBACXxR,WAAWv2B,KAAKymB,OAAO8P,UAAAA,CAAAA,GAEzBv2B,KAAK0xB,OAAO/pB,GAAG,QAAQ3H,KAAKgoC,uBAAAA,GAC5BhoC,KAAK0xB,OAAO/pB,GAAG,WAAW3H,KAAKioC,sBAAAA,GAC/BjoC,KAAK0xB,OAAO/pB,GAAG,SAAS3H,KAAKkoC,uBAC7BloC,KAAKulC,OACH;AAAA,UAAgCvlC,KAAKwnC,wBAAwBL,CAAAA;AAAAA,UAAuB5T,CAAAA,EAAAA;AAAAA,EAExF;AAAA,EArCA4U,OAAAA,uBAA+C,oBAAIhI;AAAAA,EAElCqH;AAAAA,EACA9V;AAAAA,EACA0W,6BAAajI;AAAAA,EACboF,SAAS74B,EAAM,+BAAA;AAAA,EAkChC,QAAA3L;AACEf,SAAK0xB,OAAO3wB,MAAAA;AAAAA,EACd;AAAA,EAEA,UAAAsL;AACErM,SAAK0xB,OAAOrlB;AAEZ,eAAA,EAAWmnB,MAAEA,GAAA6U,sBAAMA,EAAAA,KAA0BroC,KAAKooC,OAAO5a,OAAAA,GAAU;AACjEgG,MAAAA,GAAMnnB,QAAAA;AACN,iBAAWw2B,KAAcwF,EACvBxF,CAAAA,EAAWx2B,QAAAA;AAAAA,IAEf;AAEArM,SAAKooC,OAAOlwB,MAAAA,GACZlY,KAAKulC,OAAO,2BAA2BvlC,KAAKwnC,aAAAA;AAAAA,EAC9C;AAAA,EAEQQ,0BACNM,CAAAA;AAEA,UAAMC,IAAS1iB,GAAKkf,wBAAwBuD;AAC5C,QAAIE,IAAWxoC,KAAKooC,OAAOxkC,IAAI2kC,CAAAA;AAE3BC,OAAUhV,OACZ8U,EAAej8B,aAIZm8B,MACHA,IAAW,EAAEH,sBAAsB,oBAAIzR,MAAAA,GACvC0R,EAAe/E,SAASgF,GACxBvoC,KAAKooC,OAAOn6B,IAAIs6B,GAAQC,CAAAA,IAG1BA,EAASH,qBAAqBI,IAAIH,CAAAA,GAElCA,EAAe3gC,GAAG,WAAW,MAAA;AAC3B,UAAA,CAAI6gC,EAAShV,MAAb;AAEA,mBAAWqP,KAAc2F,EAASH,qBAC5BxF,CAAAA,MAAeyF,KAAgBzF,EAAWx2B;AAGhDm8B,UAASH,qBAAqBnwB,MAAAA,GAE9BswB,EAAShV,OAAO,IAAI3N,GAClByiB,GACA,EACExD,cAAc9kC,KAAK8kC,cACnBa,oBAAoB3lC,KAAK+iC,cAAc4C,oBACvCD,wBAAwB1lC,KAAK+iC,cAAc2C,0BAE7C1lC,KAAKymB,QACLzmB,KAAKyY,OAAO5Y,MACZG,KAAKQ,WAAAA,GAEPR,KAAKulC,OACH,wBAAwBiD,EAAShV,KAAK5F,EAAAA,IAAM5tB,KAAKwnC,kBAEnDxnC,KAAK+iC,cAAc2F,gBAAgBF,EAAShV;MAtBzB;AAAA,IAAA,CAAA;AAAA,EAAA;AAAA,EA0BfyU,yBACN11B,CAAAA,MAAAA;AAEAvS,SAAKulC,OAAO,uBAAuBvlC,KAAKwnC,eAAej1B,CAAAA,GACvDvS,KAAKQ,YAAYE,mBAAmB,kBAAA,EAAoB,EACtDmkC,YAAY7kC,KAAKyY,OAAO5Y,MACxB0S;;EAII21B,uBAAsD5kC,CAAAA,MAAAA;AAC5DtD,SAAKulC,OAAO,+BAA+BvlC,KAAKwnC,eAAelkC,CAAAA,GAC/DtD,KAAKQ,YAAYE,mBAAmB,gBAAA,EAAkB,EACpDmkC,YAAY7kC,KAAKyY,OAAO5Y,MACxByD,OAAAA,EAAAA,CAAAA;AAAAA,EAAAA;AAAAA,EAIJ,SAAC6uB;AACC,eAAWqW,KAAYxoC,KAAKooC,OAAO5a,OAAAA,EAC7Bgb,CAAAA,EAAShV,SAAAA,MAAYgV,EAAShV;AAAAA,EAEtC;AAAA,EAEQsR,eAAgBtR,CAAAA,MAAAA;AACtBxzB,SAAKulC,OAAO,gBAAgB/R,EAAK5F,EAAAA,EAAAA,GACjC5tB,KAAKooC,OAAOlC,OAAO1S,EAAK5F,EAAAA;AAAAA,EAAAA;AAAAA,EAG1B,0BAAO+a;AACL1B,IAAAA,GAAiBS,qBAAqBxvB,MAAAA;AAAAA,EACxC;;ACvJK,SAAS0wB,EACdC,GACApwB,GAAAA;AAEA,SAAO,MAA4BowB,CAAAA,KAsB9B,SAAqBpwB,GAAAA;AAC1B,WAAO,GAAGA,EAAO5Y,IAAAA,IAAQ4Y,EAAO7N;EAClC,GAxB4D6N,CAAAA,CAAAA;AAC5D;AAEO,SAASqwB,GACdzmB,GACA0mB,GAAAA;AAEA,aAAWtwB,KAAU4J,EAAQmL,OAAAA,GAAU;AACrC,UAAM5sB,IAAU6X,EAAOuwB,SAASplC,IAAImlC;AACpC,QAAInoC,EAAS,QAAOA;AAAAA,EACtB;AACF;AAqDO,SAASqoC,GACdroC,GACAsoC,GACAC,GACAC,GACAC,GAAAA;AAEA,UAAMC,sBACJA,GAAAC,wBACAA,GAAAC,uBACAA,EAAAA,KApCJ,SACEL,GACAM,GAAAA;AAEA,YAAMH,sBACJA,GAAAC,wBACAA,GAAAC,uBACAA,EAAAA,IACEL,GAEE7yB,IAAS,EACbgzB,yBACAC,wBAAAA,GACAC,uBAAAA,EAAAA;AAUF,WAPIC,KAA4B,KAC9BnzB,EAAOizB,yBAAyB,GAChCjzB,EAAOkzB,wBAAwB,KACtBC,KAA4B,OACrCnzB,EAAOkzB,wBAAwBlzB,EAAOizB,yBAGjCjzB;AAAAA,EACT,GAa2B6yB,GAAmBE,CAAAA;AAE5C,SAAO,EACLK,cAAcC,GACZ/oC,GACAsoC,GACAI,CAAAA,GAEFM,oBAAoBD,GAClB/oC,GACAsoC,GACAK,CAAAA,GAEFM,mBACEF,GAAsB/oC,GAASsoC,GAAUM,CAAAA,KACzCJ,EAAiBU,kCAAkClpC,CAAAA,EAAAA;AAEzD;AAEA,SAAS+oC,GACP/oC,GACAsoC,GACAa,GAAAA;AAEA,QAAA,EAAMC,WAAEA,GAAAC,SAAWA,EAAAA,IAAYrpC,GAAAA,EACzB0T,UAAEA,GAAA41B,MAAUA,EAAAA,IAAShB;AAE3B,WADoB50B,IAAWy1B,IAAmBG,IAC3BF,KAAa11B,IAAW21B;AACjD;AChHO,MAAME,GAAAA;AAAAA,EAIX,YACUC,GACS3xB,GACA4xB,GACAC,GACA7jB,GACAjmB,GACA+pC,GAAAA;AANTvqC,SAAAoqC,oBAAAA,GACSpqC,KAAAyY,SAAAA,GACAzY,KAAAqqC,WAAAA,GACArqC,KAAAsqC,iBAAAA,GACAtqC,KAAAymB,SAAAA,GACAzmB,KAAAQ,cAAAA,GACAR,KAAAuqC,wBAAAA;AAEjB,UACMrD,IAAgBsD,EADNxqC,KAAKymB,OAAOoiB,WAAW7oC,KAAKoqC,mBACgBpqC,KAAKyY,MAAAA;AAEjEzY,SAAKyqC,gBAAgB,IAAIxD,GACvBC,GACAlnC,KAAKyY,QACL,EACEiwB,iBAAiB1oC,KAAK0oC,iBAEtB/C,oBAAoB3lC,KAAK2lC,oBACzBD,wBAAwB1lC,KAAKuqC,sBAAAA,GAE/BvqC,KAAKymB,QACLzmB,KAAKQ,cAGPR,KAAKQ,YAAYkT,iBACf,oBAAoBwzB,KACpBlnC,KAAK0qC,qBAAAA,GAEP1qC,KAAKsqC,eAAeK,yBAA0BvD,CAAAA,MAAAA;AAC5CpnC,WAAKQ,YAAYoqC,cAAc,oBAAoBxD,CAAAA,EAAAA;AAAAA,IAAAA,CAAAA,GAGrDpnC,KAAKyqC,cAAc1pC,MAAAA;AAAAA,EACrB;AAAA,EArCiB0pC;AAAAA,EACTI,6BAAAA;AAAAA,EAsCR,gBAAgBjqC,GAAAA;AACd,UAAMkqC,IAA2B,CAAA;AACjC,eAAWtX,KAAQxzB,KAAKyqC,cAActY,QAEjCqB,CAAAA,EAAKgS,sBACNhS,EAAKuX,iBAAiBnqC,CAAAA,MAAa,YAEnCkqC,EAAiB1jC,KAAKosB,CAAAA;AAI1B,QAAIsX,EAAiBzkC,WAAW,EAAG;AACnC,UAAMmtB,KTjCuBzF,ISiCI+c,GThCtBxhC,KAAKgsB,MAAMhsB,KAAKisB,OAAAA,IAAWxH,EAAM1nB,MAAAA,CAAAA;AADzC,QAA0B0nB;ASmC7B,UAAMztB,IAAUN,KAAKqqC,SAASW,mBAAmBpqC,CAAAA;AACjD4yB,MAAKyX,gBAAgB3qC;EACvB;AAAA,EAEA,kCAAkCM,GAAAA;AAChC,eAAW4yB,KAAQxzB,KAAKyqC,cAActY,QACpC,KAAIqB,EAAKuX,iBAAiBnqC,CAAAA,EAAU;AAEtC,WAAA;AAAA,EACF;AAAA,EAEA,yBAAyBA,GAAAA;AACvB,eAAW4yB,KAAQxzB,KAAKyqC,cAActY,MAAAA,EACpC,KAAIqB,EAAKuX,iBAAiBnqC,CAAAA,MAAa,SAAU,QAAA;AAEnD,WAAA;AAAA,EACF;AAAA,EAEA,IAAA;AACE,QAAI8R,IAAQ;AACZ,UAAMw4B,IAAWlrC,KAAKyqC,cAActY,MAAAA;AACpC,WAAA,CAAQ+Y,EAASzzB,KAAAA,EAAO5U,OAAM6P,CAAAA;AAC9B,WAAOA;AAAAA,EACT;AAAA,EAEQ,0BAAAy4B;AACN,UAAMtC,IAAU7oC,KAAKymB,OAAOoiB,WAAW7oC,KAAKoqC,mBACtClD,IAAgBsD,EAA6B3B,GAAS7oC,KAAKyY,SAE3DgqB,IAAmBziC,KAAKsqC,eAAec,oBAC3CvC,GACA3B,CAAAA,GAEImE,IAAwB,CAAA;AAE9B,eAAW/qC,KAAWN,KAAKqqC,SAASiB,aAAAA,GAAgB;AAClD,YAAM1qC,IAAUZ,KAAKyY,OAAOuwB,SAASplC,IAAItD,EAAQM,QAAQ2qC,SAAAA;AACpD3qC,MAAAA,KAELyqC,EAAYjkC,KAAKxG,EAAQ85B;IAC3B;AACA,WAAO,EAAE+H,QAAAA,GAAQ4I;EACnB;AAAA,EAEQ3C,kBAAmBlV,CAAAA,MAAAA;AACzB,QAAIxzB,KAAKymB,OAAO+kB,oBAAqB;AAErC,UAAA,EAAMH,aAAEA,GAAA5I,QAAaA,EAAAA,IAAWziC,KAAKmrC;AACrC3X,IAAAA,EAAKiY,gCAAgChJ,GAAQ4I,CAAAA;AAAAA,EAAAA;AAAAA,EAG/CX,wBAAwB,CAACgB,IAAAA,OAAwB;AAC/C,QAAIA,EAEF,QAAA,KADA1rC,KAAK2rC,yBAAyB,CAAA,GAAI;AAIpC,QAAI3rC,KAAK6qC,8BAA8B7qC,KAAKymB,OAAO+kB,oBACjD;AAGF,UAAA,EAAM/I,QAAEA,GAAA4I,aAAQA,EAAAA,IAAgBrrC,KAAKmrC,wBAAAA;AACrCnrC,SAAK2rC,yBAAyBlJ,GAAQ4I,CAAAA;AAAAA,EAAAA;AAAAA,EAGhCM,2BAA2B,CACjClJ,GACA4I,MAAAA;AAEArrC,SAAK6qC,6BAAAA,IAELl1B,eAAe,MAAA;AACb,iBAAW6d,KAAQxzB,KAAKyqC,cAActY,MAAAA,EACpCqB,GAAKiY,gCAAgChJ,GAAQ4I,CAAAA;AAE/CrrC,WAAK6qC,6BAAAA;AAAAA;;EAIDlF,qBAAqB/iC,OAC3B4wB,GACAmT,GACA7C,GACA8H,MAAAA;AAEA,UAAMhrC,KDrHH,SACL6X,GACAkuB,GAAAA;AAEA,iBAAW/lC,KAAW6X,EAAOuwB,SAASxb,OAAAA,EACpC,KAAI5sB,EAAQ85B,eAAeiM,EAAmB,QAAO/lC;AAAAA,IAEzD,GC+GMZ,KAAKyY,QACLkuB,CAAAA;AAEF,QAAA,CAAK/lC,EAAS;AACd,QAAIZ,KAAKymB,OAAO+kB,oBAEd,QAAA,KADAhY,EAAKqY,yBAAyBlF,GAAmB7C;AAInD,UAAM+E,IAAU7oC,KAAKymB,OAAOoiB,WAAW7oC,KAAKoqC,mBACtClD,IAAgBsD,EAA6B3B,GAAS7oC,KAAKyY,MAAAA,GAE3DqzB,IAAAA,MAAoB9rC,KAAKsqC,eAAeyB,eAC5ClD,GACA3B,GACAtmC,EAAQ85B;AAELoR,IAAAA,IAAAA,MAICtY,EAAKwY,kBACTprC,GACAkjC,GACA8H,eAAyBE,EAAYr8B,MAAMm8B,KAAYE,CAAAA,IANvDtY,EAAKqY,yBAAyBlF,GAAmB7C;;EAUrD,UAAAz3B;AACE,UACM66B,IAAgBsD,EADNxqC,KAAKymB,OAAOoiB,WAAW7oC,KAAKoqC,mBACgBpqC,KAAKyY,MAAAA;AAEjEzY,SAAKQ,YAAYqT,oBACf,oBAAoBqzB,CAAAA,IACpBlnC,KAAK0qC,qBAAAA,GAEP1qC,KAAKyqC,cAAcp+B,QAAAA;AAAAA,EACrB;AAAA;AC7KK,MAAM4/B;EAKX,YACmB7B,GACjB3xB,GACiB4xB,GACAC,GACA7jB,GACAjmB,GACT+pC,GAAAA;AANSvqC,SAAAoqC,oBAAAA,GAEApqC,KAAAqqC,WAAAA,GACArqC,KAAAsqC,iBAAAA,GACAtqC,KAAAymB,SAAAA,GACAzmB,KAAAQ,cAAAA,GACTR,KAAAuqC,wBAAAA,GAERvqC,KAAKksC,qBAAqBlsC,KAAKmsC,4BAA4B1zB,CAAAA,GAC3DzY,KAAKulC,OACH,2BAA2BkC,GAA4BhvB,CAAAA,CAAAA,EAAAA;AAAAA,EAE3D;AAAA,EAjBiB2zB,8BAAcjM;AAAAA,EACvB+L;AAAAA,EACS3G,SAAS74B,EAAM;EAiBxB,aAAa+L,GAAAA;AACnB,QAAIzY,KAAKosC,QAAQ3G,IAAIhtB,EAAO8yB,SAAAA,EAC1B,OAAM,IAAI3rC,MAAM,uCAAA;AAElB,UAAMysC,IAAS,IAAIlC,GACjBnqC,KAAKoqC,mBACL3xB,GACAzY,KAAKqqC,UACLrqC,KAAKsqC,gBACLtqC,KAAKymB,QACLzmB,KAAKQ,aACL,MAAA;AACMR,WAAKksC,mBAAmBG,WAAWA,KACrCrsC,KAAKuqC;QAIL+B,IAAa7E,GAA4BhvB,CAAAA;AAE/C,WADAzY,KAAKulC,OAAO,uBAAuB+G,CAAAA,EAAAA,GAC5B,EACLD,WACA5zB,QAAAA,GACA6zB,YAAY7E,GAA4BhvB,CAAAA,EAAAA;AAAAA,EAE5C;AAAA,EAEQ,4BAA4BA,GAAAA;AAClC,UAAM8zB,IAAavsC,KAAKosC,QAAQxoC,IAAI6U,EAAO8yB;AAC3C,QAAIgB,EAGF,QAFAxmC,aAAawmC,EAAWC,gBAAAA,GACxBD,EAAWC,mBAAAA,QACJD;AACF;AACL,YAAMF,IAASrsC,KAAKysC,aAAah0B,CAAAA;AAEjC,aADAzY,KAAKosC,QAAQn+B,IAAIwK,EAAO8yB,WAAWc,CAAAA,GAC5BA;AAAAA,IACT;AAAA,EACF;AAAA,EAEA,oBAAoB5zB,GAAAA;AAClB,UAAMowB,IAAU7oC,KAAKymB,OAAOoiB,WAAW7oC,KAAKoqC,mBACtClD,IAAgBsD,EACpB3B,GACA7oC,KAAKksC,mBAAmBzzB,MAAAA;AAEdzY,SAAKsqC,eAAec,oBAAoBvC,GAAS3B,CAAAA,EACpD7gC,SACJrG,KAAK0sC,wBAAwB1sC,KAAKksC,kBAAAA,IADtBlsC,KAAK2sC,uBAAuB3sC,KAAKksC,kBAAAA,GAGlDlsC,KAAKksC,qBAAqBlsC,KAAKmsC,4BAA4B1zB,CAAAA,GAE3DzY,KAAKulC,OACH,8BAA8BkC,GAA4BhvB,CAAAA,CAAAA,EAAAA;AAAAA,EAE9D;AAAA,EAEQ,wBAAwB2V;AAC9BA,IAAAA,EAAKoe,mBAAmBnqC,OAAOwD,WAC7B,MAAM7F,KAAK2sC,uBAAuBve,CAAAA,GAClCpuB,KAAKymB,OAAOmmB,iCAAAA;AAAAA,EAEhB;AAAA,EAEQ,uBAAuBxe;AAC7BA,IAAAA,EAAKie,OAAOhgC,QAAAA,GACZrM,KAAKosC,QAAQlG,OAAO9X,EAAK3V,OAAO8yB,SAAAA,GAChCvrC,KAAKulC,OAAO,wBAAwBnX,EAAKke,UAAAA;AAAAA,EAC3C;AAAA,EAEA,IAAA,gBAAIO;AACF,WAAO7sC,KAAKksC,mBAAmBG;AAAAA,EACjC;AAAA,EAEA,UAAAhgC;AACE,eAAA,EAAWggC,QAAEA,GAAAG,kBAAQA,OAAsBxsC,KAAKosC,QAAQ5e,OAAAA,EACtD6e,CAAAA,EAAOhgC,WACPtG,aAAaymC,CAAAA;AAEfxsC,SAAKosC,QAAQl0B;EACf;AAAA;ACjEF,SAAS40B,GAA8BlsC,GAAAA;AACrC,SAAO,EACL2qC,WAAW3qC,EAAQ2qC,WACnB7Q,YAAY95B,EAAQ85B,YACpB/4B,KAAKf,EAAQe,KACbhB,WAAWC,EAAQD,WACnBqpC,WAAWppC,EAAQopC,WACnBC,SAASrpC,EAAQqpC,QAAAA;AAErB;AAEO,IAAA8C,KAAA,MAAA;AAAA,EAoBL,YACWnsC,GACQosC,GACAC,GACA/D,GACAgE,GACjB1sC,GAAAA;AALSR,SAAAY,UAAAA,GACQZ,KAAAgtC,8BAAAA,GACAhtC,KAAAitC,uBAAAA,GACAjtC,KAAAkpC,WAAAA,GACAlpC,KAAAktC,iBAAAA,GAGjBltC,KAAKmtC,iBAAiB3sC,EAAYE,mBAAmB,gBAAA,GACrDV,KAAKotC,iBAAiB5sC,EAAYE,mBAAmB,gBAAA,GACrDV,KAAKqtC,iBAAiB7sC,EAAYE,mBAAmB,gBAAA,GACrDV,KAAKstC,kBAAkB9sC,EAAYE,mBAAmB,iBAAA;AAEtD,UAAA,EAAMC,WAAEA,EAAAA,IAAcX,KAAKY;AAC3B,QAAID,GAAW;AACb,cAAMqB,KAAEA,GAAAjB,OAAKA,EAAAA,IAAUJ;AACvBX,WAAKutC,cAAcvrC,IAAMjB,IAAQ;AAAA,IACnC;AACAf,SAAKwtC,2BAA2B,IAAIC,GAAQztC,KAAK0tC,cAAAA;AAEjD,UAAA,EAAM7tC,MAAEA,MAASG,KAAKY,QAAQ6X;AAC9BzY,SAAK2tC,UAAUjhC,EAAM,sBAAsB7M,CAAAA,EAAAA;AAAAA,EAC7C;AAAA,EAzCQ+tC;AAAAA,EACAC,kBAAkB,IAAIC;AAAAA,EACtBC;AAAAA,EACAlV,QAAsB,CAAA;AAAA,EACtBmV,eAAe;AAAA,EACfT;AAAAA,EACAU,UAAyB;AAAA,EACzBC;AAAAA,EACAV;AAAAA,EACAW;AAAAA,EAGSR;AAAAA,EACTS,2BAAAA;AAAAA,EACSjB;AAAAA,EACAC;AAAAA,EACAC;AAAAA,EACAC;AAAAA,EA0BjB,mBAAAlqC;AACEpD,SAAKguC,eAAe,GACpBhuC,KAAK64B,QAAQ,CAAA,GACb74B,KAAKutC,cAAAA,QACLvtC,KAAK+tC,YAAAA;AAAAA,EACP;AAAA,EAEA,IAAA,SAAItqC;AACF,WAAOzD,KAAKiuC;AAAAA,EACd;AAAA,EAEQ,UAAUxqC;AAChBzD,SAAKiuC,UAAUxqC,GACfzD,KAAKouC;EACP;AAAA,EAEA,IAAA,iBAAIjtC;AACF,WAAOnB,KAAK4tC,gBAAgBzsC;AAAAA,EAC9B;AAAA,EAEA,kBAAIL;AACF,WAAOd,KAAKguC;AAAAA,EACd;AAAA,EAEA,IAAA,aAAIhtC;AACF,WAAOhB,KAAKutC;AAAAA,EACd;AAAA,EAEA,IAAA,OAAIpqC;AAEF,WADAnD,KAAK+tC,cAAcM,GAAiBruC,KAAK64B,KAAAA,EAAOxhB,QACzCrX,KAAK+tC;AAAAA,EACd;AAAA,EAEA,IAAA;AACE,WAAO/tC,KAAK6tC;AAAAA,EACd;AAAA,EAEA,8BAAIS;AACF,WAAOtuC,KAAKouC;AAAAA,EACd;AAAA,EAEA,4BAAAG;AACEvuC,SAAKouC,2BAAAA;AAAAA,EACP;AAAA,EAEA,cAActrC,GAAAA;AACZ,QAAI9C,KAAKutC,uBACP,OAAM,IAAI3tC,MAAM,0CAAA;AAElBI,SAAKutC,cAAczqC;AAAAA,EACrB;AAAA,EAEA,MACE0rC,GACA3I,GAAAA;AAKA,QAAI7lC,KAAKiuC,YAAY,UACnB,OAAM,IAAIruC,MACR,WAAWI,KAAKY,QAAQ85B,UAAAA,4BAAAA;AAG5B,QAAI16B,KAAKiuC,YAAY,UACnB,OAAM,IAAIruC,MACR,WAAWI,KAAKY,QAAQ85B,UAAAA,4BAAAA;AAI5B16B,SAAKyuC,UAAU,SAAA,GACfzuC,KAAK4tC,iBAAiB,EAAA,GAAKY,KAC3BxuC,KAAKkuC,WAAW,EACdQ,eAAe1uC,KAAKguC,cACpBltC,aAAa,GACb6tC,gBAAgBzuC,YAAYC,IAAAA,EAAAA,GAE9BH,KAAK4uC,gCAAgC,OAAA;AAErC,YAAMttC,4BAAEA,GAAAF,OAA4BA,EAAAA,IAAUykC;AAkB9C,WAjBA7lC,KAAKmuC,wBAAwB/sC,GAEzBE,MAFyBF,UAG3BpB,KAAKwtC,yBAAyBzsC,MAAMO,IAGtCtB,KAAKulC,OACH,GAAGiJ,EAAYrtC,kBAAkBnB,KAAKY,QAAQ85B,UAAAA,UAAAA,GAGhD16B,KAAKqtC,eAAe,EAClBzsC,SAASksC,GAA8B9sC,KAAKY,UAC5CO,gBAAgBqtC,EAAYrtC,gBAC5BoyB,QACEib,EAAYrtC,mBAAmB,QAAQqtC,EAAYjb,SAAAA,WAGhD,EACL/wB,oBAAoBxC,KAAKwC,oBACzBQ,gBAAgBhD,KAAKgD,gBACrBK,mBAAmBrD,KAAKqD,mBACxBuB,cAAc5E,KAAK4E,aAAAA;AAAAA,EAEvB;AAAA,EAEA,wBAAAiqC;AACE7uC,SAAK8uC,6BAAAA,GACL9uC,KAAKyuC,UAAU,SAAA,GACfzuC,KAAKulC,OACH,GAAGvlC,KAAK4tC,gBAAgBzsC,cAAAA,IAAkBnB,KAAKY,QAAQ85B,uBAEzD16B,KAAKmuC,wBAAwB,IAAIxuC,EAAa,WAC9CK,KAAKotC,eAAe,EAClBxsC,SAASksC,GAA8B9sC,KAAKY,OAAAA,GAC5CO,gBAAgBnB,KAAK4tC,gBAAgBzsC,gBACrCoyB,QACEvzB,KAAK4tC,gBAAgBzsC,mBAAmB,QACpCnB,KAAK4tC,eAAera,SAAAA,QAE1BsR,YAAY7kC,KAAKY,QAAQ6X,OAAO5Y,SAElCG,KAAKmuC,wBAAAA,QACLnuC,KAAK4uC,gCAAgC,MAAA,GACrC5uC,KAAKwtC,yBAAyBt1B,MAAAA;AAAAA,EAChC;AAAA,EAEQw1B,iBAAiB,MAAA;AAEvB,QADA1tC,KAAK8uC,iCACA9uC,KAAK4tC,eAAgB;AAE1B5tC,SAAKyuC,UAAU,QAAA;AACf,UAAMnrC,IAAQ,IAAI3D,EAAa,yBAAA;AAC/BK,SAAKmuC,wBAAwB7qC,CAAAA,GAC7BtD,KAAKulC,OACH,GAAGvlC,KAAKmB,cAAAA,IAAkBnB,KAAKY,QAAQ85B,UAAAA,WAAqBp3B,EAAMzD,IAAAA,EAAAA,GAEpEG,KAAK6tC,gBAAgBpF,IAAI,EAAA,GACpBzoC,KAAK4tC,gBACRtqC,OAAAA,EAAAA,CAAAA,GAEFtD,KAAKmtC,eAAe,EAClBvsC,SAASksC,GAA8B9sC,KAAKY,OAAAA,GAC5C0C,OAAAA,GACAnC,gBAAgBnB,KAAK4tC,eAAezsC,gBACpCoyB,QACEvzB,KAAK4tC,eAAezsC,mBAAmB,QACnCnB,KAAK4tC,eAAera,SAAAA,QAE1BsR,YAAY7kC,KAAKY,QAAQ6X,OAAO5Y,KAAAA,CAAAA,GAElCG,KAAKwtC,yBAAyBt1B,SAC9BlY,KAAK4uC,gCAAgC,MAAA,GACrC5uC,KAAKgtC;;EAGCpoC,eAAgBtB,CAAAA,MAAAA;AACtBtD,SAAK8uC,6BAAAA,GACA9uC,KAAK4tC,mBAEV5tC,KAAKyuC,UAAU,QAAA,GACfzuC,KAAKulC,OACH,GAAGvlC,KAAKmB,cAAAA,IAAkBnB,KAAKY,QAAQ85B,UAAAA,WAAqBp3B,EAAMzD,IAAAA,EAAAA,GAEpEG,KAAK6tC,gBAAgBpF,IAAI,EAAA,GACpBzoC,KAAK4tC,gBACRtqC,OAAAA,EAAAA,CAAAA,GAEFtD,KAAKmtC,eAAe,EAClBvsC,SAASksC,GAA8B9sC,KAAKY,OAAAA,GAC5C0C,OAAAA,GACAnC,gBAAgBnB,KAAK4tC,eAAezsC,gBACpCoyB,QACEvzB,KAAK4tC,eAAezsC,mBAAmB,QACnCnB,KAAK4tC,eAAera,SAAAA,QAE1BsR,YAAY7kC,KAAKY,QAAQ6X,OAAO5Y,KAAAA,CAAAA,GAElCG,KAAKwtC,yBAAyBt1B,SAC9BlY,KAAK4uC,gCAAgC,MAAA,GACrC5uC,KAAKgtC;;EAGC3pC,oBAAoB,MAAA;AAC1BrD,SAAK8uC,6BAAAA,GACA9uC,KAAK4tC,mBAEV5tC,KAAK4uC,gCAAgC,MAAA,GACrC5uC,KAAKwtC,yBAAyBt1B,MAAAA,GAC9BlY,KAAKyuC,UAAU,YACfzuC,KAAKutC,cAAcvtC,KAAKguC,cACxBhuC,KAAKstC,gBAAgB,EACnByB,YAAY/uC,KAAKY,QAAQe,KACzBqtC,aAAahvC,KAAKmD,KAAKF,YACvB9B,gBAAgBnB,KAAK4tC,eAAezsC,gBACpCoyB,QACEvzB,KAAK4tC,eAAezsC,mBAAmB,QACnCnB,KAAK4tC,eAAera,SAAAA,QAE1BsR,YAAY7kC,KAAKY,QAAQ6X,OAAO5Y,KAAAA,CAAAA,GAGlCG,KAAKulC,OACH,GAAGvlC,KAAK4tC,eAAezsC,cAAAA,IAAkBnB,KAAKY,QAAQ85B,UAAAA,UAAAA,GAExD16B,KAAKgtC,4BAAAA;AAAAA,EAAAA;AAAAA,EAGChqC,iBAAkBL,CAAAA,MAAAA;AAExB,QADA3C,KAAK8uC,6BAAAA,GAAAA,CACA9uC,KAAK4tC,kBAAAA,CAAmB5tC,KAAKkuC,SAAU;AAC5CluC,SAAKwtC,yBAAyByB,QAAAA;AAE9B,UAAA,EAAMhsC,YAAEA,MAAeN,GAAAA,EACf2f,KAAK4sB,GAAOC,MAAMC,MAAWpvC,KAAKitC;AAC1CiC,IAAAA,EAAM5Q,SAASr7B,IACXjD,KAAK4tC,eAAezsC,mBAAmB,UACzCiuC,EAAO9Q,SAASr7B,CAAAA,GAGlBjD,KAAK64B,MAAMzxB,KAAKzE,CAAAA,GAChB3C,KAAKkuC,SAASmB,2BAA2BnvC,YAAYC,IAAAA,GACrDH,KAAKkuC,SAASptC,eAAemC,GAC7BjD,KAAKguC,gBAAgB/qC;AAAAA,EAAAA;AAAAA,EAGfT,qBAAqB;AAC3BxC,SAAK8uC,6BAAAA,GACL9uC,KAAKwtC,yBAAyByB;;EAGxB,+BAAAH;AACN,QAAI9uC,KAAKiuC,YAAY,UACnB,OAAM,IAAIruC,MAAM,4BAA4BI,KAAKyD,MAAAA,GAAAA;AAAAA,EAErD;AAAA,EAEQ,OAAO3D,GAAAA;AACbE,SAAK2tC,QAAQjjC,QACX1K,KAAK4tC,gBAAgBzsC,mBAAmB,SAAS,UAAU,OAC7DnB,KAAK2tC,QAAQ7tC,CAAAA,GACbE,KAAK2tC,QAAQjjC,QAAQ;AAAA,EACvB;AAAA,EAEQ,gCAAgCqI,GAAAA;AACtC,UAAA,EAAMuP,KAAEA,GAAA6sB,MAAKA,EAAAA,IAASnvC,KAAKitC,sBACrBqC,IAASv8B,MAAU,UAAU,iBAAiB;AACR,IAAxC/S,KAAK4tC,gBAAgBzsC,mBAAmB,UAAQguC,EAAKG,CAAAA,EAAAA,GACzDhtB,EAAIgtB,CAAAA,EAAAA;AAAAA,EACN;AAAA;AAGF,MAAMxB,GAAAA;AAAAA,EACIyB,WAAuC,CAAA;AAAA,EAE/C,IAAIC,GAAAA;AACFxvC,SAAKuvC,SAASnoC,KAAKooC,CAAAA;AAAAA,EACrB;AAAA,EAEA,wBAAIC;AACF,WAAOzvC,KAAKuvC,SAAS1U,OACnB,CAACC,GAAK0U,MAAaA,EAAQruC,mBAAmB,SAAS25B,IAAM,IAAIA,GACjE;EAEJ;AAAA,EAEA,IAAA,cAAI4U;AACF,WAAO1vC,KAAKuvC,SAASvvC,KAAKuvC,SAASlpC,SAAS;EAC9C;AAAA,EAEA,QAAA6R;AACElY,SAAKuvC,WAAW,CAAA;AAAA,EAClB;AAAA;AAGK,MAAM9B,GAAAA;AAAAA,EAIX,YAA6B/a,GAAAA;AAAA1yB,SAAA0yB,SAAAA;AAAAA,EAAqB;AAAA,EAH1Cid;AAAAA,EACAzmC;AAAAA,EAIR,MAAMA,GAAAA;AACJ,QAAIlJ,KAAK2vC,UACP,OAAM,IAAI/vC,MAAM,6BAAA;AAElBI,SAAKkJ,KAAKA,GACVlJ,KAAK2vC,YAAYttC,OAAOwD,WAAW7F,KAAK0yB,QAAQ1yB,KAAKkJ,EAAAA;AAAAA,EACvD;AAAA,EAEA,QAAQA,GAAAA;AACFlJ,SAAK2vC,aAAW5pC,aAAa/F,KAAK2vC,SAAAA,GAClCzmC,WAASA,KAAKA,IACblJ,KAAKkJ,OACVlJ,KAAK2vC,YAAYttC,OAAOwD,WAAW7F,KAAK0yB,QAAQ1yB,KAAKkJ,EAAAA;AAAAA,EACvD;AAAA,EAEA;AACEnD,iBAAa/F,KAAK2vC,SAAAA,GAClB3vC,KAAK2vC;EACP;AAAA;ACnZK,MAAMC,GAAAA;AAAAA,EAGX,YACmB5C,GACAC,GACA/D,GACAziB,GACAjmB,GAAAA;AAJAR,SAAAgtC,8BAAAA,GACAhtC,KAAAitC,uBAAAA,GACAjtC,KAAAkpC,WAAAA,GACAlpC,KAAAymB,SAAAA,GACAzmB,KAAAQ,cAAAA;AAAAA,EAChB;AAAA,EARc6pC,+BAAelK;AAAAA,EAUhC,IAAA,qBAAI0P;AACF,QAAIn9B,IAAQ;AACZ,eAAWpS,KAAWN,KAAKsrC,eACF,CAAnBhrC,EAAQmD,WAAW,aAAWiP;AAEpC,WAAOA;AAAAA,EACT;AAAA,EAEA,IAAA,oBAAIo9B;AACF,QAAIp9B,IAAQ;AACZ,eAAWpS,KAAWN,KAAK+vC,YAAAA,EACF,CAAnBzvC,EAAQmD,WAAW,aAAWiP;AAEpC,WAAOA;AAAAA,EACT;AAAA,EAEA,IAAI9R,GAAAA;AACF,WAAOZ,KAAKqqC,SAASzmC,IAAIhD,CAAAA;AAAAA,EAC3B;AAAA,EAEA,mBAAmBA,GAAAA;AACjB,QAAIN,IAAUN,KAAKqqC,SAASzmC,IAAIhD,CAAAA;AAYhC,WAXKN,MACHA,IAAU,IAAI2B,GACZrB,GACAZ,KAAKgtC,6BACLhtC,KAAKitC,sBACLjtC,KAAKkpC,UACLlpC,KAAKymB,QACLzmB,KAAKQ,WAAAA,GAEPR,KAAKqqC,SAASp8B,IAAIrN,GAASN,CAAAA,IAEtBA;AAAAA,EACT;AAAA,EAEA,OAAOA,GAAAA;AACLN,SAAKqqC,SAASnE,OAAO5lC,EAAQM,OAAAA;AAAAA,EAC/B;AAAA,EAEA,QAAAmtB;AACE,WAAO/tB,KAAKqqC,SAAS7c,OAAAA;AAAAA,EACvB;AAAA,EAEA,CAAA,eAAC8d;AACC,eAAWhrC,KAAWN,KAAKqqC,SAAS7c,SACH,CAA3BltB,EAAQa,mBAAmB,WAAnBA,MAAiCb;AAAAA,EAEjD;AAAA,EAEA,CAAA,cAACyvC;AACC,eAAWzvC,KAAWN,KAAKqqC,SAAS7c,OAAAA,EACH,CAA3BltB,EAAQa,mBAAmB,UAAnBA,MAAgCb;AAAAA,EAEhD;AAAA,EAEA;AACE,eAAWA,KAAWN,KAAKqqC,SAAS7c,OAAAA,EACX,CAAnBltB,EAAQmD,WAAW,aACvBnD,EAAQuuC,sBAAAA;AAEV7uC,SAAKqqC,SAASnyB,MAAAA;AAAAA,EAChB;;ACxEK,MAAM83B,GAAAA;AAAAA,EAIX,YACWpvC,GACAqvC,GAAAA;AADAjwC,SAAAY,UAAAA,GACAZ,KAAAiwC,kBAAAA;AAAAA,EACR;AAAA,EANKhC,UAAwD;AAAA,EACxDiC,8BAAAA;AAAAA,EAOR,IAAA,SAAIzsC;AACF,WAAOzD,KAAKiuC;AAAAA,EACd;AAAA,EAEA,IAAA;AACE,WAAOjuC,KAAKkwC;AAAAA,EACd;AAAA,EAEA,QAAQ/sC,GAAmBgtC,GAAAA;AACJ,IAAjBnwC,KAAKiuC,YAAY,cACrBjuC,KAAKiuC,UAAU,WACfjuC,KAAKiwC,gBAAgBG,UAAU,EAAEjtC,MAAAA,GAAMgtC;EACzC;AAAA,EAEA,SAAAh/B;AACuB,IAAjBnR,KAAKiuC,YAAY,cACrBjuC,KAAKiuC,UAAU,UACfjuC,KAAKiwC,gBAAgBna,QAAQ,IAAI11B,GAAiB;EACpD;AAAA,EAEA,QAAAgB;AACuB,IAAjBpB,KAAKiuC,YAAY,cACrBjuC,KAAKiuC,UAAU,WACfjuC,KAAKiwC,gBAAgBna,QAAQ,IAAI11B,GAAiB;EACpD;AAAA,EAEA,mCAAAiwC;AACErwC,SAAKkwC;EACP;AAAA;AC7BK,UAAUI,GACfC,GACArH,GACAgE,GACA9D,GACAoH,GAAAA;AAEA,UAAMjF,WAAEA,GAAA9yB,QAAWA,EAAAA,IAAW83B,GAExBE,IAAmBh4B,EAAOuwB,SAASplC,IAAI2nC;AAC7C,MAAA,CAAKkF,EAAkB;AAEvB,QAAMC,IAAgBj4B,EAAOuwB,SAASxb,OAAAA;AAEtC,MAAImjB;AAEJ,KAAG;AACD,UAAMl5B,IAAOi5B,EAAcj5B,KAAAA;AAC3B,QAAIA,EAAK5U,KAAM;AACf8tC,IAAAA,IAAQl5B,EAAK3U;AAAAA,EACf,SAAS6tC,MAAUF;AAEnB,QAAMG,IAAgB3H,GACpB0H,GACAzH,GACAgE,GACA9D,GACAoH,CAAAA;AAEF,MAAIK,GAAoBD,CAAAA,GAAgB;AACtC,UAAMn5B,IAAOi5B,EAAcj5B,KAAAA;AAK3B,QAAIA,EAAK5U,KAAM;AAEf,UAAMiuC,IAASr5B,EAAK3U,OAEdiuC,IAAiB9H,GACrB6H,GACA5H,GACAgE,GACA9D,GACAoH,CAAAA;AAGF,QAAIK,GAAoBE,GAAiB;AACzCH,IAAAA,EAAclH,eAAAA,IAAe,MACvB,EAAE9oC,SAAS+vC,GAAOK,UAAUJ,EAAAA,GAAAA,MAC5B,EAAEhwC,SAASkwC,GAAQE,UAAUD,EAAAA;AAAAA,EACrC,aACQ,EAAEnwC,SAAS+vC,GAAOK,UAAUJ;AAGpC,aAAWhwC,KAAW8vC,GAAe;AACnC,UAAMM,IAAW/H,GACfroC,GACAsoC,GACAgE,GACA9D,GACAoH,CAAAA;AAEF,QAAIK,GAAoBG,CAAAA,EAAW;AAAA,UAC7B,EAAEpwC,SAAAA,GAASowC;EACnB;AACF;AAEA,SAASH,GAAoBG;AAC3B,QAAA,EAAMtH,cACJA,IAAAA,IAAeE,oBACfA,IAAAA,IAAqBC,mBACrBA,IAAAA,OACEmH;AACJ,SAAA,CAAQtH,KAAAA,CAAiBE,KAAAA,CAAuBC;AAClD;AC7DO,MAAMoH,GAAAA;AAAAA,EAaX,YACU7G,GACAmG,GACSW,GACAzqB,GACAwmB,GACA3C,GACA9pC,GAAAA;AANTR,SAAAoqC,oBAAAA,GACApqC,KAAAuwC,uBAAAA,GACSvwC,KAAAkxC,gBAAAA,GACAlxC,KAAAymB,SAAAA,GACAzmB,KAAAitC,uBAAAA,GACAjtC,KAAAsqC,iBAAAA,GACAtqC,KAAAQ,cAAAA;AAEjB,UAAM2wC,IAAenxC,KAAKuwC,qBAAqB93B;AAC/CzY,SAAKkpC,WAAW,EAAE50B,UAAUtU,KAAKuwC,qBAAqBvG,WAAWE,MAAM,EAAA,GACvElqC,KAAKoxC,sBPAF,SAA+B34B,GAAAA;AACpC,YAAA,EAAMuwB,UAAEA,EAAAA,IAAavwB;AACrB,UAAI44B,IAAc;AAClB,YAAA,EAAM/rB,MAAEA,EAAAA,IAAS0jB;AACjB,iBAAWpoC,KAAWooC,EAASxb,OAAAA,EAE7B6jB,CAAAA,KADiBzwC,EAAQqpC,UAAUrpC,EAAQopC;AAI7C,aAAOqH,IAAc/rB;AAAAA,IACvB,GOVgE6rB,CAAAA,GAC5DnxC,KAAKqqC,WAAW,IAAIuF,GAClB5vC,KAAKsxC,8BACLtxC,KAAKitC,sBACLjtC,KAAKkpC,UACLlpC,KAAKymB,QACLzmB,KAAKQ,WAAAA,GAGPR,KAAKuxC,aAAa,IAAItF,GACpBjsC,KAAKoqC,mBACLpqC,KAAKuwC,qBAAqB93B,QAC1BzY,KAAKqqC,UACLrqC,KAAKsqC,gBACLtqC,KAAKymB,QACLzmB,KAAKQ,aACLR,KAAKsxC,4BAAAA,GAGPtxC,KAAKulC,SAAS74B,EAAM,4BAA4BykC,EAAatxC,IAAAA,EAAAA,GAC7DG,KAAKulC,OAAO76B,QAAQ,SAEpB1K,KAAKwxC,mBAAAA;AAAAA,EACP;AAAA,EA9CiBnH;AAAAA,EACToH;AAAAA,EACSF;AAAAA,EACArI;AAAAA,EACAkI;AAAAA,EACA7L;AAAAA,EACTmM;AAAAA,EACAC;AAAAA,EACAC;AAAAA,EACAC;AAAAA,EACAC;EAsCA,qBAAAN;AACN,UAAMO,IAAa/xC,KAAKuxC,WAAW1E,cAAcmF,oBAC3CC,IArDkB,MAsDtB3oC,KAAKisB,OAAAA,IAAiCwc,IAtDhB;AAuDxB/xC,SAAK6xC,6BAA6BxvC,OAAOwD,WAAW;AAClD7F,WAAKkyC,sBAAAA,GACLlyC,KAAKwxC,mBAAAA;AAAAA,IAAAA,GACJS;EACL;AAAA,EAGA,MAAA,YACErxC,GACAuxC;AAEAnyC,SAAKulC,OAAO,aAAa6M,GAA6BxxC;AACtD,UAAA,EAAM6X,QAAEA,EAAAA,IAAW7X;AACf6X,UAAWzY,KAAKuwC,qBAAqB93B,WACvCzY,KAAKulC,OAAO,qBAAqBkC,GAA4BhvB,CAAAA,CAAAA,EAAAA,GAC7DzY,KAAKuxC,WAAWc,oBAAoB55B,CAAAA,IAEtCzY,KAAKuwC,uBAAuB3vC;AAE5B,UAAMioC,IAAU7oC,KAAKymB,OAAOoiB,WAAW7oC,KAAKoqC,mBACtClD,IAAgBsD,EAA6B3B,GAASpwB,CAAAA;AAE5DzY,SAAKsqC,eAAe3E,mBAClBkD,GACA3B,GACAtmC,EAAQ85B,YACR95B,EAAQopC,WACRppC,EAAQqpC,SACRxxB,EAAO5Y,MACPG,KAAKkxC,cAAcoB,MAAAA;AAErB,UAAMb,IAAgB,IAAIzB,GAAcpvC,GAASuxC,CAAAA;AAEjD,QAAA;AAOE,UANmBnyC,KAAKsqC,eAAeiI,WACrC1J,GACA3B,GACAtmC,EAAQ85B,UAAAA,GAGM;AACd,cAAMv3B,UAAanD,KAAKsqC,eAAeyB,eACrClD,GACA3B,GACAtmC,EAAQ85B,UAAAA;AAEV,YAAIv3B,GAAM;AACR,gBAAA,EAAMqvC,oBAAEA,EAAAA,IAAuBxyC,KAAKswC;AAEpC,iBAAA,KADAmB,EAAcvgC,QAAQ/N,GAAMnD,KAAKyyC,aAAaD,CAAAA,CAAAA;AAAAA,QAEhD;AAAA,MACF;AAEAxyC,WAAKyxC,eAAerwC,MAAAA,GACpBpB,KAAKyxC,gBAAgBA;AAAAA,IACvB,QAAA;AACEA,MAAAA,EAActgC,OAAAA;AAAAA,IAChB,UAAA;AACEnR,WAAKsxC,6BAAAA;AAAAA,IACP;AAAA,EACF;AAAA,EAEQA,+BAA+B,CAACoB,IAAAA,OAAQ;AAC9C,UAAMvyC,IAAMD,YAAYC,IAAAA;AAAAA,KAEpBuyC,KACA1yC,KAAK4xC,iCADLc,UAEAvyC,IAAMH,KAAK4xC,gCAAgC,OAC7C5xC,KAAK8xC,mCAKP9xC,KAAK8xC,qCACLn8B,eAAe,MAAA;AACb,UAAA;AACE3V,aAAK2yC,aAAAA,GACL3yC,KAAK4xC,+BAA+BzxC;AAAAA,MACtC,UAAA;AACEH,aAAK8xC,iCAAAA;AAAAA,MACP;AAAA;;EAII,gBACNc,GACAJ,GAAAA;AAEA,YAAM/5B,QAAEA,EAAAA,IAAWzY,KAAKuwC,sBAAAA,EAClBsC,kBAAEA,EAAAA,IAAqB7yC,KAAKymB,QAC5BtmB,IAAMD,YAAYC,IAAAA;AACxB,eAAWG,KAAWN,KAAKqqC,SAAStc,MAAAA,GAAS;AAC3C,cACE5sB,gBAAgBtB,GAAA4D,QAChBA,GAAA7C,SACAA,GAAA0tC,yBACAA,EAAAA,IACEhuC,GACEmxC,IACJzxC,KAAKyxC,eAAe7wC,YAAYA,IAC5BZ,KAAKyxC,gBAAAA;AAGX,cAAQhuC,GAAAA;AAAAA,QACN,KAAK;AACEmvC,UAAAA,EAAgBnN,IAAI7kC,EAAQ2qC,cAAekG,MAC9CnxC,EAAQuuC,sBAAAA,GACR7uC,KAAKqqC,SAASyI,OAAOxyC,CAAAA;AAEvB;AAAA,QAEF,KAAK,WAAW;AACd,cAAA,CAAKT,EAAM;AACE,UAATA,MAAS,UACXG,KAAKuxC,WAAW1E,cAAcnC,yBAE5B+G,MACFA,EAAcvgC,QACZ5Q,EAAQ6C,MACRnD,KAAKyyC,aAAaD,CAAAA,CAAAA,GAEpBxyC,KAAKyxC,yBAEPzxC,KAAKqqC,SAASyI,OAAOxyC;AAErB,gBAAMuoC,IAAU7oC,KAAKymB,OAAOoiB,WAAW7oC,KAAKoqC,mBACtClD,IAAgBsD,EAA6B3B,GAASpwB,CAAAA;AAEvDzY,eAAKsqC,eAAeyI,aACvBlK,GACA3B,GACAtmC,EAAQ85B,YACRp6B,EAAQ6C,MACRvC,EAAQopC,WACRppC,EAAQqpC,SACRrpC,EAAQ6X,OAAO5Y,MACfG,KAAKkxC,cAAcoB;AAErB;AAAA,QACF;AAAA,QAEA,KAAK;AACU,UAATzyC,MAAS,UAAWyuC,KACtBtuC,KAAKuxC,WAAW1E,cAAcnC,sBAAAA,GAG7B+G,KACAh5B,EAAOuwB,SAASvD,IAAInlC,EAAQM,QAAQ2qC,SAAAA,KAErCvrC,KAAKqqC,SAASyI,OAAOxyC,CAAAA,GAGrBA,EAAQ0yC,eAAevD,qBAAqBoD,KAC5CpB,MAEAzxC,KAAKyxC,gBAAAA,QACLA,EAActgC,OAAAA;AAEhB;AAAA,QAEF,KAAK;AAAA,QAIL,KAAK;AACHnR,eAAKqqC,SAASyI,OAAOxyC,CAAAA;AAAAA,MAAAA;AAIzBA,MAAAA,EAAQiuC,0BAAAA;AACR,YAAA,EAAMmB,aAAEA,EAAAA,IAAgBpvC,EAAQ0yC;AAE9BtD,MAAAA,KACAvvC,IAAMuvC,EAAYpsC,MAAMrD,YArOO,OAuO/BK,EAAQ0yC,eAAe96B,MAAAA;AAAAA,IAE3B;AAAA,EACF;AAAA,EAEQ,eAAAy6B;AACN,UAAA,EAAM1sC,OAAEA,GAAA2sC,iBAAOA,GAAAJ,oBAAiBA,EAAAA,IAAuBxyC,KAAKswC;AAC5DtwC,SAAKizC,gBAAgBL,GAAiBJ,CAAAA;AAEtC,YAAMU,2BACJA,GAAAC,0BACAA,GAAAN,kBACAA,EAAAA,IACE7yC,KAAKymB;AAET,QACEzmB,KAAKyxC,eAAe2B,8BACpBpzC,KAAKyxC,cAAchuC,WAAW,aAC9BzD,KAAKqqC,SAASwF,qBAAqBqD,GACnC;AACA,YAAA,EAAMtyC,SAAEA,EAAAA,IAAYZ,KAAKyxC,eACnBnxC,IAAUN,KAAKqqC,SAASzmC,IAAIhD,CAAAA;AAAAA,OAAAA,CAE/BN,KACDA,EAAQmD,WAAW,iBAClBnD,EAAQmD,WAAW,YAClBnD,EAAQ0yC,eAAevD,oBACrBzvC,KAAKymB,OAAOosB,qBAEhB7yC,KAAKqzC,gBAAgBzyC,CAAAA;AAAAA,IAEzB;AAEA,eAAWwtB,KAAQnoB,GAAO;AACxB,YAAA,EAAM+qC,UAAEA,GAAApwC,SAAUA,EAAAA,IAAYwtB,GACxB9tB,IAAUN,KAAKqqC,SAASzmC,IAAIhD,CAAAA;AAElC,UAAIowC,EAAStH,cAAc;AAQzB,YANEppC,GAASa,mBAAmB,UAC5Bb,EAAQmD,WAAW,aAMnBnD,GAASa,mBAAmB,UAC5Bb,EAAQmD,WAAW,YACnBnD,EAAQ0yC,eAAevD,qBAAqBoD,EAE5C;AAGF,cAAMS,IACJhzC,GAASmD,WAAW,aAAanD,EAAQa,mBAAmB;AAE9D,YAAInB,KAAKqqC,SAASwF,qBAAqBqD,GAA2B;AAC5DI,UAAAA,OAA6BzE,yBACjC7uC,KAAKqzC,gBAAgBzyC,CAAAA;AACrB;AAAA,QACF;AAEA,YACEZ,KAAKuzC,qCAAqCttC,GAAOrF,MACjDZ,KAAKqqC,SAASwF,qBAAqBqD,GACnC;AACII,UAAAA,OAA6BzE,sBAAAA,GACjC7uC,KAAKqzC,gBAAgBzyC,CAAAA;AACrB;AAAA,QACF;AAEA,YAAI0yC,EAAqB;AAEzB,YAAItzC,KAAKqqC,SAASyF,oBAAoBqD,GAA0B;AAC9DnzC,eAAKwzC,eAAe5yC;AACpB;AAAA,QACF;AAEA,YACEZ,KAAKyzC,oCAAoCxtC,GAAOrF,CAAAA,KAChDZ,KAAKqqC,SAASyF,oBAAoBqD,GAClC;AACAnzC,eAAKwzC,eAAe5yC;AACpB;AAAA,QACF;AAAA,MACF,WAAWowC,EAASnH,mBAAmB;AACrC,YAAIvpC,GAASmD,WAAW,UAAW;AAAA,SAE/BzD,KAAKqqC,SAASyF,oBAAoBqD,KAGpCnzC,KAAKuxC,WAAW1E,cAAc6G,yBAAyB9yC,CAAAA,KAGrDZ,KAAKyzC,oCAAoCxtC,GAAOrF,MAChDZ,KAAKqqC,SAASyF,oBAAoBqD,MANpCnzC,KAAKwzC,eAAe5yC,CAAAA;AAAAA,MAWxB;AAAA,IACF;AAAA,EACF;AAAA,EAGA,oBAAoBmoC,GAAAA;AACd/oC,SAAKyxC,eAAe7wC,QAAQ2qC,cAAcxC,MAC9C/oC,KAAKyxC,cAAcrwC,MAAAA,GACnBpB,KAAKulC,OACH,WACA6M,GAA6BpyC,KAAKyxC,cAAc7wC,OAAAA,CAAAA,GAElDZ,KAAKyxC,wBACLzxC,KAAKsxC,6BAAAA;AAAAA,EACP;AAAA,EAEQ,gBAAgB1wC,GAAAA;AACtB,UAAMN,IAAUN,KAAKqqC,SAASW,mBAAmBpqC,CAAAA;AACjD,QAAIP,GAAoBC,GAASN,KAAKymB,QAAQzmB,KAAKQ,cACnDR,KAAKuxC,WAAW1E,cAAcnC,sBAAAA;AAAAA,EAChC;AAAA,EAEQ,eAAe9pC,GAAAA;AACrBZ,SAAKuxC,WAAW1E,cAAc5B,gBAAgBrqC,CAAAA;AAAAA,EAChD;AAAA,EAEQ,wBAAAsxC;AACN,UAAMyB,IACJ3zC,KAAK4zC;AACP,QAAID,KAAmC,GAAI;AAE3C,YAAMT,2BAAEA,GAAAL,kBAA2BA,EAAAA,IAAqB7yC,KAAKymB,QACvDotB,IAAY7zC,KAAKuxC,WAAW1E;AAElC,QACE7sC,KAAKqqC,SAASwF,sBAAsBqD,MACnCW,EAAU7B,mBAEX;AAGF,UAAM8B,IAAsC,CAAA;AAC5C,eAAA,EAAWlzC,SAAEA,GAAAowC,UAASA,EAAAA,KAAc+C,GAClC/zC,KAAKuwC,sBACLvwC,KAAKkpC,UACLlpC,KAAKymB,QACLzmB,KAAKuxC,WAAW1E,eAChB8G,CAAAA,GACC;AACD,YAAM9K,IAAU7oC,KAAKymB,OAAOoiB,WAAW7oC,KAAKoqC,mBACtClD,IAAgBsD,EACpB3B,GACAjoC,EAAQ6X,MAAAA;AAGV,UAAA,CACGu4B,EAASpH,sBACVoH,EAASnH,qBACT7pC,KAAKsqC,eAAeiI,WAClB1J,GACA3B,GACAtmC,EAAQ85B,UAAAA,EAGV;AAEF,YAAMp6B,IAAUN,KAAKqqC,SAASzmC,IAAIhD;AAEhCN,MAAAA,MACCA,EAAQmD,WAAW,aAClBnD,EAAQmD,WAAW,aACnBnD,EAAQ0yC,eAAevD,qBAAqBoD,MAIhDiB,EAAe1sC,KAAKxG,CAAAA;AAAAA,IACtB;AAOA,QALA,CAAKkzC,EAAeztC,UAGlB6sC,IAA4BlzC,KAAKqqC,SAASwF,uBAEb,EAAG;AAElC,UAAMkC,IAAa8B,EAAU7B,qBAAqB,GAC5CgC,IAA0B1qC,KAAKuY,IACnCiyB,EAAeztC,QACf6sC,IAA4BnB,CAAAA,GAGxBkC,KfrVH,SAAyBptC,GAAAA;AAC9B,eAASM,IAAIN,EAAMR,SAAS,GAAGc,IAAI,GAAGA,KAAK;AACzC,cAAM8I,IAAI3G,KAAKgsB,MAAMhsB,KAAKisB,OAAAA,KAAYpuB,IAAI,EAAA;AAAA,SACzCN,EAAMM,CAAAA,GAAIN,EAAMoJ,CAAAA,CAAAA,IAAM,CAACpJ,EAAMoJ,CAAAA,GAAIpJ,EAAMM,CAAAA,CAAAA;AAAAA,MAC1C;AACA,aAAON;AAAAA,IACT,GegVMI,MAAM7C,KAAK,EAAEiC,QAAQ2tC,EAAAA,GAA2B,CAACvwB,GAAGtc,MAAMA,CAAAA,CAAAA;AAG5D,QAAI+sC,IAAcF,IAA0BjC;AAE5C,eAAWoC,KAAeF,GAAe;AACvC,UAAIj0C,KAAKqqC,SAASwF,sBAAsBqD,EACtC;AAGF,UAAIgB,KAAe,KAAK5qC,KAAKisB,OAAAA,KAAY2e,GAAa;AACpD,cAAMtzC,IAAUkzC,EAAeK,CAAAA;AAC/Bn0C,aAAKqzC,gBAAgBzyC,CAAAA;AAAAA,MACvB;AAGA,UADAszC,KACIA,KAAe,EAAG;AAAA,IACxB;AAAA,EACF;AAAA,EAEQ,qCACNjuC,GACArF,GAAAA;AAEA,iBAAaA,SAASwzC,EAAAA,KAAiBC,GAAqBpuC,CAAAA,GAAQ;AAClE,UAAImuC,MAAgBxzC,EAAS;AAC7B,YAAMN,IAAUN,KAAKqqC,SAASzmC,IAAIwwC;AAClC,UAAI9zC,GAASa,mBAAmB,UAAUb,EAAQmD,WAAW,UAE3D,QADAnD,EAAQuuC,sBAAAA,GAAAA;AAAAA,IAGZ;AACA,WAAA;AAAA,EACF;AAAA,EAEQ,oCACN5oC,GACArF;AAEA,eAAA,EAAaA,SAASwzC,EAAAA,KAAiBC,GAAqBpuC,CAAAA,GAAQ;AAClE,UAAImuC,MAAgBxzC,EAAS;AAC7B,YAAMN,IAAUN,KAAKqqC,SAASzmC,IAAIwwC,CAAAA;AAClC,UAAI9zC,GAASa,mBAAmB,SAASb,EAAQmD,WAAW,UAE1D,QADAnD,EAAQuuC,sBAAAA,GAAAA;AAAAA,IAGZ;AACA;EACF;AAAA,EAEQ,qCAAA+E;AACN,YAAMU,eAAEA,GAAAC,cAAeA,EAAAA,IAAiBv0C,KAAKsqC,eAAekK,SAAAA;AAC5D,WAAO,MAAOD,IAAeD,IAAiB;AAAA,EAChD;AAAA,EAEQ;AACN,UAAMruC,IAAqB,CAAA,GACrB2sC,wBAAsBhc;AAC5B,QAAI6d,IAAoB,GACpBC,IAAqB;AAEzB,UAAMf,IACJ3zC,KAAK4zC;AACP,eAAWxlB,KAAQ2lB,GACjB/zC,KAAKuwC,sBACLvwC,KAAKkpC,UACLlpC,KAAKymB,QACLzmB,KAAKuxC,WAAW1E,eAChB8G,CAAAA,GACC;AACDc;AACA,YAAA,EAAM7zC,SAAEA,EAAAA,IAAYwtB,GAEdya,IAAU7oC,KAAKymB,OAAOoiB,WAAW7oC,KAAKoqC,mBACtClD,IAAgBsD,EACpB3B,GACAjoC,EAAQ6X,MAAAA;AAIRzY,WAAKsqC,eAAeiI,WAClB1J,GACA3B,GACAtmC,EAAQ85B,UAAAA,KAEV16B,KAAKqqC,SAASzmC,IAAIhD,CAAAA,GAAU6C,WAAW,YAEvCixC,OAGFzuC,EAAMmB,KAAKgnB,CAAAA,GACXwkB,EAAgBnK,IAAI7nC,EAAQ2qC,SAAAA;AAAAA,IAC9B;AAEA,WAAO,EACLtlC,OAAAA,GACA2sC,iBAAAA,GACA6B,mBAAAA,GACAC,oBAAAA,GACAlC,oBACEiC,MAAsB,IAAIC,IAAqBD,IAAoB;EAEzE;AAAA,EAEQ,aAAajC,GAAAA;AACnB,YAAMrD,MAAEA,GAAA7sB,KAAMA,EAAAA,IAAQtiB,KAAKitC,sBAAAA,EACrB0H,oBAAEA,EAAAA,IAAuB30C,KAAKkxC;AACpC,QAAIlxC,KAAKkxC,cAAcyD,uBAAuB,EAC5C,QAAOryB,EAAIsyB,wBAAwB,CAAA;AAGrC,UAAMzE,IAAY7mC,KAAKurC,IACrBvyB,EAAImwB,aAAa,IAAIzyC,KAAK2xC,qBAAAA,GAC1BrvB,EAAImwB,aAAa,IAAIzyC,KAAK2xC,qBAAAA,GAC1BrvB,EAAImwB,aAAa,IAAIzyC,KAAK2xC,qBAAAA,CAAAA;AAG5B,QAAIa,KAAsB,OAAOrC,KAAkC,MAArBwE,EAC5C,QAAOrrC,KAAKurC,IACVvyB,EAAIsyB,wBAAwB,IAC5BtyB,EAAIsyB,wBAAwB,CAAA,GAC5BtyB,EAAIsyB,wBAAwB,CAAA,CAAA;AAIhC,UAAME,IAAoBxrC,KAAKurC,IAC7B1F,EAAKyF,wBAAwB,CAAA,GAC7BzF,EAAKyF,wBAAwB,CAAA,GAC7BzF,EAAKyF,wBAAwB,CAAA,CAAA;AAG/B,WAAOtrC,KAAKurC,IAAI1E,GAAW2E,CAAAA;AAAAA,EAC7B;AAAA,EAEA,qBAAAC;AACE/0C,SAAK2xC,wBAAwBzxC,YAAYC,IAAAA;AAAAA,EAC3C;AAAA,EAEA,0BAA0B60C,QAAgC;AACxDh1C,SAAKuxC,WAAW1E,cAAcnC,sBAC5BsK,CAAAA;AAAAA,EAEJ;AAAA,EAEA,eAAe1gC,GAAkB41B,GAAAA;AAC/B,UAAM+K,IAAgBj1C,KAAKkpC,SAASgB,SAASA,GACvCgL,IAAoBl1C,KAAKkpC,SAAS50B,aAAaA;AAErD,QAAA,CAAK2gC,KAAAA,CAAkBC,EAAmB;AAE1C,UAAMC,IACJ7rC,KAAKU,IAAIsK,IAAWtU,KAAKkpC,SAAS50B,QAAAA,IAAYtU,KAAKoxC,qBACnD;AAEE8D,UAAmBl1C,KAAKkpC,SAAS50B,WAAWA,IAC5C2gC,KAAiB/K,MAAS,MAAGlqC,KAAKkpC,SAASgB,OAAOA,IAClDiL,MACFn1C,KAAKulC,OAAO,gCAAA,GACZvlC,KAAKyxC,eAAepB,iCAAAA,IAEtBrwC,KAAKsqC,eAAe8K,kBAAkB9gC,GAAU41B,CAAAA,GAChDlqC,KAAKsxC,6BAA6B6D,CAAAA;AAAAA,EACpC;AAAA,EAEA,aAAa18B,GAAAA;AACPA,IAAAA,MAAWzY,KAAKuwC,qBAAqB93B,WACzCzY,KAAKulC,OAAO,kBAAkBkC,GAA4BhvB,CAAAA,CAAAA,EAAAA,GAC1DzY,KAAKsxC,6BAAAA;AAAAA,EACP;AAAA,EAEA,UAAAjlC;AACE+e,kBAAcprB,KAAK0xC,2BACnBtmB,cAAcprB,KAAK6xC,0BAAAA,GACnB7xC,KAAK0xC,mCACL1xC,KAAKyxC,eAAerwC,MAAAA,GACpBpB,KAAKqqC,SAASh+B,QAAAA,GACdrM,KAAKuxC,WAAWllC;EAClB;AAAA;ACjnBK,MAAMgpC,GAAAA;AAAAA,EAQX,YAA6BC,IAAmB,KAAA;AAAnBt1C,SAAAs1C,mBAAAA;AAAAA,EAA2B;AAAA,EAPhDC,gBAAgB;AAAA,EACP1c,QAAkB;EAClB2c,wBAAkC,CAAA;AAAA,EAClCC,aAAuB,CAAA;AAAA,EAChCC,iBAAiB;AAAA,EACjBC,oBAAoB;AAAA,EAI5B,SAAS3G,GAAqB7uC,IAAMD,YAAYC,IAAAA,GAAAA;AAC9CH,SAAK64B,MAAMzxB,KAAK4nC,CAAAA,GAChBhvC,KAAKw1C,sBAAsBpuC,KAAKjH,IAAMH,KAAK01C,cAAAA,GAC3C11C,KAAKy1C,WAAWruC,KAAKjH,CAAAA;AAAAA,EACvB;AAAA,EAEA,aAAaA,IAAMD,YAAYC,IAAAA,GAAAA;AAC7BH,SAAK41C,WAAAA,GACD51C,KAAKu1C,kBAAkB,KAAKv1C,KAAK21C,sBAAsB,MACzD31C,KAAK01C,kBAAkBv1C,IAAMH,KAAK21C,oBAEpC31C,KAAKu1C;AAAAA,EACP;AAAA,EAEA,YAAYp1C,IAAMD,YAAYC;AACxBH,SAAKu1C,gBAAgB,MACvBv1C,KAAKu1C,iBACDv1C,KAAKu1C,kBAAkB,MAAGv1C,KAAK21C,oBAAoBx1C;AAAAA,EAE3D;AAAA,EAEA,wBACE01C,GACAC,IAA2B1oC,OAAO2oC,mBAAAA;AAElC,QAAA,CAAK/1C,KAAKw1C,sBAAsBnvC,OAAQ,QAAO;AAC/C,UAAM2vC,IAAyB,MAAVH,GACfI,IACJj2C,KAAKw1C,sBAAsBx1C,KAAKw1C,sBAAsBnvC,SAAS;AACjE,QAAI6vC,IAAuBD;AAC3B,UAAME,IAAYF,IAAoBD;AACtC,QAAIh1C,IAAa;AAEjB,aAASmG,IAAInH,KAAK64B,MAAMxyB,SAAS,GAAGc,KAAK,GAAGA,KAAK;AAC/C,YAAMlH,IAAYD,KAAKw1C,sBAAsBruC,CAAAA;AAC7C,UACElH,IAAYk2C,KACZn2C,KAAKy1C,WAAWtuC,CAAAA,IAAK2uC,EAErB;AAEFI,MAAAA,IAAuBj2C,GACvBe,KAAchB,KAAK64B,MAAM1xB;IAC3B;AAEA,WAAqB,MAAbnG,KAAsBi1C,IAAoBC;AAAAA,EACpD;AAAA,EAEA,aACEL,GACAC,IAA2B1oC,OAAO2oC,mBAClC51C,IAAMD,YAAYC,IAAAA,GAAAA;AAElB,QAAA,CAAKH,KAAKy1C,WAAWpvC,OAAQ,QAAO;AACpC,UACM8vC,IAAYh2C,IADa,MAAV01C;AAErB,QAAIK,IAAuB/1C,GACvBa,IAAa;AAEjB,aAASmG,IAAInH,KAAK64B,MAAMxyB,SAAS,GAAGc,KAAK,GAAGA,KAAK;AAC/C,YAAMlH,IAAYD,KAAKy1C,WAAWtuC,CAAAA;AAClC,UAAIlH,IAAYk2C,KAAal2C,IAAY61C,EAA0B;AACnEI,MAAAA,IAAuBj2C,GACvBe,KAAchB,KAAK64B,MAAM1xB;IAC3B;AAEA,WAAqB,MAAbnG,KAAsBb,IAAM+1C;AAAAA,EACtC;AAAA,EAEA,aAAAN;AACE,SAAK51C,KAAKw1C,sBAAsBnvC,OAAQ;AACxC,UAAM8vC,IACJn2C,KAAKw1C,sBAAsBx1C,KAAKw1C,sBAAsBnvC,SAAS,CAAA,IAC/DrG,KAAKs1C;AAEP,QAAIc,IAAkB;AACtB,eAAWn2C,KAAaD,KAAKw1C,uBAAuB;AAClD,UAAIv1C,IAAYk2C,EAAW;AAC3BC,MAAAA;AAAAA,IACF;AAEAp2C,SAAK64B,MAAMluB,OAAO,GAAGyrC,CAAAA,GACrBp2C,KAAKw1C,sBAAsB7qC,OAAO,GAAGyrC,CAAAA,GACrCp2C,KAAKy1C,WAAW9qC,OAAO,GAAGyrC,CAAAA;AAAAA,EAC5B;;AC9FK,MAAMC,KAAmB,CAACjP,GAAkBkP,MACjD,GAAGlP,CAAAA,IAAYkP,CAAAA,ICiCXC,KAAgB;AAEf,MAAMC,GAAAA;AAAAA,EACM9qC,YAAYD,UAAUC;AAAAA,EAC/B+qC,4BAA4B;AAAA,EAC5BC,sBAAsB;AAAA,EAEtBC,4BAAYxW;AAAAA,EACHoF;AAAAA,EACTqR;AAAAA,EACAC;AAAAA,EACAC;AAAAA,EACAC;AAAAA,EACAxG;AAAAA,EACAyG;AAAAA,EAER,cAAAC;AACEj3C,SAAKulC,SAAS74B,EAAM,sCACpB1M,KAAKulC,OAAO76B,QAAQ;AAAA,EACtB;AAAA,EAGA,MAAA,WACEksC,GACAC,GACAC,GAAAA;AAEA92C,SAAK42C,aAAaA,GAClB52C,KAAK62C,mBAAmBA,GACxB72C,KAAK82C,wBAAwBA,GAE7B92C,KAAKk3C,sBAAAA,GACLl3C,KAAKulC,OAAO;EACd;AAAA,EAEA,kBAAkBjxB,GAAkB41B;AAClClqC,SAAK+2C,kBAAkB,EAAEziC,UAAAA,GAAU41B;EACrC;AAAA,EAEA,mBACErB,GACAzB,GACAkP,GACAtM,GACAC,GACApF,GACAsS;AAEAn3C,SAAKuwC,uBAAuB,EAC1BnJ,UAAAA,GACAkP,cACAtM,WAAAA,GACAC,SAAAA,GACApB,SAAAA,GACAhE,YAAAA,GACAsS;EAEJ;AAAA,EAGA,MAAA,aACEC,GACAhQ,GACAkP,GACAnzC,GACA6mC,GACAC,GACApF,GACAsS,GAAAA;AAEAn3C,SAAKkY,MAAMi/B,GAAch0C,EAAKF,UAAAA;AAE9B,UAAMo0C,IAAYhB,GAAiBjP,GAAUkP,CAAAA;AAa7C,QAZAt2C,KAAK22C,MAAM1oC,IAAIopC,GAAW,EACxBl0C,MAAAA,GACAmzC,WAAAA,GACAlP,aACA4C,WAAAA,GACAC,SAAAA,GACApF,YAAAA,EAAAA,CAAAA,GAEF7kC,KAAKs3C,qBAAqBn0C,EAAKF,UAAAA,GAE/BjD,KAAKulC,OAAO,gBAAgB+Q,CAAAA,OAAgBlP,CAAAA,EAAAA,GAAAA,CAEvCpnC,KAAKg3C,sBACR,OAAM,IAAIp3C,MAAM,wCAAA;AAGlBI,SAAKg3C,sBAAsB5P,CAAAA;AAAAA,EAC7B;AAAA,EAGA,MAAA,eAAqBgQ,GAAkBhQ,GAAkBkP,GAAAA;AACvD,UAAMiB,IAAmBlB,GAAiBjP,GAAUkP,CAAAA,GAC9CkB,IAAWx3C,KAAK22C,MAAM/yC,IAAI2zC,CAAAA;AAEhC,QAAIC,MAAJ,OAEA,QAAOA,EAASr0C;AAAAA,EAClB;AAAA,EAEA,WAAAqxC;AACE,QAAA,CAAKx0C,KAAKuwC,wBAAAA,CAAyBvwC,KAAK+2C,gBACtC,QAAO,EACLzC,eAAet0C,KAAKy2C,2BACpBlC,cAAcv0C,KAAK02C,oBAAAA;AAGvB,UAAMe,IAAmBz3C,KAAK+2C,gBAAgBziC;AAE9C,QAAIojC,IAAyB;AAC7B,eAAA,EAAWzN,SAAEA,GAAA9mC,MAASA,EAAAA,KAAUnD,KAAK22C,MAAMnpB,OAAAA,EACrCiqB,CAAAA,IAAmBxN,MAEvByN,KAA0Bv0C,EAAKF;AAGjC,WAAO,EACLqxC,eAAet0C,KAAKy2C,2BACpBlC,cAAcmD,IAAyBnB,GAAAA;AAAAA,EAE3C;AAAA,EAEA,WAAWa,GAAkBhQ,GAAkB1M;AAC7C,UAAM6c,IAAmBlB,GAAiBjP,GAAU1M;AAGpD,WAFgB16B,KAAK22C,MAAM/yC,IAAI2zC,CAAAA,MAE/B;AAAA,EACF;AAAA,EAEA,oBAAoBH,GAAkBhQ,GAAAA;AACpC,UAAMuQ,IAAwB,CAAA;AAE9B,eAAA,EAAWrB,WAAEA,GAAWlP,UAAUwQ,OAAmB53C,KAAK22C,MAAMnpB,OAAAA,EAC1DoqB,CAAAA,MAAkBxQ,KACtBuQ,EAAYvwC,KAAKkvC,CAAAA;AAGnB,WAAOqB;AAAAA,EACT;AAAA,EAEQ,MAAMR,GAAuBU;AAYnC,QAXA,EACG73C,KAAK+2C,mBACL/2C,KAAK62C,oBACL72C,KAAK82C,yBACL92C,KAAK42C,eAOR,CAF6B52C,KAAK83C,qBAAqBD,CAAAA,KAAAA,CAEzBV,EAAc;AAE5C,UAAMY,wBAAsBnhB,OACtBohB,IAAc/wC,MAAM7C,KAAKpE,KAAK22C,MAAMnpB,OAAAA,CAAAA,EAAUyqB,KAClD,CAACxgB,GAAGC,MAAMD,EAAEuS,YAAYtS,EAAEsS,SAAAA;AAG5B,eAAW8B,KAAekM,GAAa;AACrC,cAAM5Q,UAAEA,GAAAkP,WAAUA,GAAAnzC,MAAWA,EAAAA,IAAS2oC,GAChCuL,IAAYhB,GAAiBjP,GAAUkP,CAAAA;AAQ7C,UANqBt2C,KAAKk4C,oBACxBpM,GACAqL,GACAn3C,KAAK+2C,gBAAgBziC,QAAAA,MAKvBtU,KAAK22C,MAAMzQ,OAAOmR,CAAAA,GAClBU,EAAgBtP,IAAIrB,CAAAA,GACpBpnC,KAAKm4C,qBAAqBh1C,EAAKF,aAE/BjD,KAAKulC,OAAO,mBAAmB+Q,CAAAA,gBAAyBlP,OAEnDpnC,KAAK83C,qBAAqBD,CAAAA,KAAAA,CAAoBV,GAAc;AAAA,IACnE;AAEAn3C,SAAKo4C,6BAA6BL,CAAAA;AAAAA,EACpC;AAAA,EAEQ,qBAAqBM,GAAAA;AAC3B,WACEr4C,KAAK02C,sBAAsB2B,IAAoB9B,KAC/Cv2C,KAAKy2C;AAAAA,EAET;AAAA,EAEA,yBAAyB6B,GAAAA;AACvBt4C,SAAKg3C,wBAAwBsB;AAAAA,EAC/B;AAAA,EAEQ,6BAA6BP,GAAAA;AACN,IAAzBA,EAAgBzyB,SAAS,KAE7ByyB,EAAgBloC,QAAS4I,OAAAA;AACvB,UAAA,CAAKzY,KAAKg3C,sBACR,OAAM,IAAIp3C,MAAM,wCAAA;AAGlBI,WAAKg3C,sBAAsBv+B,CAAAA;AAAAA,IAAAA,CAAAA;AAAAA,EAE/B;AAAA,EAEQ,oBACNqzB,GACAqL,GACAoB,GAAAA;AAEA,UAAA,EAAMtO,SAAEA,GAAApF,YAASA,EAAAA,IAAeiH,GAC1BxC,IAAuBtpC,KAAKw4C,oBAChC3T,GACA,sBAAA;AAGF,aAAI0T,KAA2BtO,OAAAA,CAE3BkN,KACKoB,IAA0BjP,IAAuBW;AAAAA,EAI5D;AAAA,EAEQ,qBAAqBoO;AAC3Br4C,SAAK02C,uBAAuB2B,IAAoB9B;AAAAA,EAClD;AAAA,EAEQ,qBAAqB8B,GAAAA;AAC3Br4C,SAAK02C,uBAAuB2B,IAAoB9B;AAAAA,EAClD;AAAA,EAEQ;ADtQsB,QAAC7qC;ACuQzB1L,SAAK42C,YAAYH,4BACnBz2C,KAAKy2C,4BACHz2C,KAAK42C,WAAWH,6BDzQS/qC,IC6QR1L,KAAK0L,WD5Q5B,WAAWq7B,KAAKr7B,CAAAA,KAAAA,CAAe,kBAAkBq7B,KAAKr7B,CAAAA,MAJzBA,OAC7B,eAAeq7B,KAAKr7B,CAAAA,GC+QqC1L,KAAK0L,SAAAA,IAC1D1L,KAAKy2C,4BAA4B,QDnRb/qC,OAAsB,WAAWq7B,KAAKr7B,ICoRvC1L,KAAK0L,SAAAA,MACxB1L,KAAKy2C,4BAA4B;AAAA,EAErC;AAAA,EAEQ,oBACN5R,GACA4T,GAAAA;AAOA,YAJE5T,MAAe,SACX7kC,KAAK62C,mBACL72C,KAAK82C,yBAEK2B,CAAAA,KAAc;AAAA,EAChC;AAAA,EAEO,UAAApsC;AACLrM,SAAK22C,MAAMz+B,MAAAA;AAAAA,EACb;;AC1SK,MAAMwgC,GAAAA;AAAAA,EAIHrmC,6BAAa8tB;AAAAA,EAKd,cACLwY,MACG3xC,GAAAA;AAEH,UAAMoB,IAAYpI,KAAKqS,OAAOzO,IAAI+0C;AAClC,QAAKvwC,EACL,YAAW2J,KAAY3J,EACrB2J,CAAAA,EAAAA,GAAY/K,CAAAA;AAAAA,EAEhB;AAAA,EAEO,mBAAkD2xC,GAAAA;AACvD,QAAIvwC,IAAYpI,KAAKqS,OAAOzO,IAAI+0C,CAAAA;AAC3BvwC,IAAAA,MACHA,IAAY,CAAA,GACZpI,KAAKqS,OAAOpE,IAAI0qC,GAAWvwC,CAAAA;AAG7B,UAAMwwC,IAAmBxwC;AAEzB,WAAO,IAAIpB,MAAAA;AACT,iBAAW+K,KAAY6mC,EACrB7mC,CAAAA,EAAAA,GAAY/K,CAAAA;AAAAA,IAAAA;AAAAA,EAGlB;AAAA,EAEO,iBACL2xC,GACA5mC,GAAAA;AAEA,UAAM3J,IAAYpI,KAAKqS,OAAOzO,IAAI+0C,CAAAA;AAC7BvwC,QAGHA,EAAUhB,KAAK2K,CAAAA,IAFf/R,KAAKqS,OAAOpE,IAAI0qC,GAAW,CAAC5mC,CAAAA,CAAAA;AAAAA,EAIhC;AAAA,EAEO,oBACL4mC,GACA5mC,GAAAA;AAEA,UAAM3J,IAAYpI,KAAKqS,OAAOzO,IAAI+0C;AAClC,QAAIvwC,GAAW;AACb,YAAMwC,IAAQxC,EAAUywC,QAAQ9mC,CAAAA;AAAAA,MAC5BnH,MAD4BmH,MAE9B3J,EAAUuC,OAAOC,GAAO,CAAA;AAAA,IAE5B;AAAA,EACF;AAAA;AC3BK,MAAMkuC,GAAAA;AAAAA,EAEX3Q,OAAAA,6BAA+D,EAC7DsO,2BAAAA,QACAsC,6BAAAA,OAA6B;AAAA,EAI/B5Q,+BAAsD,EACpDqD,qBAAAA,IACAwN,eAAAA,IACA9F,2BAA2B,GAC3BC,0BAA0B,GAC1B7J,sBAAsB,IACtBC,wBAAwB,KACxBC,uBAAuB,KACvB9F,sBAAsB,OACtB0C,+BAA+B,KAC/BwG,mCAAmC,KACnCrrC,gCAAgC,KAChCsxC,kBAAkB,GAClBxM,iBAAiB,GACjBsB,4BAA4BxN,IAC5B4N,kBAAkB,CAChB,+BACA,gCACA,kCAAA,GAEFxR,WAAW,EACT1G,YAAY,CACV,EAAEC,MAAM,+BAAA,GACR,EAAEA,MAAM,mCAAA,CAAA,EAAA,GAGZmW,4BACA/iC,qBAAAA,QACAxB,kBAAAA,QACAmnC,SAAAA,OAAS;AAAA,EAGMroC,cAAc,IAAIk4C;AAAAA,EAC3BO;AAAAA,EACS52B,8BAAc8d;AAAAA,EACvB0W;AAAAA,EACAC;AAAAA,EACAoC;AAAAA,EACSjM,uBAA6C,EAC5D3qB,KAAK,IAAI+yB,MACTlG,MAAM,IAAIkG;EAEJ/K;AAAAA,EACA6O;AAAAA,EACAC;AAAAA,EACAlI,gBAA+B,EACrCoB,QAAAA,IACAqC,oBAAoB,EAAA;AAAA,EAqBtB,YAAYluB,GAAAA;AACV,UAAM0V,KpBrCR,SAAS7sB,EAAO+T,GAAAA;AACd,UAAI+X,GAAS/X,CAAAA,GAAM;AACjB,cAAM/M,IAAkC,CAAA;AASxC,eARAtR,OAAO4K,KAAKyT,GAAKxT,QAASC,CAAAA,MAAAA;AACxB,cAAIuT,EAAIvT,CAAAA,MAAR,QAA4B;AAC1B,kBAAMhN,IAAQwM,EAAO+T,EAAIvT,CAAAA,CAAAA;AAAAA,YACrBhN,MADqBgN,WAEvBwG,EAAOxG,CAAAA,IAAOhN;AAAAA,UAElB;AAAA,QAAA,CAAA,GAEKwT;AAAAA,MACT;AACE,aAAO+M;AAAAA,IAEX,GoBsB8CoD,KAAU;AAEtDzmB,SAAKk5C,mBAAmBrd,GAAuC,EAC7DC,eAAegd,GAAKO,4BACpBtd,YAAYI,EAAAA,CAAAA,GAGdn8B,KAAK62C,mBAAmBhb,GAAmC,EACzDC,eAAegd,GAAKQ,uBACpBvd,YAAYI,GACZH,sBAAsBG,EAAeod,WAAAA,CAAAA,GAGvCv5C,KAAK82C,wBAAwBjb,GAAmC,EAC9DC,eAAegd,GAAKQ,uBACpBvd,YAAYI,GACZH,sBAAsBG,EAAeqd;EAEzC;AAAA,EAOA,YAAAC;AACE,WAAO,KACFpe,GAASr7B,KAAKk5C,gBAAAA,GACjBK,YAAYle,GAASr7B,KAAK62C,gBAAAA,GAC1B2C,iBAAiBne,GAASr7B,KAAK82C,qBAAAA,EAAAA;AAAAA,EAEnC;AAAA,EAiBA,mBAAmB4C;AACjB,UAAA,EAAMH,YAAEA,GAAAC,iBAAYA,MAAoBE,GAElCC,IAAuBte,GAASr7B,KAAK62C,mBACrC+C,IAA4Bve,GAASr7B,KAAK82C,qBAAAA;AAEhD92C,SAAK65C,mBAAmBH,GAAeH,GAAYC,CAAAA,GAEnDx5C,KAAK85C,mCACHH,GACAD,GACA,MAAA,GAEF15C,KAAK85C,mCACHF,GACAF,GACA,WAAA;AAAA,EAEJ;AAAA,EAEQ,mCACNK,GACAC,GACAnV;AAEA,UAAMmU,IAAgBh5C,KAAKi6C,yBACzB,iBACAD,GACAnV,CAAAA;AAGEmU,SAAiBe,EAAWf,kBAAkBA,KAChDh5C,KAAKk6C,oBAAoBrV,CAAAA;AAG3B,UAAM2G,IAAsBxrC,KAAKi6C,yBAC/B,uBACAD,GACAnV,CAAAA;AAGF,IACE2G,MADF,UAEEuO,EAAWvO,wBAAwBA,MAGjC3G,MAAe,SACX7kC,KAAKm5C,mBACLn5C,KAAKo5C,wBAEGe,0BAA0B3O,CAAAA;AAAAA,EAE5C;AAAA,EAEQ,yBACN4O,GACAJ,GACAnV,GAAAA;AAOA,YAJEA,MAAe,SACXmV,EAAcT,aACdS,EAAcR,mBAESY,CAAAA,KAAiBJ,EAAcI,CAAAA;AAAAA,EAC9D;AAAA,EAQA,iBACEzB,GACA5mC,GAAAA;AAEA/R,SAAKQ,YAAYkT,iBAAiBilC,GAAW5mC,CAAAA;AAAAA,EAC/C;AAAA,EAQA,oBACE4mC,GACA5mC,GAAAA;AAEA/R,SAAKQ,YAAYqT,oBAAoB8kC,GAAW5mC,CAAAA;AAAAA,EAClD;AAAA,EAOA,uBAAuBpQ,GAAAA;AACrB3B,SAAKi5C,sBAAsBt3C,EAAI0N,MAAM,GAAA,EAAK,CAAA;AAAA,EAC5C;AAAA,EAQA,WAAW05B,GAAAA;AACT,WAAA,CAAA,CAASsR,GACPr6C,KAAKqiB,SACL0mB,CAAAA;AAAAA,EAEJ;AAAA,EAQA,UAAUuR,GAAAA;AACR,WAAOt6C,KAAKqiB,QAAQze,IAAI02C,CAAAA;AAAAA,EAC1B;AAAA,EAOA,sBAAsB7hC,GAAAA;AAChBzY,SAAKqiB,QAAQojB,IAAIhtB,EAAO8yB,SAAAA,KAE5BvrC,KAAKqiB,QAAQpU,IAAIwK,EAAO8yB,WAAW,EAAA,GAC9B9yB,GACHuwB,8BAAc7I,MAAAA,CAAAA;AAAAA,EAElB;AAAA,EASA,aACEma,GACAC,GACAC,GAAAA;AAEA,UAAM/hC,IAASzY,KAAKqiB,QAAQze,IAAI02C,CAAAA;AAChC,QAAK7hC,GAAL;AAEA,UAAI8hC,EACF,YAAW35C,KAAW25C,EAChB9hC,GAAOuwB,SAASvD,IAAI7kC,EAAQ2qC,SAAAA,KAChC9yB,EAAOuwB,SAAS/6B,IAAIrN,EAAQ2qC,WAAW,EAAA,GAAK3qC,GAAS6X;AAIzD,UAAI+hC,EACF,YAAW5sB,KAAM4sB,EACf/hC,GAAOuwB,SAAS9C,OAAOtY;AAI3B5tB,WAAKm5C,kBAAkBsB,aAAahiC,CAAAA,GACpCzY,KAAKo5C,uBAAuBqB,aAAahiC,CAAAA;AAAAA,IAhB5B;AAAA,EAiBf;AAAA,EAUA,MAAA,YAAkBswB,GAA0BoJ,GAAAA;AAC1C,SAAKnyC,KAAKi5C,oBACR,OAAM,IAAIr5C,MAAM,sCAAA;AAAA,UAGZI,KAAK06C,yBAAAA;AAEX,UAAM95C,IAAUZ,KAAK26C,gBAAgB5R,CAAAA;AAEtB/oC,SAAK46C,sBAAsBh6C,CAAAA,EAC9Bi6C,YAAYj6C,GAASuxC,CAAAA;AAAAA,EACnC;AAAA,EAOA,oBAAoBpJ,GAAAA;AAClB/oC,SAAKm5C,kBAAkB2B,oBAAoB/R,CAAAA,GAC3C/oC,KAAKo5C,uBAAuB0B,oBAAoB/R,CAAAA;AAAAA,EAClD;AAAA,EAQA,eAAez0B,GAAkB41B,GAAAA;AAC/BlqC,SAAKm5C,kBAAkB4B,eAAezmC,GAAU41B,CAAAA,GAChDlqC,KAAKo5C,uBAAuB2B,eAAezmC,GAAU41B,CAAAA;AAAAA,EACvD;AAAA,EAQA,sBAAsB8Q;AAChBA,IAAAA,MAAYh7C,KAAKkxC,cAAcyD,uBACjC30C,KAAKkxC,cAAcyD,qBAAqBqG,GACxCh7C,KAAKm5C,kBAAkBpE,mBAAAA,GACvB/0C,KAAKo5C,uBAAuBrE,mBAAAA;AAAAA,EAEhC;AAAA,EAOA,UAAUzC,GAAAA;AACRtyC,SAAKkxC,cAAcoB,SAASA;AAAAA,EAC9B;AAAA,EAOA,kBAAkBvJ,GAAAA;AAChB,QAAA;AACE,YAAMnoC,IAAUZ,KAAK26C,gBAAgB5R,CAAAA;AAErC,cACEnoC,EAAQ6X,OAAO5Y,SAAS,UAATA,CACfG,KAAK62C,iBAAiBmC,mBAMtBp4C,EAAQ6X,OAAO5Y,SAAS,eAATA,CACfG,KAAK82C,sBAAsBkC;AAAAA,IAM/B,QAAA;AACE;IACF;AAAA,EACF;AAAA,EAMA;AACEh5C,SAAKqiB,QAAQnK,MAAAA,GACblY,KAAKm5C,kBAAkB9sC,QAAAA,GACvBrM,KAAKo5C,uBAAuB/sC,QAAAA,GAC5BrM,KAAKsqC,gBAAgBj+B,QAAAA,GACrBrM,KAAKm5C,mBAAAA,QACLn5C,KAAKo5C,wBAAAA,QACLp5C,KAAKsqC,yBACLtqC,KAAKi5C,sBAAAA,QACLj5C,KAAKkxC,gBAAgB,EAAEoB,QAAAA,IAAeqC,oBAAoB,EAAA,GAC1D1N,GAAiB0B,iBAAAA;AAAAA,EACnB;AAAA,EAEA,iCAAc+R;AACZ,QAAI16C,KAAKsqC,eAAgB;AAEzB,UAAA,EAAMgI,QAAEA,EAAAA,IAAWtyC,KAAKkxC,eAClB+J,IACJj7C,KAAKk5C,iBAAiBH;AAExB,QAAIkC,KAAsD,OAAxBA,KAAwB,WACxD,OAAM,IAAIr7C,MAAM,kCAAA;AAGlB,UAAM0qC,IAAiB2Q,IACnBA,EAAoB3I,CAAAA,IACpB,IAAIkE;AAAAA,UAEFlM,EAAe4Q,WACnBl7C,KAAKk5C,kBACLl5C,KAAK62C,kBACL72C,KAAK82C,qBAAAA,GAGP92C,KAAKsqC,iBAAiBA;AAAAA,EACxB;AAAA,EAEQ,gBAAgBvB,GAAAA;AACtB,SAAK/oC,KAAKi5C,oBACR,OAAM,IAAIr5C,MAAM,oCAAA;AAGlB,UAAMgB,IAAUy5C,GACdr6C,KAAKqiB,SACL0mB,CAAAA;AAEF,QAAA,CAAKnoC,EACH,OAAM,IAAIhB,MAAM,8BAA8BmpC,CAAAA,EAAAA;AAGhD,WAAOnoC;AAAAA,EACT;AAAA,EAEQ,mBACN84C,GACAH,GACAC,GAAAA;AAEAje,IAAAA,GAAev7B,KAAKk5C,kBAAkBQ,CAAAA,GACtCne,GAAev7B,KAAK62C,kBAAkB6C,IACtCne,GAAev7B,KAAK82C,uBAAuB4C,CAAAA,GAEvCH,KACFhe,GAAev7B,KAAK62C,kBAAkB0C,CAAAA,GAGpCC,KACFje,GAAev7B,KAAK82C,uBAAuB0C,CAAAA;AAAAA,EAE/C;AAAA,EAEQ,oBAAoB3U,GAAAA;AACP,IAAfA,MAAe,UACjB7kC,KAAKm5C,kBAAkB9sC,QAAAA,GACvBrM,KAAKm5C,8BAELn5C,KAAKo5C,uBAAuB/sC,QAAAA,GAC5BrM,KAAKo5C,wBAAAA;AAAAA,EAET;AAAA,EAEQ,sBAAsBx4C,GAAAA;AAC5B,WAAIA,EAAQ6X,OAAO5Y,SAAS,UAC1BG,KAAKm5C,qBAAqBn5C,KAAKm7C,sBAAsBv6C,CAAAA,GAC9CZ,KAAKm5C,qBAEZn5C,KAAKo5C,0BAA0Bp5C,KAAKm7C,sBAAsBv6C,CAAAA,GACnDZ,KAAKo5C;AAAAA,EAEhB;AAAA,EAEQ,sBAAsBx4C,GAAAA;AAC5B,SAAKZ,KAAKi5C,oBACR,OAAM,IAAIr5C,MAAM,sCAAA;AAGlB,QAAA,CAAKI,KAAKsqC,eACR,OAAM,IAAI1qC,MAAM,oCAAA;AAGlB,UAAMw7C,IACJx6C,EAAQ6X,OAAO5Y,SAAS,SACpBG,KAAK62C,mBACL72C,KAAK82C;AAEX,WAAO,IAAI7F,GACTjxC,KAAKi5C,qBACLr4C,GACAZ,KAAKkxC,eACLkK,GACAp7C,KAAKitC,sBACLjtC,KAAKsqC,gBACLtqC,KAAKQ,WAAAA;AAAAA,EAET;AAAA;;","x_google_ignoreList":[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,24,25,26,27,28,29]}